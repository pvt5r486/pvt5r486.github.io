<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pvt5r486&#39;s Blog</title>
  
  <subtitle>喜歡烏龜的宅宅工程師</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://pvt5r486.github.io/"/>
  <updated>2020-03-06T08:03:39.574Z</updated>
  <id>http://pvt5r486.github.io/</id>
  
  <author>
    <name>pvt5r486</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.56 在 Angular 中結合 Bootstrap4 做個麵包屑</title>
    <link href="http://pvt5r486.github.io/f2e/20200306/1169816670/"/>
    <id>http://pvt5r486.github.io/f2e/20200306/1169816670/</id>
    <published>2020-03-06T08:04:03.000Z</published>
    <updated>2020-03-06T08:03:39.574Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同上篇，這篇也是寫玩具 (side project) 時遇到的需求，麵包屑 (Breadcrumbs) 這個功能亦是網站相當常見的元素，那麼又該如何透過 Angular 的 Router 搭配 Bootstrap 4 建立麵包屑呢?</p><p><img src="https://images.unsplash.com/photo-1583311590134-e5f52ab9175d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1110&amp;q=80" alt></p><h2 id="本文環境"><a href="#本文環境" class="headerlink" title="本文環境"></a>本文環境</h2><ul><li>Angular CLI: 8.3.20</li><li>Angular: 8.2.14</li><li>Bootstrap: 4.3.1</li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>因為這個需求源自於我的玩具 (side project) ，而麵包屑的做法在網路上查完一輪後，因人而異的有各種方式能實作，所以本文的做法僅供參考。</p><p>如同上一段提到的，這個專案環境使用懶載入的方式載入模組 (lazy-loading-ngmodules) ，而網路上查到的資料卻很少提到在這個前提下應該怎麼調整，導致照著做是無法順利運行的。</p><p>又爬了好一陣的資料，折騰了好久才完成，但完成的版本需要再麵包屑元件的 <code>constructor(){}</code> 內進行 <code>router.events</code> 的訂閱。</p><p>但根據查到的資料，<code>constructor(){}</code> 指的是物件實體剛被建立時，此時是不包含在生命週期中的，而 <code>constructor(){}</code> 應該只做依賴注入，不要亂加一些東西。</p><p>想想，又對於這個做法不滿意，想辦法改良後最後決定放在這邊記錄下來。</p><h3 id="routing-module-設置"><a href="#routing-module-設置" class="headerlink" title="routing.module 設置"></a>routing.module 設置</h3><p>在各個父層路由定義 <code>data</code> 物件內容，如：</p><p><strong>app-routing.module</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    redirectTo: <span class="string">'/login'</span>,</span><br><span class="line">    pathMatch: <span class="string">'full'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'login'</span>,</span><br><span class="line">    component: LoginComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'dashboard'</span>,</span><br><span class="line">    loadChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./back-ui/back-routing.module'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.BackRoutingModule),</span><br><span class="line">    data: &#123; breadcrumb: <span class="string">'後台'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'**'</span>,</span><br><span class="line">    redirectTo: <span class="string">'/login'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p></p><p><strong>back-routing.module</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    component: DashboardComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'products'</span>,</span><br><span class="line">        loadChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../module/products/products-routing.module'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.ProductsRoutingModule),</span><br><span class="line">        data: &#123; breadcrumb: <span class="string">'產品列表'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'orders'</span>,</span><br><span class="line">        loadChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../module/orders/orders-routing.module'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.OrdersRoutingModule),</span><br><span class="line">        data: &#123; breadcrumb: <span class="string">'訂單列表'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p></p><h3 id="訂閱-Router-events"><a href="#訂閱-Router-events" class="headerlink" title="訂閱 Router events"></a>訂閱 Router events</h3><p>在 <code>AppComponent</code> 中訂閱 <code>Router</code> 的事件， 而這些事件相當多，在此只需要針對 <code>NavigationEnd</code> 進行處理即可。</p><p>另外要記得在 <code>ngOnDestroy()</code> 階段取消訂閱。</p><p>接著還需要一隻服務 <code>BreadcrumbService</code> 將資料存下來，供 <code>BreadcrumbComponent</code> 使用</p><p><strong>app.component</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, OnDestroy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRoute, Router, NavigationEnd &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BreadcrumbService &#125; <span class="keyword">from</span> <span class="string">'./module/breadcrumb/breadcrumb-service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _routerSubscription: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> activatedRoute: ActivatedRoute,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> router: Router,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> breadcrumbService: BreadcrumbService,</span></span><br><span class="line"><span class="params">  </span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._routerSubscription = <span class="keyword">this</span>.router.events.subscribe(<span class="function">(<span class="params">event: NavigationEnd</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (event <span class="keyword">instanceof</span> NavigationEnd) &#123;</span><br><span class="line">        <span class="keyword">const</span> root: ActivatedRoute = <span class="keyword">this</span>.activatedRoute.root;</span><br><span class="line">        <span class="keyword">this</span>.breadcrumbService.setActivatedRouteRoot(root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._routerSubscription.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>當 <code>event</code> 為 <code>NavigationEnd</code> 時，透過 <code>setActivatedRouteRoot()</code> 將資料儲存。</p><h3 id="新增-Breadcrumb-Service"><a href="#新增-Breadcrumb-Service" class="headerlink" title="新增 Breadcrumb Service"></a>新增 Breadcrumb Service</h3><p><strong>breadcrumb-service</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, EventEmitter &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BreadcrumbService &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> root: ActivatedRoute;</span><br><span class="line">  <span class="keyword">public</span> routeEvent = <span class="keyword">new</span> EventEmitter&lt;ActivatedRoute&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> setActivatedRouteRoot(root: ActivatedRoute): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = root;</span><br><span class="line">    <span class="keyword">this</span>.routeEvent.emit(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getActivatedRouteRoot(): ActivatedRoute &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>當 <code>setActivatedRouteRoot()</code> 被觸發時，將資料 <code>emit</code> 出去，這時 <code>BreadcrumbComponent</code> 只需要訂閱 <code>routeEvent</code> 事件就好了～</p><h3 id="建立-BreadcrumbComponent"><a href="#建立-BreadcrumbComponent" class="headerlink" title="建立 BreadcrumbComponent"></a>建立 BreadcrumbComponent</h3><p>接著來處理本次的主角：</p><ul><li>依賴注入 <code>BreadcrumbService</code></li><li>在 <code>ngOnInit()</code> 內 訂閱<code>BreadcrumbService</code> 的 <code>routeEvent</code> 事件，確保資料的取得<ul><li>由於是在 <code>ngOnInit()</code> 階段訂閱，所以程式首次運行必須跑一次 <code>getActivatedRouteRoot()</code></li></ul></li><li>在 <code>ngOnDestroy()</code> 階段取消訂閱</li><li>運用遞迴的技巧取回顯示在麵包屑上的內容</li></ul><p><strong>將取回的資料印出觀察，會發現路由的資料其實是一層層包覆的資料結構</strong><br><img src="https://i.imgur.com/IDBvcT0.png" alt></p><p><strong>breadcrumb.component.html</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">"breadcrumb"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"breadcrumb bg-transparent px-0 mb-0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngFor</span>=<span class="string">"let breadcrumb of breadcrumbs;let lastRecord = last"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"breadcrumb-item"</span> [<span class="attr">ngClass</span>]=<span class="string">"&#123;'active': lastRecord&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">"[breadcrumb.url]"</span> *<span class="attr">ngIf</span>=<span class="string">"!lastRecord"</span>&gt;</span>&#123;&#123; breadcrumb.label &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">"lastRecord"</span>&gt;</span>&#123;&#123; breadcrumb.label &#125;&#125;<span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>breadcrumb.component.ts</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, OnDestroy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BreadcrumbDTO &#125; <span class="keyword">from</span> <span class="string">'../breadcrumb-dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRoute, PRIMARY_OUTLET &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BreadcrumbService &#125; <span class="keyword">from</span> <span class="string">'../breadcrumb-service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-breadcrumb'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./breadcrumb.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./breadcrumb.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BreadcrumbComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> breadcrumbs: <span class="built_in">Array</span>&lt;BreadcrumbDTO&gt; = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> breadcrumbService: BreadcrumbService,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.breadcrumbService.routeEvent.subscribe(<span class="function">(<span class="params">root: ActivatedRoute</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.breadcrumbs = <span class="keyword">this</span>.getBreadcrumbs(root);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.breadcrumbs = <span class="keyword">this</span>.getBreadcrumbs(<span class="keyword">this</span>.breadcrumbService.getActivatedRouteRoot());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.breadcrumbService.routeEvent.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> getBreadcrumbs(route: ActivatedRoute, url: <span class="built_in">string</span> = <span class="string">''</span>, breadcrumbs: <span class="built_in">Array</span>&lt;BreadcrumbDTO&gt; = []): <span class="built_in">Array</span>&lt;BreadcrumbDTO&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ROUTE_DATA_BREADCRUMB = <span class="string">'breadcrumb'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> children: ActivatedRoute[] = route.children;</span><br><span class="line">    <span class="keyword">if</span> (children.length === <span class="number">0</span>) &#123; <span class="keyword">return</span> breadcrumbs; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> child of children) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (child.outlet !== PRIMARY_OUTLET) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      <span class="keyword">if</span> (!child.snapshot.data.hasOwnProperty(ROUTE_DATA_BREADCRUMB)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getBreadcrumbs(child, url, breadcrumbs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> routeURL: <span class="built_in">string</span> = child.snapshot.url.map(<span class="function"><span class="params">segment</span> =&gt;</span> segment.path).join(<span class="string">'/'</span>);</span><br><span class="line">      <span class="keyword">if</span> (routeURL) &#123;</span><br><span class="line">        url += <span class="string">`/<span class="subst">$&#123;routeURL&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> breadcrumb: BreadcrumbDTO = &#123;</span><br><span class="line">        label: child.snapshot.data[ROUTE_DATA_BREADCRUMB],</span><br><span class="line">        params: child.snapshot.params,</span><br><span class="line">        url,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (child.component) &#123;</span><br><span class="line">        breadcrumbs.push(breadcrumb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getBreadcrumbs(child, url, breadcrumbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> breadcrumbs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>特別要注意如果是使用懶載入模組的方式，則需要判斷 <code>child.component</code> 否則會有麵包屑名稱重複的問題，原因參考資料中有提到，有興趣的不妨看看。</p></blockquote><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><strong>這篇文章參考的內容</strong></p><ul><li><a href="https://www.jianshu.com/p/44f1be15b547" rel="external nofollow noopener noreferrer" target="_blank">Angular 6 breadcrumb 面包屑</a></li><li><a href="https://ng.ant.design/components/breadcrumb/zh#api" rel="external nofollow noopener noreferrer" target="_blank">Breadcrumb面包屑</a></li><li><a href="https://angular.tw/api/router" rel="external nofollow noopener noreferrer" target="_blank">Angular 台灣</a></li><li><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/235284/" rel="external nofollow noopener noreferrer" target="_blank">詳解Angular之constructor和ngOnInit差異及適用場景</a></li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>成果圖：</p><p><img src="https://i.imgur.com/AFfHkXf.gif" alt></p><p>本文不會有完整程式碼提供下載，僅紀錄相關程式碼片段，如果之後這個玩具有完成，會再考慮要不要公開。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      同上篇，這篇也是寫玩具 (side project) 時遇到的需求，麵包屑 (Breadcrumbs) 這個功能亦是網站相當常見的元素，那麼又該如何透過 Angular 的 Router 搭配 Bootstrap 4 建立麵包屑呢?
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.55 如何調整 Bootstrap4 的 NavBar 使其增強使用者體驗</title>
    <link href="http://pvt5r486.github.io/f2e/20200305/925313422/"/>
    <id>http://pvt5r486.github.io/f2e/20200305/925313422/</id>
    <published>2020-03-05T06:18:21.000Z</published>
    <updated>2020-03-06T08:04:39.037Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:53 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇主要記錄自己在寫玩具 (side project) 時遇到的小問題，也是蠻常見的需求。</p><p>我習慣開發時使用 Bootstrap4 ，而在 Bootstrap4 中有提供 NavBar 的元件供開發者快速套版，亦有相關的 ClassName 可供使用，那麼該如何進一步的提升使用者體驗呢 (UX)？</p><p><img src="https://images.unsplash.com/photo-1583294436447-a9cbb933d05e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1189&amp;q=80" alt></p><h2 id="本文環境"><a href="#本文環境" class="headerlink" title="本文環境"></a>本文環境</h2><ul><li>Angular CLI: 8.3.20</li><li>Angular: 8.2.14</li><li>Bootstrap: 4.3.1</li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>常常看到某些網站的 NavBar 在使用者往下捲動 ScrollBar 時， NavBar 會往上隱藏；反之，當往上捲動時則顯示。</p><p>那麼該如何調整 Angular &amp; Bootstrap 來達成我們的需求呢?</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>需要進行 HTML &amp; CSS 的調整，程式碼如:</p><p><strong>navbar.component.html</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"sticky-top"</span> [<span class="attr">ngClass</span>]=<span class="string">"&#123;'hidden': isNavBarHidden&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-expand-md navbar-dark bg-main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/dashboard"</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fas fa-home fa-fw mr-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h5 mb-0 d-inline-block"</span>&gt;</span>ipsum dolor.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"navbar-toggler"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#navbarSupportedContent"</span> <span class="attr">aria-controls</span>=<span class="string">"navbarSupportedContent"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"navbarSupportedContent"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"navbar-nav mr-auto"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"products"</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span> [<span class="attr">routerLinkActiveOptions</span>]=<span class="string">"&#123; exact: false &#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fas fa-list fa-fw mr-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>產品列表</span><br><span class="line">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"orders"</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span> [<span class="attr">routerLinkActiveOptions</span>]=<span class="string">"&#123; exact: false &#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fas fa-list fa-fw mr-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>訂單列表</span><br><span class="line">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"nav-link logout"</span> <span class="attr">id</span>=<span class="string">"logout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fas fa-sign-out-alt fa-fw mr-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>登出</span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>navbar.component.scss</strong><br></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navbar-toggler</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">&amp;:focus&#123;</span><br><span class="line"><span class="attribute">outline</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logout</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">0</span>;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">    <span class="attribute">color</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">75</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sticky-top</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform .<span class="number">3s</span>;</span><br><span class="line">  &amp;<span class="selector-class">.hidden</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: translateY(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>透過調整 <code>.sticky-top</code> 並且當 ClassName 內同時具有 <code>sticky-top</code> 、 <code>hidden</code> 時透過 <code>transform</code> 隱藏 NavBar 。</p><h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p>接著需要針對 scroll 進行監聽</p><p><strong>navbar.component.ts</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, OnDestroy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-navbar'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./navbar.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./navbar.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NavbarComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> last_known_scroll_position = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> ticking = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">private</span> _isNavBarHidden = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">private</span> scrollBarListener: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addScrollBarListener();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeScrollBarListener();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> removeScrollBarListener(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'scroll'</span>, <span class="keyword">this</span>.scrollBarListener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> getWindowScrollY(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.ticking) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.navBarDisplay());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ticking = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> navBarDisplay(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.last_known_scroll_position &lt; <span class="built_in">window</span>.scrollY) &#123;</span><br><span class="line">      <span class="keyword">this</span>._isNavBarHidden = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.last_known_scroll_position &gt;= <span class="built_in">window</span>.scrollY) &#123;</span><br><span class="line">      <span class="keyword">this</span>._isNavBarHidden = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ticking = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.last_known_scroll_position = <span class="built_in">window</span>.scrollY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> isNavBarHidden(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._isNavBarHidden;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>說明：</strong></p><ul><li>監聽 <code>scroll 滾動事件</code></li><li>於 <code>ngOnDestroy</code> 時將監聽卸掉</li><li>由於 <code>scroll 滾動事件</code>觸發的非常頻繁，需要加上額外的措施<ul><li>如 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document/scroll_event" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 建議</li></ul></li><li>關於 <code>requestAnimationFrame</code> 的補充<ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Window.requestAnimationFrame" rel="external nofollow noopener noreferrer" target="_blank">MDN</a></li><li><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/260087/" rel="external nofollow noopener noreferrer" target="_blank">深入理解requestAnimationFrame的動畫迴圈</a></li></ul></li><li>使用一個屬性來記錄最後 <code>scrollY</code> 的位置，如 <code>last_known_scroll_position</code><ul><li>這樣才有辦法比較當前的 <code>window.scrollY</code> 與 <code>last_known_scroll_position</code> 是往上捲還是往下捲</li><li>先比較，最後才更新 <code>last_known_scroll_position</code> 的值</li></ul></li><li>根據捲動的方向給予對應的 ClassName</li></ul><p><strong>成果展示</strong></p><p><img src="https://i.imgur.com/llbU7zm.gif" alt></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為還沒這個玩具還沒完成，暫時還不想公開，所以就不附上完整的 code 了。</p><p>不過這個範例還蠻簡單的，我想應該貼上片段就足夠了 (?)</p><p>這樣就達成強化 NavBar UX 的目的了：</p><ul><li>往下捲可能代表使用者想看畫面的內容，所以隱藏 NavBar</li><li>往上捲可能代表使用者在找 NavBar ，所以顯示</li></ul><p>如果不想只單純的使用 <code>sticky-top</code> 不妨嘗試這樣的方式，讓網站更加活潑哦～</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我習慣開發時使用 Bootstrap4 ，而在 Bootstrap4 中有提供 NavBar 的元件供開發者快速套版，亦有相關的 ClassName 可供使用，那麼該如何進一步的提升使用者體驗呢 (UX)？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.54 在 Angular 中切換預設 or 深色主題</title>
    <link href="http://pvt5r486.github.io/f2e/20200216/4072739768/"/>
    <id>http://pvt5r486.github.io/f2e/20200216/4072739768/</id>
    <published>2020-02-16T06:18:21.000Z</published>
    <updated>2020-02-16T10:15:55.844Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自上一篇文章後，就很少上來發表文章了，一方面是工作到家就有點累了，更別說沒有想到什麼適合寫的主題。剛好前幾天有個 Issue 希望我研究如何在 Angular 中快速的切換預設 / 暗色主題，也就是所謂的開關燈模式囉。</p><p><img src="https://images.unsplash.com/photo-1581548937058-8460f5d5fd4b?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=749&amp;q=80" alt></p><h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><ul><li>建立出一個 Angualr 8 版本的空白專案</li><li>引入 <a href="https://getbootstrap.com/" rel="external nofollow noopener noreferrer" target="_blank">Bootstrap 4</a></li><li>引入 <a href="https://material.angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular Material</a></li></ul><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>稍微了解情況後便立即開始展開網路上的搜尋，初步的整理出了以下兩種方案：</p><ol><li>透過添加 / 移除 <code>className</code> 的方式切換主題</li><li>透過設置 <code>angular.json</code> 使其打包出兩份不同的主題 CSS ，並且將其動態引入</li></ol><blockquote><p>先破梗，兩種方案都有優缺點，端看團隊的情況能接受哪一種方案。最後我們團隊是採用第二種方案，因為這對我們來說，能避開最多可預見的問題。</p></blockquote><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>透過異動 <code>className</code> 達成切換主題的方式可以參考<a href="https://wellwind.idv.tw/blog/2018/01/19/angular-material-32-custom-theme/" rel="external nofollow noopener noreferrer" target="_blank">這篇文章</a>做一些微調即可。</p><p>嘗試過後覺得不太適合我們，理由如下：</p><ol><li>兩種主題打包後的單支 CSS 檔案太大了</li><li>由於是在最外層的標籤套上特定的 <code>className</code> 來切換主題，以我們專案來說會出現 CSS 權重問題造成跑版。<ul><li>而如果要解決這個問題，則需要到作為基底的 lib 內調整 <code>Bootstrap 4</code> &amp; <code>Angular Material</code> 等相關的 SCSS ，評估後覺得這個不是目前最佳解，暫時跳過。</li></ul></li></ol><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>做法如下：</strong></p><ul><li>建立兩份主題，如： <code>default-theme.scss</code> 、 <code>dark-theme.scss</code></li><li>調整 <code>angular.json</code><ul><li>調整 <code>styles</code> 區塊配置<ul><li>設定 <code>input</code>、<code>bundleName</code>、<code>inject</code> 屬性<ul><li><code>input</code> - 要載入的 SCSS 路徑</li><li><code>bundleName</code> - 獨立打包的檔案名稱</li><li><code>inject</code> - 是否自動載入至 <code>index.html</code></li></ul></li></ul></li><li>調整 <code>configurations</code> 的 <code>outputHashing</code> 配置<ul><li>將其設定為 <code>bundles</code> ，確保打包後的 CSS 檔案名稱不會被加上 hash</li></ul></li><li>調整 <code>build</code> 內的 <code>options</code> 區塊配置，加入 <code>extractCss</code> 屬性，設置為 <code>true</code></li></ul></li><li>新增 <code>CSSLoaderService</code> 用來動態引入指定的 CSS</li><li>調整 <code>index.html</code> ，使其預設載入 <code>default-theme.scss</code></li></ul><p>範例：<a href="https://github.com/pvt5r486/switch-theme" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p><p><strong>成果 Gif 圖</strong></p><p><img src="https://i.imgur.com/Hm03jpD.gif" alt></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>透過方案二的做法，能有效的控制 CSS 大小，不會因為兩種主題而使 CSS 檔案膨脹，而這個做法也相當的簡單暴力。</p><p>甚至可以繞過很多不好處理的問題，像是 SCSS 內的變數宣告順序、又或者是多了 <code>!default</code> 的 SCSS 變數，方案二並非方案一是將全部 SCSS 都打包再一起成為 CSS ，所以會讓情況單純很多。</p><p>當然方案二也不是完全沒有缺點的，像是：</p><ul><li>取消掉 hash 後可能需要處理 CSS 被快取住的問題 (待驗證)</li><li>如果單個主題 CSS 本身就有點分量，那麼切換時可能會有點延遲，這時需要透過 viewblock 等手段提升使用者體驗。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      自上一篇文章後，就很少上來發表文章了，一方面是工作到家就有點累了，更別說沒有想到什麼適合寫的主題。剛好前幾天有個 Issue 希望我研究如何在 Angular 中快速的切換預設 / 深色主題，也就是所謂的開關燈模式囉。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>初次參加 MOPCON 2019</title>
    <link href="http://pvt5r486.github.io/life-note/20191020/1754622689/"/>
    <id>http://pvt5r486.github.io/life-note/20191020/1754622689/</id>
    <published>2019-10-19T23:06:57.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因緣際會之下，同事 A 冷不防地丟來一則訊息，問我有沒有參加過 MOPCON ，理由是他沒有參加過不確定是否該怒衝一波。於是也真的就這麼巧，六角社團內也剛好有個免費領取公關票寫心得的活動，而寫心得對我來說並不是一件特別困難的事情。確認完同事是否「孤單寂寞覺得冷」真的需要我陪同參加後，就毫無懸念的報名了。</p><p>再開始之前想打個預防針，因為我有點懶且內向不太擅長攀談，以至於這一篇文章並不會讓讀者有跟「某某大神聊過之後獲得什麼啟發、聽了某場演講技術突然暴增一甲子」這種雞湯文的感覺，就只是很單純主觀地描述我的感受。</p><p><img src="https://images.unsplash.com/photo-1571511825803-b75a423e86c7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="行前安排"><a href="#行前安排" class="headerlink" title="行前安排"></a>行前安排</h2><p>由於同事 B 參加過很多次 MOPCON 了，不免俗地問了一下要帶什麼裝備去比較好。在我實際體驗後確實所言不假，像是：</p><ul><li>完全不需要帶筆電，其實用途不大<ul><li>因為只有前幾排有桌子，而且每個人的座位空間其實不大，若筆電很大台只是增加自己的困擾</li><li>充電區滿滿的都是人</li><li>不需要勤勉的做筆記，因為有其他人會幫你寫好，例如： <a href="https://hackmd.io/5VaxK2gzTvutKiLMoos2Iw#Day1-Unconference" rel="external nofollow noopener noreferrer" target="_blank">MOPCON 2019 共同筆記</a></li><li>與其低頭猛抄筆記，不如沉浸在講者想傳達的內容內</li></ul></li></ul><p>再來是決定想聽些什麼內容， Day 2 的議題反覆的刷了幾遍之後硬是排出了一份跟自己比較有關係的內容，在這邊做個紀錄。</p><ul><li>0915-1000 R1 3F 機器學習於量化交易的挑戰與解法</li><li>1015-1055 R3 4F 從後端開始，到架構之路</li><li>1110-1150 R1 3F 技術人員如何陳述自己的商業價值</li><li>1300-1340 R3 4F 我們與測試的距離</li><li>1355-1435 R3 4F 高效率錄製撥放網頁自動化測試技術與趨勢 - 以 SideeX 為例</li><li>1450-1530 R1 3F 敏捷論壇 - 不同世代的敏捷推行之道</li><li>1600-1700 R1 3F 職涯論壇 - 接下來要繼續當工程師，或者轉職到管理職？</li></ul><p>這樣行程跟裝備都決定了，靜待活動當天。</p><h2 id="當天心得"><a href="#當天心得" class="headerlink" title="當天心得"></a>當天心得</h2><p>果然是南台灣最大的科技年會真的是人山人海，也很容易認親！望眼看去很容易就認出一些看起來很眼熟的人，但我生性害羞又怕尷尬，原諒我沒有上去 Say Hello 了。</p><h3 id="參加這種盛會，心得一定要很正面嗎？"><a href="#參加這種盛會，心得一定要很正面嗎？" class="headerlink" title="參加這種盛會，心得一定要很正面嗎？"></a>參加這種盛會，心得一定要很正面嗎？</h3><p>因為個人背景的關係，技術底子相對的沒那麼深厚，舉例來說第一場的議題講的內容其實大部分時間我幾乎都處於 <code>204 No Content</code> 狀態，意思是我有接收到，但也僅是有接收到而已，並沒有激起什麼化學變化。</p><p>而後面幾場議題也或多或少有類似這樣子的情況出現，我相信每位聽眾的技術水平肯定也是參差不齊，所以我合理的推斷，跟我有差不多症狀的人大有人在。</p><p>而另一方面，技術好的人不見得是好的講者，反之亦然。</p><blockquote><p>合理且理性的分析後(?)，肥宅如我不如下午茶吃到飽、珍奶冰棒吃到頭痛好了。</p><p><del>其實我真的吃了兩支冰</del></p></blockquote><h3 id="獲得什麼是很主觀的"><a href="#獲得什麼是很主觀的" class="headerlink" title="獲得什麼是很主觀的"></a>獲得什麼是很主觀的</h3><p>就我自己的觀點來說，這場聚會的目的其實並不是提升聽者的技術力，畢竟聽眾水準參差不齊，以這一點切入的話，講者要怎麼準備內容呢？</p><p>所以內容肯定是不會太深入的，而太深入的技術肯定也不會在這種場合談，取而代之的內容是講者<strong>對於這些事情的看法或經驗談</strong>。</p><p>基於這樣子的推論，我把今天所有聽不懂的東西都當成<code>關鍵字</code>或者稱為<code>知識點</code>，而埋下這些東西有什麼好處呢？</p><ul><li>爾後如果有人提起類似的東西，會有似曾相識的感覺</li><li>人是習慣的動物，當習慣某個東西後，即使不全然了解那個東西，也不會那麼抗拒學習</li></ul><blockquote><p><strong>而聽得懂的內容，也值得思考為何該名講者會有這樣的觀點、看法，或許這就是為什麼今天他在台上，我們在台下的原因。</strong></p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上就是我 MOPCON 2019 很佛系的參加心得，若看完這些還是不清楚到底明年該不該一起參與 MOPCON ，只能說身為一個工程師就是一直不斷的 <code>Try &amp; Error</code> ，都沒親自試過要如何怎麼知道好不好？</p><p>更何況門票也只是區區的 800 ，這個錢比課一單還要少。</p><p>真的覺得虧，頂多下午茶吃到飽，沒事的。</p><p>身為工程師的你，平常通靈就夠辛苦了，沒必要連這種地方也通靈，你說是吧？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      因緣際會之下，同事 A 冷不防地丟來一則訊息，問我有沒有參加過 MOPCON ，理由是他沒有參加過不確定是否該怒衝一波。於是也真的就這麼巧，六角社團內也剛好有個免費領取公關票寫心得的活動，而寫心得對我來說並不是一件特別困難的事情。確認完同事是否「孤單寂寞覺得冷」真的需要我陪同參加後，就毫無懸念的報名了。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="MOPCON" scheme="http://pvt5r486.github.io/tags/MOPCON/"/>
    
      <category term="自我投資" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.53 將 Angular Universal 專案部屬至 Heroku</title>
    <link href="http://pvt5r486.github.io/f2e/20190809/1267942988/"/>
    <id>http://pvt5r486.github.io/f2e/20190809/1267942988/</id>
    <published>2019-08-09T07:40:56.000Z</published>
    <updated>2019-08-21T03:44:23.834Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們辛苦地做完網站後，總是會部屬到正式的伺服器上，而因為使用了 SSR 的技術， GitHub Pages 提供的靜態網頁服務已經不能滿足這個需求了，所以可以使用另一個常見的服務 <a href="https://www.heroku.com/home" rel="external nofollow noopener noreferrer" target="_blank"><strong>Heroku</strong></a> 。</p><p><img src="https://images.unsplash.com/photo-1565213821230-76951fa8b5c7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="關於-Heroku"><a href="#關於-Heroku" class="headerlink" title="關於 Heroku"></a>關於 Heroku</h2><p>這個部分不會著墨太多，僅會說明必要的部分，在此預設已經註冊一組 Heroku 的帳號了。</p><p>如果要將專案部屬到 Heroku 可以使用 <a href="https://devcenter.heroku.com/articles/heroku-cli" rel="external nofollow noopener noreferrer" target="_blank">Heroku CLI</a> 來達成，下載安裝後可以開啟終端機輸入 <code>heroku -v</code> 確定版本號。</p><p><img src="https://i.imgur.com/pKZDXFK.png" alt="Heroku CLI 安裝成功"></p><h2 id="調整-Angular-Universal-專案"><a href="#調整-Angular-Universal-專案" class="headerlink" title="調整 Angular Universal 專案"></a>調整 Angular Universal 專案</h2><p>Heroku 部屬的過程其實也不算太難，它有點像是一般開發過程時我們將專案推到 GitHub 般，所以是相當熟悉的。</p><p>但我們目前並不能直接將專案直接推上 Heroku ，因為還需要進行一些<strong>必要的調整</strong>，不然它會死給你看。</p><h3 id="新增-Procfile-檔案"><a href="#新增-Procfile-檔案" class="headerlink" title="新增 Procfile 檔案"></a>新增 Procfile 檔案</h3><p>Procfile 只是一個文件告訴 Heroku 要啟動你的應用程序需要執行什麼命令。所以需要在裡面填入：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: npm run start:heroku</span><br></pre></td></tr></table></figure><p></p><p>接著就可以保存退出了。</p><h3 id="編輯-package-json"><a href="#編輯-package-json" class="headerlink" title="編輯 package.json"></a>編輯 package.json</h3><p>接著要在 <code>scripts</code> 中新增一些指令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;start:heroku&quot;: &quot;node dist/server&quot;,</span><br><span class="line">&quot;postinstall&quot;: &quot;npm run build:ssr&quot;</span><br></pre></td></tr></table></figure><p></p><ul><li>第一個命令會啟動由 Angular Universal 構建的 node server</li><li><code>postinstall</code> 是 Heroku 在 npm 完成每個構建的所有依賴項安裝後自動運行的命令。</li></ul><p><strong>這麼一來前置作業都完成了，可以準備部屬到 Heroku 囉！</strong></p><h2 id="部屬到-Heroku"><a href="#部屬到-Heroku" class="headerlink" title="部屬到 Heroku"></a>部屬到 Heroku</h2><p>在部屬之前，務必要確認所有的異動都已經被 commit ，這樣待會推到 Heroku 才會正常哦。</p><p><strong>部屬步驟</strong></p><ol><li>在終端機執行 <code>heroku login</code> ，按照指示操作並且透過瀏覽器登入</li></ol><p><img src="https://i.imgur.com/mTp3L5E.png" alt="登入 Heroku"></p><ol start="2"><li>在終端機執行 <code>heroku create</code> ，新增一台 Heroku 主機</li></ol><p><img src="https://i.imgur.com/Hl2gOeg.png" alt="新增一台 Heroku 主機"></p><p>從這個步驟得知我們建立了一台叫 <code>radiant-refuge-87634</code> 的 Heroku 主機。</p><p><img src="https://i.imgur.com/L3uZ6Si.png" alt="git remomte -v"></p><ol start="3"><li>在終端機執行 <code>git push heroku master</code> ，將專案推到主機。</li></ol><p><img src="https://i.imgur.com/XfsHzGb.png" alt="push 成功"></p><blockquote><p>這個步驟會耗費比較多的時間，如果沒有什麼意外的話通常是會 push 成功。</p></blockquote><p><img src="https://i.imgur.com/FDVEVwq.png" alt="部屬成功"></p><p><img src="https://i.imgur.com/gC5Vs4a.png" alt="SSR 的效果還在"></p><h2 id="參考文章-amp-程式碼"><a href="#參考文章-amp-程式碼" class="headerlink" title="參考文章 &amp; 程式碼"></a>參考文章 &amp; 程式碼</h2><p>推到 Heroku 的過程中其實是遇到蠻多困難的，幸好國外有人整理文章供後人學習：</p><ul><li><a href="https://medium.com/augie-gardner/deploying-an-angular-universal-app-to-heroku-eca2b7966947" rel="external nofollow noopener noreferrer" target="_blank">Deploying an Angular Universal App to Heroku</a></li><li><a href="https://github.com/stephengardner/universal-starter-heroku" rel="external nofollow noopener noreferrer" target="_blank">universal-starter-heroku</a></li></ul><p><strong>程式碼</strong></p><ul><li><a href="https://github.com/pvt5r486/SSRDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></li><li><a href="https://radiant-refuge-87634.herokuapp.com/" rel="external nofollow noopener noreferrer" target="_blank">推上 Heroku 的結果</a></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實這兩篇文章最初就是自己在想：如果我幫朋友以現代的網頁技術架一個網站，那麼我可以怎麼做的想法作為出發點。</p><p>希望這兩篇簡單的筆記可以幫助到有同樣需求的人 &amp; 未來金魚腦忘記的自己。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      當我們辛苦地做完網站後，總是會部屬到正式的伺服器上，而因為使用了 SSR 的技術， GitHub Pages 提供的靜態網頁服務已經不能滿足這個需求了，所以可以使用另一個常見的服務 Heroku 。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.52 使用 Angular Universal 讓網站 SEO 提升</title>
    <link href="http://pvt5r486.github.io/f2e/20190809/2128364955/"/>
    <id>http://pvt5r486.github.io/f2e/20190809/2128364955/</id>
    <published>2019-08-09T06:10:58.000Z</published>
    <updated>2019-08-21T03:44:23.834Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Angular 建立的網站是屬於 SPA (Single-Page Application) 單頁應用，是一種網路應用程式或網站的模型，它通過動態重寫目前頁面來與用戶互動，而非傳統的從伺服器重新載入整個新頁面。</p><p>雖然現在 Google 的爬蟲已經可以看得懂 SPA 架構的網站，但其他的搜尋引擎不見得看得懂，因此使用 SSR (Server Side Render) 技術來輔助網站的 SEO 還是必要的。</p><p>關於更詳細的名詞解釋可以參考 <strong><a href="https://blog.techbridge.cc/2017/09/16/frontend-backend-mvc/" rel="external nofollow noopener noreferrer" target="_blank">前後端分離與 SPA - Huli</a></strong> ，本文不會有太多著墨。</p><p><img src="https://images.unsplash.com/photo-1565191999001-551c187427bb?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="Angular-Universal"><a href="#Angular-Universal" class="headerlink" title="Angular Universal"></a>Angular Universal</h2><p>其他前端主流框架如 React 或 Vue 對於 SPA 不利於 SEO 都有相關的解決辦法，如：</p><ul><li>React 可以使用 <a href="https://nextjs.org/" rel="external nofollow noopener noreferrer" target="_blank">Next</a></li><li>Vue 可以使用 <a href="https://zh.nuxtjs.org/" rel="external nofollow noopener noreferrer" target="_blank">Nuxt</a></li></ul><p>而 Angular 的解決方案就是使用 <strong><a href="https://angular.tw/guide/universal" rel="external nofollow noopener noreferrer" target="_blank">Angular Universal</a></strong>了。</p><p>在早期 Angular 要使用 SSR 技術似乎是相當麻煩的要修改很多地方，但現在卻可以使用少少的幾行指令就達成！而且幾乎是手把手照著　Angular　官網的步驟做，是不是相當友善呢～</p><h3 id="建立新的空白專案"><a href="#建立新的空白專案" class="headerlink" title="建立新的空白專案"></a>建立新的空白專案</h3><p>在終端機內輸入 <code>ng new [projectName]</code> 就可以建立起一個 Angular 的專案，這個示範中建立了 SSRDemo 專案。</p><p><img src="https://i.imgur.com/OHleM62.png" alt></p><p><img src="https://i.imgur.com/rRldqwW.png" alt="運行 SSRDemo"></p><h3 id="加入-nguniversal-express-engine-到專案中"><a href="#加入-nguniversal-express-engine-到專案中" class="headerlink" title="加入 @nguniversal/express-engine 到專案中"></a>加入 @nguniversal/express-engine 到專案中</h3><p>在終端機輸入以下指令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng add @nguniversal/express-engine --clientProject SSRDemo</span><br></pre></td></tr></table></figure><p></p><p>如此一來 Angular CLI 就會幫這個專案產生必要的檔案如： <code>app.server.module.ts</code> 。</p><p><img src="https://i.imgur.com/YUTHd6d.png" alt="執行指令後的異動"></p><p>不難看出 Angular CLI 幫我們做了相當多的事情，在早期這可是需要自己手動進行的而且不太容易。</p><h3 id="運行-Universal-Web-伺服器"><a href="#運行-Universal-Web-伺服器" class="headerlink" title="運行 Universal Web 伺服器"></a>運行 Universal Web 伺服器</h3><p>所有的準備工作都已經就緒，可以在終端機輸入以下指令啟動伺服器：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:ssr &amp;&amp; npm run serve:ssr</span><br></pre></td></tr></table></figure><p></p><p><strong>會得到乍看之下與尚未使用 SSR 技術前一樣的結果：</strong><br><img src="https://i.imgur.com/NaADLQv.png" alt></p><p><strong>但實際上原始的程式碼內已經大不相同了！</strong><br><img src="https://i.imgur.com/6tiiGTI.png" alt="使用 SSR"></p><p><img src="https://i.imgur.com/OLz8EeS.png" alt="不使用 SSR"></p><blockquote><p>不難看出有使用 SSR 技術的原始碼內多了不少內容，而這些內容就是要給搜尋引擎爬蟲看的。</p></blockquote><h3 id="在-HTTP-中使用絕對位置"><a href="#在-HTTP-中使用絕對位置" class="headerlink" title="在 HTTP 中使用絕對位置"></a>在 HTTP 中使用絕對位置</h3><p>在 Universal 應用中 HTTP 的 URL 必須是絕對位置，只有這樣 Universal 的 Web 伺服器才能處理那些請求。</p><p>這意味著當執行在伺服器端時，要使用絕對 URL 發起請求，而在瀏覽器中，則使用相對 URL。</p><p>在官網的 Angular 教學 (英雄範例) 中的服務都把請求送到了相對的 URL ，所以為了使其正常運作，需要額外建立 <code>HttpInterceptor</code> ，令其使用絕對 URL 發起請求。</p><p><strong>建立 universal-interceptor.ts</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Injectable, Inject, Optional&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HttpInterceptor, HttpHandler, HttpRequest, HttpHeaders&#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Request&#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;REQUEST&#125; <span class="keyword">from</span> <span class="string">'@nguniversal/express-engine/tokens'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UniversalInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Optional</span>() <span class="meta">@Inject</span>(REQUEST) <span class="keyword">protected</span> request: Request</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler) &#123;</span><br><span class="line">    <span class="keyword">let</span> serverReq: HttpRequest&lt;<span class="built_in">any</span>&gt; = req;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.request) &#123;</span><br><span class="line">      <span class="keyword">let</span> newUrl = <span class="string">`<span class="subst">$&#123;this.request.protocol&#125;</span>://<span class="subst">$&#123;this.request.get('host')&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">if</span> (!req.url.startsWith(<span class="string">'/'</span>)) &#123;</span><br><span class="line">        newUrl += <span class="string">'/'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      newUrl += req.url;</span><br><span class="line">      serverReq = req.clone(&#123;url: newUrl&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next.handle(serverReq);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>調整 app.server.module.ts</strong><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HTTP_INTERCEPTORS&#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;UniversalInterceptor&#125; <span class="keyword">from</span> <span class="string">'./universal-interceptor'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  providers: [&#123;</span><br><span class="line">    provide: HTTP_INTERCEPTORS,</span><br><span class="line">    useClass: UniversalInterceptor,</span><br><span class="line">    multi: <span class="literal">true</span></span><br><span class="line">  &#125;],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppServerModule &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>現在當伺服器發起每個 HTTP 請求時，該攔截器都會被觸發，並把請求的 URL 替換為由 Express 的 Request 物件給出的絕對位置。</p></blockquote><h3 id="參考文件-amp-程式碼"><a href="#參考文件-amp-程式碼" class="headerlink" title="參考文件 &amp; 程式碼"></a>參考文件 &amp; 程式碼</h3><p>一開始還沒實作時看了蠻多篇文章的，但距今都有一定的時日了，在前端技術迭代的如此迅速的情況下，一篇幾年前的文章參考價值就不那麼高了，但對於了解整個脈絡還是很有幫助的，因此還是列出大致上看過那些文章：</p><ul><li><strong><a href="https://angular.tw/guide/universal" rel="external nofollow noopener noreferrer" target="_blank">Angular 官方 - Universal</a></strong></li><li><strong><a href="https://ithelp.ithome.com.tw/articles/10195360" rel="external nofollow noopener noreferrer" target="_blank">IT 鐵人邦 - Angular Universal</a></strong></li><li><strong><a href="https://blog.miniasp.com/post/2017/06/18/How-to-setup-Angular-Universal-in-an-Angular-CLI-project" rel="external nofollow noopener noreferrer" target="_blank">保哥 - 如何在 Angular CLI 建立的專案加入 Angular Universal 伺服器渲染功能</a></strong></li></ul><p><strong>程式碼</strong></p><ul><li><strong><a href="https://github.com/pvt5r486/SSRDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></strong></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>結束了本篇的學習後，下一篇文章我們將試著將這份專案正式部屬到 Heroku 讓練習更加完整。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      使用 Angular 建立的網站是屬於 SPA (Single-Page Application) 單頁應用，是一種網路應用程式或網站的模型，它通過動態重寫目前頁面來與用戶互動，而非傳統的從伺服器重新載入整個新頁面。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Request 的取消與檔案上傳實作</title>
    <link href="http://pvt5r486.github.io/f2e/20190724/1338660786/"/>
    <id>http://pvt5r486.github.io/f2e/20190724/1338660786/</id>
    <published>2019-07-24T02:04:56.000Z</published>
    <updated>2019-08-09T07:38:54.245Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前陣子因為專案需求，所以開始研究如何實踐 Drag &amp; Drop 進行拖曳上傳，由於 Team Leader 的要求，希望目標是能達到跟 Google Drive 一樣的操作體感，於是遇到第一個問題，「<strong>Google Drive 允許使用者取消上傳欸，啊我們要怎麼實作取消上傳</strong>」？</p><p><img src="https://images.unsplash.com/photo-1563861826100-9cb868fdbe1c?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="實際觀察-Google-Drive"><a href="#實際觀察-Google-Drive" class="headerlink" title="實際觀察 Google Drive"></a>實際觀察 Google Drive</h2><p><strong>模仿的第一步就是先觀察</strong>，所以到 Google Drive 實際操作一次檔案上傳的流程，並且透過開發者工具觀察。</p><p><img src="https://i.imgur.com/Suue94c.png" alt="上傳後取消上傳的 Request"></p><p>雖然從這個角度仍無法得知 Google 這段期間在背後做了什麼，但是至少有了可以追查的線索：</p><ul><li>有個 HTTP Request 的 Status 在按下取消後變成了 <code>cancel</code></li></ul><p>換句話說可以接著從「<strong>如何取消 or 中斷 HTTP 的 Request</strong>」開始著手。</p><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>如果多嘗試這些關鍵字，最後會搜尋到再 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest" rel="external nofollow noopener noreferrer" target="_blank"><code>Xhr</code></a> 內有個 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/abort" rel="external nofollow noopener noreferrer" target="_blank"><code>.abort</code></a> 方法可以使用。</p><p><img src="https://i.imgur.com/7lPJAUT.png" alt="截自 MDN"></p><h2 id="方法嘗試階段"><a href="#方法嘗試階段" class="headerlink" title="方法嘗試階段"></a>方法嘗試階段</h2><p>有了可用的方法，接下來就是試著實作看看了，由於目前沒有後端開 API 給我們測試，在本機端使用 Json-Server 可能回應速度太快來不及按取消就完成了，於是理想方案可以串 <a href="https://randomuser.me/" rel="external nofollow noopener noreferrer" target="_blank">RANDOM USER</a> 這支好用的 API 來測試想法。</p><p><strong>Code</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"sendRequest"</span>&gt;</span>發送請求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"cancelRequest"</span>&gt;</span>取消請求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./play2request.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sendRequest = <span class="built_in">document</span>.querySelector(<span class="string">'#sendRequest'</span>);</span><br><span class="line"><span class="keyword">const</span> cancelRequest = <span class="built_in">document</span>.querySelector(<span class="string">'#cancelRequest'</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">sendRequest.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, <span class="string">'https://randomuser.me/api/'</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">cancelRequest.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'取消請求'</span>);</span><br><span class="line">  xhr.abort();</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/AHutukB.png" alt="按下發送後馬上取消"></p><p><img src="https://i.imgur.com/8wQdwSz.png" alt="取消後確實不再取得資料"></p><p><strong>至此，足以驗證 <code>xhr.abort()</code> 確實是可以中斷請求的發送，那麼如果是用在檔案上傳呢？伺服器真的會因為前端中斷的　HTTP 的請求就停止檔案上傳嗎？</strong></p><p>為了驗證想法，我們必須自己實作一個簡易的 node.js 伺服器。</p><h2 id="使用-node-js-實作一個簡易的檔案上傳功能"><a href="#使用-node-js-實作一個簡易的檔案上傳功能" class="headerlink" title="使用 node.js 實作一個簡易的檔案上傳功能"></a>使用 node.js 實作一個簡易的檔案上傳功能</h2><p>基於「方法嘗試階段」最後的結論，必須實作一個伺服器才能滿足我的好奇心。</p><p>但是我又不太熟 node.js 又有點懶，因此在這裡感謝 <a href="https://hsiangfeng.github.io/" target="_blank" rel="noopener">Ray</a> 幫我產出一個簡易的模板。</p><p>至於 node.js 該怎麼實作檔案上傳以及怎麼開 API 我就不多著墨了，畢竟這不是主要的內容。</p><p>於是一番努力後，我們有了最基本的 code ，試著調整並搭配剛才的程式碼。</p><p><strong>code</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">`./uploads`</span>;</span><br><span class="line"><span class="keyword">var</span> storage = multer.diskStorage(&#123;</span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, path)</span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, file.originalname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;).any()</span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/upload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  upload(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> multer.MulterError) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    res.json(&#123; <span class="attr">message</span>: <span class="string">'上傳完成'</span>&#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/9WbP7nR.png" alt="發送請求 &amp; 接收到回應"></p><p><img src="https://i.imgur.com/sXLtfy8.png" alt="確實有收到檔案"></p><p><strong>很快地發現了第一個問題：</strong></p><ul><li>當按下取消請求後，請求確實被終止了，但為什麼後端還是有接收到檔案？<ul><li>原因是檔案的上傳並不是直接就上傳一個檔案，而是會分解成很多個封包進行傳送，所以再<strong>取消</strong>請求後，後端仍然會收到殘缺的檔案。</li></ul></li></ul><p><img src="https://i.imgur.com/UYnXnwA.png" alt="大型檔案取消請求後"></p><p><img src="https://i.imgur.com/rEvdxBa.png" alt="後端仍然接收到，但大小不正確"></p><p><strong>總結現況得出以下結論：</strong></p><ul><li>需要得知前端何時按下取消鈕，這樣才能做出相應的處置，像是刪除不完整的檔案。</li></ul><h2 id="方法嘗試階段-1"><a href="#方法嘗試階段-1" class="headerlink" title="方法嘗試階段"></a>方法嘗試階段</h2><p>於是乎我們又回到了方法嘗試階段，老實說這裡我嘗試了很多方法，仍然無法得知前端何時按下<code>取消請求</code>，後來不得已把問題整理乾淨後上<a href="https://www.facebook.com/groups/f2e.tw/permalink/2272532992784053/" rel="external nofollow noopener noreferrer" target="_blank">前端社群</a>發問。</p><p>最後得知我要的答案或許在 <a href="https://github.com/expressjs/multer/issues/259?fbclid=IwAR2LIvNnTiUDvafrCx2EM1q552_q0ykqxSNVR7uNtYjXuGB6uRtphISStro" rel="external nofollow noopener noreferrer" target="_blank">multer 的 issue 內</a></p><p>當然這個過程是不斷的反覆測試、修改的，最終我也實作檔案上傳比較常見的流程：</p><ol><li>當檔案上傳時，會先被放在 <code>temp</code> 資料夾</li><li>如果使用者取消請求，則進行刪除</li><li>如果使用者完成上傳，則移動到 <code>uploads</code> 資料夾</li></ol><p><strong>另外再進行檔案刪除時，也碰到一個雷：</strong><br>當使用 <a href="https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback" rel="external nofollow noopener noreferrer" target="_blank">fs.unlink()</a> 進行檔案的刪除時：</p><ul><li>VS Code 內的檔案瀏覽器重新整理後的確會看到檔案已經被刪除</li><li>但是 Windows 的檔案總管以及終端機指令仍然可以發現檔案還是存在，直到關閉 node.js 伺服器</li></ul><p>這個地雷最終也獲得了詳細說明，<a href="http://man7.org/linux/man-pages/man2/unlink.2.html" rel="external nofollow noopener noreferrer" target="_blank">詳見此</a>，感謝<a href="https://medium.com/@hulitw" rel="external nofollow noopener noreferrer" target="_blank">胡立</a>大大指點。</p><blockquote><p>截自連結部分敘述<br>unlink() deletes a name from the filesystem. If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available for reuse.</p></blockquote><p><strong>所以我們又有了新的實作目標，接著又回到實作階段了！</strong></p><h2 id="改良檔案上傳的程式碼"><a href="#改良檔案上傳的程式碼" class="headerlink" title="改良檔案上傳的程式碼"></a>改良檔案上傳的程式碼</h2><p>基於上一階段的結論，所以我使用社群內前輩的建議作法，上傳後先放在 <code>temp</code> 資料夾，等到確定上傳完成才移動到 <code>uploads</code> 資料夾，而 <code>temp</code> 資料夾就可以用各種做法定期清除或者自然等伺服器重啟清除。</p><p>而我最終版本的 code 如下：</p><p><strong>node.js</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">`./tmp`</span>;</span><br><span class="line"><span class="keyword">var</span> storage = multer.diskStorage(&#123;</span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, path)</span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, file.originalname);</span><br><span class="line">    req.filename = file.originalname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;).any()</span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/upload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  req.on(<span class="string">'aborted'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'req aborted by client'</span>);</span><br><span class="line">    fs.unlink(<span class="string">`<span class="subst">$&#123;path&#125;</span>/<span class="subst">$&#123;req.filename&#125;</span>`</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'已經刪除檔案!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  upload(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> multer.MulterError) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> targetPath = <span class="string">`./uploads/<span class="subst">$&#123;req.filename&#125;</span>`</span>;</span><br><span class="line">    fs.rename(<span class="string">`<span class="subst">$&#123;path&#125;</span>/<span class="subst">$&#123;req.filename&#125;</span>`</span>, targetPath, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'移動完成'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.json(&#123; <span class="attr">message</span>: <span class="string">'上傳完成'</span>&#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>前端部分</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sendRequest = <span class="built_in">document</span>.querySelector(<span class="string">'#sendRequest'</span>);</span><br><span class="line"><span class="keyword">const</span> cancelRequest = <span class="built_in">document</span>.querySelector(<span class="string">'#cancelRequest'</span>);</span><br><span class="line"><span class="keyword">const</span> fileUploader = <span class="built_in">document</span>.querySelector(<span class="string">'#file-uploader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">fileUploader.addEventListener(<span class="string">'change'</span>, (e) =&gt; &#123;</span><br><span class="line">  form.append(<span class="string">"file"</span>, e.target.files[<span class="number">0</span>])</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">sendRequest.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'http://localhost:3000/upload'</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.send(form);</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">cancelRequest.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'取消請求'</span>);</span><br><span class="line">  xhr.abort();</span><br><span class="line">  form = <span class="keyword">new</span> FormData();</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fileUploader.addEventListener(<span class="string">'change'</span>, (e) =&gt; &#123;</span><br><span class="line">  form.append(<span class="string">"file"</span>, e.target.files[<span class="number">0</span>])</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/We9h53x.png" alt="上傳大檔案發送後取消"></p><p><img src="https://i.imgur.com/cXskbXL.png" alt="上傳小檔案完成"></p><blockquote><p>特別要注意的是，這邊的 code 終究只是我拿來驗證想法而寫的 code ，因此有很多狀況沒有考慮到，所以不建議直接把這段 code 直接複製拿去用。</p></blockquote><p>其實做到這邊已經功德圓滿了～我想知道的都已經知道了，但我們專案都是使用 Angular 寫的，那麼再 Angular 該如何取消請求呢？</p><h2 id="Angular-取消請求"><a href="#Angular-取消請求" class="headerlink" title="Angular 取消請求"></a>Angular 取消請求</h2><p>再 Angular 專案中會使用 <code>.subscribe()</code> 方法來訂閱某個 API 的結果，而要取消請求則可以使用 <code>.unsubscribe()</code> 方法，具體實作如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file-uploader"</span> <span class="attr">name</span>=<span class="string">"file"</span> (<span class="attr">change</span>)=<span class="string">"selectFile($event)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"sendRequest"</span> (<span class="attr">click</span>)=<span class="string">"sendRequest()"</span>&gt;</span>發送請求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"cancelSub()"</span>&gt;</span>取消訂閱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild, ElementRef, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpRequest &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Subscription &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  data;</span><br><span class="line">  subscript: Subscription;</span><br><span class="line">  form: FormData;</span><br><span class="line">  <span class="keyword">constructor</span>(private httpClient: HttpClient) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscript = <span class="keyword">new</span> Subscription();</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cancelSub() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscript.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  selectFile(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.form = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">this</span>.form.append(<span class="string">'file'</span>, e.target.files[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sendRequest() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscript = <span class="keyword">this</span>.uploadFile().subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data = result;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'錯誤資訊'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uploadFile() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.post(<span class="string">'http://localhost:3000/upload'</span>, <span class="keyword">this</span>.form);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊運行的結果會跟上一段的結論一樣～就不反覆截圖了。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>其實寫程式我覺得就是一直重複「方法嘗試階段」以及「實作階段」。</p><p>而這個過程中我覺得最累也最有趣同時也最傷腦筋的就是「方法嘗試階段」，只要過了這個階段，後面的「實作階段」就相對單純很多。</p><p>而當「實作階段」結束後肯定會玩看看，如果出現預期外的結果，就回到「方法嘗試階段」，周而復始。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前陣子因為專案需求，所以開始研究如何實踐 Drag &amp; Drop 進行拖曳上傳，由於 Team Leader 的要求，希望目標是能達到跟 Google Drive 一樣的操作體感，於是遇到第一個問題，「Google Drive 允許使用者取消上傳欸，啊我們要怎麼實作取消上傳」？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://pvt5r486.github.io/tags/Node-js/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Base64 是編碼不是加密 &amp; 用 Node.js 實作簡易 RSA 非對稱式加密</title>
    <link href="http://pvt5r486.github.io/f2e/20190711/4123217379/"/>
    <id>http://pvt5r486.github.io/f2e/20190711/4123217379/</id>
    <published>2019-07-11T01:55:49.000Z</published>
    <updated>2019-07-24T02:06:11.935Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因為專案需求所以有稍微用到一些密碼學的部分，前幾天團隊內的同事在研究的時候，我也好奇的上前圍觀，但才疏學淺，居然脫口說出 base64 是加密的一種然後被噹爆，超想躲進土裡的啊啊啊！！</p><p>所以為了雪恥，決定稍微研究一下 RSA 非對稱式加密，以及整理一下 Base64 只是<strong>編碼</strong>不是<strong>加密</strong>這件事情。</p><p><img src="https://images.unsplash.com/photo-1556742205-e10c9486e506?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>在說明之前可以先從 WIKI 上了解 <a href="https://zh.wikipedia.org/wiki/Base64" rel="external nofollow noopener noreferrer" target="_blank">Base64 是什麼樣的東西</a>。</p><p><strong>懶人包： Base64 是編碼的一種，並沒有 Base64 加密這回事。</strong></p><blockquote><p>以下節錄自 <strong>WIKI</strong>：<br>Base64 是一種基於 64 個可列印字元來表示二進位資料的表示方法，常用於在通常處理文字資料的場合，表示、傳輸、儲存一些二進位資料，包括MIME的電子郵件及 XML 的一些複雜資料。</p></blockquote><p>而如果我們有仔細看 WIKI 的話，會發現這份文檔皆是使用 Base64 <strong>編碼</strong>而非 Base64<strong>加密</strong>，從這邊其實就可以看出一些蛛絲馬跡。</p><h2 id="加密？編碼？"><a href="#加密？編碼？" class="headerlink" title="加密？編碼？"></a>加密？編碼？</h2><p>這三者無論是用中文、英文來看都有相當大的差異：</p><ol><li>加密 (Encrypt)</li><li>編碼 (Encode)</li></ol><p>到底為什麼很多人會把這三種完全不一樣的東西都當成加密呢？</p><blockquote><p>主要是因為透過這三種方式處理過後的資料，都會長的跟原本不一樣，一般人無法直接用肉眼辨別，就會讓人覺得像是被加密處理過的天書。</p></blockquote><p>然而並不是把資料變成人看不懂的東西就可以稱為加密，身為一個工程師，如果搞不清楚箇中差異是會被笑的。 (就跟我被噹爆一樣…)</p><p>所幸這部分已經有前輩整理好了，以下敘述引用自 <a href="https://blog.m157q.tw/posts/2017/12/23/differences-between-encryption-compression-and-encoding/" rel="external nofollow noopener noreferrer" target="_blank">m157q 前輩的部落格 - 如何區分加密、壓縮、編碼</a>，感謝前輩辛苦整理的資料。</p><h3 id="加密-Encrypt"><a href="#加密-Encrypt" class="headerlink" title="加密 (Encrypt)"></a>加密 (Encrypt)</h3><p><strong>對稱式加密 (Symmetric Encryption)</strong>：</p><ul><li>首先產生一個新的字串作為密鑰，也就是一把鑰匙<ul><li>可以想像成，加密演算法幫你打造出你給它的這把密鑰才可以開啟的寶箱，幫你把原文放入寶箱後，用這把密鑰上鎖，上鎖後的寶盒就是密文，看不到裡面的東西是什麼</li><li>這種只有一把鑰匙的加密演算法被稱為<strong>對稱式加密 (Symmetric Encryption)</strong></li></ul></li></ul><p>然而對稱式加密的安全性以及在實際應用上不夠理想，於是出現了安全性更高，應用範圍更廣的<strong>非對稱式加密 (Asymmetric Encryption)</strong></p><p><strong>非對稱式加密 (Asymmetric Encryption)</strong>：</p><ul><li>非對稱式加密演算法會有兩把鑰匙，分別為公鑰、私鑰</li><li>非對稱式加密除了可以做到加密以外，還可以生成數位簽章，確認密文的傳送方身份真的是本人</li></ul><blockquote><p>兩者各有各的優缺點，所以實際應用上通常都是視情況而定。</p></blockquote><p><strong>常見演算法</strong></p><ul><li>對稱式：DES 、 3DES 、 AES</li><li>非對稱式：RSA 、 DSA 、 ECC</li></ul><p>根據這一段加密的介紹，再回頭過來想使用 Base64 的場景，可推出如下結論：<br><strong>使用 base64 的時候不需要密鑰，而且任何人編碼的 base64 訊息，誰都可以經過 base64 解碼回來，所以 base64 不是加密。</strong></p><h3 id="編碼-Encoding"><a href="#編碼-Encoding" class="headerlink" title="編碼 (Encoding)"></a>編碼 (Encoding)</h3><p>編碼牽涉的範圍非常廣，如:</p><ul><li>字元編碼 (Character Encoding)</li><li>音訊編碼 (Audio Encoding)</li><li>視訊編碼 (Video Encoding)</li></ul><p>而 Base64 屬於字元編碼的部分，而<strong>編碼</strong>的特性為：</p><ul><li>將原文轉換成另外一種表達方式</li><li>不需要密鑰，只要知道使用哪個編碼演算法，任何人都可以解碼<ul><li>這也是單純編碼被拿來誤用成加密演算法最危險的地方，因為完全不需要花時間猜密鑰</li></ul></li><li>不同的編碼演算法有不同的特性<ul><li>錯誤偵測 (Error Detection)<ul><li>檢查訊息在經過傳送後是否已經改變</li></ul></li><li>錯誤校正 (Error Correction)<ul><li>自動修正在經過傳送後錯誤的內容</li></ul></li><li>方便資料進行傳輸<ul><li>以不同的形式表示相同的資料</li><li>例如: base64 就把二進位的資料用 ASCII 來表示</li></ul></li></ul></li></ul><p><strong>常見演算法</strong></p><ul><li><a href="https://zh.wikipedia.org/wiki/Base64" rel="external nofollow noopener noreferrer" target="_blank">Base64</a></li><li><a href="https://blog.xuite.net/dizzy03/murmur/44843892-%5B%E8%BD%89%5D+%E6%B7%B7%E4%BA%82%E7%9A%84+URLEncode" rel="external nofollow noopener noreferrer" target="_blank">URLEncode</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E7%A0%81" rel="external nofollow noopener noreferrer" target="_blank">hamming code</a></li></ul><h2 id="RSA-非對稱式加密"><a href="#RSA-非對稱式加密" class="headerlink" title="RSA 非對稱式加密"></a>RSA 非對稱式加密</h2><p>由於看同事們那個時候再弄的範例有公鑰 (public Key) 、私鑰 (private Key) 之分，藉由上面的介紹可知這是一種非對稱式的加密方式，因此更進一步 Google 後，決定使用 node.js 來簡單實作看看 <strong>RSA 非對稱式加密</strong>。</p><p>有關 RSA 非對稱式加密的部分，可以參考：</p><ul><li><a href="https://blog.techbridge.cc/2017/04/16/simple-cryptography/" rel="external nofollow noopener noreferrer" target="_blank">網路安全(1) - 基礎密碼學</a></li><li><a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" rel="external nofollow noopener noreferrer" target="_blank">RSA加密演算法</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10188824" rel="external nofollow noopener noreferrer" target="_blank">[Day27] 非對稱金鑰加密系統(RSA)</a></li></ul><h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>技術實作方面，得知 Node.js 已經有相關的加密包 (crypto) 可以使用，於是可以針對這個關鍵字搜尋，得出不少可用資源，整理如下：</p><ul><li><a href="https://www.cnblogs.com/chyingp/p/nodejs-asymmetric-enc-dec.html" rel="external nofollow noopener noreferrer" target="_blank">Node.js 进阶：5 分钟入门非对称加密方法</a><ul><li>本文範例是基於此改良</li></ul></li><li><a href="https://nodejs.org/api/crypto.html" rel="external nofollow noopener noreferrer" target="_blank">Node.js 官方文件 - crypto</a></li></ul><p><strong>直接上完整程式碼</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> priPassword = <span class="string">`Nice Password`</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello`</span>;</span><br><span class="line">play2RSA(message, priPassword);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">play2RSA</span>(<span class="params">message, priPassword</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keyPair = <span class="keyword">await</span> makeKeyPair(priPassword);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'公鑰：'</span>,　keyPair.publicKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'私鑰：'</span>,　keyPair.privateKey);</span><br><span class="line">  <span class="keyword">let</span> crypted = encrypt(message, keyPair.publicKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'加密結果：'</span>,　crypted.toString(<span class="string">'base64'</span>));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> decrypted = decrypt(crypted, keyPair.privateKey, priPassword);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'解密結果：'</span>, decrypted.toString());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'解密失敗'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params">data, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> crypto.publicEncrypt(key, Buffer.from(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params">encrypted, key, priPassword</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keyObj = &#123;</span><br><span class="line">    key: key,</span><br><span class="line">    passphrase: priPassword</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crypto.privateDecrypt(keyObj, encrypted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 KeyPair, 並單獨針對私鑰再進行一次加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKeyPair</span>(<span class="params">priPassword</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    crypto.generateKeyPair(<span class="string">'rsa'</span>, &#123;</span><br><span class="line">      modulusLength: <span class="number">4096</span>,</span><br><span class="line">      publicKeyEncoding: &#123;</span><br><span class="line">        type: <span class="string">'spki'</span>,</span><br><span class="line">        format: <span class="string">'pem'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      privateKeyEncoding: &#123;</span><br><span class="line">        type: <span class="string">'pkcs8'</span>,</span><br><span class="line">        format: <span class="string">'pem'</span>,</span><br><span class="line">        cipher: <span class="string">'aes-256-cbc'</span>,</span><br><span class="line">        passphrase: priPassword</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, (err, publicKey, privateKey) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> keyPair = &#123;</span><br><span class="line">        publicKey: publicKey,</span><br><span class="line">        privateKey: privateKey</span><br><span class="line">      &#125;</span><br><span class="line">      err !== <span class="literal">null</span> ? reject(err) : resolve(keyPair);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這段程式主要是按照希望的格式產生公、私鑰之後，接著使用公鑰加密 <code>message</code> 變數的字串，最後在使用私鑰解密。</p><p>但因為私鑰的部分，我額外的上了一層加密，所以在進行解密的時候需要額外帶入私鑰的密碼才可以順利進行。</p><ul><li><a href="https://repl.it/repls/RoyalblueOurConnection" rel="external nofollow noopener noreferrer" target="_blank">範例線上試玩</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      因為專案需求所以有稍微用到一些密碼學的部分，前幾天團隊內的同事在研究的時候，我也好奇的上前圍觀，但才疏學淺，居然脫口說出 base64 是加密的一種然後被噹爆，超想躲進土裡的啊啊啊啊！！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://pvt5r486.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>滿月紀念</title>
    <link href="http://pvt5r486.github.io/life-note/20190708/724990059/"/>
    <id>http://pvt5r486.github.io/life-note/20190708/724990059/</id>
    <published>2019-07-08T02:41:42.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>時間過得很快，不知不覺的我就滿月了。期間不斷進行的是與團隊成員的磨合，而之前提到的 Side Project 也如期地進行中。</p><p>畢竟是優先度較低的 Side Project ，所以對於其他團隊成員來說，都是運用比較零碎的時間來做，主要還是處理主力專案。</p><p>而我因為還沒正式接觸到公司專案，自然重心是放在這個 Side Project 上。</p><p><img src="https://images.unsplash.com/photo-1562337680-64ccd42beca3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=700&amp;q=80" alt="還有好一段要走"></p><h2 id="磨合-amp-心境"><a href="#磨合-amp-心境" class="headerlink" title="磨合 &amp; 心境"></a>磨合 &amp; 心境</h2><p>如上面提到的，這是個團隊的 Side Project ，意味著可以自由地玩很多新東西。</p><p>Team Leader 決定導入 <a href="https://prettier.io/" rel="external nofollow noopener noreferrer" target="_blank">prettier</a> 並且提交 <code>commit</code> 時觸發 <code>prettier</code> 的自動格式化，最後在 GitLab 上 進行 CICD 的檢查，達成團隊的 Coding Style 一致。</p><p>然而在開發習慣上，因為之前都是單兵作業，所以比較少顧慮到可能會有其他團隊成員來維護同一份 Code 的情形。</p><p>這也導致了寫某些程式時缺少了比較長遠的思考，很多部分都是後來發現「<strong>不能這樣寫、這麼寫不夠好</strong>」而又回頭修改。</p><p>團隊基本上是使用 Angular 搭配 TypeScript 進行開發的，而我之前在學習前端時都是使用 JavaScript ，在思維上有一點差異，這也是我目前需要學習與磨合的地方。</p><h3 id="舉例來說"><a href="#舉例來說" class="headerlink" title="舉例來說"></a>舉例來說</h3><p>在敏捷開發 Sprint 的第一周，我負責的是串接某一支自己 Mock 出來的 API，裡面的內容雖然我有整理好一份文件，但呼叫 API 後的內容仍然只有我一個人知道，團隊的其他成員完全不知道呼叫這支 API 後會回傳什麼結果，導致後續維護不方便。</p><p>因為：</p><ul><li>如果要知道這支 API 會回傳什麼就得呼叫它，並印出來</li><li>翻閱文件</li></ul><p>但這對之前的我來說是一件很正常的事情：</p><blockquote><p>接 API 如果不知道內容是什麼，印出來不就好了嗎？或者看文件也行，上面都有寫。</p></blockquote><p><strong>這樣的確可以，但對團隊來說，這還不夠好。</strong></p><p>所以實作一個 class 並且透過 TypeScript 將該變數型別設定為它，如此一來就可以在接到 API 傳來的資料後，使用「.」看到這個物件下有什麼屬性、方法能使用。</p><p>搭配適當的命名就可以讓維護的人明白這支 API 會回傳的內容有哪些。</p><p>而這也只是與團隊磨合的一小部分而已，我還必須持續透過這個 Side Project 了解到許多團隊協作的眉角。</p><h3 id="心境"><a href="#心境" class="headerlink" title="心境"></a>心境</h3><p>在開發上當然也遇到了一些困難，自己歸納後最主要的原因果然還是：</p><ul><li>不夠熟悉 Angular 以及 TypeScript 的原理</li></ul><p>在 Sprint 的第一周時，我先行使用原生的 JavaScript 快速的把原型給搭建出來，像是 Mock API 、 GitLab API 的串接整理、圖表繪製等等…，過程都蠻順利的，也很少麻煩到團隊內的前端同事。</p><p>但在實際轉換成 Angular 時，卻遇到了不少自己想不透的問題需要請教同事，這讓我有點不好意思。</p><blockquote><p>像是上面提到的協作問題、舊版本 <code>ng2charts</code> 的 Bug 、寫測試、還有一些特殊名詞 &amp; 觀念問題。</p></blockquote><p>最終總算是在交作業的前一天完成了，幸好同事也不厭其煩地與我一同排除掉這些問題，真的是非常感謝。</p><p>但我也希望自己能夠早日解除這種狀態，實在是有點擔心自己試用期不會過 (汗)</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實還有很多族繁不及備載的芝麻蒜皮小事，像是命名與程式寫完之後該怎麼調整才能讓結構看起來易讀，這些都是值得我去努力的東西。</p><p>然後也借了一本<a href="https://www.books.com.tw/products/0010598217" rel="external nofollow noopener noreferrer" target="_blank">無瑕的程式碼 番外篇：專業程式設計師的生存之道</a>，書名看起來就像是我這輩子絕對不會看的東西，但我終究是借來看了。</p><blockquote><p><strong>那個當初連 「Hello World」 印出都有困難的人去哪了？</strong></p></blockquote><p><strong>一個人可以改變這麼多，每當回頭想起，我還是覺得很不可思議。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      時間過得很快，不知不覺的我就滿月了。期間不斷進行的是與團隊成員的磨合，而之前提到的 Side Project 也如期地進行中。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="職場經驗" scheme="http://pvt5r486.github.io/tags/%E8%81%B7%E5%A0%B4%E7%B6%93%E9%A9%97/"/>
    
      <category term="里程碑" scheme="http://pvt5r486.github.io/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.51 如何在 Angular 內使用第三方套件</title>
    <link href="http://pvt5r486.github.io/f2e/20190628/4197344469/"/>
    <id>http://pvt5r486.github.io/f2e/20190628/4197344469/</id>
    <published>2019-06-28T02:05:35.000Z</published>
    <updated>2019-07-08T02:36:51.110Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在專案的開發中有些時候為了應付特殊的需求會安裝一些第三方的套件，避免重複造輪子。而這第三方套件很可能會是 CSS 框架或者是一些 很方便的 library 等等，而我們要如何在 Angular 環境中使用它們呢？本篇將介紹 Bootstrapt4 以及 json-server 如何再 Angular 的環境下使用。</p><h2 id="建立新的-Angular-專案"><a href="#建立新的-Angular-專案" class="headerlink" title="建立新的 Angular 專案"></a>建立新的 Angular 專案</h2><p>都已經是 No.51 了，我想對於建立新的 Angular 專案並不是什麼太困難的事情。</p><p>執行 <code>ng new pluginDemo</code> ，建立起本次範例的專案。</p><p><img src="https://i.imgur.com/06J2Xik.png" alt></p><h2 id="安裝-CSS-框架-Bootstrap4"><a href="#安裝-CSS-框架-Bootstrap4" class="headerlink" title="安裝 CSS 框架 - Bootstrap4"></a>安裝 CSS 框架 - Bootstrap4</h2><p>接著來到 <a href="https://getbootstrap.com/" rel="external nofollow noopener noreferrer" target="_blank">Bootstrap4 的官方</a>，看看如何取得 Bootstrap4 吧！</p><p>Bootstrap4 提供下列使用方式：</p><ul><li>以 CDN 的方式使用</li><li>以 npm / yarn 的方式取得</li></ul><h3 id="以-CDN-的方式使用-Bootstrap4"><a href="#以-CDN-的方式使用-Bootstrap4" class="headerlink" title="以 CDN 的方式使用 Bootstrap4"></a>以 CDN 的方式使用 Bootstrap4</h3><p>以這個情境來講，一定是整個專案都希望可以用 Bootstrap4 的東西，因此可以在 <code>src/styles.scss</code> 這裡做一些調整，這隻檔案會影響到整個 Angular 專案的 CSS 。</p><p><strong>src/styles.scss</strong><br></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* You can add global styles to this file, and also import other style files */</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">'https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css'</span>);</span><br></pre></td></tr></table></figure><p></p><p>如果要完整的使用 Bootstrap4 所有的東西，也必須引入相關的 js 檔案才行， js 檔案可以在 <code>index.html</code> 內引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>PluginDemo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-root</span>&gt;</span><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.3.1.slim.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接著隨意地找 Bootstrap4 官網上的範例，貼在 appComponent 的 Template 上，測試有無效果。</p><p>例如貼上 <a href="https://getbootstrap.com/docs/4.3/components/modal/" rel="external nofollow noopener noreferrer" target="_blank">modal 的範例程式碼</a></p><p><img src="https://i.imgur.com/lsv9eFQ.png" alt="成功執行 modal"></p><h3 id="以-npm-或-yarn-的方式使用-Bootstrap4"><a href="#以-npm-或-yarn-的方式使用-Bootstrap4" class="headerlink" title="以 npm 或 yarn 的方式使用 Bootstrap4"></a>以 npm 或 yarn 的方式使用 Bootstrap4</h3><p>這部分因為 npm 或 yarn 使用的方式差不多，所以我就只使用 yarn 來示範。</p><p>先移除方才所有引入的 js 檔以及 import 進 <code>src/styles.scss</code> 的檔案。</p><p>接著可以參考<a href="https://getbootstrap.com/docs/4.3/getting-started/download/#package-managers" rel="external nofollow noopener noreferrer" target="_blank"> Package managers </a>得知可以使用 <code>yarn add bootstrap</code> 取得 Bootstrap4。</p><p><img src="https://i.imgur.com/17xvXoR.png" alt></p><p><img src="https://i.imgur.com/RUv01iq.png" alt="package.json 內的紀錄"></p><p><strong>接著我們一樣要引用這些下載好的檔案。</strong></p><p><img src="https://i.imgur.com/6CVEH8z.png" alt="src/styles.scss"></p><p>可以看到透過這種方式，使用 Bootstrap4 的彈性就更大了，可以單獨選擇想要使用 Bootstrap4 的某部分。但在這裡為了示範，選擇 <code>bootstrap.scss</code> 即可。</p><p>接著還需要把 Bootstrap4 本身依賴的 js 檔案也引入才可以正常使用所有的功能，但這裡還有個前提是：<br><strong>Bootstrap4 也依賴著 jQuery</strong> ，因此我們還需要額外使用 yarn 下載 jQuery ，才能完整使用 Bootstrap4 。</p><p><strong>以下是 Bootstrapt4 中有使用到 JavaScript 控制的元件：</strong></p><ul><li>Alerts for dismissing</li><li>Buttons for toggling states and checkbox/radio functionality</li><li>Carousel for all slide behaviors, controls, and indicators</li><li>Collapse for toggling visibility of content</li><li>Dropdowns for displaying and positioning (also requires Popper.js)</li><li>Modals for displaying, positioning, and scroll behavior</li><li>Navbar for extending our Collapse plugin to implement responsive behavior</li><li>Tooltips and popovers for displaying and positioning (also requires Popper.js)</li><li>Scrollspy for scroll behavior and navigation updates</li></ul><p>來到 <a href="https://jquery.com/download/" rel="external nofollow noopener noreferrer" target="_blank">jQuery 官方</a>得知可以使用 <code>yarn add jquery</code> 下載。</p><p><strong>這部分的調整則必須到 <code>angular.json</code> 內的 <code>scripts</code> 設定了。</strong><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": [</span><br><span class="line">  "./node_modules/jquery/dist/jquery.min.js",</span><br><span class="line">  "./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js",</span><br><span class="line">  <span class="string">"./node_modules/bootstrap/dist/js/bootstrap.min.js"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p></p><p>這邊使用 <code>bootstrap.bundle.min.js</code> 原因是 Bootstrap4 官方表示 「Our bootstrap.bundle.js and bootstrap.bundle.min.js include Popper」，也就是只要引入這隻檔案即可。</p><p>接著運行開發伺服器確認結果吧！</p><p><img src="https://i.imgur.com/c33lhpC.png" alt="設置成功"></p><h2 id="安裝-json-server"><a href="#安裝-json-server" class="headerlink" title="安裝 json-server"></a>安裝 json-server</h2><p>會使用到這個功能是因為有時候專案開發時，配合的後端不一定會很快就提供 API 給前端串接，為了不浪費時間，前端可以自行透過 json-server 快速 Mock 出一個 API 供自己測試使用。</p><p>而<a href="https://pvt5r486.github.io/f2e/20190625/2362558207/">如何在一般的環境下使用 json-server </a>也已經再另外一篇介紹過，因此這裡就不會這麼仔細介紹，僅介紹如何安裝使用。</p><p><a href="https://github.com/typicode/json-server#getting-started" rel="external nofollow noopener noreferrer" target="_blank">json-server GitHub 官方</a>顯然地並沒有提供 yarn 方式的下載，只能使用 npm 。</p><p><strong>官網提供的安裝方式是全域的</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure><p></p><p><strong>但如果想被記錄在 package.json 下的話可使用</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install json-server --save-dev</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/vB7Pnmx.png" alt></p><h3 id="建立運行-json-server-需要的檔案"><a href="#建立運行-json-server-需要的檔案" class="headerlink" title="建立運行 json-server 需要的檔案"></a>建立運行 json-server 需要的檔案</h3><p>如 json-server 官方的起手範例，建立一個 <code>db.json</code> 檔案，並貼上如下內容：<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"posts"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"title"</span>: <span class="string">"json-server"</span>, <span class="attr">"author"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"body"</span>: <span class="string">"some comment"</span>, <span class="attr">"postId"</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"profile"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著再 package.json 的 <code>script</code> 內加入指令，方便使用：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "ng": "ng",</span><br><span class="line">  "start": "ng serve",</span><br><span class="line">  "build": "ng build",</span><br><span class="line">  "test": "ng test",</span><br><span class="line">  "lint": "ng lint",</span><br><span class="line">  "e2e": "ng e2e",</span><br><span class="line">  "mock-server": "json-server db.json --port 3010"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p></p><p><strong>先運行看看吧～</strong></p><p><img src="https://i.imgur.com/9lGDdbK.png" alt></p><p>雖然是成功了，但很快的我們發現了第一個問題：</p><ul><li>成功啟動 json-server 後就不能輸入 <code>ng serve</code> 了，怎麼辦？</li></ul><p>在這裡我們要額外安裝一個叫做 <a href="https://www.npmjs.com/package/concurrently" rel="external nofollow noopener noreferrer" target="_blank">concurrently</a> 的套件，它允許多進程以異步並行而​​非順序同步方式運行。</p><p><strong>安裝方式</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install concurrently --save-dev</span><br></pre></td></tr></table></figure><p></p><p>安裝完成後，打開 package.json 進行指令的設定：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "ng": "ng",</span><br><span class="line">  "start": "ng serve",</span><br><span class="line">  "build": "ng build",</span><br><span class="line">  "test": "ng test",</span><br><span class="line">  "lint": "ng lint",</span><br><span class="line">  "e2e": "ng e2e",</span><br><span class="line">  "mock-server": "json-server db.json --port 3010",</span><br><span class="line">  "dev": " concurrently \"ng serve\" \"npm run mock-server\" "</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p></p><p><strong>最後，實際運行看看吧～</strong><br><img src="https://i.imgur.com/Fa8WvPE.png" alt="npm run dev"></p><p>運行成功～這樣子就可以同時運行 Angular 的開發伺服器以及 json-server 囉～</p><p><strong>參考資料</strong></p><ul><li><a href="http://angular-friday.com/2017/08/20/configuring-your-mock-server/#page" rel="external nofollow noopener noreferrer" target="_blank">Configuring your local mock server in 10 minutes</a></li><li><a href="https://andy6804tw.github.io/2018/02/01/json-server-intro/" rel="external nofollow noopener noreferrer" target="_blank">使用 JSON Server 快速模擬 Restful API</a></li><li><a href="https://blog.csdn.net/weixin_40817115/article/details/81281454" rel="external nofollow noopener noreferrer" target="_blank">json-server 常用自定义路由和简单配置</a></li></ul><p><strong>原始碼</strong> - <a href="https://github.com/pvt5r486/pluginDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在專案的開發中有些時候為了應付特殊的需求會安裝一些第三方的套件，避免重複造輪子。而我們要如何在 Angular 環境中使用它們呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>json-server 與 chart.js</title>
    <link href="http://pvt5r486.github.io/f2e/20190625/2362558207/"/>
    <id>http://pvt5r486.github.io/f2e/20190625/2362558207/</id>
    <published>2019-06-25T07:38:11.000Z</published>
    <updated>2019-07-08T02:38:16.746Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好一陣子沒有寫 Blog 了，原因也是因為初階的 Angular 學到一個段落了，團隊的 Leader 決定讓隊伍內的成員們以敏捷開發的方式跑看看一個 Side Project ，順便讓我學習如何與團隊合作一個專案。</p><p>而這篇文章主要是簡單記錄自己如何使用 json-server 快速 Mock 一個 API 讓自己串接，並且使用 chart.js 繪製出堆疊長條圖。</p><p><img src="https://images.unsplash.com/photo-1561336635-c0e118ad72a0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1055&amp;q=80" alt></p><h2 id="在專案中使用-json-server"><a href="#在專案中使用-json-server" class="headerlink" title="在專案中使用 json-server"></a>在專案中使用 json-server</h2><p>來到 <a href="https://github.com/typicode/json-server" rel="external nofollow noopener noreferrer" target="_blank">json-server 的 GitHub</a> 查看如何使用。</p><h3 id="下載-json-server"><a href="#下載-json-server" class="headerlink" title="下載 json-server"></a>下載 json-server</h3><p><strong>使用步驟如下：</strong></p><ul><li>如果是新的專案而且沒有 package.json 檔<ul><li>輸入 <code>npm init</code> 建立 package.json 檔</li></ul></li><li>輸入 <code>npm install -g json-server</code> 安裝 json-server</li></ul><h3 id="建立-db-json"><a href="#建立-db-json" class="headerlink" title="建立 db.json"></a>建立 db.json</h3><p>接著新增 <code>db.json</code> 檔，內容可先複製官網範例進行參考：<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"posts"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"title"</span>: <span class="string">"json-server"</span>, <span class="attr">"author"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: [</span><br><span class="line">    &#123; <span class="attr">"id"</span>: <span class="number">1</span>, <span class="attr">"body"</span>: <span class="string">"some comment"</span>, <span class="attr">"postId"</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"profile"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"typicode"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>輸入 <code>json-server db.json</code> 運行 json-serve ，等候呼叫 API</strong></p><p><code>db.json</code> 檔就是當呼叫 API 時會傳回那些資料的檔案，舉例來說：</p><ul><li>預設狀態下，在網址列輸入 <code>http://localhost:3000/posts</code><ul><li>會傳回 <code>{ &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }</code></li></ul></li></ul><p>這邊因為之後要使用 chart.js 進行圖表繪製，所以我另外有準備資料，因為跟工作有關就不貼上來了。</p><h3 id="自訂路由"><a href="#自訂路由" class="headerlink" title="自訂路由"></a>自訂路由</h3><p>大多時候 json-server 的預設範例是滿足不了我們的。</p><p>舉例來說，我想要 Mock 的 API 路徑希望是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/issues/analysis?gid=:gid&amp;sDate=:sDate&amp;eDate=:eDate</span><br></pre></td></tr></table></figure><p></p><p>這時候就需要自訂路由了！</p><p><strong>新增 <code>route.json</code> 檔案</strong></p><p>接著在裡面貼上官網的範例：<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"/api/*"</span>: <span class="string">"/$1"</span>,</span><br><span class="line">  <span class="attr">"/:resource/:id/show"</span>: <span class="string">"/:resource/:id"</span>,</span><br><span class="line">  <span class="attr">"/posts/:category"</span>: <span class="string">"/posts?category=:category"</span>,</span><br><span class="line">  <span class="attr">"/articles\\?id=:id"</span>: <span class="string">"/posts/:id"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如上設定後，對應結果如下：</p><ul><li>輸入 <code>/api/posts</code> # → /posts</li><li>輸入 <code>/api/posts/1</code> # → /posts/1</li><li>輸入 <code>/posts/1/show</code> # → /posts/1</li><li>輸入 <code>/posts/javascript</code> # → /posts?category=javascript</li><li>輸入 <code>/articles?id=1</code> # → /posts/1</li></ul><p><strong>找出規則後，修改 <code>route.json</code> 變成我們要的結果。</strong><br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"/api/v1/issues/analysis\\?gid=:gid&amp;sDate=:sDate&amp;eDate=:eDate"</span>: <span class="string">"/api"</span>,</span><br><span class="line">  <span class="attr">"/api/v1/issues/analysis"</span>: <span class="string">"/api"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="自訂配置"><a href="#自訂配置" class="headerlink" title="自訂配置"></a>自訂配置</h3><p>為了更方便使用，也可以自行配置 json-server 。</p><p><strong>新增 json-server.json</strong></p><p>並且在裡面輸入：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"port": 5000,              //自定 port</span><br><span class="line">"watch": true,             //監聽改動</span><br><span class="line">"routes": "route.json"     //路由配置路徑</span><br></pre></td></tr></table></figure><p></p><p>因為只有使用到這些配置，更多配置請參考官方 GitHub 文件。</p><p>配置已經完成了，最後在 <code>package.json</code> 中加入以下指令：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "mock": "json-server --c json-server.json db.json"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p></p><p><strong>之後只需要執行 <code>npm run mock</code> 指令即可運行以上這些配置囉！</strong></p><p><strong>參考文件</strong></p><ul><li><a href="https://github.com/typicode/json-server" rel="external nofollow noopener noreferrer" target="_blank">json-server GitHub</a></li><li><a href="https://blog.csdn.net/weixin_40817115/article/details/81281454" rel="external nofollow noopener noreferrer" target="_blank">json-server常用自定义路由和简单配置</a></li></ul><h2 id="在專案中使用-chart-js"><a href="#在專案中使用-chart-js" class="headerlink" title="在專案中使用 chart.js"></a>在專案中使用 chart.js</h2><p>先到 <a href="https://www.chartjs.org/docs/latest/" rel="external nofollow noopener noreferrer" target="_blank">chart.js</a> 官方了解如何使用，發現有兩種使用方式：</p><ul><li>使用 <a href="https://www.jsdelivr.com/package/npm/chart.js" rel="external nofollow noopener noreferrer" target="_blank">CDN</a></li><li>透過 <a href="https://github.com/chartjs/Chart.js/releases/tag/v2.8.0" rel="external nofollow noopener noreferrer" target="_blank">npm 安裝</a></li></ul><p><strong>為了方便，這裡我使用了 CDN 的方式使用 chart.js</strong></p><h3 id="參考官方建立一個範本"><a href="#參考官方建立一個範本" class="headerlink" title="參考官方建立一個範本"></a>參考官方建立一個範本</h3><p>由於我想畫的是堆疊柱狀圖，但我們依然可先參考官方的<a href="https://www.chartjs.org/docs/latest/getting-started/" rel="external nofollow noopener noreferrer" target="_blank">起手範例</a>，先行建構一個範本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myChart"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'myChart'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> chart = <span class="keyword">new</span> Chart(ctx, &#123;</span><br><span class="line">    <span class="comment">// The type of chart we want to create</span></span><br><span class="line">    type: <span class="string">'bar'</span>,</span><br><span class="line">    <span class="comment">// The data for our dataset</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        labels: [<span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>, <span class="string">'June'</span>, <span class="string">'July'</span>],</span><br><span class="line">        datasets: [&#123;</span><br><span class="line">            label: <span class="string">'My First dataset'</span>,</span><br><span class="line">            backgroundColor: <span class="string">'rgb(255, 99, 132)'</span>,</span><br><span class="line">            borderColor: <span class="string">'rgb(255, 99, 132)'</span>,</span><br><span class="line">            data: [<span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">45</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Configuration options go here</span></span><br><span class="line">    options: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>官網文件寫得十分詳細，但因為是英文，所以需要花一點時間找相關的方法、屬性如何使用。</p><p>最後參考了<a href="https://bbs.csdn.net/topics/392185606" rel="external nofollow noopener noreferrer" target="_blank">這篇文章</a>得知如何把柱狀圖堆疊起來，修改程式碼後順利完成本次目標～</p><p>因為資料涉及公司，所以就不放上程式碼以及相關圖片了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      文章主要是簡單記錄自己如何使用 json-server 快速 Mock 一個 API 讓自己串接，並且使用 chart.js 繪製出堆疊長條圖。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="職場經驗" scheme="http://pvt5r486.github.io/tags/%E8%81%B7%E5%A0%B4%E7%B6%93%E9%A9%97/"/>
    
      <category term="json-server" scheme="http://pvt5r486.github.io/tags/json-server/"/>
    
      <category term="chart.js" scheme="http://pvt5r486.github.io/tags/chart-js/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.50 Angular 表單啟用原生的 HTML5 驗證</title>
    <link href="http://pvt5r486.github.io/f2e/20190618/4000441909/"/>
    <id>http://pvt5r486.github.io/f2e/20190618/4000441909/</id>
    <published>2019-06-18T08:49:12.000Z</published>
    <updated>2019-06-25T07:36:21.286Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這是我參考官方文件進行 Angular 表單實作時遇到的問題，當我建立一份 form 表單並且在裡面的 input 內添加 required ，企圖使用原生的 HTML5 驗證卻沒有生效，最後找到解決辦法，因此特別寫下這一篇。</p><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p><strong>這是一個非常單純的 HTML5 的驗證：</strong><br><a href="https://codepen.io/pvt5r486/pen/KjMbWN?editors=1000" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這會驗證 form 表單內的 input 是否有值，若為空值則無法提交。</p><p><img src="https://i.imgur.com/bvUM3qa.png" alt></p><p><strong>我嘗試要在 Angular 內使用，但卻沒有觸發驗證。</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> (ngSubmit)=<span class="string">"onSubmit()"</span> required&gt;</span><br><span class="line">  &lt;button type=<span class="string">"submit"</span>&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/rsbXRtN.png" alt="沒有觸發驗證"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>參考以下文章解決</p><ul><li><a href="https://my.oschina.net/lwenhao/blog/1922844" rel="external nofollow noopener noreferrer" target="_blank">Angular4+表单提交时未检查“required”属性</a></li><li><a href="https://stackoverflow.com/questions/43189364/angular-4-enable-html5-validation" rel="external nofollow noopener noreferrer" target="_blank">Angular 4 enable HTML5 validation</a></li><li><a href="https://github.com/angular/angular/blob/master/packages/forms/src/directives/ng_no_validate_directive.ts" rel="external nofollow noopener noreferrer" target="_blank">ng_no_validate_directive.ts</a></li></ul><blockquote><p>而從文章得知，似乎是自從 Angular 4 後，預設把 HTML5 的驗證關閉了，需要手動在 form 元素上添加 <code>ngNativeValidate</code> 將其開啟。</p></blockquote><p><img src="https://i.imgur.com/ftIWu2z.png" alt="未添加 ngNativeValidate ，出現 novalidate "></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form  (ngSubmit)=<span class="string">"onSubmit()"</span> ngNativeValidate&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>  required&gt;</span><br><span class="line">  &lt;button type=<span class="string">"submit"</span>&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/1XAze4S.png" alt="成功觸發 HTML5 驗證"></p><p><img src="https://i.imgur.com/314rOz3.png" alt="添加 ngNativeValidate ， novalidate 消失"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這是我參考官方文件進行 Angular 表單實作時遇到的問題，當我建立一份 form 表單並且在裡面的 input 內添加 required ，企圖使用原生的 HTML5 驗證卻沒有生效，最後找到解決辦法，因此特別寫下這一篇。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.49 Angular 響應式表單 (Reactive forms) (二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190618/751180778/"/>
    <id>http://pvt5r486.github.io/f2e/20190618/751180778/</id>
    <published>2019-06-18T07:53:06.000Z</published>
    <updated>2019-06-25T07:36:21.286Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>承上篇，接著使用 FormBuilder 重構程式碼。</p><p><img src="https://images.unsplash.com/photo-1560768063-0c81fe6f38b1?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="使用-FormBuilder-來產生表單控制元件"><a href="#使用-FormBuilder-來產生表單控制元件" class="headerlink" title="使用 FormBuilder 來產生表單控制元件"></a>使用 FormBuilder 來產生表單控制元件</h2><p>當需要與多個表單打交道時，手動建立多個表單控制元件例項會非常繁瑣。</p><p>FormBuilder 服務提供了一些便捷方法來產生表單控制元件，在幕後也使用同樣的方式來建立和返回這些實例，只是用起來更簡單。</p><p>接下來會重構 ProfileEditor 元件，用 FormBuilder 來建立這些 FormControl 和 FormGroup 實例。</p><h3 id="匯入-FormBuilder-類"><a href="#匯入-FormBuilder-類" class="headerlink" title="匯入 FormBuilder 類"></a>匯入 FormBuilder 類</h3><p>從 @angular/forms 包中匯入 FormBuilder 類。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FormGroup, FormControl, FormBuilder &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br></pre></td></tr></table></figure><h3 id="注入-FormBuilder-服務"><a href="#注入-FormBuilder-服務" class="headerlink" title="注入 FormBuilder 服務"></a>注入 FormBuilder 服務</h3><p>FormBuilder 是一個可注入的服務提供商，它是由 ReactiveFormModule 提供的。</p><p>只要把它新增到元件的建構函式中就可以注入這個依賴。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(private fb: FormBuilder) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="產生表單控制元件"><a href="#產生表單控制元件" class="headerlink" title="產生表單控制元件"></a>產生表單控制元件</h3><p>FormBuilder 服務有三個方法：</p><ul><li>control()</li><li>group()</li><li>array()</li></ul><p>這些方法都是工廠方法，用於在元件的 class 中分別產生 FormControl 、 FormGroup 和 FormArray。</p><p><strong>所以可以使用 group 方法建立 profileForm 控制元件。</strong></p><p>而目前 profile-editor.component 的 class 是這樣的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormGroup, FormControl, FormBuilder &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-profile-editor'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./profile-editor.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./profile-editor.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileEditorComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  profileForm = <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">    firstName: [<span class="string">''</span>],</span><br><span class="line">    lastName: [<span class="string">''</span>],</span><br><span class="line">    address: <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">      street: [<span class="string">''</span>],</span><br><span class="line">      city: [<span class="string">''</span>],</span><br><span class="line">      state: [<span class="string">''</span>],</span><br><span class="line">      zip: [<span class="string">''</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">constructor</span>(private fb: FormBuilder) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  onSubmit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.profileForm.value);</span><br><span class="line">  &#125;</span><br><span class="line">  updateProfile() &#123;</span><br><span class="line">    <span class="keyword">this</span>.profileForm.patchValue(&#123;</span><br><span class="line">      firstName: <span class="string">'Nancy'</span>,</span><br><span class="line">      address: &#123;</span><br><span class="line">        street: <span class="string">'123 Drew Street'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不難看出與先前手動建立 FormControl 、 FormGroup 十分相似，而且省下了非常大量的 new 。</p><p>每個控制元件名對應的值都是一個陣列，而<strong>陣列中的第一項是其初始值。</strong></p><blockquote><p>可以只使用初始值來定義控制元件，但是如果控制元件還需要同步或非同步驗證器，那就在這個陣列中的第二項和第三項提供同步和非同步驗證器。</p></blockquote><p><strong>運行看看重構的結果吧！</strong></p><p><img src="https://i.imgur.com/L02nbQ2.png" alt="執行成功"></p><h2 id="簡易表單驗證"><a href="#簡易表單驗證" class="headerlink" title="簡易表單驗證"></a>簡易表單驗證</h2><p>表單驗證用於驗證使用者的輸入，以確保其完整和正確。</p><p>那麼該如何把單個驗證器新增到表單控制元件中，以及如何顯示表單的整體狀態呢？</p><h3 id="匯入驗證器函式"><a href="#匯入驗證器函式" class="headerlink" title="匯入驗證器函式"></a>匯入驗證器函式</h3><p>響應式表單包含了一組內建的常用驗證器函式。</p><p>這些函式接收一個控制元件，用以驗證並根據驗證結果返回一個錯誤物件或空值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Validators &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br></pre></td></tr></table></figure><h3 id="把欄位設為必填（required）"><a href="#把欄位設為必填（required）" class="headerlink" title="把欄位設為必填（required）"></a>把欄位設為必填（required）</h3><p>檢查某個欄位有沒有被正確的填入值是相當常見的驗證：</p><ul><li>把 firstName 設為必填項目</li><li>在 ProfileEditor 元件中，把靜態方法 Validators.required 設定為 firstName 控制元件值陣列中的第二項。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">profileForm = <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">  firstName: [<span class="string">''</span>, Validators.required],</span><br><span class="line">  lastName: [<span class="string">''</span>],</span><br><span class="line">  address: <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">    street: [<span class="string">''</span>],</span><br><span class="line">    city: [<span class="string">''</span>],</span><br><span class="line">    state: [<span class="string">''</span>],</span><br><span class="line">    zip: [<span class="string">''</span>]</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然後使用內嵌繫結觀察表單的驗證狀態。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Form Value: &#123;&#123; profileForm.valid &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  Form Status: &#123;&#123; profileForm.status &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/1BfGxCG.png" alt="firstName 未輸入，狀態為 INVALID"></p><p><img src="https://i.imgur.com/yz1vhlh.png" alt="輸入後，狀態為 VALID"></p><p>而我們也可以搭配原生的 HTML5 驗證屬性，可以防止在 Template 檢查完之後表示式再次被修改導致的錯誤。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"firstName"</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以做得更好！像是把驗證有沒有通過的狀態繫結在提交按鈕的 disabled 屬性上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> [<span class="attr">disabled</span>]=<span class="string">"!profileForm.valid"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/c1C4Fkd.png" alt="驗證未通過"></p><p><img src="https://i.imgur.com/ixDfSuJ.png" alt="驗證通過"></p><blockquote><p>提交按鈕被禁用了，因為 firstName 控制元件的必填項規則導致了 profileForm 也是無效的。</p></blockquote><h2 id="使用表單陣列管理動態控制元件"><a href="#使用表單陣列管理動態控制元件" class="headerlink" title="使用表單陣列管理動態控制元件"></a>使用表單陣列管理動態控制元件</h2><p>FormArray 是 FormGroup 之外的另一個選擇，用於管理任意數量的匿名控制元件。</p><p>像 FormGroup 實例一樣，可以在 FormArray 中動態插入和移除控制元件，並且 FormArray 實例的值和驗證狀態也是根據它的子控制元件計算得來的。</p><p>FormArray 與 FormGroup 差別在於<strong>不需要為每個控制元件定義一個名字作為 key</strong>。</p><p>因此，如果不知道子控制元件的數量，這就是一個很好的選擇。</p><p>舉例來說，我們可以加入綽號的部分，因為我們不知道綽號會有幾個。</p><h3 id="匯入-FormArray"><a href="#匯入-FormArray" class="headerlink" title="匯入 FormArray"></a>匯入 FormArray</h3><p>從 @angular/form 中匯入 FormArray，以使用它的型別資訊。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FormArray &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br></pre></td></tr></table></figure><h3 id="定義-FormArray"><a href="#定義-FormArray" class="headerlink" title="定義 FormArray"></a>定義 FormArray</h3><p>可以透過把一組（從零項到多項）控制元件定義在一個陣列中藉以初始化一個 FormArray。</p><p>為 profileForm 新增一個 alias 屬性，把它定義為 FormArray 型別。</p><p>使用 FormBuilder.array() 方法來定義該陣列，並用 FormBuilder.control() 方法來往該陣列中新增一個初始控制元件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">profileForm = <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">  firstName: [<span class="string">''</span>, Validators.required],</span><br><span class="line">  lastName: [<span class="string">''</span>],</span><br><span class="line">  address: <span class="keyword">this</span>.fb.group(&#123;</span><br><span class="line">    street: [<span class="string">''</span>],</span><br><span class="line">    city: [<span class="string">''</span>],</span><br><span class="line">    state: [<span class="string">''</span>],</span><br><span class="line">    zip: [<span class="string">''</span>]</span><br><span class="line">  &#125;),</span><br><span class="line">  alias: <span class="keyword">this</span>.fb.array([</span><br><span class="line">    <span class="keyword">this</span>.fb.control(<span class="string">''</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>現在 FormGroup 中的這個 alias 控制元件現在管理著一個控制元件，將來還可以動態新增多個。</p><h3 id="訪問-FormArray-控制元件"><a href="#訪問-FormArray-控制元件" class="headerlink" title="訪問 FormArray 控制元件"></a>訪問 FormArray 控制元件</h3><p>相對於重復使用 profileForm.get() 方法獲取每個例項的方式， getter 可以讓你輕鬆訪問 FormArray 實例中的綽號。</p><p>FormArray 實例用一個陣列來代表未定數量的控制元件。</p><p>透過 getter 來訪問控制元件很方便，這種方法還能很容易地重複處理更多控制元件。</p><p>使用 getter 語法建立<strong>類屬性 aliases</strong>，以從父表單組中接收表示 aliases 的 FormArray 控制元件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> aliases() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.profileForm.get(<span class="string">'aliases'</span>) <span class="keyword">as</span> FormArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因為 return 的控制元件的型別是 AbstractControl，所以要為該方法提供一個顯式的型別宣告來訪問 FormArray 特有的語法。</p></blockquote><p>宣告 addAlias 方法來把一個控制元件動態插入到 aliases 的 FormArray 中：</p><ul><li>用 FormArray.push() 方法把該控制元件新增為陣列中的新元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addAlias() &#123;</span><br><span class="line">  <span class="keyword">this</span>.aliases.push(<span class="keyword">this</span>.fb.control(<span class="string">''</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Template 中，這些控制元件會被迭代，把每個控制元件都顯示為一個獨立的輸入框。</p><h2 id="在-Template-中顯示-FormArray"><a href="#在-Template-中顯示-FormArray" class="headerlink" title="在 Template 中顯示 FormArray"></a>在 Template 中顯示 FormArray</h2><p>使用 formArrayName 在這個 FormArray 例項和範本之間建立繫結。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">formArrayName</span>=<span class="string">"aliases"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Aliases<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"addAlias()"</span>&gt;</span>新增綽號<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">"let item of aliases.controls; let i=index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      綽號:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> [<span class="attr">formControlName</span>]=<span class="string">"i"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 ngFor 指令對 aliases FormArray 提供的每個 FormControl 進行迭代。</p><p>因為 FormArray 中的元素是匿名的，所以要把索引號賦值給 i 變數，並且把它傳給每個控制元件的 formControlName 輸入屬性。</p><p>每當新的 alias 加進來時，FormArray 的實例就會基於這個索引號提供它的控制元件。</p><p><img src="https://i.imgur.com/k3yvNLA.png" alt></p><p><img src="https://i.imgur.com/2aHrtM6.png" alt></p><p><strong>至此，我們完成了響應式表單的基礎範例練習。</strong></p><ul><li><a href="https://github.com/pvt5r486/ngForm" rel="external nofollow noopener noreferrer" target="_blank">GitHub 範例程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      承上篇，接著使用 FormBuilder 重構程式碼。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.48 Angular 響應式表單 (Reactive forms) (一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190618/1504140932/"/>
    <id>http://pvt5r486.github.io/f2e/20190618/1504140932/</id>
    <published>2019-06-18T03:55:11.000Z</published>
    <updated>2019-06-25T07:36:21.286Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩過範本驅動表單後，接著來體驗看看響應式表單吧～</p><p><img src="https://images.unsplash.com/photo-1558981420-c532902e58b4?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1177&amp;q=80" alt></p><h2 id="響應式表單-Reactive-forms"><a href="#響應式表單-Reactive-forms" class="headerlink" title="響應式表單 (Reactive forms)"></a>響應式表單 (Reactive forms)</h2><blockquote><p>以下節錄自官網敘述:<br>響應式表單使用顯式的、不可變的方式，管理表單在特定的時間點上的狀態。對表單狀態的每一次變更都會返回一個新的狀態，這樣可以在變化時維護模型的整體性。<br>響應式表單還提供了一種更直觀的測試路徑，因為在請求時你可以確信這些資料是一致的、可預料的。這個流的任何一個消費者都可以安全地操縱這些資料。</p></blockquote><h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><p>如果要使用響應式表單，就要從 @angular/forms 包中匯入 ReactiveFormsModule 。</p><h3 id="註冊-ReactiveFormsModule"><a href="#註冊-ReactiveFormsModule" class="headerlink" title="註冊 ReactiveFormsModule"></a>註冊 ReactiveFormsModule</h3><p><img src="https://i.imgur.com/5GtCzoC.png" alt></p><h3 id="產生並匯入一個新的表單控制元件"><a href="#產生並匯入一個新的表單控制元件" class="headerlink" title="產生並匯入一個新的表單控制元件"></a>產生並匯入一個新的表單控制元件</h3><p>輸入 <code>ng g c NameEditor</code> 建立元件。</p><p><img src="https://i.imgur.com/18alxUZ.png" alt></p><p>當使用響應式表單時， <code>FormControl</code> 類是最基本的構成要素。</p><p>所以要在這個元件中匯入 <code>FormControl</code> 類，並 <code>new</code> 一個 <code>FormControl</code> 實體，把它儲存在 class 的某個屬性中。</p><p><strong>name-editor.component class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormControl &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-name-editor'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./name-editor.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./name-editor.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NameEditorComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  name = <span class="keyword">new</span> FormControl(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以用 <code>FormControl</code> 的建構函式設定初始值，這個例子中它是空字串。</p><p>我們可以在元件的 class 中建立這些控制元件，直接對表單控制元件的狀態進行監聽、修改和驗證。</p><h3 id="在-Template-中註冊該控制元件"><a href="#在-Template-中註冊該控制元件" class="headerlink" title="在 Template 中註冊該控制元件"></a>在 Template 中註冊該控制元件</h3><p>剛才的步驟在 class 中建立控制元件後，我們還需要把它和範本中的表單控制元件關聯起來。</p><p><strong>例如：為表單控制元件新增 <code>formControl</code> 繫結</strong></p><p><code>formControl</code> 是由 <code>ReactiveFormsModule</code> 中的 <code>FormControlDirective</code> 提供的，更多class 以及指令可以參考<a href="https://angular.tw/guide/reactive-forms#reactive-forms-api" rel="external nofollow noopener noreferrer" target="_blank">響應式表單 API</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  Name:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> [<span class="attr">formControl</span>]=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用這種範本繫結語法，把該表單控制元件註冊給了 Template 中名為 <code>name</code> 的輸入元素。</p></blockquote><p>這樣表單控制元件和 DOM 元素就可以互相通訊了</p><ul><li>View 會反映 model 的變化， model 也會反映 View 中的變化。</li></ul><p>實際將元件運行來觀察是否正常：</p><p><img src="https://i.imgur.com/nVPk7Rp.png" alt></p><h2 id="管理控制元件的值"><a href="#管理控制元件的值" class="headerlink" title="管理控制元件的值"></a>管理控制元件的值</h2><p>剛才的步驟已經建立了一個基礎了表單控制元件，而響應式表單讓你可以訪問表單控制元件此刻的狀態和值。</p><p><strong>可以透過元件的 class 或元件的 Template 來操縱其當前狀態和值。</strong></p><h3 id="顯示表單控制元件的值"><a href="#顯示表單控制元件的值" class="headerlink" title="顯示表單控制元件的值"></a>顯示表單控制元件的值</h3><p>可以用兩種方式顯示它的值：</p><ul><li>透過可觀察物件 valueChanges，可以在 Template 中使用 AsyncPipe 或在元件的 class 中使用 subscribe() 方法來監聽表單值的變化。</li><li>使用 <code>value</code> 屬性，它能讓你獲得當前值的一份快照。</li></ul><p><strong>這邊示範方法二 - 使用內嵌繫結的方式觀察表單的值。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  Name:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> [<span class="attr">formControl</span>]=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Value: &#123;&#123; name.value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2Mnc6tM.png" alt></p><blockquote><p>一旦修改了表單控制元件所關聯的元素， p 標籤內顯示的值也跟著變化了。</p></blockquote><h3 id="替換表單控制元件的值"><a href="#替換表單控制元件的值" class="headerlink" title="替換表單控制元件的值"></a>替換表單控制元件的值</h3><p>響應式表單還有一些方法可以用程式設計的方式修改控制元件的值：</p><ul><li>FormControl 提供了一個 setValue() 方法<ul><li>它會修改這個表單控制元件的值，並且驗證與控制元件結構相對應的值的結構<ul><li>比如，當從後端 API 或服務接收到了表單資料時，可以透過 setValue() 方法來把原來的值替換為新的值</li></ul></li></ul></li></ul><p>舉例來說我們在元件的 class 內新增一個 updateName() 方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateName() &#123;</span><br><span class="line">  <span class="keyword">this</span>.name.setValue(<span class="string">'Nancy'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著修改 Template 新增一個按鈕，並把剛才新增的方法綁上去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"updateName()"</span>&gt;</span>Update Name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cNFFubB.png" alt="點擊按鈕後"></p><blockquote><p>特別要注意的是：<br>在這個例子中，我們只使用單個控制元件，但是當呼叫 <code>FormGroup</code> 或 <code>FormArray</code> 的 <code>setValue()</code> 方法時，傳入的值就必須匹配「控制元件組」或「控制元件陣列」的結構才行。</p></blockquote><p><strong>接著來談談如何將把表單控制元件分組。</strong></p><h2 id="表單控制元件分組"><a href="#表單控制元件分組" class="headerlink" title="表單控制元件分組"></a>表單控制元件分組</h2><p>FormControl 的實例能讓我們控制單個輸入框所對應的控制元件，而 FormGroup 的實例能追蹤一組 FormControl 實例（比如一個表單的狀態）</p><h3 id="產生新的元件並且匯入-FormGroup-和-FormControl-的-class"><a href="#產生新的元件並且匯入-FormGroup-和-FormControl-的-class" class="headerlink" title="產生新的元件並且匯入 FormGroup 和 FormControl 的 class"></a>產生新的元件並且匯入 FormGroup 和 FormControl 的 class</h3><p>輸入 <code>ng g c ProfileEditor</code> ，建立元件。</p><p><img src="https://i.imgur.com/ELBW2Yb.png" alt></p><p><strong>匯入 FormGroup 和 FormControl 的 class</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormGroup, FormControl &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-profile-editor'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./profile-editor.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./profile-editor.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileEditorComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立-FormGroup-的實例"><a href="#建立-FormGroup-的實例" class="headerlink" title="建立 FormGroup 的實例"></a>建立 FormGroup 的實例</h3><p>跟剛才單個的 FormControl 蠻像的，差別在於 FormGroup 就是一個物件包著很多 FormControl 的概念，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormGroup, FormControl &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-profile-editor'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./profile-editor.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./profile-editor.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileEditorComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  profileForm = <span class="keyword">new</span> FormGroup(&#123;</span><br><span class="line">    firstName: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">    lastName: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormGroup 實例擁有和 FormControl 實例</p><ul><li>相同的屬性，比如 value、untouched</li><li>相同的方法，比如 setValue()</li></ul><h3 id="關聯-FormGroup-的-model-和-view"><a href="#關聯-FormGroup-的-model-和-view" class="headerlink" title="關聯 FormGroup 的 model 和 view"></a>關聯 FormGroup 的 model 和 view</h3><p>這個 FormGroup 能追蹤其中每個控制元件的狀態及其變化，所以如果其中的某個控制元件的狀態或值變化了，父控制元件也會發出一次新的狀態變更或值變更事件。</p><p>該控制元件組的 model 來自它的所有成員，在定義了這個 model 後，你必須更新 Template ，把該 model 反映到 view 中。</p><p><strong>profile-editor.component</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"profileForm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    First Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"firstName"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Last Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"lastName"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>就像 FormGroup 所包含的那些控制元件一樣， <code>profileForm</code> 這個 FormGroup 也透過 FormGroup 指令繫結到了 form 元素上，在該 model 和表單中的輸入框之間建立了一個通訊層。</p><p>藉由 FormControlName 指令把每個輸入框和 FormGroup 中定義的表單控制元件繫結起來。</p><p>這些表單控制元件會和相應的元素通訊，如果有修改，把修改傳遞給 FormGroup 。</p><h2 id="取得表單資料"><a href="#取得表單資料" class="headerlink" title="取得表單資料"></a>取得表單資料</h2><p>ProfileEditor 元件從使用者那裡獲得輸入，但在實務上我們可能想要先獲得表單的值。</p><p>FormGroup 指令會監聽 form 元素發出的 submit 事件，然後發出一個 ngSubmit 事件，讓你可以繫結一個 callback 函式。</p><p>所以之後我們可以在 class 內建立一個 onSubmit() 方法，並且綁在 ngSubmit 事件上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"profileForm"</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit()"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ProfileEditor 元件上的 onSubmit() 方法會捕獲 profileForm 的當前值。要保持該表單的封裝性，就要使用 EventEmitter 向元件外部提供該表單的值。</p><p>並且使用 console.log 觀察提交結果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onSubmit() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.profileForm.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後我們必須新增一個按鈕，並且把 type 設定為 submit 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> [<span class="attr">disabled</span>]=<span class="string">"!profileForm.valid"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ccnOaEY.png" alt="輸入後提交"></p><h2 id="巢狀的表單組"><a href="#巢狀的表單組" class="headerlink" title="巢狀的表單組"></a>巢狀的表單組</h2><p>FormGroup 支援巢狀結構，因此我們可以建立更複雜的表單應用。</p><h3 id="建立巢狀的-FormGroup"><a href="#建立巢狀的-FormGroup" class="headerlink" title="建立巢狀的 FormGroup"></a>建立巢狀的 FormGroup</h3><p>比如說可以在目前的例子中加入地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormGroup, FormControl &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-profile-editor'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./profile-editor.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./profile-editor.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileEditorComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  profileForm = <span class="keyword">new</span> FormGroup(&#123;</span><br><span class="line">    firstName: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">    lastName: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">    address: <span class="keyword">new</span> FormGroup(&#123;</span><br><span class="line">      street: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">      city: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">      state: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">      zip: <span class="keyword">new</span> FormControl(<span class="string">''</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  onSubmit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.profileForm.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然 address 這個 FormGroup 是 profileForm 這個整體 FormGroup 的一個子控制元件，但是仍然適用同樣的值和狀態的變更規則。</p><p><strong>來自內嵌控制元件組的狀態和值的變更將會冒泡到它的父控制元件組。</strong></p><h3 id="在-Template-中分組內嵌的表單"><a href="#在-Template-中分組內嵌的表單" class="headerlink" title="在 Template 中分組內嵌的表單"></a>在 Template 中分組內嵌的表單</h3><p>因為剛才修改了 class 內的 model ，所以 Template 也需要作出調整。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">"profileForm"</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    First Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"firstName"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Last Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"lastName"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">formGroupName</span>=<span class="string">"address"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Address<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      Street:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"street"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      City:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"city"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      State:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"state"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      Zip Code:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">formControlName</span>=<span class="string">"zip"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>測試看看是否仍正常運作。</p><p><img src="https://i.imgur.com/VIT0YsK.png" alt></p><h2 id="部分模型更新"><a href="#部分模型更新" class="headerlink" title="部分模型更新"></a>部分模型更新</h2><p>如果想更新部分 model 的內容而不是整個都替換掉的話，有兩種更新 model 值的方式：</p><ul><li>使用 setValue() 方法來為單個控制元件設定新值<ul><li>setValue() 方法會嚴格遵循表單組的結構，並整體性替換控制元件的值</li></ul></li><li>使用 patchValue() 方法可以用物件中所定義的任何屬性為表單模型進行替換</li></ul><p>setValue() 方法的嚴格檢查可以幫助你捕獲複雜表單巢狀中的錯誤，而 patchValue() 在遇到那些錯誤時可能會默默的失敗。</p><p>新增一個更新鈕，並且在 class 內新增一個 updateProfile() 方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> (<span class="attr">click</span>)=<span class="string">"updateProfile()"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用 patchValue() 方法</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateProfile() &#123;</span><br><span class="line">  <span class="keyword">this</span>.profileForm.patchValue(&#123;</span><br><span class="line">    firstName: <span class="string">'Nancy'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">      street: <span class="string">'123 Drew Street'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/TRR1S3b.png" alt="點擊更新後提交"></p><p><strong>使用 setValue() 方法</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">updateProfile() &#123;</span><br><span class="line">  <span class="comment">// this.profileForm.patchValue(&#123;</span></span><br><span class="line">  <span class="comment">//   firstName: 'Nancy',</span></span><br><span class="line">  <span class="comment">//   address: &#123;</span></span><br><span class="line">  <span class="comment">//     street: '123 Drew Street'</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="keyword">this</span>.profileForm.setValue(&#123;</span><br><span class="line">    firstName: <span class="string">'Nancy'</span>,</span><br><span class="line">    lastName: <span class="string">''</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">      street: <span class="string">'123 Drew Street'</span>,</span><br><span class="line">      city: <span class="string">''</span>,</span><br><span class="line">      state: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>像這樣，使用 setValue() 方法會整體性替換控制元件的值，但在這裡我故意少寫 zip 屬性，並嘗試提交。</p><p><img src="https://i.imgur.com/0pCq23Q.png" alt="少寫 zip 屬性"></p><p>因此如果使用 setValue() 方法就必須要把屬性全部寫上去才行。</p><p><img src="https://i.imgur.com/7GuUEy5.png" alt="補上 zip 屬性後"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>接下來要使用 FormBuilder 進行重構，都寫在同一篇感覺篇幅太長了，因此拆開兩篇寫。</p><ul><li><a href="https://github.com/pvt5r486/ngForm" rel="external nofollow noopener noreferrer" target="_blank">GitHub 範例程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      玩過範本驅動表單後，接著來體驗看看響應式表單吧～
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.47 Angular 範本驅動表單 (Template-Driven Forms)</title>
    <link href="http://pvt5r486.github.io/f2e/20190617/1498157669/"/>
    <id>http://pvt5r486.github.io/f2e/20190617/1498157669/</id>
    <published>2019-06-17T07:00:33.000Z</published>
    <updated>2019-06-18T04:05:06.156Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹完 Angular 內兩種表單的不同後，接著實作看看範本驅動表單吧。</p><p><img src="https://images.unsplash.com/photo-1560635041-160852985094?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Angular 框架支援：</p><ul><li>雙向資料繫結</li><li>變更檢測</li><li>驗證和錯誤處理</li></ul><p>而實作過程中，將學會：</p><ul><li>用元件和範本建構 Angular 表單</li><li>用 ngModel 建立雙向資料繫結，以讀取和寫入輸入控制元件的值</li><li>追蹤狀態的變化，並驗證表單控制元件</li><li>使用特殊的 CSS 類來追蹤控制元件的狀態並給出視覺反饋</li><li>向用戶顯示驗證錯誤提示，以及啟用/禁用表單控制元件</li><li>使用範本參考變數在 HTML 元素之間共享資訊</li></ul><p>這個範例將：</p><ul><li>以範本驅動表單的方式實作一個建立英雄的表單</li><li>必填的欄位在左側有個綠色的豎條，代表這個欄位是必填的<ul><li>如果沒有填寫，表單就會用醒目的樣式把驗證錯誤顯示出來</li></ul></li><li>而如果有條件未達成，則無法按下 Submit 按鈕提交</li></ul><h2 id="環境準備"><a href="#環境準備" class="headerlink" title="環境準備"></a>環境準備</h2><h3 id="建立專案"><a href="#建立專案" class="headerlink" title="建立專案"></a>建立專案</h3><p>建立專案的部分就不再贅述了。</p><h3 id="建立-hero-的-class"><a href="#建立-hero-的-class" class="headerlink" title="建立 hero 的 class"></a>建立 hero 的 class</h3><p>因為每次輸入表單資料時，資料大致上都是固定的，因此可以建立一個 hero 的 class 來處理這些事情。<br>之後要使用時可以透過 <code>new</code> 將其實例化成物件後，方便我們取用。</p><p><img src="https://i.imgur.com/OxD9leO.png" alt></p><p><strong>hero.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    public id: number,</span><br><span class="line">    public name: string,</span><br><span class="line">    public power: string,</span><br><span class="line">    public alterEgo?: string</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中 <code>alterEgo</code> 屬性後面接了 <code>?</code> 號，代表 <code>alterEgo</code> 屬性不是必須的，呼叫建構函式時這個參數可以省略。</p><p>也就是說之後我們可以這樣來建立一個新英雄：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myHero =  <span class="keyword">new</span> Hero(<span class="number">1</span>, <span class="string">'超級牛'</span>, <span class="string">'超級牛來拯救雷'</span>, <span class="string">'牛妹妹'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'My hero is called '</span> + myHero.name);</span><br></pre></td></tr></table></figure><p></p><h3 id="建立表單元件"><a href="#建立表單元件" class="headerlink" title="建立表單元件"></a>建立表單元件</h3><p>輸入 <code>ng g c HeroForm</code> 建立元件。</p><p><img src="https://i.imgur.com/e0nScNq.png" alt></p><p>接著在 class 內寫一些東西：<br><strong>hero-form.component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Hero &#125; <span class="keyword">from</span> <span class="string">'../hero'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-hero-form'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./hero-form.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./hero-form.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroFormComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 能力陣列</span></span><br><span class="line">  powers = [<span class="string">'噴火'</span>, <span class="string">'降雷'</span>, <span class="string">'結冰'</span>, <span class="string">'呼風'</span>];</span><br><span class="line">  <span class="comment">// 預設的 model 物件</span></span><br><span class="line">  model = <span class="keyword">new</span> Hero(<span class="number">1</span>, <span class="string">'火焰鳥'</span>, <span class="keyword">this</span>.powers[<span class="number">0</span>], <span class="string">'黑火焰鳥'</span>);</span><br><span class="line">  <span class="comment">// 阻止提交</span></span><br><span class="line">  submitted = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  onSubmit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.submitted = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改 app.module.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroFormComponent &#125; <span class="keyword">from</span> <span class="string">'./hero-form/hero-form.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    HeroFormComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p>在這裡要匯入：</p><ul><li>FormsModule</li><li>把 FormsModule 新增到 ngModule 裝飾器的 imports 陣列中，這樣應用就能訪問範本驅動表單的所有特性，包括 ngModel</li></ul><p><strong>修改 app.component.ts</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-hero-form</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-form</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>別忘了在根元件內把這個子元件載入。</p><h3 id="建立初始-HTML-表單範本"><a href="#建立初始-HTML-表單範本" class="headerlink" title="建立初始 HTML 表單範本"></a>建立初始 HTML 表單範本</h3><p>修改 hero-form 的元件範本 (Template)<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"alterEgo"</span>&gt;</span>裏人格<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"alterEgo"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在這裡添加了兩個欄位：</p><ul><li>姓名 - 必填</li><li>裏人格 - 非必填</li></ul><p>可以發現到這一小段 HTML5 的程式碼，裡面用了一些 Bootstrap4 的 className 。</p><p>但這不是必需的，這裡只是因為美觀所以想要使用。</p><p>可以透過修改 <code>src/styles.css</code> 引入 Bootstrap4。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* You can add global styles to this file, and also import other style files */</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">'https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css'</span>);</span><br></pre></td></tr></table></figure><p>接著運行開發伺服器，觀察一下目前的樣子。</p><p><img src="https://i.imgur.com/lNeMTKn.png" alt></p><p><strong>添加能力選單</strong><br>還記得我們在 HeroFormComponent 的 class 內寫的 <code>powers</code> 陣列嗎？</p><p>接下來要使用 ngFor 建立一個下搭式選單。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"power"</span>&gt;</span>能力<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"power"</span> <span class="attr">id</span>=<span class="string">"power"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> [<span class="attr">value</span>]=<span class="string">"item"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of powers"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/8jWf7EY.png" alt></p><h2 id="使用-ngModel-進行雙向資料繫結"><a href="#使用-ngModel-進行雙向資料繫結" class="headerlink" title="使用 ngModel 進行雙向資料繫結"></a>使用 ngModel 進行雙向資料繫結</h2><p>基礎的表單已經成形，接著我們要將資料雙向繫結到 Input 上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> #<span class="attr">heroForm</span>=<span class="string">"ngForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">      目前的資料狀態[姓名]：&#123;&#123;model.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"alterEgo"</span>&gt;</span>裏人格<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></span><br><span class="line"><span class="tag">        [(<span class="attr">ngModel</span>)]=<span class="string">"model.alterEgo"</span> <span class="attr">name</span>=<span class="string">"alterEgo"</span> <span class="attr">id</span>=<span class="string">"alterEgo"</span>&gt;</span></span><br><span class="line">        目前的資料狀態[裏人格]：&#123;&#123;model.alterEgo&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"power"</span>&gt;</span>能力<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"power"</span> <span class="attr">id</span>=<span class="string">"power"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.power"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> [<span class="attr">value</span>]=<span class="string">"item"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of powers"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      目前的資料狀態[能力]：&#123;&#123;model.power&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/p27UHJP.png" alt></p><p>做到這邊的時候，遇到一個小小的阻礙：</p><ul><li>當使用 ngModel 時，要記得替 input 補上 name 屬性</li></ul><h3 id="NgForm-指令"><a href="#NgForm-指令" class="headerlink" title="NgForm 指令"></a>NgForm 指令</h3><p>往 form 標籤中加入 <code>#heroForm=&quot;ngForm&quot;</code></p><p>heroForm 變數是一個到 NgForm 指令的參考，它代表該表單的整體。</p><p>NgForm 指令為 form 增補了一些額外特性：</p><ul><li>它會控制那些帶有 ngModel 指令和 name 屬性的元素，監聽他們的屬性（包括其有效性）。</li><li>它還有自己的 valid 屬性，這個屬性只有在它包含的每個控制元件都有效時才是真。</li></ul><h2 id="透過-ngModel-追蹤修改狀態與有效性驗證"><a href="#透過-ngModel-追蹤修改狀態與有效性驗證" class="headerlink" title="透過 ngModel 追蹤修改狀態與有效性驗證"></a>透過 ngModel 追蹤修改狀態與有效性驗證</h2><p>現在我們已經可以透過雙向繫結修改資料了，但是還可以透過 ngModel 知道更多資訊：</p><ul><li>使用者碰過此控制元件嗎？</li><li>值變化了嗎？</li><li>資料變得無效了嗎？</li></ul><p>ngModel 指令不僅僅追蹤狀態。它還使用特定的 Angular CSS 類來更新控制元件，以反映當前狀態。 可以利用這些 CSS 類來修改控制元件的外觀，顯示或隱藏訊息。</p><p><img src="https://i.imgur.com/gGdsiTj.png" alt></p><p>在姓名的 input 標籤上新增名叫 <code>spy</code> 的臨時範本參考變數，然後用這個 <code>spy</code> 來顯示它上面的所有 className。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"name"</span> #<span class="attr">spy</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  目前的資料狀態[姓名]：&#123;&#123;model.name&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  input 上的 className 狀態 &#123;&#123;spy.className&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/pGX88Gl.png" alt="尚未觸碰過"></p><p><img src="https://i.imgur.com/jkR1KeE.png" alt="focus 後 blur"></p><p><img src="https://i.imgur.com/QudKYuM.png" alt="修改過資料後"></p><p><img src="https://i.imgur.com/kfseQdF.png" alt="必填欄位但資料完全刪除時"></p><h2 id="新增用於視覺反饋的自訂-CSS"><a href="#新增用於視覺反饋的自訂-CSS" class="headerlink" title="新增用於視覺反饋的自訂 CSS"></a>新增用於視覺反饋的自訂 CSS</h2><p>既然可以追蹤 input 上的 className 狀態，我們就可以自訂一些視覺反饋效果。</p><p><strong>hero-form.component.scss</strong><br></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ng-valid</span><span class="selector-attr">[required]</span>, <span class="selector-class">.ng-valid</span><span class="selector-class">.required</span>  &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#42A948</span>; <span class="comment">/* green */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ng-invalid</span>:not(<span class="selector-tag">form</span>)  &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#a94442</span>; <span class="comment">/* red */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/GBAAP5x.png" alt="驗證失敗"></p><p><img src="https://i.imgur.com/3cFB0y9.png" alt="驗證成功"></p><p><strong>甚至可以透過控制 hidden 屬性，自訂一些錯誤訊息。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"name"</span> #<span class="attr">name</span>=<span class="string">"ngModel"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> [<span class="attr">hidden</span>]=<span class="string">"name.valid || name.pristine"</span> <span class="attr">class</span>=<span class="string">"alert alert-danger"</span>&gt;</span>姓名是必填欄位！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  目前的資料狀態[姓名]：&#123;&#123;model.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>範本參考變數可以訪問 Template 中的 input ，建立 name 的變數並且賦值為 <code>ngModel</code>。</p><p>當這個 input 的驗證是有效的 (valid) 或全新的 (pristine) 時，隱藏訊息。</p><blockquote><p>全新的 (pristine) 意味著從它顯示在表單中開始，使用者還從未修改過它的值。</p></blockquote><p><img src="https://i.imgur.com/U97Naao.png" alt></p><p><strong>這樣就完成了視覺反饋效果。</strong></p><p>裏人格因為是非必填，所以不需要做處理；下拉式選單則因為設計的關係一定會有值，所以也不需要處理。</p><h2 id="新增英雄"><a href="#新增英雄" class="headerlink" title="新增英雄"></a>新增英雄</h2><p>在表單的底部放置新增英雄的按鈕，並把它的點選事件繫結到元件上的 newHero 方法。<br><strong>hero-form.component.html</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> (<span class="attr">click</span>)=<span class="string">"newHero()"</span>&gt;</span>新增英雄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>hero-form.component.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHero() &#123;</span><br><span class="line">  <span class="keyword">this</span>.model = <span class="keyword">new</span> Hero(<span class="number">2</span>, <span class="string">''</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>觀察看看結果～</strong></p><p><img src="https://i.imgur.com/Qb9qjbf.png" alt="尚未點擊新增英雄"></p><p><img src="https://i.imgur.com/C1lmCDa.png" alt="點擊新增英雄後"></p><p>使用瀏覽器工具審查這個元素就會發現，這個 name 輸入框並不是全新的。</p><p>所以跑出了錯誤提示訊息，但這樣不正確，因為我們並不希望按下新增英雄時跑出錯誤視窗。</p><p>發生預期之外的原因是:</p><ul><li>表單會記得點選新增英雄前輸入的名字，而更換了英雄物件並不會重置 input 的 全新(pristine) 狀態。</li></ul><p><strong>所以必須在 newHero() 後補上 heroForm.reset() 重置表單狀態。</strong></p><p>因此目前 Template 內的程式碼是這樣的：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> #<span class="attr">heroForm</span>=<span class="string">"ngForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"name"</span> #<span class="attr">name</span>=<span class="string">"ngModel"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> [<span class="attr">hidden</span>]=<span class="string">"name.valid || name.pristine"</span> <span class="attr">class</span>=<span class="string">"alert alert-danger"</span>&gt;</span>姓名是必填欄位！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      目前的資料狀態[姓名]：&#123;&#123;model.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"alterEgo"</span>&gt;</span>裏人格<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></span><br><span class="line"><span class="tag">        [(<span class="attr">ngModel</span>)]=<span class="string">"model.alterEgo"</span> <span class="attr">name</span>=<span class="string">"alterEgo"</span> <span class="attr">id</span>=<span class="string">"alterEgo"</span>&gt;</span></span><br><span class="line">        目前的資料狀態[裏人格]：&#123;&#123;model.alterEgo&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"power"</span>&gt;</span>能力<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"power"</span> <span class="attr">id</span>=<span class="string">"power"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.power"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> [<span class="attr">value</span>]=<span class="string">"item"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of powers"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      目前的資料狀態[能力]：&#123;&#123;model.power&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> (<span class="attr">click</span>)=<span class="string">"newHero();heroForm.reset()"</span>&gt;</span>新增英雄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="使用-ngSubmit-提交該表單"><a href="#使用-ngSubmit-提交該表單" class="headerlink" title="使用 ngSubmit 提交該表單"></a>使用 ngSubmit 提交該表單</h2><p>填表完成之後，使用者應該要能提交這個表單。</p><p>目前這個表單的提交按鈕位於底部，並沒有在這顆按鈕上綁定任何的點擊事件，但因為有特殊的 type 值 (type=”submit”)，所以會觸發表單提交。</p><p>但現在這樣僅僅觸發表單提交是沒用的。</p><p>要讓它有用，就要把該表單的 ngSubmit 事件屬性繫結到英雄表單元件的 onSubmit() 方法上：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit()"</span> #<span class="attr">heroForm</span>=<span class="string">"ngForm"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>這樣就可以在按下提交鈕後觸發寫在 class 內的 onSubmit() 方法了。</p><h3 id="提升使用者體驗"><a href="#提升使用者體驗" class="headerlink" title="提升使用者體驗"></a>提升使用者體驗</h3><p>可以進一步的把表單的總體有效性透過 heroForm 變數繫結到此按鈕的 disabled 屬性，這樣能讓使用者明白如果沒有填寫姓名是不能提交的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> [<span class="attr">disabled</span>]=<span class="string">"!heroForm.form.valid"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Vle2LOV.png" alt="未填寫姓名，不得提交"></p><h2 id="切換兩個表單區域"><a href="#切換兩個表單區域" class="headerlink" title="切換兩個表單區域"></a>切換兩個表單區域</h2><p>在我們按下提交後，可以將表單利用先前設置好的屬性 <code>submitted</code> 來控制隱藏或顯示。</p><h3 id="建立提交後的顯示區塊，並且利用-submitted-控制隱藏或顯示"><a href="#建立提交後的顯示區塊，並且利用-submitted-控制隱藏或顯示" class="headerlink" title="建立提交後的顯示區塊，並且利用 submitted 控制隱藏或顯示"></a>建立提交後的顯示區塊，並且利用 submitted 控制隱藏或顯示</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit()"</span> #<span class="attr">heroForm</span>=<span class="string">"ngForm"</span> [<span class="attr">hidden</span>]=<span class="string">"submitted"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"name"</span> #<span class="attr">name</span>=<span class="string">"ngModel"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> [<span class="attr">hidden</span>]=<span class="string">"name.valid || name.pristine"</span> <span class="attr">class</span>=<span class="string">"alert alert-danger"</span>&gt;</span>姓名是必填欄位！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      目前的資料狀態[姓名]：&#123;&#123;model.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"alterEgo"</span>&gt;</span>裏人格<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></span><br><span class="line"><span class="tag">        [(<span class="attr">ngModel</span>)]=<span class="string">"model.alterEgo"</span> <span class="attr">name</span>=<span class="string">"alterEgo"</span> <span class="attr">id</span>=<span class="string">"alterEgo"</span>&gt;</span></span><br><span class="line">        目前的資料狀態[裏人格]：&#123;&#123;model.alterEgo&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"power"</span>&gt;</span>能力<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"power"</span> <span class="attr">id</span>=<span class="string">"power"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"model.power"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> [<span class="attr">value</span>]=<span class="string">"item"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of powers"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      目前的資料狀態[能力]：&#123;&#123;model.power&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> (<span class="attr">click</span>)=<span class="string">"newHero();heroForm.reset()"</span>&gt;</span>新增英雄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> [<span class="attr">disabled</span>]=<span class="string">"!heroForm.form.valid"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> [<span class="attr">hidden</span>]=<span class="string">"!submitted"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>英雄能力如下:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span>&gt;</span>&#123;&#123; model.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span>裏人格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span>&gt;</span>&#123;&#123; model.alterEgo &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span>能力<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span>&gt;</span>&#123;&#123; model.power &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> (<span class="attr">click</span>)=<span class="string">"submitted=false"</span>&gt;</span>編輯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一開始屬性 <code>submitted</code> 為 <code>false</code> ，顯示輸入表單</p><ul><li>當按下提交後，觸發 onSubmit() 將 <code>submitted</code> 修改為 <code>true</code><ul><li>輸入表單關閉，顯示提交後的區塊</li></ul></li><li>當按下編輯按鈕時，再度將 <code>submitted</code> 修改為 <code>false</code>，隱藏提交後的區塊並顯示輸入表單。</li></ul><p><img src="https://i.imgur.com/2FzmRuz.png" alt="提交前"></p><p><img src="https://i.imgur.com/6kzT7cI.png" alt="按下提交後"></p><p><strong>如此我們就完成了範本驅動表單 (Template-Driven Forms) 的簡單範例。</strong></p><ul><li><a href="https://github.com/pvt5r486/ngForm" rel="external nofollow noopener noreferrer" target="_blank">GitHub 範例程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      介紹完 Angular 內兩種表單的不同後，接著實作看看範本驅動表單吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.46 Angular 表單</title>
    <link href="http://pvt5r486.github.io/f2e/20190617/2466170401/"/>
    <id>http://pvt5r486.github.io/f2e/20190617/2466170401/</id>
    <published>2019-06-17T06:50:20.000Z</published>
    <updated>2019-06-18T04:05:06.156Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用表單處理使用者輸入的資料是許多常見應用的基礎功能，像是使用者登入、修改資料、建立資料等等。</p><p>而 Angular 提供了兩種不同的方式透過表單處理使用者的輸入：</p><ul><li>響應式表單 ( reactive )</li><li>範本驅動表單 ( template-driven )</li></ul><p>這些名詞看起來相當陌生，實際上用起來最簡單的會是範本驅動表單，因為它的使用方式相當直觀。</p><p><img src="https://images.unsplash.com/photo-1560553174-28b8e2f73bc1?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1051&amp;q=80" alt></p><h2 id="響應式表單-reactive"><a href="#響應式表單-reactive" class="headerlink" title="響應式表單 ( reactive )"></a>響應式表單 ( reactive )</h2><p>然而，根據官方文件的敘述，響應式表單的優點是：</p><ul><li>可擴充套件性</li><li>可複用性</li><li>可測試性</li></ul><p>以上這三點特性都比範本驅動表單要強，如果這個表單是專案內相當重要且複雜的部份，推薦使用這種方式來建立表單。</p><h2 id="範本驅動表單-template-driven"><a href="#範本驅動表單-template-driven" class="headerlink" title="範本驅動表單 ( template-driven )"></a>範本驅動表單 ( template-driven )</h2><p>範本驅動表單的優點就是易於使用，很容易就能在目前的 Angular 應用中添加一個簡易的表單，像是使用者的登入。</p><p>白話來說，如果需求的表單功能相當簡易、邏輯不複雜，可以考慮使用範本驅動表單。</p><h2 id="兩者差異"><a href="#兩者差異" class="headerlink" title="兩者差異"></a>兩者差異</h2><p>以下為官方標註的差異</p><p><img src="https://i.imgur.com/ZSjobMe.png" alt></p><ul><li><a href="https://my.oschina.net/u/2949632/blog/1488455" rel="external nofollow noopener noreferrer" target="_blank">Reactive Forms 與 Template-Driven Forms 的特点</a></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>具體來說該用哪種呢？</p><blockquote><p>實際上這沒有絕對的好壞，還是得看使用情境。</p></blockquote><p>倘若使用的情境既不需要寫測試、需要用到表單的地方邏輯又相當簡單，那就可以使用範本驅動表單搞定；相反的，若是相當複雜那就可以考慮使用響應式表單了。</p><p>接下來試著以範本驅動表單的方式來建立一個表單吧～</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      用表單處理使用者輸入的資料是許多常見應用的基礎功能，像是使用者登入、修改資料、建立資料等等。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.45 在 Angular 內進行測試(五) - 帶有非同步服務的元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190613/2750930562/"/>
    <id>http://pvt5r486.github.io/f2e/20190613/2750930562/</id>
    <published>2019-06-13T07:20:13.000Z</published>
    <updated>2019-06-18T04:05:06.156Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>也有一種狀況是：依賴的服務元件資料的取得，是透過呼叫 API 等待伺服器吐資料的非同步行為，那麼這又該如何進行測試呢？</p><p><img src="https://images.unsplash.com/photo-1560278078-d31b4ed980c6?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1036&amp;q=80" alt></p><h2 id="帶有非同步服務的元件"><a href="#帶有非同步服務的元件" class="headerlink" title="帶有非同步服務的元件"></a>帶有非同步服務的元件</h2><p>改寫上一個範例，當點選 welcomeComponent 元件內的登入按鈕時，會以 <code>.subscribe()</code> 的形式觸發 user 服務元件的 <code>getData()</code> 方法取得資料，最後顯示出歡迎提示，並且停用登入按鈕。</p><p><strong>welcome.component 的 Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"welcome"</span> *<span class="attr">ngIf</span>=<span class="string">"data.isLoggedIn"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;data.user&#125;&#125;，&#123;&#123;data.message&#125;&#125;！<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"error"</span> *<span class="attr">ngIf</span>=<span class="string">"!data.isLoggedIn"</span>&gt;</span>未授權，請登入！<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"login()"</span>  [<span class="attr">disabled</span>]=<span class="string">"data.isLoggedIn"</span>&gt;</span>登入<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>welcome.component 的 class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'../user.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-welcome'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./welcome.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./welcome.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  data = &#123;</span><br><span class="line">    isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">    user: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>(public userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  login() &#123;</span><br><span class="line">    <span class="keyword">this</span>.userService.getData().subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>user.service</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">      user: <span class="string">''</span>,</span><br><span class="line">      message: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      data.isLoggedIn = <span class="literal">true</span>;</span><br><span class="line">      data.user = <span class="string">'Alvan'</span>;</span><br><span class="line">      data.message = <span class="string">'歡迎登入'</span>;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> observer.next(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="如何測試帶有非同步服務的元件"><a href="#如何測試帶有非同步服務的元件" class="headerlink" title="如何測試帶有非同步服務的元件"></a>如何測試帶有非同步服務的元件</h2><p>這個範例測試的重點是：</p><ul><li>元件上的登入按鈕的 click 觸發事件是否有效<ul><li>意思是當透過點擊事件觸發元件內的 <code>login()</code> 時，方法真的有被呼叫</li></ul></li><li>元件的渲染是不是正常的<ul><li>意思是獲得資料後元件有正確的顯示</li></ul></li></ul><h2 id="測試環境建置"><a href="#測試環境建置" class="headerlink" title="測試環境建置"></a>測試環境建置</h2><p>於是我們可以像先前一樣，使用 <code>jasmine.createSpyObj()</code> 產生一個假的 <code>getData()</code> 方法，並且預先建立好一組假的資料 - <code>data</code> 。</p><p><strong>welcome.component.spec</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">async</span>, ComponentFixture, TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; WelcomeComponent &#125; <span class="keyword">from</span> <span class="string">'./welcome.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'../user.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'WelcomeComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: WelcomeComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;WelcomeComponent&gt;;</span><br><span class="line">  <span class="keyword">let</span> userService;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> spy = jasmine.createSpyObj(<span class="string">'UserServiceSpy'</span>, [<span class="string">'getData'</span>]);</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ WelcomeComponent ],</span><br><span class="line">      providers: [</span><br><span class="line">        &#123; <span class="attr">provide</span>: UserService, <span class="attr">useValue</span>: spy &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(WelcomeComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">    userService = TestBed.get(UserService);</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">    el = fixture.nativeElement.querySelector(<span class="string">'.welcome'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="撰寫測試"><a href="#撰寫測試" class="headerlink" title="撰寫測試"></a>撰寫測試</h2><p>前置作業準備完畢，開始撰寫測試吧。</p><h3 id="第一個測試"><a href="#第一個測試" class="headerlink" title="第一個測試"></a>第一個測試</h3><ul><li>元件上的登入按鈕的 click 觸發事件是否有效<ul><li>意思是當透過點擊事件觸發元件內的 <code>login()</code> 時，方法真的有被呼叫</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'觸發 Click 事件後，是否有正常呼叫 getData() '</span>, () =&gt; &#123;</span><br><span class="line">  userService.getData.and.returnValue(<span class="keyword">new</span> Observable());</span><br><span class="line">  <span class="comment">// 模擬點擊</span></span><br><span class="line">  component.login();</span><br><span class="line">  expect(userService.getData).toHaveBeenCalled();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二行的意思是，當假的 <code>getData</code> 方法被呼叫時必須回傳一個觀察者物件 (Observable) 。</p><p>因為第三行觸發元件內的 <code>login</code> 方法時</p><ul><li>user 服務元件內的 <code>getData()</code> 被觸發了，並且使用 <code>.subscribe()</code> 方法訂閱</li><li>而我們在測試時使用的 <code>getData()</code> 是假造的替身，所以必須回傳一個觀察者物件才可以使用 <code>.subscribe()</code> ，否則會出錯導致測試失敗</li></ul><p><img src="https://i.imgur.com/PejzRF8.png" alt></p><h3 id="第二個測試"><a href="#第二個測試" class="headerlink" title="第二個測試"></a>第二個測試</h3><ul><li>測試元件的渲染是正常的<ul><li>意思是獲得資料後元件有正確的顯示<ul><li>像是當 <code>isLoggedIn</code> 為 <code>true</code> 時，登入按鈕為 <code>disabled</code></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'未登入時元件的渲染'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> el: HTMLElement = fixture.nativeElement.querySelector(<span class="string">'.error'</span>);</span><br><span class="line">  expect(el.textContent).toContain(<span class="string">'未授權，請登入！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">it(<span class="string">'登入獲取資料後，元件的渲染'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">    user: <span class="string">'Alvan'</span>,</span><br><span class="line">    message: <span class="string">'歡迎登入'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  component.data = data;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  <span class="keyword">const</span> el: HTMLElement = fixture.nativeElement.querySelector(<span class="string">'.welcome'</span>);</span><br><span class="line">  expect(el.textContent).toContain(data.user);</span><br><span class="line">  <span class="keyword">const</span> btn: HTMLButtonElement = fixture.nativeElement.querySelector(<span class="string">'button'</span>);</span><br><span class="line">  expect(btn.disabled).toBeTruthy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而這部分測試的關鍵在於「順序」，像是：</p><ul><li><code>component.data = data;</code> 當我們把假資料重新賦值給元件內的 <code>data</code> 後<ul><li>必須呼叫 <code>fixture.detectChanges();</code> 重新進行資料與元件間的繫結<ul><li>如此才可以使用 <code>fixture.nativeElement.querySelector()</code> 找到指定目標</li></ul></li></ul></li></ul><h3 id="fakeAsync-進行非同步測試"><a href="#fakeAsync-進行非同步測試" class="headerlink" title="fakeAsync() 進行非同步測試"></a>fakeAsync() 進行非同步測試</h3><p><a href="https://angular.tw/api/core/testing/fakeAsync" rel="external nofollow noopener noreferrer" target="_blank">fakeAsync()</a></p><p>在這個範例內，我並沒有實際的呼叫 API ，而是在 user 服務元件內透過 <code>setTimeout()</code> 模擬呼叫 API 時等待伺服器的時間。</p><p>而如果也想在測試過程中模擬這一段情境的話，可以使用 <code>fakeAsync()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'非同步測試渲染情形'</span>, fakeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = &#123;</span><br><span class="line">    isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">    user: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> errEl: HTMLElement = fixture.nativeElement.querySelector(<span class="string">'.error'</span>);</span><br><span class="line">  expect(errEl.textContent).toContain(<span class="string">'未授權，請登入！'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    data = &#123;</span><br><span class="line">      isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">      user: <span class="string">'Alvan'</span>,</span><br><span class="line">      message: <span class="string">'歡迎登入'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    component.data = data;</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">  tick(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> weEl: HTMLElement = fixture.nativeElement.querySelector(<span class="string">'.welcome'</span>);</span><br><span class="line">  expect(weEl.textContent).toContain(data.user);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>這個測試使用了 <code>setTimeout()</code> 方法，令 <code>data</code> 物件內的屬性三秒後變更，並且重新賦值給元件內的 <code>data</code> 屬性，最後重新繫結。</p><p>而這個測試另一個關鍵是 <a href="https://angular.tw/api/core/ApplicationRef#tick" rel="external nofollow noopener noreferrer" target="_blank">tick()</a> ， <code>tick()</code> 函式接受一個毫秒值作為參數（如果沒有提供則預設為 0）。</p><p>該參數表示虛擬時鐘要前進多少，也就是說：</p><ul><li><code>setTimeout()</code> 如果時間設置 3000 ，那麼 <code>tick()</code> 也要設置 3000</li></ul><p>這樣才能正確取得資料。</p><p><img src="https://i.imgur.com/985KWgL.png" alt></p><p><img src="https://i.imgur.com/K4XkEEM.png" alt="tick() 時間參數設置小於 setTimeout() 的時間參數"></p><blockquote><p>至此完成了對元件的測試。</p></blockquote><ul><li><a href="https://github.com/pvt5r486/ngTestDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub 原始碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      也有一種狀況是：依賴的服務元件資料的取得，是透過呼叫 API 等待伺服器吐資料的非同步行為，那麼這又該如何進行測試呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.44 在 Angular 內進行測試(四) - 有依賴關係的元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190613/1415116741/"/>
    <id>http://pvt5r486.github.io/f2e/20190613/1415116741/</id>
    <published>2019-06-13T07:02:56.000Z</published>
    <updated>2019-06-13T07:22:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇大致理解了如何測試一個單純的元件或是帶有繫結的元件。但在實務的應用上，元件經常依賴著其他服務元件，因此這個例子要實作的範例是 - 如何測試一個帶有依賴的元件？</p><p><img src="https://images.unsplash.com/photo-1556912102-895497aa1c7c?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1015&amp;q=80" alt></p><ul><li>在這個範例中，一個帶有依賴的元件可以拆成<ul><li>製作一個 welcome 元件 + 一個負責提供資料的 user 服務元件</li></ul></li></ul><h2 id="環境建立"><a href="#環境建立" class="headerlink" title="環境建立"></a>環境建立</h2><p>輸入 <code>ng g c welcome -m app</code> 在產生 welcome 元件後將其註冊到 app.module 內。</p><p><img src="https://i.imgur.com/GFAqKOC.png" alt></p><p>輸入 <code>ng g s user</code> 產生 user 服務元件</p><p><img src="https://i.imgur.com/vO7Rx2X.png" alt></p><blockquote><p>到 <strong>app.module</strong> 註冊 user 服務元件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DemoService &#125; <span class="keyword">from</span> <span class="string">'./demo.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Demo2Service &#125; <span class="keyword">from</span> <span class="string">'./demo2.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LightSwichComponent &#125; <span class="keyword">from</span> <span class="string">'./light-swich/light-swich.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BannerComponent &#125; <span class="keyword">from</span> <span class="string">'./banner/banner.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; WelcomeComponent &#125; <span class="keyword">from</span> <span class="string">'./welcome/welcome.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    LightSwichComponent,</span><br><span class="line">    BannerComponent,</span><br><span class="line">    WelcomeComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [DemoService, Demo2Service, UserService],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>基本的檔案建立完成後，接著就是撰寫程式碼了。</p><p><strong>user.service</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  isLoggedIn = <span class="literal">true</span>;</span><br><span class="line">  user = &#123;</span><br><span class="line">    name: <span class="string">'Alvan'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在服務元件內建立 <code>isLoggedIn</code> 屬性以及 <code>user</code> 物件，這是待會要提供給 welcomeComponent 的內容。</p><p><strong>welcome Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"welcome"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;welcome&#125;&#125;<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>welcome class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'../user.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-welcome'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./welcome.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./welcome.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  welcome: string;</span><br><span class="line">  <span class="keyword">constructor</span>(private userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.welcome = <span class="keyword">this</span>.userService.isLoggedIn ?</span><br><span class="line">      <span class="string">`歡迎, <span class="subst">$&#123;<span class="keyword">this</span>.userService.user.name&#125;</span>`</span> : <span class="string">`未授權, 請登入！`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最後把 app-welcome 標籤加到 app.component.html 。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-welcome</span>&gt;</span><span class="tag">&lt;/<span class="name">app-welcome</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>運行開發伺服器，看看執行結果。</p><p><img src="https://i.imgur.com/sx5DeEL.png" alt="isLoggedIn 為 true 的情況"></p><p><img src="https://i.imgur.com/zUkNANX.png" alt="isLoggedIn 為 false 的情況"></p><h2 id="測試帶有依賴的元件"><a href="#測試帶有依賴的元件" class="headerlink" title="測試帶有依賴的元件"></a>測試帶有依賴的元件</h2><p>在這個範例裡 WelcomeComponent 依賴著 user 服務元件的資料，接收到資料後根據 <code>isLoggedIn</code> 的狀態決定顯示的語句。</p><p><strong>welcome.component.spec</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">async</span>, ComponentFixture, TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; WelcomeComponent &#125; <span class="keyword">from</span> <span class="string">'./welcome.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'../user.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'WelcomeComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: WelcomeComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;WelcomeComponent&gt;;</span><br><span class="line">  <span class="keyword">const</span> userServiceStub = &#123;</span><br><span class="line">    isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">    user: &#123; <span class="attr">name</span>: <span class="string">'Test User'</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ WelcomeComponent ],</span><br><span class="line">      providers: [</span><br><span class="line">        &#123; <span class="attr">provide</span>: UserService, <span class="attr">useValue</span>: userServiceStub &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(WelcomeComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>這裡跟之前練習有依賴關係的服務元件的測試時有點像，我們在 TestBed.configureTestingModule 內宣告了：</p><ul><li>待測試的元件 - WelcomeComponent</li><li>在 providers 陣列中添加了 UserService 服務元件<ul><li>並且透過 useValue 將 UserService 的資料換成測試用的資料</li></ul></li></ul><p>被測試的元件不一定要注入真正的服務，可以是個模擬或偽造出來的資料。</p><blockquote><p>這裡的主要目的是測試元件，而不是服務。</p></blockquote><p>有些時候，服務元件可能連自身都有問題，不應該讓它干擾對元件的測試。</p><p>注入真實的 UserService 有可能很麻煩，像是：</p><ul><li>真實的服務可能詢問使用者登入憑據</li><li>也可能試圖連線認證伺服器</li></ul><p>這樣會很難處理這些行為，所以建立和註冊 UserService 替身 (userServiceStub) ，會讓測試更加容易。</p><h2 id="獲得注入的服務"><a href="#獲得注入的服務" class="headerlink" title="獲得注入的服務"></a>獲得注入的服務</h2><p>我們製作了一個 UserService 的替身 - <code>userServiceStub</code> ，那麼該如何取用它呢？</p><p>Angular 的注入系統是層次化的。</p><p>可以有很多層注入器，從根 TestBed 建立的注入器下來貫穿整個元件樹。</p><p>因此這邊有兩種做法：</p><p>第一種做法 - 最安全並有效的獲取注入服務的方法:</p><ul><li>從被測元件的注入器獲取</li><li>元件注入器是 fixture 的 DebugElement 的屬性之一。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserService actually injected into the component</span></span><br><span class="line">userService = fixture.debugElement.injector.get(UserService);</span><br></pre></td></tr></table></figure><p>第二種做法 - 透過 TestBed.get() 來使用根注入器獲取該服務：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserService from the root injector</span></span><br><span class="line">userService = TestBed.get(UserService);</span><br></pre></td></tr></table></figure><p>不過這只有當 Angular 元件需要的恰好是該測試的根注入器時才能正常使用。</p><p>而加入這部分後，我們的程式碼目前是這個樣子的：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">async</span>, ComponentFixture, TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; WelcomeComponent &#125; <span class="keyword">from</span> <span class="string">'./welcome.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'../user.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'WelcomeComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: WelcomeComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;WelcomeComponent&gt;;</span><br><span class="line">  <span class="keyword">let</span> userServiceStub;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模擬物件</span></span><br><span class="line">    userServiceStub = &#123;</span><br><span class="line">      isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">      user: &#123; <span class="attr">name</span>: <span class="string">'Test User'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ WelcomeComponent ],</span><br><span class="line">      providers: [</span><br><span class="line">        &#123; <span class="attr">provide</span>: UserService, <span class="attr">useValue</span>: userServiceStub &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(WelcomeComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 獲取注入的服務</span></span><br><span class="line">    <span class="keyword">const</span> userService = fixture.debugElement.injector.get(UserService);</span><br><span class="line">    <span class="keyword">const</span> el = fixture.nativeElement.querySelector(<span class="string">'.welcome'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="加入一些測試例"><a href="#加入一些測試例" class="headerlink" title="加入一些測試例"></a>加入一些測試例</h2><p>接著補上一些測試例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should welcome the user'</span>, () =&gt; &#123;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  <span class="keyword">const</span> content = el.textContent;</span><br><span class="line">  expect(content).toContain(<span class="string">'歡迎'</span>);</span><br><span class="line">  expect(content).toContain(<span class="string">'Test User'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should welcome "Bubba"'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 變更姓名</span></span><br><span class="line">  userService.user.name = <span class="string">'Bubba'</span>;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  expect(el.textContent).toContain(<span class="string">'Bubba'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">it(<span class="string">'should request login if not logged in'</span>, () =&gt; &#123;</span><br><span class="line">  userService.isLoggedIn = <span class="literal">false</span>;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  <span class="keyword">const</span> content = el.textContent;</span><br><span class="line">  <span class="comment">// 檢查字串是不是不包含 "歡迎"</span></span><br><span class="line">  expect(content).not.toContain(<span class="string">'歡迎'</span>);</span><br><span class="line">  expect(content).toBe(<span class="string">'未授權, 請登入！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>第一個測試檢查 <code>el.textContent</code> 有沒有包含「歡迎」、「Test User」</li><li>第二個測試檢查當變更姓名時，顯示是否仍包含「Bubba」</li><li>第三個測試檢查當未授權登入時，顯示是否<strong>不包含</strong>「歡迎」<ul><li>且顯示文字「未授權, 請登入！」</li></ul></li></ul><p><img src="https://i.imgur.com/ENlz6MI.png" alt="測試通過"></p><p><img src="https://i.imgur.com/hlgfXEC.png" alt="刻意失敗"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前一篇大致理解了如何測試一個單純的元件或是帶有繫結的元件。但在實務的應用上，元件經常依賴著其他服務元件，因此這個例子要實作的範例是 - 如何測試一個帶有依賴的元件？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.43 在 Angular 內進行測試(三) - 繫結元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190611/3397303578/"/>
    <id>http://pvt5r486.github.io/f2e/20190611/3397303578/</id>
    <published>2019-06-11T07:20:18.000Z</published>
    <updated>2019-06-13T07:22:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同樣是元件的測試，這次試著假設一些不同的狀況，練習如何對這些元件進行測試。</p><p><img src="https://images.unsplash.com/photo-1559736139-6531cc82432e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1051&amp;q=80" alt></p><h2 id="元件的繫結-一-內嵌繫結"><a href="#元件的繫結-一-內嵌繫結" class="headerlink" title="元件的繫結 (一) - 內嵌繫結"></a>元件的繫結 (一) - 內嵌繫結</h2><p>建立一個 BannerComponent 並且透過繫結到元件的 <code>title</code> 屬性來展示動態標題。</p><p>輸入 <code>ng g c banner -m app</code> 產生 BannerComponent 並且於 app.module 內註冊。</p><p><strong>class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-banner'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./banner.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./banner.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'This is Title'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>app.component</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-banner</span>&gt;</span><span class="tag">&lt;/<span class="name">app-banner</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/4JBi64D.png" alt></p><blockquote><p>將會寫一系列測試來探查 h1 標籤的值。</p></blockquote><h3 id="banner-component-spec"><a href="#banner-component-spec" class="headerlink" title="banner.component.spec"></a>banner.component.spec</h3><p>首先在 beforeEach() 中使用標準的 HTML querySelector 來找到該元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'BannerComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: BannerComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;BannerComponent&gt;;</span><br><span class="line">  <span class="keyword">let</span> h1: HTMLElement;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ BannerComponent ],</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(BannerComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">    h1 = fixture.nativeElement.querySelector(<span class="string">'h1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同'</span>, () =&gt; &#123;</span><br><span class="line">    expect(h1.textContent).toContain(component.title);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>測試看看！</p></blockquote><p><img src="https://i.imgur.com/sgkuz7n.png" alt></p><p><strong>createComponent() 函式不會繫結資料，因為繫結是在 Angular 執行變更檢測時才發生的。</strong></p><h3 id="解法-補上-detectChanges"><a href="#解法-補上-detectChanges" class="headerlink" title="解法 - 補上 detectChanges()"></a>解法 - 補上 detectChanges()</h3><p>TestBed.createComponent 不能觸發變更檢測，所以要補上 detectChanges() 。</p><p>透過呼叫 fixture.detectChanges() 來要求 TestBed 執行資料繫結。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同'</span>, () =&gt; &#123;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  expect(h1.textContent).toContain(component.title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wKoCKRu.png" alt></p><p>這種變更檢測是故意設計的，它給了測試者一個機會：</p><ul><li>在 Angular 初始化資料繫結以及呼叫生命週期的鉤子之前探查並改變元件的狀態</li></ul><p>像是我們可以這麼做：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同'</span>, () =&gt; &#123;</span><br><span class="line">  component.title = <span class="string">'Test Title'</span>;</span><br><span class="line">  fixture.detectChanges();</span><br><span class="line">  expect(h1.textContent).toContain(component.title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>在呼叫 fixture.detectChanges() 之前修改元件的 title 屬性。</p><h3 id="自動變更檢測"><a href="#自動變更檢測" class="headerlink" title="自動變更檢測"></a>自動變更檢測</h3><p>BannerComponent 的這些測試需要頻繁呼叫 detectChanges() ，而 Angular 測試環境可以做到自動執行變更檢測，如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'BannerComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: BannerComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;BannerComponent&gt;;</span><br><span class="line">  <span class="keyword">let</span> h1: HTMLElement;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ BannerComponent ],</span><br><span class="line">      providers: [</span><br><span class="line">        &#123;<span class="attr">provide</span>: ComponentFixtureAutoDetect, <span class="attr">useValue</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(BannerComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">    h1 = fixture.nativeElement.querySelector(<span class="string">'h1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should display original title'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Hooray! No `fixture.detectChanges()` needed</span></span><br><span class="line">    expect(h1.textContent).toContain(component.title);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should still see original title after comp.title change'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> oldTitle = component.title;</span><br><span class="line">    component.title = <span class="string">'Test Title'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二個測試例'</span>, h1.textContent, oldTitle);</span><br><span class="line">    <span class="comment">// Displayed title is old because Angular didn't hear the change :(</span></span><br><span class="line">    expect(h1.textContent).toContain(oldTitle);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should still see original title after comp.title change'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> oldTitle = component.title;</span><br><span class="line">    component.title = <span class="string">'Test Title'</span>;</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三個測試例'</span>, h1.textContent, oldTitle);</span><br><span class="line">    expect(h1.textContent).toContain(oldTitle);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第一個測試的例子展示了自動 detectChanges() 的好處。</p><p>第二、三個例子要說明的是，<strong>Angular 測試環境不會知道測試程式改變了元件的 <code>title</code> 屬性。</strong></p><blockquote><p>自動檢測只對非同步行為比如承諾的解析、計時器和 DOM 事件作出反應，直接修改元件屬性值是不會觸發自動檢測的。</p></blockquote><p>測試程式必須手動呼叫 detectChange()，來觸發新一輪的變更檢測週期。</p><p><img src="https://i.imgur.com/e1fKg6V.png" alt></p><h2 id="元件的繫結-二-模擬使用者輸入"><a href="#元件的繫結-二-模擬使用者輸入" class="headerlink" title="元件的繫結 (二) - 模擬使用者輸入"></a>元件的繫結 (二) - 模擬使用者輸入</h2><p>修改剛剛的範例，替這個元件增加一個 Input 輸入，根據輸入來變化標題。</p><p><strong>banner Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"title"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>接著需要到 app.module 內 import <code>FormsModule</code> 才可以使用<strong>雙向繫結</strong>。</p><h3 id="使用-dispatchEvent-修改輸入值"><a href="#使用-dispatchEvent-修改輸入值" class="headerlink" title="使用 dispatchEvent() 修改輸入值"></a>使用 dispatchEvent() 修改輸入值</h3><p>如果想在測試時模擬使用者輸入，你就要找到 input 元素並設定它的 value 屬性。</p><p>而 Angular 不知道我們設定了 input 元素的 value 屬性，所以需要先呼叫：</p><ul><li>dispatchEvent()</li><li>再呼叫 detectChanges()</li></ul><p>最後別忘了同樣也必須在 TestBed.configureTestingModule 內 import <code>FormsModule</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'BannerComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: BannerComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;BannerComponent&gt;;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ BannerComponent ],</span><br><span class="line">      imports: [</span><br><span class="line">        FormsModule</span><br><span class="line">      ],</span><br><span class="line">      providers: [</span><br><span class="line">        &#123;<span class="attr">provide</span>: ComponentFixtureAutoDetect, <span class="attr">useValue</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(BannerComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'比較輸入與標題是否一致'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> hostElement = fixture.nativeElement;</span><br><span class="line">    <span class="keyword">const</span> titleInput: HTMLInputElement = hostElement.querySelector(<span class="string">'input'</span>);</span><br><span class="line">    <span class="keyword">const</span> titleDisplay: HTMLElement = hostElement.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模擬使用者輸入的值</span></span><br><span class="line">    titleInput.value = <span class="string">'DCFGBHNJK'</span>;</span><br><span class="line">    titleInput.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'input'</span>));</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">    expect(titleDisplay.textContent).toBe(<span class="string">'DCFGBHNJK'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/3NVQHJh.png" alt="測試通過"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      同樣是元件的測試，這次試著假設一些不同的狀況，練習如何對這些元件進行測試。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.42 在 Angular 內進行測試(二) - 元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190611/268532028/"/>
    <id>http://pvt5r486.github.io/f2e/20190611/268532028/</id>
    <published>2019-06-11T02:59:06.000Z</published>
    <updated>2019-06-13T07:22:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹完服務元件的測試後，接著要學習如何測試一個單純的元件。</p><p><img src="https://images.unsplash.com/photo-1560092056-5669e776fc68?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1052&amp;q=80" alt></p><h2 id="元件測試"><a href="#元件測試" class="headerlink" title="元件測試"></a>元件測試</h2><p>在 Angular 中，普通的元件包含了 Template 與 class ，因此想對元件進行充分的測試，勢必得對這兩個部分都進行測試才行。</p><p>這些測試需要在瀏覽器的 DOM 中建立元件的宿主元素（就像 Angular 所做的那樣），然後檢查元件的 class 和 DOM 的互動是否如同 Template 中所描述的那樣。</p><p>Angular 的 TestBed 為所有這些型別的測試提供了基礎設施。</p><p>但是很多情況下，可以單獨測試元件類本身而不必涉及 DOM ，就已經可以用一種更加簡單、清晰的方式來驗證該元件的大多數行為了。</p><h3 id="建立一個最單純的元件"><a href="#建立一個最單純的元件" class="headerlink" title="建立一個最單純的元件"></a>建立一個最單純的元件</h3><p>測試之前我們要先準備環境，因此建立一個元件 - lightSwitch</p><ul><li>當用戶點選按鈕時，它會切換燈的開關狀態 (畫面上的文字狀態)</li></ul><blockquote><p>輸入 <code>ng g c lightSwitch</code> 建立元件。</p></blockquote><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"clicked()"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;getMessage()&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-light-swich'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./light-swich.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./light-swich.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LightSwichComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  isOn = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  ngOnInit() &#123;&#125;</span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOn = !<span class="keyword">this</span>.isOn;</span><br><span class="line">  &#125;</span><br><span class="line">  getMessage() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`燈現在是 <span class="subst">$&#123;<span class="keyword">this</span>.isOn ? <span class="string">'開'</span> : <span class="string">'關'</span>&#125;</span> 的！`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>app.component Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-light-swich</span>&gt;</span><span class="tag">&lt;/<span class="name">app-light-swich</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/9UoI9OX.png" alt="成功運行"></p><h3 id="測試元件的-class"><a href="#測試元件的-class" class="headerlink" title="測試元件的 class"></a>測試元件的 class</h3><p>可以像先前測試服務元件般，單獨測試元件中的 class 。</p><ul><li>這個範例中要測試 clicked() 方法能否正確切換燈的開關狀態</li><li>getMessage() 有無回傳合適的訊息</li></ul><blockquote><p>而這個元件的 class 並沒有依賴任何的服務元件，是非常單純的。</p></blockquote><p>這種情況下可以直接 new 出物件實體，進行 <code>isOn</code> 屬性的狀態測試。</p><p><strong>light-swich.component.spec</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">async</span>, ComponentFixture, TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; LightSwichComponent &#125; <span class="keyword">from</span> <span class="string">'./light-swich.component'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'LightSwichComponent'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'點擊 clicked() 後的狀態測試'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="keyword">new</span> LightSwichComponent();</span><br><span class="line">    expect(comp.isOn).toBe(<span class="literal">false</span>, <span class="string">'一開始的狀態是 false'</span>);</span><br><span class="line">    comp.clicked();</span><br><span class="line">    expect(comp.isOn).toBe(<span class="literal">true</span>, <span class="string">'按下後的狀態是 true'</span>);</span><br><span class="line">    comp.clicked();</span><br><span class="line">    expect(comp.isOn).toBe(<span class="literal">false</span>, <span class="string">'再按一次回到 false'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'點擊 clicked() 後 Message 會顯示 "開"'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="keyword">new</span> LightSwichComponent();</span><br><span class="line">    expect(comp.getMessage()).toMatch(<span class="regexp">/關/i</span>, <span class="string">'一開始的狀態是關的'</span>);</span><br><span class="line">    comp.clicked();</span><br><span class="line">    expect(comp.getMessage()).toMatch(<span class="regexp">/開/i</span>, <span class="string">'按下後為開'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/ixV4LKY.png" alt="測試成功"></p><p><img src="https://i.imgur.com/MvyBOzV.png" alt="故意出錯的情況"></p><h3 id="測試元件的-DOM"><a href="#測試元件的-DOM" class="headerlink" title="測試元件的 DOM"></a>測試元件的 DOM</h3><p>完整的元件不只有 class ，元件還要和 DOM 以及其它元件進行互動。</p><p>只涉及 class 的測試可以得知元件 class 的行為是否正常，但不能得知元件是否能正常渲染出來、響應使用者的輸入和查詢或與它的父元件和子元件相整合。</p><p>要進行完整的測試，我們不得不建立那些與元件相關的 DOM 元素了，必須檢查 DOM 來確認元件的狀態能在恰當的時機正常顯示出來，並且必須透過螢幕來模擬使用者的互動，以判斷這些互動是否如我們預期。</p><blockquote><p>而這部分就需要用到 <strong>TestBed</strong> 了。</p></blockquote><p><strong>當我們建立元件時， Angular CLI 會幫我們寫好預設的測試</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">async</span>, ComponentFixture, TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; LightSwichComponent &#125; <span class="keyword">from</span> <span class="string">'./light-swich.component'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'LightSwichComponent'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: LightSwichComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;LightSwichComponent&gt;;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="keyword">async</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ LightSwichComponent ]</span><br><span class="line">    &#125;)</span><br><span class="line">    .compileComponents();</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fixture = TestBed.createComponent(LightSwichComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">    fixture.detectChanges();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>而有些時候並不需要這些 Angular CLI 幫我們寫好的 Code 。<br>Angular CLI 是預設我們可能會用到這些東西，而目前我們可以再精簡一些。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'LightSwichComponent (minimal)'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ LightSwichComponent ]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> fixture = TestBed.createComponent(LightSwichComponent);</span><br><span class="line">    <span class="keyword">const</span> component = fixture.componentInstance;</span><br><span class="line">    expect(component).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>當元件逐漸演變成更加實質性的東西時，才會用到那些 Angular CLI 幫我們預設產生的測試。</strong></p><p>在這個例子中，傳給 TestBed.configureTestingModule 的元資料物件中只宣告了 <strong>LightSwichComponent</strong> - 也就是待測試的元件。</p><blockquote><p>不用宣告或匯入任何其它的東西，預設的測試模組中已經預先配置好了，<br><strong>比如來自 @angular/platform-browser 的 BrowserModule。</strong></p></blockquote><h4 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent()"></a>createComponent()</h4><p>在配置好 TestBed.configureTestingModule() 之後，可以呼叫它的 createComponent() 方法。</p><p>TestBed.createComponent() 會建立一個 LightSwichComponent 的元件，把相應的元素新增到 test-runner 的 DOM 中，然後返回一個 <a href="https://angular.tw/guide/testing#component-fixture" rel="external nofollow noopener noreferrer" target="_blank">ComponentFixture 物件</a>。</p><p>特別要注意的是，<strong>在呼叫了 createComponent 之後就不能再重新配置 TestBed 了。</strong> createComponent 方法凍結了當前的 TestBed 定義，關閉它才能再進行後續配置。</p><p>也就是說不能：</p><ul><li>呼叫任何 TestBed 的後續配置方法</li><li>不能調 configureTestingModule()</li><li>不能調 get()</li><li>能呼叫任何 override … 方法</li></ul><blockquote><p>如果試圖這麼做，TestBed 就會丟擲錯誤。</p></blockquote><h4 id="ComponentFixture"><a href="#ComponentFixture" class="headerlink" title="ComponentFixture"></a>ComponentFixture</h4><p><a href="https://angular.tw/guide/testing#component-fixture" rel="external nofollow noopener noreferrer" target="_blank">ComponentFixture</a> 是用來與所建立的元件及其 DOM 元素進行互動。</p><p>從剛才的範例程式碼來看，我們可以透過 <code>fixture</code> 來訪問該元件的 instance ，並用 Jasmine 的 expect 語句來確保其存在。</p><ul><li><a href="https://jestjs.io/docs/en/expect.html#tobedefined" rel="external nofollow noopener noreferrer" target="_blank">.toBeDefined()</a><ul><li>使用 .toBeDefined() 檢查一個變數不是 undefined 。</li></ul></li></ul><h4 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach()"></a>beforeEach()</h4><p>隨著元件的成長，可能會有很多組測試。</p><p>這時除了一直複製之外，還有個比較好的做法：</p><ul><li>把重複會用到的程式碼搬到 beforeEach() 內。</li></ul><p>因此可以重新調整剛剛那段程式碼：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'LightSwichComponent (minimal)'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: LightSwichComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;LightSwichComponent&gt;;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ LightSwichComponent ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(LightSwichComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="nativeElement"><a href="#nativeElement" class="headerlink" title="nativeElement"></a>nativeElement</h4><p>可以使用 nativeElement 中獲取元件內的元素，像是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'LightSwichComponent (minimal)'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: LightSwichComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;LightSwichComponent&gt;;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ LightSwichComponent ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(LightSwichComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'檢查元件的元素內有沒有包含 按鈕(button)'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> el: HTMLElement = fixture.nativeElement;</span><br><span class="line">    <span class="built_in">console</span>.log(el);</span><br><span class="line">    <span class="built_in">console</span>.log(el.getElementsByTagName(<span class="string">'button'</span>).length);</span><br><span class="line">    expect(el.getElementsByTagName(<span class="string">'button'</span>).length).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>console.log(el);</code> 印出來的內容是：</p><p><img src="https://i.imgur.com/nANcw17.png" alt></p><blockquote><p>於是可以藉由 .getElementsByTagName() 找到 button 標籤，最後再判斷長度，即可測試這個元件內有沒有按鈕了。</p></blockquote><p><img src="https://i.imgur.com/35qo3uE.png" alt></p><h4 id="DebugElement"><a href="#DebugElement" class="headerlink" title="DebugElement"></a>DebugElement</h4><p>而除了使用 nativeElement 取得元件內的元素之外，也可以透過 DebugElement 取得元件內的元素。</p><p>至於為什麼要使用 <a href="https://angular.tw/api/core/DebugElement" rel="external nofollow noopener noreferrer" target="_blank">DebugElement</a> 呢？</p><p>以下是官方文件給出的解釋：</p><blockquote><p>nativeElement 的屬性取決於執行環境。 你可以在沒有 DOM，或者其 DOM 模擬器無法支援全部 HTMLElement API 的平臺上執行這些測試。Angular 依賴於 DebugElement 這個抽象層，就可以安全的橫跨其支援的所有平臺。 Angular 不再建立 HTML 元素樹，而是建立 DebugElement 樹，其中包裹著相應執行平臺上的原生元素。 nativeElement 屬性會解開 DebugElement，並返回平臺相關的元素物件。</p></blockquote><p>所以上面那個使用 nativeElement 的測試可以改寫成：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'LightSwichComponent (minimal)'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> component: LightSwichComponent;</span><br><span class="line">  <span class="keyword">let</span> fixture: ComponentFixture&lt;LightSwichComponent&gt;;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      declarations: [ LightSwichComponent ]</span><br><span class="line">    &#125;);</span><br><span class="line">    fixture = TestBed.createComponent(LightSwichComponent);</span><br><span class="line">    component = fixture.componentInstance;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should create'</span>, () =&gt; &#123;</span><br><span class="line">    expect(component).toBeDefined();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'檢查元件的元素內有沒有包含按鈕 (button)'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> elDebug: DebugElement = fixture.debugElement;</span><br><span class="line">    <span class="keyword">const</span> el: HTMLElement = elDebug.nativeElement;</span><br><span class="line">    <span class="built_in">console</span>.log(el);</span><br><span class="line">    <span class="built_in">console</span>.log(el.getElementsByTagName(<span class="string">'button'</span>).length);</span><br><span class="line">    expect(el.getElementsByTagName(<span class="string">'button'</span>).length).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>改寫後的結果會與改寫前完全一樣。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>實務上的元件可能不會像範例上一樣這麼單純，可能會依賴某個服務元件之類的…情況，因為再寫下去可能篇幅會過長，所以決定先在這邊設個中斷點。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      介紹完服務元件的測試後，接著要學習如何測試一個單純的元件。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.41 在 Angular 內進行測試(一) - 服務元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190610/3544502226/"/>
    <id>http://pvt5r486.github.io/f2e/20190610/3544502226/</id>
    <published>2019-06-10T09:53:35.000Z</published>
    <updated>2019-06-13T07:22:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>測試對於一個公司的專案有多重要自然不言而喻，如何在 Angular 中進行測試呢？讓我們一起學習吧。</p><p><img src="https://images.unsplash.com/photo-1560100261-226dff8daa82?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="關於測試"><a href="#關於測試" class="headerlink" title="關於測試"></a>關於測試</h2><p>相信測試的好處以及壞處網路上隨便搜尋能夠找到相當大量的文章，所以這部份我想應該也不過多著墨在這裡了，以下附上一些文章，目的在於建立對於那些陌生名詞的認知：</p><ul><li><a href="https://blog.miniasp.com/post/2019/02/18/Unit-testing-Integration-testing-e2e-testing" rel="external nofollow noopener noreferrer" target="_blank">一次搞懂單元測試、整合測試、端對端測試之間的差異</a><ul><li>單元測試 (Unit testing)</li><li>整合測試 (Integration testing)</li><li>端對端測試 (End-to-end testing)</li></ul></li><li><a href="https://yu-jack.github.io/2017/11/01/how-to-test/" rel="external nofollow noopener noreferrer" target="_blank">關於『測試』這件事</a><ul><li>User Story Test - 測試整個使用情景有沒有跟使用者所想的一樣</li></ul></li></ul><h2 id="Angular-中的測試"><a href="#Angular-中的測試" class="headerlink" title="Angular 中的測試"></a>Angular 中的測試</h2><p>根據官方的文件描述 Angular CLI 會下載並安裝 <a href="https://jasmine.github.io/" rel="external nofollow noopener noreferrer" target="_blank">Jasmine 測試框架</a>，測試 Angular 應用時所需的一切。</p><p>而每個新開的 Angular 專案都可以直接運行 <code>ng test</code> 指令立即進行測試。</p><h3 id="建立新的-Angular-專案"><a href="#建立新的-Angular-專案" class="headerlink" title="建立新的 Angular 專案"></a>建立新的 Angular 專案</h3><p><img src="https://i.imgur.com/QSjg1Rw.png" alt></p><p>接著運行 <code>ng test</code> 指令，會看到一些測試的過程</p><p><img src="https://i.imgur.com/E8rTjnZ.png" alt></p><p>而測試執行完畢後，也會開啟 chrome 瀏覽器並在 Jasmine HTML 報告器中顯示測試結果。</p><p>可以直接點選 AppComponent 連結，重新跑過 AppComponent 底下的測試，或者是點擊掛在 AppComponent 下的連結也可以進行單獨的測試。</p><p><img src="https://i.imgur.com/trRO5M5.png" alt></p><p>而這個由測試指令開啟的 chrome 瀏覽器會持續監聽程式碼的變化，因此可以對 app.component.ts 做一個小修改，並儲存它。</p><blockquote><p>這些測試就會重新執行，瀏覽器也會重新整理，然後新的測試結果就出現了。</p></blockquote><p>而<strong>直接關閉由測試指令開啟的 chrome 瀏覽器會馬上又被開啟</strong>，原因是必須回到終端機按下 CTRL + C 終止指令運行才可以正確關閉。</p><p><img src="https://i.imgur.com/hro1ORg.png" alt></p><h3 id="測試檔案的配置"><a href="#測試檔案的配置" class="headerlink" title="測試檔案的配置"></a>測試檔案的配置</h3><p>通常的情況下 Angular CLI 會自動的產生 Jasmine 和 Karma 的配置檔案。</p><p>也可以透過編輯 src/ 目錄下的 karma.conf.js 和 test.ts 檔案來微調很多選項。</p><p><img src="https://i.imgur.com/z7gIyPX.png" alt></p><p>Angular CLI 會基於 angular.json 檔案中指定的專案結構和 karma.conf.js 檔案，來在記憶體中構建出完整的執行時配置。</p><p>而如果要調整這些預設的設定，可能就要到 <a href="https://jasmine.github.io/pages/docs_home.html" rel="external nofollow noopener noreferrer" target="_blank">Jasmine</a> 和 <a href="https://karma-runner.github.io/4.0/index.html" rel="external nofollow noopener noreferrer" target="_blank">Karma</a> 的官方文件找找了。</p><h2 id="啟用程式碼覆蓋率報告"><a href="#啟用程式碼覆蓋率報告" class="headerlink" title="啟用程式碼覆蓋率報告"></a>啟用程式碼覆蓋率報告</h2><p>在 Angular CLI 中， <code>ng test</code> 指令後面可以額外追加一些參數產生程式碼覆蓋率報告。</p><h3 id="而什麼是程式碼覆蓋率呢？"><a href="#而什麼是程式碼覆蓋率呢？" class="headerlink" title="而什麼是程式碼覆蓋率呢？"></a>而什麼是<strong>程式碼覆蓋率</strong>呢？</h3><p>根據 <a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87" rel="external nofollow noopener noreferrer" target="_blank">WIKI</a> 的解釋，程式碼覆蓋（英語：Code coverage）是軟體測試中的一種度量，描述程式中原始碼被測試的比例和程度，所得比例稱為<strong>程式碼覆蓋率</strong>。</p><blockquote><p>白話來說大概可以當成是專案中的健康指標之類的吧，越高越好的那種。</p></blockquote><p>附上一篇雖然年代久遠，但對於名詞的了解上仍有一定的幫助：</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10080981" rel="external nofollow noopener noreferrer" target="_blank">[如何提升系統品質-Day24] 測試 - Code Coverage</a></li></ul><h3 id="試著產生第一份程式碼覆蓋率報告"><a href="#試著產生第一份程式碼覆蓋率報告" class="headerlink" title="試著產生第一份程式碼覆蓋率報告"></a>試著產生第一份程式碼覆蓋率報告</h3><p>指令 <code>ng test</code> 後面可以接的參數可參考</p><ul><li><a href="https://angular.io/cli/test" rel="external nofollow noopener noreferrer" target="_blank">ng test</a></li></ul><p>執行下列指令，觀察檔案結構有何異動：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng test --no-watch --code-coverage</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/JDhmuWw.png" alt></p><p>當測試完成時，該命令會在專案中建立一個新的 /coverage 目錄。</p><p><img src="https://i.imgur.com/vk1N9Mr.png" alt></p><p>這裡我使用 VS Code 的插件 - <a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" rel="external nofollow noopener noreferrer" target="_blank">Live Server</a> 開啟其 index.html 檔案以檢視帶有原始碼和程式碼覆蓋率值的報告。</p><p><img src="https://i.imgur.com/IeYIVpD.png" alt></p><p>除了每次在 <code>ng test</code> 指令後方加入參數的作法外，也可以透過 Angular CLI 的 <code>angular.json</code> 中設定：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"test": &#123;</span><br><span class="line">  "options": &#123;</span><br><span class="line">    "codeCoverage": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/HGKBe0n.png" alt></p><blockquote><p>刪除 coverage 資料夾，執行 <code>ng test</code> 指令觀察是否仍產出 coverage 資料夾。</p></blockquote><p><img src="https://i.imgur.com/ED9RpPt.png" alt="測試 OK"></p><h2 id="服務元件的測試"><a href="#服務元件的測試" class="headerlink" title="服務元件的測試"></a>服務元件的測試</h2><p>服務元件的測試算是比較單純的，因為服務元件建立後，不像普通的元件含有 Template 的部分。</p><p>使用 <code>ng g s demo</code> 指令建立服務元件，並且在 demo.service 寫一些程式。</p><p><strong>demo.service.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'en'</span>, <span class="string">'es'</span>, <span class="string">'fr'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  getString(str) &#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著在 demo.service.spec 寫測試案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; DemoService &#125; <span class="keyword">from</span> <span class="string">'./demo.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'DemoService'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> demoService: DemoService;</span><br><span class="line">  it(<span class="string">'檢查陣列是否包含特定語系'</span>, () =&gt; &#123;</span><br><span class="line">    demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line">    <span class="keyword">const</span> languages = demoService.getArray();</span><br><span class="line">    expect(languages).toContain(<span class="string">'en'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'es'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'fr'</span>);</span><br><span class="line">    expect(languages.length).toBe(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'檢查輸入字串是否等於輸出字串'</span>, () =&gt; &#123;</span><br><span class="line">    demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line">    expect(demoService.getString(<span class="string">'o'</span>)).toBe(<span class="string">'o'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>Angular CLI 預設會幫我們把服務元件 import 進該服務元件的測試檔中，方便進行測試。</p></blockquote><p>第一個測試利用了 new 讓 DemoService 實體化，並且得以取用 DemoService 內的方法：</p><ul><li>getArray()</li><li>getString()</li></ul><p>而這段測試 Code 使用的方法可以從 <a href="https://jasmine.github.io/api/3.4/global.html" rel="external nofollow noopener noreferrer" target="_blank">jasmine</a> 的文件中找到詳細描述。</p><ul><li><p>describe(description, specDefinitions)</p><ul><li>建立一<strong>組</strong>測試規範 (spec)，通常會把性質相近的測試放在一起</li><li>description - 這組測試的描述</li><li>specDefinitions - 等待被測試的函式</li></ul></li><li><p>it(description, testFunction, timeout)</p><ul><li>定義一<strong>個</strong>測試規範</li><li>description - 這個測試的描述</li><li>testFunction - 包含測試代碼的函式</li><li>timeout - 自訂非同步時的規範</li></ul></li><li><p>expect(actual) → {matchers}</p><ul><li>為這個規範建立期望</li><li>actual - 用於測試預期的實際值</li></ul></li><li><p>toContain(expected)</p><ul><li>expect 包含特定值的實際值</li><li>如 <code>expect(languages).toContain(&#39;en&#39;);</code> 為 languages 陣列是否有包含 <code>en</code> 字串在某個陣列元素內</li></ul></li><li><p>toBe(expected)</p><ul><li>將對 expected 進行三個等號的比較</li></ul></li></ul><blockquote><p>輸入測試指令 <code>ng test</code> 並觀察。</p></blockquote><p><img src="https://i.imgur.com/QLnPPTv.png" alt="5 個測試都通過了"></p><p>而刻意營造錯誤的話則會呈現：</p><p><img src="https://i.imgur.com/LBkhuQ5.png" alt></p><h2 id="使用-TestBed-測試服務元件"><a href="#使用-TestBed-測試服務元件" class="headerlink" title="使用 TestBed 測試服務元件"></a>使用 TestBed 測試服務元件</h2><p>在實務中，服務元件最終會透過 Angular 的相依注入 (DI) 來建立服務。</p><p>而 TestBed 會動態建立一個用來模擬 @NgModule 的 Angular 測試模組，因此我們可以將服務元件注入到 TestBed ，接著就可以進行測試了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; DemoService &#125; <span class="keyword">from</span> <span class="string">'./demo.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'DemoService'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> service: DemoService;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> TestBed.configureTestingModule(&#123; <span class="attr">providers</span>: [DemoService]&#125;));</span><br><span class="line">  it(<span class="string">'檢查語系陣列是否包含特定語系'</span>, () =&gt; &#123;</span><br><span class="line">    service = TestBed.get(DemoService);</span><br><span class="line">    <span class="keyword">const</span> languages = service.getArray();</span><br><span class="line">    expect(languages).toContain(<span class="string">'en'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'es'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'fr'</span>);</span><br><span class="line">    expect(languages.length).toEqual(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'檢查輸入字串是否等於輸出字串'</span>, () =&gt; &#123;</span><br><span class="line">    service = TestBed.get(DemoService);</span><br><span class="line">    <span class="keyword">const</span> returnInput = service.getString;</span><br><span class="line">    expect(returnInput(<span class="string">'a'</span>)).toBe(<span class="string">'a'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>beforeEach(function, timeout)<ul><li>describe 在調用它的每個規範之前運行一些共享設置</li></ul></li><li>TestBed.configureTestingModule()<ul><li>接收一個元資料物件，其中具有 @NgModule 中的絕大多數屬性。</li><li>要測試某個服務，就要在元資料的 <code>providers</code> 屬性中指定一個將要進行測試的陣列。</li></ul></li><li>TestBed.get()<ul><li>取得 TestBed 中的服務</li></ul></li></ul><p>上面那一段測試 Code 還有可以優化的地方，例如：</p><ul><li>可以把 <code>service = TestBed.get(DemoService);</code> 提出來放在 beforeEach() 內<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; DemoService &#125; <span class="keyword">from</span> <span class="string">'./demo.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'DemoService'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> service: DemoService;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    TestBed.configureTestingModule(&#123; <span class="attr">providers</span>: [DemoService]&#125;);</span><br><span class="line">    service = TestBed.get(DemoService);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'檢查語系陣列是否包含特定語系'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> languages = service.getArray();</span><br><span class="line">    expect(languages).toContain(<span class="string">'en'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'es'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'fr'</span>);</span><br><span class="line">    expect(languages.length).toEqual(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'檢查輸入字串是否等於輸出字串'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> returnInput = service.getString;</span><br><span class="line">    expect(returnInput(<span class="string">'a'</span>)).toBe(<span class="string">'a'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-jasmine-createSpyObj-測試一個有相依關係的服務元件"><a href="#使用-jasmine-createSpyObj-測試一個有相依關係的服務元件" class="headerlink" title="使用 jasmine.createSpyObj() 測試一個有相依關係的服務元件"></a>使用 jasmine.createSpyObj() 測試一個有相依關係的服務元件</h2><p>新增另一個服務元件 demo2 並且把 demo 注入，使 demo2 形成對 demo 的相依關係。</p><p><strong>demo1.service</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'en'</span>, <span class="string">'es'</span>, <span class="string">'fr'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  getString(str) &#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>demo2.service</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DemoService &#125; <span class="keyword">from</span> <span class="string">'./demo.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(private demoService: DemoService) &#123; &#125;</span><br><span class="line">  getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.demoService.getArray();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>撰寫 <strong>demo2.service.spec.ts</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TestBed &#125; <span class="keyword">from</span> <span class="string">'@angular/core/testing'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Demo2Service &#125; <span class="keyword">from</span> <span class="string">'./demo2.service'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Demo2Service'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> masterService: jasmine.SpyObj&lt;Demo2Service&gt;;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> spy = jasmine.createSpyObj(<span class="string">'ArrayService'</span>, [<span class="string">'getArray'</span>]);</span><br><span class="line">    TestBed.configureTestingModule(&#123;</span><br><span class="line">      providers: [</span><br><span class="line">        &#123; <span class="attr">provide</span>: Demo2Service, <span class="attr">useValue</span>: spy &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    masterService = TestBed.get(Demo2Service);</span><br><span class="line">    <span class="built_in">console</span>.log(masterService);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'檢查語系陣列是否包含特定語系'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="string">'en'</span>, <span class="string">'es'</span>, <span class="string">'fr'</span>];</span><br><span class="line">    masterService.getArray.and.returnValue(arr);</span><br><span class="line">    <span class="keyword">const</span> languages = masterService.getArray();</span><br><span class="line">    expect(languages).toContain(<span class="string">'en'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'es'</span>);</span><br><span class="line">    expect(languages).toContain(<span class="string">'fr'</span>);</span><br><span class="line">    expect(languages.length).toEqual(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 <a href="https://jasmine.github.io/api/3.4/jasmine.html" rel="external nofollow noopener noreferrer" target="_blank">jasmine.createSpyObj()</a> 產生一個含有 <code>getArray</code> 方法的物件。</p><p>而 <code>useValue</code> 可以參考<a href="https://angular.tw/guide/dependency-injection-providers#value-providers" rel="external nofollow noopener noreferrer" target="_blank">官方說明文件</a>，定義物件使用 <code>useValue</code> 作為 key 來把該變數關聯起來。</p><p>最後需要透過 <code>.getArray.and.returnValue()</code> 設定</p><ul><li>當 getArray 方法被呼叫時回傳什麼值</li></ul><blockquote><p>如果少了這個步驟，呼叫 getArray 方法的話可是什麼事情都不會發生的。</p></blockquote><p>透過這樣的方式使 demo2 與 demo 脫鉤，就可以單獨測試 demo2 。</p><p><img src="https://i.imgur.com/26rA6VG.png" alt></p><ul><li><a href="https://github.com/pvt5r486/ngTestDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub 原始碼</a></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在學習這一部分的時候，遇到蠻明顯的卡關…。</p><p>主要是因為看不懂官方中文的文件，感覺省略了很多東西。</p><p>例如<a href="https://angular.tw/guide/testing#service-tests" rel="external nofollow noopener noreferrer" target="_blank">對服務的測試 Service Tests</a> ，這邊範例感覺提供的不夠完整，讓我不知從何下手做起。</p><p>於是我轉而參考其他篇文章，如：</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10189022" rel="external nofollow noopener noreferrer" target="_blank">[Day 30] Angular 2 單元測試 Unit Test</a> 裡面的測試服務 (Service)</li></ul><p>並與官方的程式碼交叉參考，反覆撞牆下才完成本次的範例實作。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      測試對於一個公司的專案有多重要自然不言而喻，如何在 Angular 中進行測試呢？讓我們一起學習吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.40 Angular Router 加上路由守衛 (Route Guards)</title>
    <link href="http://pvt5r486.github.io/f2e/20190609/1487025750/"/>
    <id>http://pvt5r486.github.io/f2e/20190609/1487025750/</id>
    <published>2019-06-09T05:22:14.000Z</published>
    <updated>2019-06-11T02:58:13.754Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>延續上一篇的情境，現在有了前台與後台的區分。但實務上後台是不允許未經認證的人隨意進入瀏覽的，通常會搭配一個登入介面，而光靠登入介面還不夠，因為使用者很可能會藉由直接輸入網址的方式瀏覽後台頁面，這時候就需要依賴路由守衛 (Route Guards) 了 。</p><p><img src="https://images.unsplash.com/photo-1559888894-7199667c0558?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>延續上一份 ngRouteDemo 的範例，現在需求為：</p><ul><li>前台 (front) - 一般人可以隨意瀏覽的部分<ul><li>index<ul><li>page1</li><li>page2</li><li>page3</li></ul></li></ul></li><li>後台 (back) - 希望加入路由守衛的部分<ul><li>index<ul><li>page1</li><li>page2</li><li>page3</li></ul></li></ul></li></ul><p><strong>範例參考<a href="https://angular.tw/guide/router#milestone-5-route-guards" rel="external nofollow noopener noreferrer" target="_blank">中文 Angular 官方手冊</a></strong></p><h2 id="路由守衛-Route-Guards"><a href="#路由守衛-Route-Guards" class="headerlink" title="路由守衛 (Route Guards)"></a>路由守衛 (Route Guards)</h2><p>根據官方文件說明，路由守衛被<strong>應用的場合</strong>可能會是：</p><ul><li>該使用者可能無權導航到目標元件</li><li>可能使用者得先登入（認證）</li><li>在顯示目標元件前，可能得先獲取某些資料。</li><li>在離開元件前，你可能要先儲存修改。</li><li>你可能要詢問使用者：你是否要放棄本次更改，而不用儲存它們？</li></ul><blockquote><p>可以藉由路由配置中新增守衛，來處理以上這些應用場合。</p></blockquote><h3 id="路由守衛的返回值"><a href="#路由守衛的返回值" class="headerlink" title="路由守衛的返回值"></a>路由守衛的返回值</h3><p>路由守衛會返回一個值，以控制路由器的行為：</p><ul><li>如果它返回 <code>true</code> 導航過程會繼續</li><li>如果它返回 <code>false</code> 導航過程就會終止，且<strong>使用者留在原地</strong><ul><li>當返回 <code>false</code> 時，也可以告訴路由器導航到別處，例如可以導航到登入頁面</li></ul></li><li>如果它返回 UrlTree 則取消當前的導航，並且開始導航到返回的這個 UrlTree</li></ul><h3 id="路由守衛的介面種類"><a href="#路由守衛的介面種類" class="headerlink" title="路由守衛的介面種類"></a>路由守衛的介面種類</h3><p>路由器可以支援多種守衛介面：</p><ul><li>CanActivate - 處理導航到某路由的情況</li><li>CanActivateChild - 處理導航到某子路由的情況</li><li>CanDeactivate - 來處理從當前路由離開的情況</li><li>Resolve - 在路由啟用之前獲取路由資料</li><li>CanLoad - 處理非同步導航到某特性模組的情況</li></ul><p><strong>路由守衛檢查的順序</strong><br>根據手冊上的描述，在分層路由的每個級別上，可以設定多個守衛。</p><ul><li>路由器會先按照從最深的子路由，由下往上檢查的順序來檢查 CanDeactivate() 和 CanActivateChild() 守衛<ul><li>然後它會按照從上到下的順序檢查 CanActivate() 守衛。</li><li>如果特性模組是非同步載入的，在載入它之前還會檢查 CanLoad() 守衛。</li></ul></li></ul><p><strong>如果任何一個守衛返回 <code>false</code> ，其它尚未完成的守衛會被取消，這樣整個導航就被取消了。</strong></p><blockquote><p>這樣看起來最適合這個範例使用的應該就是 CanActivate 了。</p></blockquote><h2 id="CanActivate"><a href="#CanActivate" class="headerlink" title="CanActivate"></a>CanActivate</h2><p>所以我們要使用 CanActivate 來保護後台的所有頁面不被未授權的使用者看到。</p><p>但是在這個範例中，為了方便示範：</p><ul><li>將使用 CanActivate 並把路由守衛回傳值設為 <code>false</code><ul><li>藉以證明無法透過輸入網址進入保護頁面</li></ul></li></ul><h2 id="建立路由守衛"><a href="#建立路由守衛" class="headerlink" title="建立路由守衛"></a>建立路由守衛</h2><p>輸入指令，以下兩種指令則一即可<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate guard auth/auth</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g g auth/auth</span><br></pre></td></tr></table></figure><p>輸入後 Angular CLI 也會很貼心的問我們要使用哪一種<br><img src="https://i.imgur.com/7ZSY4yy.png" alt></p><p>選擇 CanActivate 後按下 Enter ，發現 Angular CLI 建立了兩隻檔案，分別為測試檔以及主要檔案。</p><p><img src="https://i.imgur.com/iOp8vzY.png" alt></p><h3 id="觀察-auth-guard"><a href="#觀察-auth-guard" class="headerlink" title="觀察 auth.guard"></a>觀察 auth.guard</h3><p>這支由 Angular CLI 建立的檔案，剛打開時什麼都沒有，而且還會跳出錯誤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span>  </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/OyKwQWS.png" alt></p><p><strong>顯然的需要在這裡寫一些東西才行。</strong></p><p>於是可以先使用官方提供的範例，觀察一下運作情形，稍後再來修改成我們要的。</p><ul><li>從 <code>@angular/router</code> 中 import <code>CanActivate</code></li><li>貼上官方的範例程式</li></ul><p><strong>auth.guard</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivate &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span> <span class="title">CanActivate</span> </span>&#123;</span><br><span class="line">  canActivate(</span><br><span class="line">    next: ActivatedRouteSnapshot,</span><br><span class="line">    state: RouterStateSnapshot): boolean &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'AuthGuard#canActivate 被觸發了'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>這樣基本的路由守衛配置就完成了。</p></blockquote><h2 id="匯入路由守衛"><a href="#匯入路由守衛" class="headerlink" title="匯入路由守衛"></a>匯入路由守衛</h2><p>接著把剛才設定好的路由守衛匯入 back-routing.module 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent&#125; <span class="keyword">from</span> <span class="string">'./index/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'../auth/auth.guard'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'back'</span>,</span><br><span class="line">    component: IndexComponent,</span><br><span class="line">    canActivate: [AuthGuard],</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page1'</span>,</span><br><span class="line">        component: Page1Component,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page2'</span>,</span><br><span class="line">        component: Page2Component,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page3'</span>,</span><br><span class="line">        component: Page3Component,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BackRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>搞定，先運行看看吧！</p></blockquote><p><img src="https://i.imgur.com/MKaXtw4.png" alt="位於前台時"></p><p><img src="https://i.imgur.com/hEWSLPb.png" alt="切換到後台時"></p><p><img src="https://i.imgur.com/6GLD9IN.png" alt="手動輸入後台的 URL"></p><p><strong>成功了，接著我們回過頭來研究 auth.guard.ts 檔內的 canActivate() 吧！</strong></p><h2 id="調整-auth-guard-內的-canActivate"><a href="#調整-auth-guard-內的-canActivate" class="headerlink" title="調整 auth.guard 內的 canActivate()"></a>調整 auth.guard 內的 canActivate()</h2><p>可以參考官方提供的文件</p><ul><li><a href="https://angular.tw/api/router/CanActivate" rel="external nofollow noopener noreferrer" target="_blank">CanActivate()</a></li><li><a href="https://angular.tw/api/router/Router#navigate" rel="external nofollow noopener noreferrer" target="_blank">navigate()</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivate, Router &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span> <span class="title">CanActivate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private router: Router) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  canActivate(</span><br><span class="line">    next: ActivatedRouteSnapshot,</span><br><span class="line">    state: RouterStateSnapshot): boolean &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'AuthGuard#canActivate 被觸發了, 你沒有授權！將跳轉回前台頁面'</span>);</span><br><span class="line">    <span class="keyword">this</span>.router.navigate([<span class="string">'/front'</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://angular.tw/api/router/ActivatedRouteSnapshot" rel="external nofollow noopener noreferrer" target="_blank">ActivatedRouteSnapshot</a> 包含了即將被啟用的路由</li><li><a href="https://angular.tw/api/router/RouterStateSnapshot" rel="external nofollow noopener noreferrer" target="_blank">RouterStateSnapshot</a> 包含了該應用即將到達的狀態</li></ul><p>為了使未認證的使用者能導航到指定頁面，我們需要匯入 <code>Router</code> 類別，並且在建構式內實例化，接著使用底下的方法 <code>navigate()</code> 。</p><p><strong>強制返回 <code>false</code> ，並且觀察當觸發路由守衛時，是否會正確的導航到指定頁面。</strong></p><blockquote><p>搞定了！測試看看吧。</p></blockquote><p><img src="https://i.imgur.com/fjKK3se.png" alt="點擊後台連結，被導航回前台"></p><p>嘗試輸入後台子頁面的網址仍被路由守衛攔下，由於畫面相同就不重複張貼了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>於是靠著官方手冊的指引，我們成功地建立了一個路由守衛，使得未通過驗證的人不得訪問後台的網頁。</p><p>當然這部分省略了很多東西，但我目的僅為了實作一個簡單的路由守衛範例，並驗證它是真的有效，所以就省略了登入步驟，直接設定不管如何都是 <code>false</code> ，藉以觀察當未通過驗證時是否正確導航到指定目的地。</p><ul><li><a href="https://github.com/pvt5r486/ngRouterDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub - 範例原始碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      延續上一篇的情境，現在有了前台與後台的區分。但實務上後台是不允許未經認證的人隨意進入瀏覽的，通常會搭配一個登入介面，而光靠登入介面還不夠，因為使用者很可能會藉由直接輸入網址的方式瀏覽後台頁面，這時候就需要依賴路由守衛 (Route Guards) 了 。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>轉職成為菜鳥前端的第一個禮拜</title>
    <link href="http://pvt5r486.github.io/life-note/20190607/2705349571/"/>
    <id>http://pvt5r486.github.io/life-note/20190607/2705349571/</id>
    <published>2019-06-07T05:58:15.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>還記得那個下定決心的夜晚是 2018 年的 6 月 11 日，那個時候的我仍任職於鄉下某間負責修理電腦、偶爾打雜，職稱卻掛 MIS 的公司。距今也已經差不多快要一年了，換句話說我花了一年的時間努力，才終於跨過轉職的門檻，得以成為 Junior 前端工程師。</p><p><img src="https://images.unsplash.com/photo-1559830772-73d4ede5bcac?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjF9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="轉職契機"><a href="#轉職契機" class="headerlink" title="轉職契機"></a>轉職契機</h2><p>我本身是私立科大資工系畢業的，那個時候系上還在推寫 APP ，不過那個時候很混，算是把大學的時間都玩掉了，畢業的時候連點像樣的東西都沒有。</p><p>接著就去當兵了，退伍後更是什麼程式語言、演算法都不記得了。</p><blockquote><p>幸好本科系的加持還是有差的，雖然大學期間頗混，但在耳濡目染下一些基礎的計算機概論常識還是有的。</p></blockquote><h3 id="第一個誘因"><a href="#第一個誘因" class="headerlink" title="第一個誘因"></a>第一個誘因</h3><p>後來應徵上了一間公司，雖然職稱是掛 MIS ，不過就如同前言所提到的：</p><ul><li>修電腦、排除操作系統、軟體上的障礙 (例如 office 系列) - 60%</li><li>打雜 - 30%</li><li>寫程式 - 10%</li></ul><p>雖然寫程式的比例頗低，但我第一件進公司的事情是：</p><ul><li>負責把公司的 ASP 網頁改成 ASP.NET Web Forms</li><li>資料庫的部分使用 MSSQL Server 2012 Express</li></ul><blockquote><p>其實我不會這些東西，當時面試時就只是說了「我願意試試看」就錄取了。</p></blockquote><p>後來事實證明我辦到了，雖然從現在的角度看來那網頁有點慘不忍睹，不過至少階段性任務還是達成了。</p><p>而我在接觸網頁的過程中逐漸的喜歡上這部分，對我來說網頁最大的魅力莫過於：</p><ul><li>基礎網頁非常容易上手，容易建立成就感<ul><li>你可以看到那些文字、圖片呈現在瀏覽器畫面上</li></ul></li><li>初期學習曲線平緩</li></ul><h3 id="第二個誘因"><a href="#第二個誘因" class="headerlink" title="第二個誘因"></a>第二個誘因</h3><p>由於任職的公司對於前端網頁的技術能量需求不大，而我任職快滿 2 年時逐漸萌生轉職的念頭，覺得自己這樣下去不行。</p><p>對我來說這樣的職涯，學習已經停滯了，而且這份工作技術含量太低了。</p><p>我也不敢想像三、四十歲時仍然蹲在桌子下幫人安裝電腦、修理電腦的那個畫面。</p><p><strong>話是這麼說沒錯，但辭掉這份工作後，我會什麼？</strong></p><p>我說不上來。</p><p>基於先前替公司寫網頁時的感覺，有了一個不太肯定的答案「<strong>或許我可以寫看看網頁？</strong>」</p><p>現在看來也不是什麼破釜沉舟的決定，就只是相較之下比較合理的選擇。</p><h2 id="往前端前進的方向"><a href="#往前端前進的方向" class="headerlink" title="往前端前進的方向"></a>往前端前進的方向</h2><p>既然都決定要轉職成一個以「寫網頁」當作工作的人，那具體來說該怎麼辦呢？</p><blockquote><p>那時候的我連<strong>前端</strong>這個名詞都不知道，我只知道我想把寫網頁當成工作，就這麼簡單。</p></blockquote><p>但我一點方向都沒有，那個時候看著自己替公司做的網頁醜到不行，朋友說可以試試看套 Bootstrap 4 ，至少不會這麼醜。</p><h3 id="一切起於-Bootstrap-4"><a href="#一切起於-Bootstrap-4" class="headerlink" title="一切起於 Bootstrap 4"></a>一切起於 Bootstrap 4</h3><p>我按照朋友的建議，看了一下 Bootstrap 4 該怎麼用，但是怎麼用就是不順。</p><p>後來因為一直看到網頁內的某個廣告，好奇驅使下就點擊了，這也是認識六角學院的開始。</p><p>因為<strong>六角學院</strong>的資源下，我知道了前端工程師大致上是在做什麼的、也有了一些方向。</p><p><strong>更不可思議的是也間接地拓展了一些人脈。</strong></p><h3 id="寫筆記帶來意想不到的收穫"><a href="#寫筆記帶來意想不到的收穫" class="headerlink" title="寫筆記帶來意想不到的收穫"></a>寫筆記帶來意想不到的收穫</h3><p>拓展人脈這點也是始料未及的，<strong>起因只是因為被建議可以寫寫筆記、記錄學習心得，讓自己學得更好。</strong></p><p>那個時候我選擇 Medium 並且寫了 「JavaScript 的奇怪部分」筆記，並且被建議可以試著貼到社團，這樣可以幫助同樣在學習這個部分的新手。</p><blockquote><p>而這個建議奠定了到現在我還仍然喜歡寫文章的基石，也認識了一些同樣愛分享的前端朋友。</p></blockquote><p>因為這些人脈，對於前端的知識在這些日子裡有飛躍式的提升，亦獲得一些實質的建議與資源，諸如：</p><ul><li>履歷怎麼改善、面試技巧等等</li><li>前端技術的學習資源<ul><li>例如被邀請去參加 <a href="https://medium.com/hulis-blog/mentor-program-3rd-47a2e85e33b3" rel="external nofollow noopener noreferrer" target="_blank">程式導師實驗計畫第三期</a><ul><li>這是一個需要投入非常大量時間自學的<a href="https://github.com/Lidemy/mentor-program-3rd-pvt5r486" rel="external nofollow noopener noreferrer" target="_blank">計畫</a>，但因為跑到一半我就找到工作了，所以沒有跑完</li></ul></li></ul></li><li>思維的轉換</li><li>情報交換</li></ul><p><strong>而更重要的是，也是因為寫了這些文章，儘管我不會 Angular ，但我的履歷仍被現在的主管看中。</strong></p><p>後來與現任主管閒聊時，他說「<strong>寫技術筆記這件事，可以當成是一種自學能力的展現，雖然你不會 Angular ，但我認為可以讓你試試看。</strong>」</p><blockquote><p>所以直到現在，我仍然維持著寫作的習慣，相信這可以讓人變得更好，也可以讓更多比我菜的新手得到幫助。</p></blockquote><h2 id="轉職成為菜鳥前端的第一個禮拜"><a href="#轉職成為菜鳥前端的第一個禮拜" class="headerlink" title="轉職成為菜鳥前端的第一個禮拜"></a>轉職成為菜鳥前端的第一個禮拜</h2><p>雖然現在連試用期都還沒過，但我總算是完成了當初自己設下的里程碑，這對肯定自己過去投入的那些時間學習是很有幫助的。</p><p>而現在的公司也蠻符合內心的期望：</p><ul><li>同事們都蠻幽默且好相處的</li><li>技術能量相當充沛</li><li>上班時間很彈性</li></ul><p>剛進公司的第一個禮拜就參與了自家產品的優化會議</p><ul><li>這也讓我了解到原來一個產品要優化大概是怎麼一回事</li><li>由那些團隊一起討論解決方案之類的</li></ul><p>總之剛進公司的第一個禮拜什麼事情都蠻新鮮的，除了很多陌生的名詞要記憶以及熟悉專案結構外，主管也決定要先在我們 UI Team 內試著跑跑看 Scrum 敏捷開發，並且試著利用這種開發模式做一個 Side Project ，當成是讓我練習 Angular 以及與團隊其他成員的協作。</p><blockquote><p>對我來說一切才剛要開始，這些都是還我沒有經歷過的，目前一切是這麼的令人期待，我也不能浪費這些機會，得好好把握才行。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      還記得那個下定決心的夜晚是 2018 年的 6 月 11 日，那個時候的我仍任職於鄉下某間負責主修電腦、偶爾打雜，職稱卻掛 MIS 的公司。距今也已經差不多快要一年了，換句話說我花了一年的時間努力，才終於跨過轉職的門檻，得以成為 Junior 前端工程師。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="職場經驗" scheme="http://pvt5r486.github.io/tags/%E8%81%B7%E5%A0%B4%E7%B6%93%E9%A9%97/"/>
    
      <category term="里程碑" scheme="http://pvt5r486.github.io/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.39 實作一個 Angular Router 切換元件頁面(二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190607/3107809513/"/>
    <id>http://pvt5r486.github.io/f2e/20190607/3107809513/</id>
    <published>2019-06-07T05:30:46.000Z</published>
    <updated>2020-03-06T08:03:35.838Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:53 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇的實作中，我們完成了一個最基礎的 Angular Router ，而本文將修改需求，將其擴充並實作出一個具有子路由功能的範例。</p><p><img src="https://images.unsplash.com/photo-1556742504-16b083241fab?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>延續上一份 ngRouteDemo 的範例，現在需求變更為：</p><ul><li>有前台 (front) 與後台 (back) 的區分<ul><li>前台就是一般人可以隨意瀏覽的部分<ul><li>裡面有 index 、 page1 、 page2 、 page3</li></ul></li><li>後台就是會套用路由守衛，要滿足條件才可以進入<ul><li>裡面有 index 、 page1 、 page2 、 page3</li></ul></li></ul></li></ul><h2 id="建立環境-區分前後台"><a href="#建立環境-區分前後台" class="headerlink" title="建立環境 - 區分前後台"></a>建立環境 - 區分前後台</h2><p>先從區分前後台開始做起吧！</p><h3 id="新增功能模組"><a href="#新增功能模組" class="headerlink" title="新增功能模組"></a>新增功能模組</h3><p>新增兩個功能模組分別為：</p><ul><li>front - 前台</li><li>back - 後台</li></ul><p>新增功能模組，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g m front</span><br></pre></td></tr></table></figure><p></p><blockquote><p>執行完指令後 Angular CLI 會自動將我們新增的功能模組 import 至 AppModule 內。</p></blockquote><p>此時 <code>app.module</code> 內容如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FrontModule &#125; <span class="keyword">from</span> <span class="string">'./front/front.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BackModule &#125; <span class="keyword">from</span> <span class="string">'./back/back.module'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FrontModule,</span><br><span class="line">    BackModule,</span><br><span class="line">    AppRoutingModule,</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>特別注意此處 <code>imports</code> 陣列內的順序，父路由最後只會負責<strong>萬用字元路由與預設路由</strong>，因此應將其順序放於最後。</p></blockquote><h3 id="新增元件-amp-搬運元件"><a href="#新增元件-amp-搬運元件" class="headerlink" title="新增元件 &amp; 搬運元件"></a>新增元件 &amp; 搬運元件</h3><p>我們新加入了兩個功能模組用來區分前後台，接著要建立前後台都有的 index 元件，目的是作為殼使用。</p><p>cd 進剛才建立的功能模組內，並新增元件，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c index</span><br></pre></td></tr></table></figure><p></p><p>最後將之前建立好的 Page1 、 Page2 、 Page3 元件搬進 front / back 功能模組內。</p><p><strong>最後結構上會像是這樣</strong></p><ul><li>AppComponent - 父路由<ul><li>front - 功能模組<ul><li>index - 子路由<ul><li>page1</li><li>page2</li><li>page3</li></ul></li></ul></li><li>back - 功能模組<ul><li>index - 子路由<ul><li>page1</li><li>page2</li><li>page3</li></ul></li></ul></li></ul></li></ul><blockquote><p>別忘了要在建好的功能模組內， import 相關的元件進來，並且設置要 <code>exports</code> 的元件，因為最後配置父路由時會需要用到。</p></blockquote><p><strong>front.module</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent &#125; <span class="keyword">from</span> <span class="string">'./index/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    IndexComponent,</span><br><span class="line">    Page1Component,</span><br><span class="line">    Page2Component,</span><br><span class="line">    Page3Component</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">  ],</span><br><span class="line">  exports: [IndexComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontModule</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>back.module 同 front.module 設置。</p></blockquote><h3 id="調整各個元件的-Template"><a href="#調整各個元件的-Template" class="headerlink" title="調整各個元件的 Template"></a>調整各個元件的 Template</h3><p><strong>front 功能模組 IndexComponent 的 Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>現在位於 front 元件，請點擊以下連結切換頁面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page1"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page2"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page3"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>back 功能模組 IndexComponent 的 Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>現在位於 back 元件，請點擊以下連結切換頁面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page1"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page2"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page3"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>AppComponent 的 Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>點擊以下連結切換元件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/front"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>前台<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/back"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>後台(需驗證)<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="替功能模組設置子路由"><a href="#替功能模組設置子路由" class="headerlink" title="替功能模組設置子路由"></a>替功能模組設置子路由</h2><p>複製 <code>app-routing.module</code> 並且貼進 front 功能模組內，重新命名為 <code>front-routing.module</code> 。</p><p><strong>修改 <code>front.module</code> ，將剛才新增的路由設定檔引入，如：</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent &#125; <span class="keyword">from</span> <span class="string">'./index/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FrontRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./front-routing.module'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    IndexComponent,</span><br><span class="line">    Page1Component,</span><br><span class="line">    Page2Component,</span><br><span class="line">    Page3Component</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    FrontRoutingModule</span><br><span class="line">  ],</span><br><span class="line">  exports: [IndexComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontModule</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改 <code>front-routing.module</code></strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent&#125; <span class="keyword">from</span> <span class="string">'./index/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'front'</span>,</span><br><span class="line">    component: IndexComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page1'</span>,</span><br><span class="line">        component: Page1Component,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page2'</span>,</span><br><span class="line">        component: Page2Component,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'page3'</span>,</span><br><span class="line">        component: Page3Component,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>這部分 back 功能模組同 front 功能模組配置。</p></blockquote><h2 id="修改-app-routing-module-配置"><a href="#修改-app-routing-module-配置" class="headerlink" title="修改 app-routing.module 配置"></a>修改 app-routing.module 配置</h2><p>配置完功能模組的子路由後，最後只需要微調一下這邊就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent &#125; <span class="keyword">from</span> <span class="string">'./front/index/index.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">''</span>,   <span class="attr">redirectTo</span>: <span class="string">'/front'</span>, <span class="attr">pathMatch</span>: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'**'</span>, <span class="attr">component</span>: IndexComponent &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>這裡 import front 功能模組內的 IndexComponent 元件，因為我希望當使用者胡亂輸入時會顯示這個元件。</p></blockquote><h2 id="測試看看"><a href="#測試看看" class="headerlink" title="測試看看"></a>測試看看</h2><p><img src="https://i.imgur.com/wOh4I8I.png" alt="預設狀態"></p><p><img src="https://i.imgur.com/zSXE5f0.png" alt="胡亂輸入時"></p><p><img src="https://i.imgur.com/Lg5fO3D.png" alt="切換到後台的狀態"></p><p><img src="https://i.imgur.com/ESm6VJi.png" alt="處於前台且 page1 的狀態"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本來以為這部分應該不會太複雜，但在不熟 Angular 的情況下我還是搞了蠻久的。</p><p>當初預計這一篇要一起實作路由守衛的部分，看來只能下一篇了，不然篇幅太長囉。</p><ul><li><a href="https://github.com/pvt5r486/ngRouterDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub - 範例原始碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在上一篇的實作中，我們完成了一個最基礎的 Angular Router ，而本文將修改需求，將其擴充並實作出一個具有子路由功能的範例。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.38 實作一個 Angular Router 切換元件頁面(一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190605/512374788/"/>
    <id>http://pvt5r486.github.io/f2e/20190605/512374788/</id>
    <published>2019-06-05T04:38:10.000Z</published>
    <updated>2019-06-11T02:58:13.754Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是進入公司的第三天，為了能盡快投入專案與成為團隊可用的戰力，我正在努力啃官方文件學習 Angular 的知識，所以這一篇文章主要是記錄我如何閱讀官方文件後，實作這個非常基本的、帶導航的網頁應用。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需求大概是這樣的：</p><ul><li>開一個新的 Angular 專案，並且一開始選擇加入 Router 功能<ul><li>根元件是 AppComponent ，然後下方有三個子元件分別是<ul><li>page1</li><li>page2</li><li>page3</li></ul></li><li>可以在 AppComponent 內點擊連結切換到這三個頁面</li></ul></li></ul><p><strong>參考文件:</strong></p><ul><li><a href="https://angular.tw/guide/router#routing--navigation" rel="external nofollow noopener noreferrer" target="_blank">路由與導航</a></li><li><a href="https://angular.tw/api/router/Routes#simple-configuration" rel="external nofollow noopener noreferrer" target="_blank">Routes</a></li></ul><h2 id="建立環境"><a href="#建立環境" class="headerlink" title="建立環境"></a>建立環境</h2><p>輸入 <code>ng new ngRouterDemo</code> 建立新專案，並直接選擇要使用 Router 。</p><p><img src="https://i.imgur.com/in0naEz.png" alt></p><h3 id="觀察檔案結構"><a href="#觀察檔案結構" class="headerlink" title="觀察檔案結構"></a>觀察檔案結構</h3><p>這次選擇加入 Router 後，發現 app 資料夾內多了 <code>app-routing.module.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>然後 <code>app.module.ts</code> 中也把 <code>app-routing.module.ts</code> 這隻檔案給引入了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    AppRoutingModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>對照一下有無加入 Router 的部分</p></blockquote><p><img src="https://i.imgur.com/ng0fBOP.png" alt="app.module"></p><p>除此之外就是 app 資料夾內多了 <code>app-routing.module.ts</code> 這隻檔案。</p><p><strong>運行結果</strong></p><p><img src="https://i.imgur.com/XtHwZdA.png" alt></p><p>沒有什麼明顯的變化。</p><h2 id="分別建立三個元件"><a href="#分別建立三個元件" class="headerlink" title="分別建立三個元件"></a>分別建立三個元件</h2><p>輸入指令建立本次範例用的元件</p><ul><li>page1</li><li>page2</li><li>page3</li></ul><p>如 <code>ng g c page1</code></p><p><img src="https://i.imgur.com/K3wk8Gy.png" alt></p><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>因為是選擇使用 Router 的模式，所以 Angular CLI 預設幫我們加入了 <code>router-outlet</code> 標籤，這代表路由切換後的畫面都會在這個標籤裡面呈現。</p><blockquote><p><strong>以下引用自官方說明：</strong><br>RouterOutlet 是一個來自路由模組中的指令，它的用法類似於元件。 它扮演一個佔位符的角色，用於在範本中標出一個位置，路由器將會把要顯示在這個出口處的元件顯示在這裡。<br>有了這份配置，當本應用在瀏覽器中的 URL 變為 /heroes 時，路由器就會匹配到 path 為 heroes 的 Route，並在宿主檢視中的 RouterOutlet 之後顯示 HeroListComponent 元件。</p></blockquote><h3 id="加入-RouterLink-連結"><a href="#加入-RouterLink-連結" class="headerlink" title="加入 RouterLink 連結"></a>加入 RouterLink 連結</h3><p>因為要點擊連結後透過路由配置切換到該元件，所以必須先設置路由器連結 (Router links)：</p><p><strong>對 Appcomponent 進行 Template 上的調整</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>點擊以下連結切換元件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/page1"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>Page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/page2"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>Page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/page3"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>Page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>RouterLink<ul><li>a 標籤上的 RouterLink 指令讓路由器得以控制這個 a 元素，這裡的導航路徑是固定的，因此可以把一個字串賦給 routerLink（”一次性”繫結）。</li><li>這後面接的就是實際上網址列顯示的路徑</li></ul></li><li>RouterLinkActive<ul><li>在每個 a 標籤上，你會看到一個 <code>RouterLinkActive</code> 的屬性繫結，像是 <code>routerLinkActive=&quot;...&quot;</code></li><li>等號右邊可以填入包含一些用空格分隔的 CSS 類名，當這個連結啟用時，路由器將會把它們加上去<ul><li>並在處於非活動狀態時移除</li></ul></li></ul></li></ul><p><strong>為了方便辨識效果，所以也加入 .active 的樣式吧</strong><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>這邊要注意的是 CSS 樣式要寫在 Appcomponent 內。</p></blockquote><h3 id="註冊路由器與路由定義"><a href="#註冊路由器與路由定義" class="headerlink" title="註冊路由器與路由定義"></a>註冊路由器與路由定義</h3><p>要使用路由的話，必須要把要使用的元件 import 進來，並且在 <code>routes</code> 陣列內配置它們，陣列內傳入一個物件，而物件內可以傳入參數：</p><ul><li>path - 切換到這個元件的路徑</li><li>component - 切換的元件名稱</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page1'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page2'</span>, <span class="attr">component</span>: Page2Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page3'</span>, <span class="attr">component</span>: Page3Component &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>當我們定義好路由陣列 routes 並把它傳給 RouterModule.forRoot() 方法後：</p><ul><li>它會返回一個模組，其中包含配置好的 Router 服務提供商，以及路由庫所需的其它提供商。</li></ul><p>一旦啟動了應用 Router 就會根據當前的瀏覽器 URL 進行首次導航。</p><blockquote><p>存檔，試著運行看看。</p></blockquote><p><img src="https://i.imgur.com/TO8A5PM.png" alt="page1"></p><p><img src="https://i.imgur.com/qqY6dEB.png" alt="page2"></p><p><strong>這樣基礎的 Angular 路由範例就完成了！</strong></p><p>而因為我們有在 RouterModule.forRoot() 把 <code>enableTracing</code> 打開，所以當切換路由時時可以看到一些額外訊息：</p><p><img src="https://i.imgur.com/nSkIDMn.png" alt></p><h2 id="設置萬用字元與預設路由"><a href="#設置萬用字元與預設路由" class="headerlink" title="設置萬用字元與預設路由"></a>設置萬用字元與預設路由</h2><p>雖然我們基礎的範例完成了但還不夠好，因為：</p><ul><li>如果在網址列隨意輸入會跳出錯誤<ul><li>而使用者是這麼白目</li></ul></li><li>需要設定一組預設路由，也就是使用者初次進入網頁時會顯示的畫面</li></ul><h3 id="設置萬用字元"><a href="#設置萬用字元" class="headerlink" title="設置萬用字元"></a>設置萬用字元</h3><p>新增一個萬用字元路由來攔截所有無效的 URL 並處理它們。 萬用字元路由的 path 是兩個星號（**），它會匹配任何 URL。 當路由器匹配不上以前定義的那些路由時，它就會選擇這個路由。</p><p>萬用字元路由可以導航到自訂的 “404 Not Found” 元件，也可以重定向到一個現有路由。</p><p>特別要注意的是：<br><strong>路由器使用先匹配者優先的策略來選擇路由，萬用字元路由是路由配置中最沒有特定性的那個，因此務必確保它是配置中的最後一個路由。</strong></p><p>因此修改 <strong>app-routing.module</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page1'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page2'</span>, <span class="attr">component</span>: Page2Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page3'</span>, <span class="attr">component</span>: Page3Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'**'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/suunvI6.png" alt="胡亂輸入路徑"></p><blockquote><p>像這樣，永遠確保萬用字元在最後一組路由就可以了，而且也不會跳錯誤。</p></blockquote><h3 id="設置預設路由"><a href="#設置預設路由" class="headerlink" title="設置預設路由"></a>設置預設路由</h3><p>與設置萬用字元時差不多，由於路由是有順序性的，因此應該其放在萬用字元路由的前一個。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page1Component &#125; <span class="keyword">from</span> <span class="string">'./page1/page1.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page2Component &#125; <span class="keyword">from</span> <span class="string">'./page2/page2.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Page3Component &#125; <span class="keyword">from</span> <span class="string">'./page3/page3.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page1'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page2'</span>, <span class="attr">component</span>: Page2Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page3'</span>, <span class="attr">component</span>: Page3Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">''</span>,   <span class="attr">redirectTo</span>: <span class="string">'page2'</span>, <span class="attr">pathMatch</span>: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'**'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    RouterModule.forRoot(routes, &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>為了方便辨識，我將預設路由設置為 <code>page2</code> ，也就是預期當使用者初次進入網站時會看到這個畫面。</p><p>重定向路由需要一個 pathMatch 屬性，來告訴路由器如何用 URL 去匹配路由的路徑，否則路由器就會報錯。</p><blockquote><p>在本範例中路由器應該只有在完整的 URL 等於 ‘’ 時才選擇 Page2Component 元件，因此要把 <code>pathMatch</code> 設定為 ‘full’。</p></blockquote><p><img src="https://i.imgur.com/U33vD2t.png" alt></p><blockquote><p>可以觀察下方的 log ，發現一開始如果網址都沒輸入時，會自動跳轉到 <code>page2</code></p></blockquote><h3 id="順序錯誤的場合"><a href="#順序錯誤的場合" class="headerlink" title="順序錯誤的場合"></a>順序錯誤的場合</h3><p>前面提到路由器使用先匹配者優先的策略來選擇路由，所以順序很重要，如果把萬用字元的順序稍微挪動，如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page1'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page2'</span>, <span class="attr">component</span>: Page2Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'page3'</span>, <span class="attr">component</span>: Page3Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'**'</span>, <span class="attr">component</span>: Page1Component &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">''</span>,   <span class="attr">redirectTo</span>: <span class="string">'page2'</span>, <span class="attr">pathMatch</span>: <span class="string">'full'</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/dYvHME9.png" alt="路由順序調換"></p><p>因為匹配到的路由會變成萬用字元的路由，因此就不會跳轉到 <code>page2</code> 了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過實作這個非常基本的、帶導航的網頁應用學到了如何：</p><ul><li>載入路由庫</li><li>在根元件的 Template 中新增一個導覽列，導覽列中有一些 A 標籤、routerLink 指令和 routerLinkActive 指令</li><li>在根元件的 Template 中新增一個 router-outlet 指令，頁面將會被顯示在那裡</li><li>用 RouterModule.forRoot 配置路由器模組</li><li>使用萬用字元路由來處理無效路由</li><li><p>當應用在空路徑下啟動時，導航到預設路由</p></li><li><p><a href="https://github.com/pvt5r486/ngRouterDemo" rel="external nofollow noopener noreferrer" target="_blank">GitHub - 範例原始碼</a></p></li></ul><blockquote><p>之後會嘗試實作路由守衛的部分。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      今天是進入公司的第三天，為了能盡快投入專案與成為團隊可用的戰力，我正在努力啃官方文件學習 Angular 的知識，所以這一篇文章主要是記錄我如何閱讀官方文件後，實作這個非常基本的、帶導航的網頁應用。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>使用 nvm 切換 node 版本</title>
    <link href="http://pvt5r486.github.io/f2e/20190603/3226447527/"/>
    <id>http://pvt5r486.github.io/f2e/20190603/3226447527/</id>
    <published>2019-06-03T14:37:49.000Z</published>
    <updated>2019-06-07T05:30:41.456Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在公司的專案中若有部分是屬於較早之前的專案，很可能在使用 <code>npm install</code> 或 <code>yarn</code> 指令時跳出因版本過高而無法順利下載專案相依套件，此時就只能考慮將目前的 node 版本降下來，或者透過 nvm 切換 node 版本了。</p><p><img src="https://images.unsplash.com/photo-1559494007-9f5847c49d94?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=334&amp;q=80" alt></p><h2 id="安裝-nvm"><a href="#安裝-nvm" class="headerlink" title="安裝 nvm"></a>安裝 nvm</h2><p>取得 nvm 的方式有很多種：</p><ul><li>透過 curl<ul><li><a href="https://curl.haxx.se/download.html" rel="external nofollow noopener noreferrer" target="_blank">取得 curl</a></li></ul></li><li>透過 wget<ul><li><a href="https://eternallybored.org/misc/wget/" rel="external nofollow noopener noreferrer" target="_blank">取得 wget</a></li></ul></li><li>Windows 系統有安裝檔可以使用<ul><li><a href="https://github.com/coreybutler/nvm-windows/releases" rel="external nofollow noopener noreferrer" target="_blank">nvm-windows</a></li></ul></li></ul><p>因為我的筆電環境沒有 curl 也沒有 wget ，索性就直接吃安裝檔了，最方便。</p><p><strong>關於詳細安裝方式可以看官方的 <a href="https://github.com/nvm-sh/nvm" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></strong></p><p>之後可以打開終端機輸入 <code>nvm version</code> 查看目前版本，有看到版本代表安裝成功。</p><p><img src="https://i.imgur.com/HQAnPrt.png" alt></p><h2 id="使用-nvm"><a href="#使用-nvm" class="headerlink" title="使用 nvm"></a>使用 nvm</h2><p><strong>輸入以下指令取得 node 其他版本：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;version&gt;</span><br></pre></td></tr></table></figure><p></p><p>如 <code>nvm install 9.0.0</code> ，如此一來就會安裝 node 9.0.0 的版本</p><p><strong>查看目前可切換的版本</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><p></p><p><strong>切換 node 版本</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use &lt;version&gt;</span><br></pre></td></tr></table></figure><p></p><p>如 <code>nvm use 9.0.0</code> ，切換到 node 9.0.0 的版本</p><p><strong>使用別名稱呼版本號</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias &lt;Name&gt; &lt;version&gt;</span><br></pre></td></tr></table></figure><p></p><p>如 <code>nvm alias forWork 9.0.0</code> ，這樣就完成別名的命名，爾後就能使用 <code>nvm use forWork</code> 切換到 node 9.0.0 版了。</p><blockquote><p>因為我的電腦工作時已經安裝一次，這部分就偷懶不補圖片了。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天是到職的第一天，在完成報到手續以及認識環境後，隨即就正式開始對公司專案的探索了，持續的督促自己，也謝謝今天給予我指點的前輩。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在公司的專案中若有部分是屬於較早之前的專案，很可能在使用 npm install 或 yarn 指令時跳出因版本過高而無法順利下載專案相依套件，此時就只能考慮將目前的 node 版本降下來，或者透過 nvm 切換 node 版本了。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="職場經驗" scheme="http://pvt5r486.github.io/tags/%E8%81%B7%E5%A0%B4%E7%B6%93%E9%A9%97/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.37 使用 async 管道元件訂閱 Observable 物件</title>
    <link href="http://pvt5r486.github.io/f2e/20190602/184648847/"/>
    <id>http://pvt5r486.github.io/f2e/20190602/184648847/</id>
    <published>2019-06-02T08:02:06.000Z</published>
    <updated>2019-06-09T05:29:07.499Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不覺也到了 No.37 了，最後還想要再介紹一個名為 Async 的管道元件，說到管道元件一定不陌生，因為先前就介紹蠻多常用的管道元件了。</p><p><img src="https://images.unsplash.com/photo-1559298400-3770039ce246?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Async-管道元件"><a href="#Async-管道元件" class="headerlink" title="Async 管道元件"></a>Async 管道元件</h2><p>管道元件可以讓我們用在 Template 上的屬性繫結或者內嵌繫結的地方。</p><p>使用方法也相當簡單，加上 | 符號後再加上要使用的 Pipe 元件即可。</p><p>Async 管道元件 也可以在官網找到相關文件</p><ul><li><a href="https://angular.cn/api/common/AsyncPipe" rel="external nofollow noopener noreferrer" target="_blank">Async 管道元件</a></li></ul><p>Async 管道元件就是用來訂閱任何一個 Observable 物件 (觀察者物件)</p><ul><li>所以這個 Async 管道元件通常是用於 HttpClient 的回傳值或者是 Observable 的情況</li><li>可以省略在類別中的方法內使用 .subscribe() 的動作<ul><li>意思就是透過 Async 管道元件幫我們做 .subscribe() 的動作</li></ul></li></ul><p>因此，讓我們再度進行重構吧！</p><h2 id="ArticleList-的重構"><a href="#ArticleList-的重構" class="headerlink" title="ArticleList 的重構"></a>ArticleList 的重構</h2><ul><li>將屬性 <code>atticleData</code> 重新命名為 <code>atticleData$</code><ul><li>$ 字號是命名觀察者物件的一個命名習慣<ul><li>必要時也使用 TypeScript 將 Observable 的型別也加上<ul><li>而 Observable 是泛型語法，因此也需要加上角括號 <code>&lt;any&gt;</code></li></ul></li></ul></li></ul></li><li>而修改了屬性 <code>atticleData</code> ，所以有用到屬性 <code>atticleData</code> 的方法全部都報錯<ul><li>這部分可以先暫時刪除，因為這篇只是為了要介紹 Async 管道元件</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  atticleData$: Observable&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>(public datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData$ = <span class="keyword">this</span>.datasvc.getData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Template 部分一樣要修改，豪邁的砍掉錯誤的部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData$ | async; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span> [<span class="attr">counter</span>]=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p>最後來看一下結果吧：<br><img src="https://i.imgur.com/v4f0GU7.png" alt></p><p>透過這個簡單的範例介紹 Async 管道元件的用途。</p><blockquote><p>而通常 Async 管道元件會被用於只需要單純取得資料且來源又是 Observable 時可以簡化不少程式碼。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>總算是跑完這一系列了，也逐漸覺得 Angular 有不少好用的地方是 Vue 所體會不到的，但有部分的觀念其實很類似，所以學習起來不會感到特別吃力。</p><p>但是儘管我完成了這一系列，不可置否的是我仍然對於 Angular 語法以及 TypeScript 的語法不夠熟悉，這樣是沒辦法熟練應用於實務上的，因此還必須持續的努力、複習。</p><p>這一系列完成於到新公司上班的前一天，而我也是因為這間公司才開始投入學習 Angular 的，希望透過這樣職前的自我訓練，能在進入公司後盡快地掌握公司內 Angular 的專案。</p><p>一系列的文章通常只有最初跟最後有人看，所以我還是在這裡把環境稍微交代一下：</p><ul><li>專案使用的 Angular CLI 版本是 7.3.9</li><li>使用 Angular 7 的語法撰寫</li><li><a href="https://github.com/pvt5r486/firstAngular" rel="external nofollow noopener noreferrer" target="_blank">GitHub Repo</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      不知不覺也到了 No.37 了，最後還想要再介紹一個名為 Async 的管道元件，說到管道元件一定不陌生，因為先前就介紹蠻多常用的管道元件。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.36 重構 DataService 服務元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190602/2466431500/"/>
    <id>http://pvt5r486.github.io/f2e/20190602/2466431500/</id>
    <published>2019-06-02T06:57:24.000Z</published>
    <updated>2019-06-09T05:28:55.944Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用得好好的為啥要重構呢？原因是目前這個 DataService 並沒有寫得很漂亮，原因是通常不會直接在服務元件內直接做 .subscribe() 的動作，大部分的情況都是在其他元件內進行。畢竟什麼時候要訂閱是各個元件自己才知道，服務元件單純的提供服務就好。</p><h2 id="重構-DataService"><a href="#重構-DataService" class="headerlink" title="重構 DataService"></a>重構 DataService</h2><p>移除先前為了介紹寫在建構式內的程式碼，並且新增一個方法叫 <code>getData()</code></p><ul><li>httpClient.get() 方法會最後會產生一個觀察者物件，將其回傳<ul><li>而這麼做，意味著資料最後不會出現在服務元件內，因此先註解其他程式碼</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private httpClient: HttpClient) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.get(<span class="string">'http://localhost:4200/api/articles.json'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// doDelete(item) &#123;</span></span><br><span class="line">  <span class="comment">//   this.atticleData = this.atticleData.filter(v =&gt; v.id !== item.id);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// doModify(post: any) &#123;</span></span><br><span class="line">  <span class="comment">//   this.atticleData = this.atticleData.map((item) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     if (post.id === item.id) &#123;</span></span><br><span class="line">  <span class="comment">//       return Object.assign(&#123;&#125;, item, post);</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     return item;</span></span><br><span class="line">  <span class="comment">//   &#125;);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="調整-ArticleList-元件"><a href="#調整-ArticleList-元件" class="headerlink" title="調整 ArticleList 元件"></a>調整 ArticleList 元件</h2><p>因為先前的調整，ArticleList 內幾乎已經沒有程式碼了，原因是該元件的 Tamplate 內是直接讀取 DataService 的資料。</p><p><strong>但現在 DataService 已經沒有 <code>atticleData</code> 屬性了，怎麼辦呢？</strong></p><p>解決辦法：</p><ul><li>呼叫 DataService 內的 getData 方法<ul><li>因為這個方法將回傳一個觀察者物件 (Observable Object)，因此可以使用 .subscribe() 方法<ul><li>成功取得資料後，將資料賦值給 <code>atticleData</code> 屬性<ul><li>因為之前把元件內的 <code>atticleData</code> 屬性移除了，現在必須加回去</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  atticleData;</span><br><span class="line">  <span class="keyword">constructor</span>(public datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.datasvc.getData().subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.atticleData = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣看起來就合理多了，應該是由元件來決定何時訂閱，而不是由服務元件來決定。</p><p>因為可能會有多種不同的事件來處發 API ，所以由個別元件來決定是最合理的。</p><p><strong>調整完後還有 Template 要修改：</strong></p><ul><li>目前資料已經透過訂閱回到 ArticleList 本身了<br>也因為資料已經在自身元件，所以刪除與改標題的方法也必須移動回元件本身。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"doDelete($event)"</span> (<span class="attr">changeTitle</span>)=<span class="string">"doModify($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span> [<span class="attr">counter</span>]=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p>最終 ArticleList 是這樣的：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  atticleData;</span><br><span class="line">  <span class="keyword">constructor</span>(public datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.datasvc.getData().subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.atticleData = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (post.id === item.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重新整理一下想法：</p><ul><li>目前 ArticleList 透過服務元件上的 getData() 方法取得 文章資料<ul><li>而現在的資料都是來自於 Server 端，我們只是把 Server 端的資料抓下來暫存在 atticleData 屬性而已</li></ul></li><li>因此 doDelete() 、 doModify() 都是修改存放在 local 端的資料，並不是真正修改 Server 端的資料</li></ul><p><strong>也就是說需要回到 DataService 上調整 doDelete() 、 doModify() 這兩個方法。</strong></p><h2 id="調整-DataService-服務元件"><a href="#調整-DataService-服務元件" class="headerlink" title="調整 DataService 服務元件"></a>調整 DataService 服務元件</h2><p>doDelete()</p><ul><li>使用 httpClient.delete() 發送一個 delete 請求給伺服器刪除特定資料，並帶上文章 id</li></ul><p>doModify()</p><ul><li>使用 httpClient.put() 發送一個 put 請求給伺服器更新特定資料，並帶上文章 id<ul><li>第二個參數則傳入 <code>post</code> ， httpClient 會自動把 <code>post</code> 這個物件轉換成 json 格式</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public httpClient: HttpClient) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.get(<span class="string">'http://localhost:4200/api/articles.json'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  doDelete(item) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.delete(<span class="string">`http://localhost:4200/api/articles.json/<span class="subst">$&#123;item.id&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.put(<span class="string">`http://localhost:4200/api/articles.json/<span class="subst">$&#123;post.id&#125;</span>`</span>, post);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>至此 DataService 就調整完畢了，最後再次回到 ArticleList 元件完成真正的刪除與修改！</strong></p><h2 id="觸發-DataService-上的-doDelete-及-doModify"><a href="#觸發-DataService-上的-doDelete-及-doModify" class="headerlink" title="觸發 DataService 上的 doDelete() 及 doModify()"></a>觸發 DataService 上的 doDelete() 及 doModify()</h2><p>用法是這樣的：</p><ul><li>當 ArticleList 元件內的 doDelete() 被觸發時<ul><li>呼叫 DataService 上的 doDelete() 並傳入 <code>item</code> 並且訂閱結果<ul><li>當結果成立時 (伺服器端的資料被刪除了) 才執行 local 端的資料刪除</li></ul></li></ul></li></ul><p>同理 doModify() 也是。</p><p>另外，串接 API 時常常會遇到一些意外的狀況，此時</p><ul><li>可以用上 .subscribe() 第二個參數 error ，同樣也是個 callback function<ul><li>可以透過這個 callback 取得錯誤的結果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  atticleData;</span><br><span class="line">  <span class="keyword">constructor</span>(public datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.datasvc.getData().subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.atticleData = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.datasvc.doDelete(item).subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'錯誤資訊'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.datasvc.doModify(post).subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (post.id === item.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'錯誤資訊'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大功告成，來試試看吧！</strong></p><p><img src="https://i.imgur.com/12tOtrH.png" alt="順利取得全部資料"></p><p><img src="https://i.imgur.com/ZRDDezU.png" alt="進行刪除時因為找不到這隻 API 所以報錯"></p><p><img src="https://i.imgur.com/ACfmnGQ.png" alt="進行編輯時因為找不到這隻 API 所以報錯"></p><p><strong>一切都符合我們的預期 :D</strong></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p><a href="https://github.com/pvt5r486/firstAngular" rel="external nofollow noopener noreferrer" target="_blank">這一系列的原始碼</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      用得好好的為啥要重構呢？原因是目前這個 DataService 並沒有寫得很漂亮，原因是通常不會直接在服務元件內直接做 .subscribe() 的動作，大部分的情況都是在其他元件內進行。畢竟什麼時候要訂閱是各個元件自己才知道，服務元件單純的提供服務就好。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.35 了解 @Injectable() 裝飾器與注入 HttpClient 服務元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190602/951431477/"/>
    <id>http://pvt5r486.github.io/f2e/20190602/951431477/</id>
    <published>2019-06-02T05:34:12.000Z</published>
    <updated>2019-06-09T05:29:46.741Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介紹服務元件的時候就已經看過 @Injectable() 但那個時候並沒有詳加著墨介紹，究竟 @Injectable() 是什麼意思呢？</p><p><img src="https://images.unsplash.com/photo-1559376210-54a1b73ddb88?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1189&amp;q=80" alt></p><h2 id="Injectable"><a href="#Injectable" class="headerlink" title="@Injectable()"></a>@Injectable()</h2><p>Injectable 本身是一個裝飾器 (Decorator) ，主要目的是用於描述這個類別 (class) 是否可以被注入其他的服務元件，事實上如果把之前服務元件上寫的 @Injectable() 刪除，還是可以成功地注入其他元件上，舉例來說：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="comment">/* tslint:disable */</span></span><br><span class="line">    <span class="keyword">this</span>.atticleData = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">        <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">        <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">        <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ... 省略 ...</span></span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(post.id === item.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刪除 <code>@Injectable()</code> 後功能依然正常，也就是說移除裝飾器後，服務元件依然有被注入成功。<br><img src="https://i.imgur.com/JD3LjlA.png" alt></p><h2 id="既然可以被移除又何必要寫-Injectable"><a href="#既然可以被移除又何必要寫-Injectable" class="headerlink" title="既然可以被移除又何必要寫 @Injectable()"></a>既然可以被移除又何必要寫 @Injectable()</h2><p>因為它可以注入一些額外其它的服務元件，什麼意思呢？</p><p>我們可以透過 @Injectable() 注入 HTTP Client 的元件，從伺服器取得動態的資料。</p><h2 id="注入服務元件-HTTP-Client"><a href="#注入服務元件-HTTP-Client" class="headerlink" title="注入服務元件 HTTP Client"></a>注入服務元件 HTTP Client</h2><p>在 Angular 中有內建一個服務元件 HTTP Client ，所以先將其注入目前的 Data Service 中。</p><p><img src="https://i.imgur.com/4kPqPH5.png" alt="Image"></p><ul><li>值得一提的是這裡的自動完成匯入的路徑並不是我們要的，應修正為：<ul><li><code>import { HttpClient } from &#39;@angular/common/http&#39;;</code></li></ul></li></ul><p><strong>這才是正確的 HTTP 模組來源</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>(private httpClient: HttpClient) &#123;</span><br><span class="line">  <span class="comment">/* tslint:disable */</span></span><br><span class="line">    <span class="keyword">this</span>.atticleData = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">        <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">        <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">        <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ... 省略 ...</span></span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(post.id === item.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>處理完之後，這個 httpClient 注入還是失敗的，因為還沒將它加入到 ArticleModule 下。</strong></p><p><img src="https://i.imgur.com/O6HsUGq.png" alt></p><p>錯誤訊息說明了必須匯入 HttpClientModule 到 ArticleModule</p><p><img src="https://i.imgur.com/WPuQhX5.png" alt="import HttpClientModule"></p><p>此時網頁又可以正常運作了<br><img src="https://i.imgur.com/IpHKT25.png" alt></p><p>前面有提到如果把 <code>@Injectable()</code> 刪除不影響程式運作，但此時如果直接將 <code>@Injectable()</code> 移除可是會出錯的。</p><p><img src="https://i.imgur.com/QeLM8K8.png" alt></p><p>意思是無法解析 DataService 內所有的參數，雖然不太懂是什麼意思，但如果看到 resolve 通常是跟相依注入有關。</p><p>因為此時相依注入是從建構式內找到一個 httpClient 參數，然後參數標註 HttpClient 型別</p><ul><li>所以它必須解析 httpClient 的內容從何而來<ul><li>此時 Angular 會去找出 HttpClient 並且將其 new 出來成為一個物件實體<ul><li>再把這個物件實體丟給 httpClient 參數，然後就解析完成 (resolve 就是這個意思)</li></ul></li></ul></li></ul><p>當透過 Angular CLI 建立服務元件時，預設都會自動加入 <code>@Injectable()</code> ，建議還是不要把它胡亂移除比較好。</p><blockquote><p>於是 HttpClient 服務元件就注入完成了！</p></blockquote><h2 id="如何使用-HttpClient-服務元件"><a href="#如何使用-HttpClient-服務元件" class="headerlink" title="如何使用 HttpClient 服務元件"></a>如何使用 HttpClient 服務元件</h2><p>目前文章資料都是寫死的，可以透過 HttpClient 服務元件當中的 get() 方法，動態的取得伺服器上的文章資料。</p><p>詳細的 http.get() 方法可以參考<a href="https://angular.cn/api/common/http/HttpClient#get" rel="external nofollow noopener noreferrer" target="_blank">官網</a></p><p>而這邊要注意的是 Ajax 的操作在瀏覽器內是非同步的，因此沒辦法在建構式內直接回傳取得的結果</p><ul><li>在 Angular 內則是透過 Rxjs 幫忙訂閱 http.get() 資料的結果<ul><li>而這個 .get() 的資料類型是 Observable 物件 (觀察者物件)<ul><li>所有的 Observable 物件都必須透過 .subscribe() 方法來訂閱結果<br>關於 HttpClient 使用方式可以參考這篇 - <a href="https://ithelp.ithome.com.tw/articles/10195344" rel="external nofollow noopener noreferrer" target="_blank">HttpClient 功能介紹</a></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  atticleData;</span><br><span class="line">  <span class="keyword">constructor</span>(private httpClient: HttpClient) &#123;</span><br><span class="line">    httpClient.get(<span class="string">'http://localhost:4200/api/articles.json'</span>).subscribe(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      <span class="keyword">this</span>.atticleData = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (post.id === item.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/9a4gS98.png" alt></p><p>透過 HttpClient 服務元件，正確的接收到資料了！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      之前介紹服務元件的時候就已經看過 @Injectable() 但那個時候並沒有詳加著墨介紹，究竟 @Injectable() 是什麼意思呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.34 透過服務元件重構現有的元件程式碼</title>
    <link href="http://pvt5r486.github.io/f2e/20190602/1279142451/"/>
    <id>http://pvt5r486.github.io/f2e/20190602/1279142451/</id>
    <published>2019-06-02T03:12:16.000Z</published>
    <updated>2019-06-09T05:29:51.463Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>呈上篇，在掌握如何使用服務元件並且透過 DI 將其注入元件中使用後，緊接著我們就可以利用此技巧將原本元件內的邏輯抽出進行重構了。</p><h2 id="判斷服務元件的範圍"><a href="#判斷服務元件的範圍" class="headerlink" title="判斷服務元件的範圍"></a>判斷服務元件的範圍</h2><p>在這個例子中 Data Service 只會用在 ArticleModule ，所以最好是把 data.service 的兩隻檔案都搬進去模組資料夾內，比較方便管理。</p><blockquote><p>但是現在的情況下並不能直接移動，因為這個服務很可能在不同地方被引用了，一旦移動位置就必須跟著改其他地方。</p></blockquote><p>做法有二：</p><ul><li>在建立服務元件時就必須確定這個服務元件要被放在哪個模組下，這樣就 OK 了</li><li>或者使用 <a href="https://marketplace.visualstudio.com/items?itemName=stringham.move-ts" rel="external nofollow noopener noreferrer" target="_blank">Move TS</a> 這個 VS Code 上的插件，協助移動 TS 檔案</li></ul><blockquote><p>現在這個情況就使用 Move TS 來處理吧！</p></blockquote><p>如果已經裝好了這個插件，那麼在移動 TS 檔案的時候，這個插件就會自動地幫我們把所有參考到這個檔案的 TypeScript 檔一併修改路徑，讓我們測試看看。</p><p><img src="https://i.imgur.com/A8tWHhB.png" alt="移動前"></p><ul><li>對著要移動的檔案點右鍵，使用 Move TS 來搬運檔案<br><img src="https://i.imgur.com/yh2N2Yu.png" alt></li></ul><p><img src="https://i.imgur.com/oURgnhK.png" alt="輸入指定資料夾"></p><p><img src="https://i.imgur.com/2VipsQi.png" alt="搬運成功"></p><p><img src="https://i.imgur.com/kM6ERvu.png" alt="移動後"></p><h2 id="搬運並重構程式碼"><a href="#搬運並重構程式碼" class="headerlink" title="搬運並重構程式碼"></a>搬運並重構程式碼</h2><p>接著開始搬運 ArticleList 的部分程式碼包含資料與邏輯的部分，都搬進 Data Service 。</p><h3 id="Data-Service"><a href="#Data-Service" class="headerlink" title="Data Service"></a>Data Service</h3><ul><li>把 doDelete() 、 doChange() 搬出去<ul><li>但搬運到服務元件內之後，此時方法的命名就沒這麼好了，因此也需要調整</li></ul></li><li>搬運文章的資料並建立屬性 <code>articleData</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="comment">/* tslint:disable */</span></span><br><span class="line">    <span class="keyword">this</span>.atticleData = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">        <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">        <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">        <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//...以下省略...</span></span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doDelete(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">  &#125;</span><br><span class="line">  doModify(post: any)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(post.id === item.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣 Data Service 的部分算是處理好了，接下來回到 ArticleList 。</p><h3 id="ArticleList"><a href="#ArticleList" class="headerlink" title="ArticleList"></a>ArticleList</h3><ul><li>由於我們先前在測試時已經時做了相依注入<ul><li>所以在建構式執行完之後會得到一個 Data Service 物件的實體<ul><li>而且存在 <code>datasvc</code> 這個屬性裡面，因此可以從這取得原本文章的資料維持畫面的呈現。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>(private datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.datasvc.atticleData;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter++;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程式碼都搬運了，自然 Template 的部分也需要做調整：</p><ul><li>因為 doDelete() 以及 doModify() 已經被轉移到 Data Service ，所以必須做調整<ul><li>使用 <code>datasvc</code> 屬性即可取用服務元件下的方法<ul><li>特別注意如果前面冠有 <code>private</code> 是無法在 Template 內取用的，要改成 <code>public</code><ul><li>因此將其修正為 <code>public</code></li></ul></li></ul></li></ul></li></ul><p><strong>修正後即可順利取用方法</strong></p><p><img src="https://i.imgur.com/38OPit9.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"datasvc.doDelete($event)"</span> (<span class="attr">changeTitle</span>)=<span class="string">"datasvc.doModify($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span> [<span class="attr">counter</span>]=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="測試運行"><a href="#測試運行" class="headerlink" title="測試運行"></a>測試運行</h3><p>迫不及待地馬上測試看看！</p><p>然後會發現完全沒有效果。</p><p><strong>為什麼？明明 console.log 也沒有錯誤訊息？</strong><br><img src="https://i.imgur.com/qAbIImL.png" alt></p><p>問題在於，在 JavaScript 中有個非常重要的語言特性是:</p><ul><li>所有的屬性、變數物件參考到的永遠是物件的本身</li></ul><p>什麼意思呢？ 先來看看服務元件內 doModify() 的寫法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doModify(post: any)&#123;</span><br><span class="line">  <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(post.id === item.id) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, post);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是 <code>this.atticleData</code> 透過 map() 被賦值一個全新的物件</p><ul><li>所以每一次進行 doModify() 時所得到的 <code>atticleData</code> 值都是一個全新的物件</li></ul><p>但是第一次進行相依注入時， ArticleList 元件內的 ngOnInit() 我們是這麼寫的：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit() &#123;</span><br><span class="line">  <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.datasvc.atticleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>就是把 <code>this.datasvc.atticleData</code> 所指向的物件參考傳給了 <code>atticleData</code> 這個屬性</p></blockquote><p><strong>所以當服務元件 DataService 內重新又建立一個元件時，這裡的 ngOnInit() 可不會重新又執行一次，也就是說我們在 DataService 上做的任何修改 ArticleList 完全看不到。</strong></p><h2 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h2><p>既然方法可以直接從服務元件內取用，那麼資料想必也是可以的。</p><p>所以我們修改 ArticleList 的 Template<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of datasvc.atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"datasvc.doDelete($event)"</span> (<span class="attr">changeTitle</span>)=<span class="string">"datasvc.doModify($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span> [<span class="attr">counter</span>]=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>因為改用 <code>datasvc.atticleData</code> 所以可以刪除 class 內不再用到的 <code>atticleData</code> 屬性</p><ul><li>因為資料的來源就是由服務元件提供，自然就不需要寫 <code>this.atticleData = this.datasvc.atticleData;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(public datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter++;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>於是現在這個 ArticleList 元件的 class 基本上快被搬光了，只剩下一個服務元件 Data Service 的注入，所有的邏輯都在服務元件上，而 Template 是直接取用服務元件上的資料以及邏輯。</p></blockquote><p><strong>再次進行測試</strong><br><img src="https://i.imgur.com/aFQWq2n.png" alt="編輯成功"></p><p><img src="https://i.imgur.com/zKBwXew.png" alt="刪除成功"></p><p>大功告成！</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>實作完成後發現服務元件蠻吃 JavaScript 觀念，如果基礎沒有打穩，當發生這個 Bug 時肯定找不到問題，更別說這個問題連開發者工具都沒顯示錯誤，若基礎不穩肯定不知道發生什麼事了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      呈上篇，在掌握如何使用服務元件並且透過 DI 將其注入元件中使用後，緊接著我們就可以利用此技巧將原本元件內的邏輯抽出進行重構了。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.33 建立 Angular 服務元件與實作相依注入</title>
    <link href="http://pvt5r486.github.io/f2e/20190602/3971501155/"/>
    <id>http://pvt5r486.github.io/f2e/20190602/3971501155/</id>
    <published>2019-06-02T01:16:54.000Z</published>
    <updated>2019-06-09T05:29:55.904Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到目前為止大部分的程式碼都放在 ArticleModule ，而這個 Module 內包含三個元件，其中 ArticleList 是父元件 ； ArticleHeader 與 ArticleBody 為子元件。大部分的程式邏輯與資料全部都放在 ArticleList 內，那麼我們要如何利用服務元件來協助處理這部分呢？</p><p><img src="https://images.unsplash.com/photo-1559373753-acae56e06ae3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="服務元件"><a href="#服務元件" class="headerlink" title="服務元件"></a>服務元件</h2><p>服務元件是一個類別，而類別內只有兩種東西</p><ul><li>屬性</li><li>方法</li></ul><blockquote><p>既然類別內只有這兩種東西，此時就可以想著該把什麼東西給獨立抽離使其變成服務元件。</p></blockquote><p><strong>以 ArticleList 元件為例</strong><br>在設計元件的時候，通常會把相關的資料或邏輯放在同一的元件做管理。</p><p>而這個元件的 OnInit() 內放有文章的初始化資料內容，因此：</p><ul><li>可以把這些資料與資料處理邏輯抽離，建立一個 Data Service 的服務元件</li></ul><h2 id="建立一個服務元件-Data-Service"><a href="#建立一個服務元件-Data-Service" class="headerlink" title="建立一個服務元件 - Data Service"></a>建立一個服務元件 - Data Service</h2><p>建立的方式同樣透過 Angular CLI 指令，以下則一即可：</p><ul><li><code>ng generate service 名稱</code></li><li><code>ng g s data 名稱</code></li></ul><p><img src="https://i.imgur.com/yBzbeXI.png" alt="建立成功"></p><blockquote><p>此時會發現專案內多了兩支檔案，單元測試檔及服務元件主要的程式碼。</p></blockquote><p><strong>data.service.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這樣的程式碼結構是不是跟之前建立元件時看到的很相似呢？</p><h2 id="註冊-Data-Service"><a href="#註冊-Data-Service" class="headerlink" title="註冊 Data Service"></a>註冊 Data Service</h2><p>建立好 Data Service 後，接著還需要將其註冊進模組 (Module) 內才可以使用。</p><p>目前有兩個模組，分別是 AppModule 以及 ArticleModule</p><ul><li>要選擇的是 ArticleModule ，因為我們是要幫這個模組建立服務元件</li></ul><p>如果要將服務元件註冊進模組內，必須：</p><ul><li>加入一個 providers 屬性，值為陣列型別<ul><li>這樣就可以放入多個服務的提供者，如<ul><li><code>providers: [DataService]</code></li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/lReyqnj.png" alt></p><p><img src="https://i.imgur.com/oZspiFs.png" alt></p><p><strong>article.module</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ArticleListComponent &#125; <span class="keyword">from</span> <span class="string">'./article-list/article-list.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ArticleHeaderComponent &#125; <span class="keyword">from</span> <span class="string">'./article-header/article-header.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ArticleBodyComponent &#125; <span class="keyword">from</span> <span class="string">'./article-body/article-body.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'../data.service'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [ArticleListComponent, ArticleHeaderComponent, ArticleBodyComponent],</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [DataService],</span><br><span class="line">  exports: [ArticleListComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p>這樣子服務元件就註冊完成了！</p><p><strong>而任何一種元件內都可以透過相依注入 (DI) ，把服務元件取出來使用。</strong></p><h2 id="測試-Data-Service"><a href="#測試-Data-Service" class="headerlink" title="測試 Data Service"></a>測試 Data Service</h2><p>目前 Data Service 的確沒有任何程式碼在裡面，但我們可以做個小測試驗證一下。</p><h3 id="準備-Data-Service-內的程式碼"><a href="#準備-Data-Service-內的程式碼" class="headerlink" title="準備 Data Service 內的程式碼"></a>準備 Data Service 內的程式碼</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DataService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DataService!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="將服務注入到元件內"><a href="#將服務注入到元件內" class="headerlink" title="將服務注入到元件內"></a>將服務注入到元件內</h3><p>接著使用相依注入，注入到 ArticleList 內。</p><p>如何進行相依注入：</p><ul><li>宣告一個 <code>dService</code> 屬性，並且利用 TypeScript 宣告型別為 DataService<ul><li>不一定會叫做 DataServie ，是根據剛才建立的服務名稱不同也會改變</li></ul></li><li>在元件的 constructor () 內宣告一個參數 <code>datasvc</code> ，並且利用 TypeScript 宣告型別為 DataService<ul><li>當我們透過建構式成功注入時，將 <code>dService</code> 屬性值給定 <code>datasvc</code> 參數</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'src/app/data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  dService: DataService;</span><br><span class="line">  <span class="keyword">constructor</span>(datasvc: DataService) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dService = datasvc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...以下省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次做相依注入的同時 Angular 會自動的 <code>new</code> 出 DataService 的 <code>class</code> ，所以參數 <code>datasvc</code> 得到的其實是一個<strong>物件的實體</strong>。</p><blockquote><p>而不管有幾個 Component 要注入相同的元件，在預設的情況下 Angular 只會 <code>new</code> 一次，也就是最終只會得到一個唯一的物件實體。</p></blockquote><p>如此一來不管是在任何的 Component 內，只要是相同的服務元件，就可以確保得到的物件是<strong>唯一</strong>的，因此可以更輕易的在不同元件間共享一些必要的資料。</p><h3 id="將服務注入到元件內-利用-TypeScript"><a href="#將服務注入到元件內-利用-TypeScript" class="headerlink" title="將服務注入到元件內 - 利用 TypeScript"></a>將服務注入到元件內 - 利用 TypeScript</h3><p>透過 TypeScript 有效的簡化使用相依注入時的語法</p><ul><li>在建構式傳入的參數前面加上 <code>public</code> 或 <code>private</code><ul><li>加上之後 TypeScript 預設會在 ArticleList 這個元件的類別自動宣告一個 DataServie 型別的屬性</li></ul></li><li>也就是說屬性不再需要自己額外宣告了，只需要宣告建構式內的參數即可。</li><li>也不再需要將注入成功的值賦予給屬性</li></ul><p>修改如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">'src/app/data.service'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(private datasvc: DataService) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...以下省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>修改後一行就搞定了～而且完全等價於剛剛三行的寫法。</p></blockquote><p>所以未來再進行其他的相依注入時，只是要適當地在建構式參數前面加上 <code>public</code> 或 <code>private</code> ，後面再透過 TypeScript 的型別標註，就可以快速完成 DI 。</p><h3 id="如何在元件內使用注入的服務元件"><a href="#如何在元件內使用注入的服務元件" class="headerlink" title="如何在元件內使用注入的服務元件"></a>如何在元件內使用注入的服務元件</h3><p>以 ngOnInit() 為例：</p><ul><li>直接調用剛才傳入建構式的參數名 (此時是 DataService 物件)，可以印出觀察</li><li>因為是物件，可以使用 . 運算子執行裡面的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.datasvc);</span><br><span class="line">  <span class="keyword">this</span>.datasvc.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最後，看看結果是否如我們預期吧！</strong></p><p><img src="https://i.imgur.com/AwjaUNd.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本篇介紹了如何建立服務元件以及注入到其他元件內，下一篇我們要使用這個技巧替 ArticleList 進行重構。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      到目前為止大部分的程式碼都放在 ArticleModule ，而這個 Module 內包含三個元件，其中 ArticleList 是父元件 ； ArticleHeader 與 ArticleBody 為子元件。大部分的程式邏輯與資料全部都放在 ArticleList 內，那麼我們要如何利用服務元件來協助處理這部分呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.32 介紹 ngOnChanges 生命週期 Hook</title>
    <link href="http://pvt5r486.github.io/f2e/20190601/3408173890/"/>
    <id>http://pvt5r486.github.io/f2e/20190601/3408173890/</id>
    <published>2019-06-01T04:06:46.000Z</published>
    <updated>2019-06-09T05:30:00.639Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前曾經介紹到 Angular 元件生命週期的 Hook分別是 ngOnInit 與 ngOnDestroy ，在那篇文章內曾經說過元件被實體化的過程，第一個先執行的是建構式 constructor ，也提到盡量不要再建構式裡面寫程式碼。這次要介紹的式另一個生命週期的 Hook - ngOnChanges 。</p><p><img src="https://images.unsplash.com/photo-1557739820-f55c4bd03537?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="ngOnChanges-、-constructor-、-ngOnInit"><a href="#ngOnChanges-、-constructor-、-ngOnInit" class="headerlink" title="ngOnChanges() 、 constructor() 、 ngOnInit()"></a>ngOnChanges() 、 constructor() 、 ngOnInit()</h2><p>在介紹之前，來一張元件生命週期的圖表：</p><p><img src="https://i.imgur.com/eMUPWsS.png" alt></p><p>ngOnChanges() 與 constructor() 、 ngOnInit() 之間的執行順序是如何，可以很容易地從這張圖表上看出來。</p><p>但秉持著實踐精神，我們還是實際寫一些程式測試看看～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, OnChanges &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-body'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-body.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-body.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleBodyComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnChanges</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ArticleBodyComponent: constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ArticleBodyComponent: ngOnInit'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnChanges() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ArticleBodyComponent: ngOnChanges'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因為有跑 ngFor 而文章資料總共有 6 筆，因此產生 6 個 ArticleBody 元件。</p><p><img src="https://i.imgur.com/C0ZVl6K.png" alt></p><ul><li>可以從這裡觀察出無論如何一定會先執行 constructor() ，但執行過程中元件還沒被初始化。<ul><li>此時元件內什麼東西都沒有，也沒有透過屬性繫結傳進來的資料。</li></ul></li><li>緊接著執行 ngOnChanges() 然後才是 ngOnInit()</li></ul><p>這就是它們的執行順序。</p><h2 id="什麼是-ngOnChanges"><a href="#什麼是-ngOnChanges" class="headerlink" title="什麼是 ngOnChanges()"></a>什麼是 ngOnChanges()</h2><p>ngOnChanges() 觸發的時機點</p><ul><li>元件裡面的屬性如果有套用 @input() ，只要該元件的父元件透過屬性繫結傳資料進來的話， ngOnChanges() 就會被觸發</li></ul><h3 id="驗證-ngOnChanges-觸發的時機點"><a href="#驗證-ngOnChanges-觸發的時機點" class="headerlink" title="驗證 ngOnChanges() 觸發的時機點"></a>驗證 ngOnChanges() 觸發的時機點</h3><ul><li>在 ArticleBody 元件內新增一個屬性 <code>counter</code><ul><li><code>counter</code> 值會從父元件透過屬性繫結傳入</li><li>當 <code>counter</code> 發生改變時 ngOnChanges() 就會觸發，由此驗證</li></ul></li></ul><p><strong>ArticleBody</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleBodyComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnChanges</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Input()</span><br><span class="line">  counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ArticleBodyComponent: constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ArticleBodyComponent <span class="subst">$&#123;<span class="keyword">this</span>.item.id&#125;</span> : ngOnInit`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnChanges() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ArticleBodyComponent <span class="subst">$&#123;<span class="keyword">this</span>.item.id&#125;</span> : ngOnChanges`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"doDelete($event)"</span> (<span class="attr">changeTitle</span>)=<span class="string">"doChange($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span> [<span class="attr">counter</span>]=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>ArticleList</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter++;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>為了方便所以補上 <code>item.id</code> ，接著運行開發伺服器，觀察 <code>console.log</code> 變化：</p><p><img src="https://i.imgur.com/b6UurMk.png" alt="重新整理"></p><p><img src="https://i.imgur.com/80PGWhX.png" alt="兩秒後"></p><p><strong>由此可知，在兩秒後六個不同的 ArticleBody 元件都觸發了 ngOnChanges()</strong> ，證明了只有在屬性繫結傳入資料發生改變時才會觸發 ngOnChanges() 。</p><h3 id="ngOnChanges-參數的作用"><a href="#ngOnChanges-參數的作用" class="headerlink" title="ngOnChanges() 參數的作用"></a>ngOnChanges() 參數的作用</h3><p>另外 ngOnChanges() 可以傳入一個參數，比較傳入前與傳入後的資料：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngOnChanges(changes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`ArticleBodyComponent <span class="subst">$&#123;<span class="keyword">this</span>.item.id&#125;</span> : ngOnChanges`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(changes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/KAvpajv.png" alt></p><p>發現這個 <code>changes</code> 接收到一個叫物件，點開後會發現裡面還有一層以 <code>counter</code> 屬性命名的物件：</p><ul><li>該物件的型別為 SimpleChange</li><li>代表當前值為多少的屬性 <code>currentValue</code></li><li>代表前一個值為多少的屬性 <code>previousValue</code></li><li><code>firstChange</code> 是不是第一次發生改變<ul><li>目前已經是第二次改變了，所以是 <code>false</code></li><li>第一次改變發生於重新整理時那一次的 ngOnChanges()</li></ul></li></ul><blockquote><p>透過這個例子得知可以利用這個參數在觸發 ngOnChanges() 時多做一些額外的判斷。</p></blockquote><h2 id="ngOnChanges-實務應用"><a href="#ngOnChanges-實務應用" class="headerlink" title="ngOnChanges() 實務應用"></a>ngOnChanges() 實務應用</h2><p>前面幾篇文章提到，建議不要在子元件上直接使用雙向繫結修改傳入的資料，因為這樣會直接的修改到原始資料。</p><p>但現在我們懂得使用 ngOnChanges() 這個 Hook ，因此可以針對這個部分對整個程式碼進行重構。</p><h3 id="ActicleHeader"><a href="#ActicleHeader" class="headerlink" title="ActicleHeader"></a>ActicleHeader</h3><p>切回 ActicleHeader 元件觀察：</p><ul><li>目前有一個 <code>@input()</code> 綁定了 <code>item</code> 屬性<ul><li>所以當接到 <code>item</code> 資料時 ngOnChanges() 會被觸發</li></ul></li><li>透過 <code>ngOnChanges(changes)</code> ，當接收到值時建立一份與原始資料不同的新物件<ul><li>如此一來就可以放心地使用雙向繫結，也不怕修改到原始資料</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter, OnChanges&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnChanges</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  changeTitle = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  isEdit = <span class="literal">false</span>;</span><br><span class="line">  newTitle = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.newTitle = <span class="keyword">this</span>.item.title;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnChanges(changes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changes.item) &#123;</span><br><span class="line">      <span class="keyword">this</span>.item = <span class="built_in">Object</span>.assign(&#123;&#125;, changes.item.currenValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteArticle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  editTitle(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editTitle'</span>, e.target);</span><br><span class="line">    <span class="keyword">this</span>.newTitle = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.changeTitle.emit(&#123; <span class="attr">title</span>: <span class="keyword">this</span>.newTitle, <span class="attr">id</span>: <span class="keyword">this</span>.item.id &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  editExit(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editExit'</span>, e.target);</span><br><span class="line">    e.target.value = <span class="keyword">this</span>.item.title;</span><br><span class="line">    <span class="keyword">this</span>.isEdit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著修改 Template</p><ul><li>在 Input 內補上雙向繫結<ul><li>因為改為使用雙向繫結 <code>editTitle()</code> 與 <code>editExit()</code> 不再需要傳入 <code>$event</code> 參數</li></ul></li><li>調整取消編輯上的點擊事件，當點擊時觸發 <code>editExit()</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"70"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"item.title"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keyup.enter</span>)=<span class="string">"editTitle()"</span> (<span class="attr">keyup.escape</span>)=<span class="string">"editExit()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=true"</span>&gt;</span>編輯標題<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=false"</span>&gt;</span>取消編輯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因為調整了 Template ，所以 class 內的方法也需要跟著調整。</p><p>邏輯部分</p><ul><li>新增了一個屬性 <code>originData</code> 用途是保存原始傳入的資料，用於取消編輯時使用<ul><li>並於 ngOnChanges() 觸發時將原始資料賦值給 <code>originData</code><ul><li>特別注意這裡不可以寫 <code>this.originData = this.item;</code> 因為此時還沒有 <code>item</code></li></ul></li></ul></li><li>刪除不再需要的屬性 <code>newTitle</code></li><li>調整 <code>editTitle()</code> ，此時發射的 <code>this.item</code> 已經不是原始資料了</li><li>調整 <code>editExit()</code> ，實作不可變物件特性，使用原始資料重新建立新物件還原</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter, OnChanges&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnChanges</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  changeTitle = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line">  originData;</span><br><span class="line">  isEdit = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnChanges(changes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changes.item) &#123;</span><br><span class="line">      <span class="keyword">this</span>.originData = changes.item.currentValue;</span><br><span class="line">      <span class="keyword">this</span>.item = <span class="built_in">Object</span>.assign(&#123;&#125;, changes.item.currentValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteArticle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  editTitle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.changeTitle.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  editExit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.originData);</span><br><span class="line">    <span class="keyword">this</span>.isEdit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>現在 ArticleHeader 這個元件邏輯已經完成，可以測試一下。</strong></p><p><img src="https://i.imgur.com/w0oJckd.png" alt="編輯成功"></p><p><img src="https://i.imgur.com/PoQ8LqM.png" alt="編輯中"></p><p><img src="https://i.imgur.com/h1gvitC.png" alt="取消編輯"></p><ul><li>倘若這個步驟沒辦法完成，可能是雙向繫結出了問題<ul><li>應檢查是否有在 Article 功能模組內匯入 <code>FormsModule</code> ，需匯入才可在 input 上使用雙向繫結</li></ul></li></ul><blockquote><p>至此程式的運作都如預期，唯獨刪除功能出狀況了，所以我們到 ArticleList 父元件調整一下程式碼。</p></blockquote><h3 id="ArticleList"><a href="#ArticleList" class="headerlink" title="ArticleList"></a>ArticleList</h3><ul><li>造成刪除失敗的原因是，現在的 item 物件已經不是原本的 item 物件了<ul><li>而任意兩個物件在 JavaScript 中相比都是 False ，因此刪除導致失敗</li><li>修正方法為改採 <code>item.id</code> 比較即可</li></ul></li></ul><p>因此程式碼修改如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doDelete(item)&#123;</span><br><span class="line">  <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== item.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>測試看看是否如我們預期。</p><p><img src="https://i.imgur.com/qeWNmVM.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 ngOnChanges() 的特性在屬性繫結的階段時，讓 <code>item</code> 屬性變成是一個「不可變的物件」，因為只是有任何新的資料進來，馬上就會重新產生新的物件，並且賦值給 <code>item</code> ，藉由這種方式讓 <code>item</code> 值與原本傳進子物件的 <code>item</code> 值得以脫鉤。</p><p>脫鉤後就可以在 Template 內放心地使用雙向繫結而不會影響到父物件內的原始資料，這麼做也確保了修改 <code>item</code> 屬性時不會一併的修改到其他元件內 <code>item</code> 屬性的內容。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      之前曾經介紹到 Angular 元件生命週期的 Hook 分別是 ngOnInit 與 ngOnDestroy ，在那篇文章內曾經說過元件被實體化的過程，第一個先執行的是建構式 constructor ，也提到盡量不要再建構式裡面寫程式碼。這次要介紹的是另一個生命週期的 Hook- ngOnChanges 。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.31 實作單向資料流與不可變的物件</title>
    <link href="http://pvt5r486.github.io/f2e/20190531/736106338/"/>
    <id>http://pvt5r486.github.io/f2e/20190531/736106338/</id>
    <published>2019-05-31T12:40:52.000Z</published>
    <updated>2019-06-09T05:30:04.894Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇解釋了什麼是單向資料流以及不可變的物件，這一篇要透過實作來了解。</p><p><img src="https://images.unsplash.com/photo-1559163232-cf9427758ee6?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>我想要實作一個修改文章標題的功能</p><ul><li>在 ArticleHeader 內新增一個按鈕叫做編輯標題<ul><li>按下後標題顯示輸入框供使用者輸入新標題，按下 Enter 確定修改；按下 ESC 則退出</li></ul></li></ul><p>了解需求後立馬動手吧～</p><h2 id="先從-UI-開始"><a href="#先從-UI-開始" class="headerlink" title="先從 UI 開始"></a>先從 UI 開始</h2><p>因為這個需求所以要調整 ArticleHeader 元件下的 Template 以及 class ，順便移除掉一些不相干的東西讓這個範例看起來更單純。</p><h3 id="ArticleHeader-Template-的調整"><a href="#ArticleHeader-Template-的調整" class="headerlink" title="ArticleHeader Template 的調整"></a>ArticleHeader Template 的調整</h3><ul><li>新增編輯標題按鈕、取消編輯按鈕並加上點擊事件</li><li>把之前的 PipeComponent 給取消</li><li>重新調整一下文章的資料格式，讓範例更簡單易懂<ul><li>把 <code>subject</code> 那一層拿掉、刪除 <code>subtitle</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"70"</span> [<span class="attr">value</span>]=<span class="string">"item.title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">""</span>&gt;</span>編輯標題<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">""</span>&gt;</span>取消編輯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>現在網頁呈現的畫面是這樣的：</p><p><img src="https://i.imgur.com/XY4RgNv.png" alt></p><p>邏輯是這樣的：</p><ul><li>使用結構型指令 ngIf 控制標題與輸入框以及編輯與取消按鈕的顯示</li><li>當使用者點擊編輯標題按鈕時修改 <code>isEdit</code> 的值為 <code>True</code> 、點擊取消編輯按鈕時 <code>isEdit</code> 的值為 <code>False</code></li></ul><blockquote><p>為了做到這些事情，所以必須先到 ArticleHeader class 進行調整</p></blockquote><h3 id="ArticleHeader-class-的調整"><a href="#ArticleHeader-class-的調整" class="headerlink" title="ArticleHeader class 的調整"></a>ArticleHeader class 的調整</h3><p>這裡需要做的調整如下：</p><ul><li>新增屬性　<code>isEdit</code> 用來判斷是不是處於編輯模式，預設為 <code>False</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  isEdit = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回到 Template 補上 ngIf</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"70"</span> [<span class="attr">value</span>]=<span class="string">"item.title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=true"</span>&gt;</span>編輯標題<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=false"</span>&gt;</span>取消編輯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>測試一下目前的邏輯是否正確</strong></p><p><img src="https://i.imgur.com/MKSogOE.png" alt="非編輯模式"></p><p><img src="https://i.imgur.com/vRK5l1Q.png" alt="編輯模式"></p><h2 id="實作編輯文章標題"><a href="#實作編輯文章標題" class="headerlink" title="實作編輯文章標題"></a>實作編輯文章標題</h2><p>這邊有個一個簡單但不太建議的做法：</p><ul><li>直接在 input 上使用雙向繫結綁定 <code>item.title</code></li></ul><blockquote><p>這麼做會直接把修改的內容直接寫回去，而需求瞬間就完成了。</p></blockquote><p><strong>但伴隨而來的缺點是</strong></p><ul><li>會讓子元件與父元件間相依性太重</li><li>因為是雙向繫結，一但修改後是沒辦法透過取消編輯取消的，會直接修改到原始的資料。</li></ul><blockquote><p>所以這個做法肯定是不太行的，得換個方式。</p></blockquote><p><strong>比較好的方式</strong> - 透過單向資料流與不可變的物件方式</p><ul><li>在 ArticleHeader Template 的 input 上建立二個 Keyup 事件，並傳入參數 <code>$event</code><ul><li>當使用者按下 Enter 時觸發 <code>editTitle</code> 方法</li><li>當使用者按下 ESC 時觸發 <code>exitEdit</code> 方法</li></ul></li><li>在 ArticleHeader class 內建立一個屬性值 <code>newTitle</code></li><li>進行 <code>ngOnInit()</code> 時將 <code>newTitle</code> 賦值為 <code>item.title</code></li><li>input 上使用屬性繫結 value 的值改用 <code>newTitle</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"70"</span> [<span class="attr">value</span>]=<span class="string">"newTitle"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keyup.enter</span>)=<span class="string">"editTitle($event)"</span> (<span class="attr">keyup.escape</span>)=<span class="string">"editExit($event)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"!isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=true"</span>&gt;</span>編輯標題<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngIf</span>=<span class="string">"isEdit"</span> (<span class="attr">click</span>)=<span class="string">"isEdit=false"</span>&gt;</span>取消編輯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line">  isEdit = <span class="literal">false</span>;</span><br><span class="line">  newTitle = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.newTitle = <span class="keyword">this</span>.item.title;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteArticle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  editTitle(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editTitle'</span>, e.target);</span><br><span class="line">    <span class="keyword">this</span>.newTitle = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line">  editExit(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editExit'</span>, e.target);</span><br><span class="line">    e.target.value = <span class="keyword">this</span>.item.title;</span><br><span class="line">    <span class="keyword">this</span>.isEdit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>當觸發 <code>editTitle</code> 方法時，會將 input 內的 value 值取出並賦值給 <code>newTitle</code> ，等待傳送給父元件</li><li>當觸發 <code>editExit</code> 方法時，將原始資料塞回 input 內的 value</li></ul><p><strong>前置作業都做完了，剩下就是通知父元件 ArticleList 囉！</strong></p><ul><li>建立一個新的 <code>@Output()</code> 並宣告一個 <code>titleChange</code> 的事件</li><li>當觸發 <code>editTitle</code> 方法時，使用 <code>emit</code> 發射要變更的資料給父元件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  changeTitle = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line"></span><br><span class="line">  isEdit = <span class="literal">false</span>;</span><br><span class="line">  newTitle = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.newTitle = <span class="keyword">this</span>.item.title;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteArticle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  editTitle(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editTitle'</span>, e.target);</span><br><span class="line">    <span class="keyword">this</span>.newTitle = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.changeTitle.emit(&#123; <span class="attr">newTitle</span>: <span class="keyword">this</span>.newTitle, <span class="attr">id</span>: <span class="keyword">this</span>.item.id &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  editExit(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'editExit'</span>, e.target);</span><br><span class="line">    e.target.value = <span class="keyword">this</span>.item.title;</span><br><span class="line">    <span class="keyword">this</span>.isEdit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下來就是到父元件上設定接收並做出實際的改變啦～</p></blockquote><ul><li>事件繫結 <code>changeTitle</code> 並且當這個事件被觸發時執行 <code>doChange()</code> 方法，使用 <code>$event</code> 參數接收子元件送來的資料</li></ul><p><strong>ArticleList Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"doDelete($event)"</span> (<span class="attr">changeTitle</span>)=<span class="string">"doChange($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>到了最後這個步驟了，為了讓底下的所有子元件都知道資料物件發生改變，所以 <code>atticleData</code> 屬性指向的陣列要重新建立，而陣列裡面的物件如果裡面的屬性有發生修改，也要重新建立。</p></blockquote><p><strong>ArticleList class</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">/* tslint:disable */</span></span><br><span class="line">    <span class="keyword">this</span>.atticleData = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">        <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">        <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">        <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...以下省略</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">  doDelete(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== item);</span><br><span class="line">  &#125;</span><br><span class="line">  doChange($event: any)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>($event.id === item.id) &#123;</span><br><span class="line">        <span class="comment">// 不要這樣寫 item.title = $event.title;</span></span><br><span class="line">        <span class="comment">// 當屬性被改動時，要建立新的物件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, $event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>為了讓陣列重新建立，使用 ES6 的陣列方法 map ，它會回傳一個新的陣列</li><li>值得注意的是，當進入 if 判斷時，不可以直接寫 <code>item.title = $event.title</code> 這樣就落入之前說的陷阱了<ul><li>正確應該使用 <code>Object.assign</code> 方法，回傳一個新的物件並且合併 <code>item</code> 以及 <code>$event</code><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="external nofollow noopener noreferrer" target="_blank">MDN - Object.assign()</a></li></ul></li></ul></li></ul><blockquote><p>根據 MDN 的解釋，使用 <code>Object.assign</code> 方法時，如果在目標物件裡的屬性名稱 (key) 和來源物件的屬性名稱相同，將會被覆寫。若來源物件之間又有相同的屬性名稱，則後者會將前者覆寫。</p></blockquote><p><strong>都完成了，來測試看看吧！</strong></p><p><img src="https://i.imgur.com/0MpYqhW.png" alt="編輯中"></p><p><img src="https://i.imgur.com/01hAhDu.png" alt="無法順利變更標題"></p><p>糟糕程式好像出了點問題，加上幾行 <code>console.log</code> 觀察看看吧。</p><p><img src="https://i.imgur.com/Za4CO0u.png" alt></p><p><strong>原來問題是沒有正確合併，因位子元件傳送給父元件的資料物件內的屬性名稱要與標題的屬性名稱一致才會覆蓋，因此必須回去修改。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">editTitle(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'editTitle'</span>, e.target);</span><br><span class="line">  <span class="keyword">this</span>.newTitle = e.target.value;</span><br><span class="line">  <span class="keyword">this</span>.changeTitle.emit(&#123; <span class="attr">title</span>: <span class="keyword">this</span>.newTitle, <span class="attr">id</span>: <span class="keyword">this</span>.item.id &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重新測試！</strong></p><p><img src="https://i.imgur.com/kk6Afog.png" alt="修改成功"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這個範例主要是練習實作一個稍微複雜一點的單向資料流與不可變物件特性的開發技巧，透過這個練習未來在開發多個元件時，可以有效降低元件與元件間的相依性也提升可維護性。</p><p>看來有空必須要常常回來這篇文章複習哩～</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇解釋了什麼是單向資料流以及不可變的物件，這一篇要透過實作來了解。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.30 解釋單向資料流與不可變的物件</title>
    <link href="http://pvt5r486.github.io/f2e/20190531/2148310774/"/>
    <id>http://pvt5r486.github.io/f2e/20190531/2148310774/</id>
    <published>2019-05-31T11:42:21.000Z</published>
    <updated>2019-06-09T05:30:09.273Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>單向資料流與不可變的物件，究竟這是什麼意思呢？</p><p><img src="https://images.unsplash.com/photo-1559157865-4982964542a3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="目前架構"><a href="#目前架構" class="headerlink" title="目前架構"></a>目前架構</h2><p>我們目前的專案結構大致如下：</p><p><img src="https://i.imgur.com/PuCHg6s.png" alt></p><ul><li>ArticleList 元件 - 擁有所有的資料，並透過屬性繫結把資料傳給子元件<ul><li>ArticleHeader - 擁有屬性 item ，承接來自父元件的物件資料</li><li>ArticleBody - 擁有屬性 item ，承接來自父元件的物件資料</li></ul></li></ul><h2 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h2><p>假設今天有一個需求是要更改文章標題，最簡單的做法就是直接從 ArticleHeader 動手，修改 item 這個物件的屬性值，這個屬性值只要一改變，父元件 data 下的這些物件值也會跟著改變。</p><blockquote><p>而雖然這個改法很簡單，不過建議最好不要這麼做。</p></blockquote><p>盡量不要在子元件內直接對資料進行任何修改，否則元件間的相依性會太重，當有 Bug 產生時也不容易除錯。</p><p>最好是透過<strong>單向資料流</strong>的方式來達成。</p><h2 id="單向資料流"><a href="#單向資料流" class="headerlink" title="單向資料流"></a>單向資料流</h2><p>單向資料流的意思就是，<strong>所有資料的變更永遠是從上層元件傳給下層元件。</strong></p><p>換句話說，比較好的做法是：</p><ul><li>ArticleHeader 內提供一個編輯的介面，讓使用者設定新的標題</li><li>當確定送出時才把要變更的內容透過事件繫結傳遞給父元件，也就是 ArticleList 元件</li><li>ArticleList 元件做實際物件的操作 (變更資料等等)</li></ul><h2 id="不可變的物件"><a href="#不可變的物件" class="headerlink" title="不可變的物件"></a>不可變的物件</h2><p>JavaScript 物件本身是可變的，所以當物件發生改變時如果希望另一個元件也能知道這個物件發生改變，這在 JavaScript 內非常不容易做到。</p><p>舉例來說，在 ArticleHeader 內修改了 item 物件，那麼 ArticleBody 如何知道 ArticleHeader 內修改了 item 物件的哪個屬性呢？</p><p>要怎麼樣 Angular 這個物件確實發生了改變、讓 ArticleBody 能反映出相對應的資料呢？</p><p><strong>Angular 確實做得到，但是這樣效能會很差。</strong></p><p>像是在 ArticleHeader 新增了一個點擊事件，並且觸發一個 <code>test</code> 方法，執行 <code>item</code> 物件內 <code>summary</code> 屬性值的修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span> (<span class="attr">click</span>)=<span class="string">"test()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject?.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;&#123;item.subject?.subtite&#125;&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteArticle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.item);</span><br><span class="line">    <span class="keyword">this</span>.item.summary = <span class="string">'aaa'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/bU0KI9w.png" alt></p><blockquote><p>點擊後的確影響到 ArticleBody 內的資料了，但是非常不推薦這麼做。</p></blockquote><p><strong>好的作法</strong></p><ul><li>當在 ArticleHeader 修改了 item 物件的內容，應該把修改過的內容往上傳給父元件</li><li>在父元件內找出是哪一筆資料更動，假設是第一筆<ul><li>接著重新建立一個全新的物件、連同陣列的部分也產生新的</li></ul></li></ul><p>而這樣就是所謂的<strong>不可變的物件特性</strong>。</p><p>只要物件不管哪個屬性發生變更，通通都重新產生物件的話，在 Angular 內很容易就可以辨識出那些物件發生了變化。</p><p>舉例來說</p><ul><li>只要陣列變成新的，那麼 ngFor 就會重新渲染</li><li>陣列的其中一個元素的物件是新的，Angular 就會知道這個物件在做資料繫結時要把新的資料渲染到畫面上。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      單向資料流與不可變的物件，究竟這是什麼意思呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.29 定義 Angular 元件的輸出介面 - @Output()</title>
    <link href="http://pvt5r486.github.io/f2e/20190531/3041477683/"/>
    <id>http://pvt5r486.github.io/f2e/20190531/3041477683/</id>
    <published>2019-05-31T07:24:53.000Z</published>
    <updated>2019-06-09T05:30:14.094Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在物件導向程式的領域，有個稱為 OCP ( Open Closed Principle ) 的原則，中文稱為開放封閉原則。這原則說的是，在進行物件導向程式設計時要能符合開放擴充但封閉修改的要素，這樣子才能把每個不同的物件獨立切開、互不干擾。</p><p>這段前言又跟這篇文章有什麼關係呢？</p><p><img src="https://images.unsplash.com/photo-1559149517-3ab947621a90?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="截至目前為止的結構"><a href="#截至目前為止的結構" class="headerlink" title="截至目前為止的結構"></a>截至目前為止的結構</h2><p>可整理出如下列表</p><ul><li>AppModule - 根模組<ul><li>AppComponent<ul><li>ArticleList<ul><li>ArticleHeader</li><li>ArticleBody</li></ul></li></ul></li></ul></li></ul><p>而元件一層包一層的好處是，一次只要關注一個想要修改的地方就好了，不管應用程式多複雜透過元件化的架構，就可以把一份複雜的網頁切割成多個元件，每個元件只單純負責幾件事情就好。</p><h2 id="製作刪除文章的功能"><a href="#製作刪除文章的功能" class="headerlink" title="製作刪除文章的功能"></a>製作刪除文章的功能</h2><p>假使想要實作出刪除文章的按鈕，想要將這個按鈕放在 ArticleHeader 的 Template 內，點擊後能夠將刪除的資訊傳給父元件 ArticleList ，最後達成刪除文章的效果。</p><h3 id="添加刪除按鈕"><a href="#添加刪除按鈕" class="headerlink" title="添加刪除按鈕"></a>添加刪除按鈕</h3><p>首先在 ArticleHeader 的 Template 內做出一顆按鈕。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject?.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;&#123;item.subject?.subtite&#125;&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是這樣是沒辦法刪除的，因為資料是由父元件 ArticleList 傳遞給子元件 ArticleHeader ，子元件本身並不具有這份資料。</p><p><strong>解決辦法是將要刪除哪筆篇文章的資料往上傳遞給父元件，透過父元件刪除該篇文章。</strong></p><p>白話來說，以刪除文章這個功能而言：</p><ul><li>子元件 ArticleHeader 扮演的角色是：<strong>透過點擊事件通知父元件哪一篇文章的刪除按鈕被點擊了。</strong></li><li>接著父元件 ArticleList 接收到訊息後把對應資料刪除，重新透過 ngFor 渲染網頁。</li></ul><h3 id="註冊-ArticleHeader-內的事件"><a href="#註冊-ArticleHeader-內的事件" class="headerlink" title="註冊 ArticleHeader 內的事件"></a>註冊 ArticleHeader 內的事件</h3><p><strong>從父元件傳值給子元件是透過屬性繫結；從子元件傳值給父元件則必須透過事件繫結。</strong></p><p>在 Angular 元件內要註冊一個事件必須先宣告一個屬性，同時宣告一個 <code>@Output</code> 裝飾器，跟之前介紹過的 <code>@Input</code> 一樣。</p><p>首先來到 ArticleHeader 的 <code>class</code> 內進行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>這樣就完成了 delete 事件的註冊，接著要將這個事件繫結到父元件上。</p></blockquote><p><strong>事件的名稱可以自由命名。</strong></p><h3 id="在父元件上繫結-delete-事件"><a href="#在父元件上繫結-delete-事件" class="headerlink" title="在父元件上繫結 delete 事件"></a>在父元件上繫結 delete 事件</h3><p>剛才已經在子元件內註冊了 delete 事件，此時在 ArticleList 內已經可以從自動完成中看到對應的選項。</p><p><img src="https://i.imgur.com/l4Hl1aK.png" alt></p><p>ArticleList 內的 Template<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">"item"</span> (<span class="attr">delete</span>)=<span class="string">"doDelete($event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>當接收到 <code>delete</code> 事件發出的通知時，就會觸發 ArticleList 內的 <code>doDelete()</code> 方法，而且還要讓它傳入一個 <code>$event</code> 參數，這樣才能知道使用者點擊的是哪一篇文章的刪除按鈕。</p></blockquote><h3 id="完成-ArticleHeader-內的-delete-事件"><a href="#完成-ArticleHeader-內的-delete-事件" class="headerlink" title="完成 ArticleHeader 內的 delete 事件"></a>完成 ArticleHeader 內的 delete 事件</h3><p>剛才雖然已經註冊 <code>delete</code> 事件，但還有很多細節尚待處理。</p><ul><li>例如剛才宣告的 <code>delete</code> 屬性需要 new 一個 EventEmitter 物件<ul><li>EventEmitter 是一個事件的發射器。</li><li>EventEmitter 後面可以接 <code>&lt;any&gt;</code> ，代表要傳送的資料可以是任意型別</li></ul></li></ul><p><img src="https://i.imgur.com/S0vTXFQ.png" alt="選擇正確的 EventEmitter"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什麼時候發射 delete 的事件？自然是按下刪除按鈕的時候</strong><br>回到 ArticleHeader 的 Template :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject?.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;&#123;item.subject?.subtite&#125;&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">        [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"deleteArticle()"</span>&gt;</span>刪除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>當點擊按鈕時透過點擊事件，觸發 ArticleHeader 內的 <code>deleteArticle</code> 方法。<br>因此我們必須實作 <code>deleteArticle</code> 方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input, Output, EventEmitter &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line"></span><br><span class="line">  @Output()</span><br><span class="line">  <span class="keyword">delete</span> = <span class="keyword">new</span> EventEmitter&lt;any&gt;();</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteArticle()&#123;</span><br><span class="line">    <span class="keyword">this</span>.delete.emit(<span class="keyword">this</span>.item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當 <code>deleteArticle</code> 方法被觸發時，透過 <code>delete.emit()</code> 這個事件發射器，將 <code>this.item</code> 向父元件射出。</p><p>而父元件上的 <code>$event</code> 接收的資料就會是剛才被射出的 <code>this.item</code> 。</p><h3 id="實作-doDelete-方法"><a href="#實作-doDelete-方法" class="headerlink" title="實作 doDelete 方法"></a>實作 doDelete 方法</h3><p>回到 ArticleList 的 <code>class</code> 內，實作刪除文章。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-list.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-list.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  atticleData: <span class="built_in">Array</span>&lt;any&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">/* tslint:disable */</span></span><br><span class="line">    <span class="keyword">this</span>.atticleData = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">        <span class="string">"subject"</span>: &#123;</span><br><span class="line">          <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">          <span class="string">"subtite"</span>: <span class="string">"Visual Studio Code"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">        <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">        <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">        <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">  doDelete(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.atticleData = <span class="keyword">this</span>.atticleData.filter(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.id !== item.id;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因為 <code>atticleData</code> 屬性並沒有明確的型別，所以使用自動完成並沒有提示可以使用什麼方法，因此手動補上 <code>Array&lt;any&gt;</code> 代表這是一個可以傳入任何資料的陣列。</p><p>最後透過 ES6 的 filter 方法篩選被刪除的文章，達成本次需求。</p><blockquote><p>搞定～測試看看吧！</p></blockquote><p><img src="https://i.imgur.com/Ijsd8NI.png" alt="把文章全刪除了"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>可以很明顯的看出，從子元件將資料傳遞給父元件是要透過比較多道手續的，但整體而言也不難理解，就花點時間好好地記住吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在物件導向程式的領域，有個稱為 OCP ( Open Closed Principle ) 的原則，中文稱為開放封閉原則。這原則說的是，在進行物件導向程式設計時要能符合開放擴充但封閉修改的要素，這樣子才能把每個不同的物件獨立切開、互不干擾。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.28 Angular 的生命週期 Hook - ngOnInit 與 ngOnDestroy</title>
    <link href="http://pvt5r486.github.io/f2e/20190530/3127782962/"/>
    <id>http://pvt5r486.github.io/f2e/20190530/3127782962/</id>
    <published>2019-05-30T11:42:08.000Z</published>
    <updated>2019-06-09T05:30:20.058Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一個 Angular 元件都有自己的生命周期，元件隨時會被建立也有可能隨時被註銷，之前介紹到結構性指令的時候也有稍微提到一些。而這一篇文章主要介紹的是，元件被建立的過程中程式碼運行的順序是如何？</p><p><img src="https://images.unsplash.com/photo-1559163206-6615672fad34?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="元件的生命週期-Hook"><a href="#元件的生命週期-Hook" class="headerlink" title="元件的生命週期 Hook"></a>元件的生命週期 Hook</h2><p>之前在建立元件時，常常會在元件的 class 內看到兩個方法，但是從來沒有使用過。</p><p>分別是：</p><ul><li>constructor(){}</li><li>ngOnInit(){}</li></ul><h3 id="最先執行-建構式-constructor"><a href="#最先執行-建構式-constructor" class="headerlink" title="最先執行 - 建構式 constructor()"></a>最先執行 - 建構式 constructor()</h3><p>constructor 是一個建構式，而建構式會在 class 被建立時，第一時間被執行，換句話說在 Angular 的生命週期裡面，這是第一個執行的程式碼。</p><p>不過幾乎不會寫任何程式在 constructor 內，因為當 constructor 執行時，元件尚未被初始化，所以是接不到任何資料的。</p><p>儘管如此， constructor 還是有特殊的用途，例如拿來做<strong>相依注入 ( DI )</strong></p><h3 id="生命週期-Hook-ngOnInit"><a href="#生命週期-Hook-ngOnInit" class="headerlink" title="生命週期 Hook - ngOnInit()"></a>生命週期 Hook - ngOnInit()</h3><p>從這個名稱來看，應該多少會猜到是 Angular 進行 Init 初始化後會執行的程式碼。</p><p>從 ngOnInit() 開始，該元件的初始化、該元件所有必要的屬性繫結都已經完成。</p><blockquote><p>也就是說可以對目前這個元件做一些初始化的動作。</p></blockquote><p>舉例來說</p><ul><li>設定屬性的預設值</li><li>發出 Ajax 的要求跟伺服器要資料，並把值寫到屬性內，透過屬性繫結呈現在 Template 上</li></ul><blockquote><p>所以這個方法算是蠻常用到的。</p></blockquote><p><strong>當 ngOnInit() 結束後就會正式進入到 Angular 的生命週期，像是進行屬性繫結、事件繫結等等。</strong></p><h3 id="生命週期-Hook-ngOnDestroy"><a href="#生命週期-Hook-ngOnDestroy" class="headerlink" title="生命週期 Hook - ngOnDestroy()"></a>生命週期 Hook - ngOnDestroy()</h3><p>當父元件決定要摧毀目前這個子元件時，這個方法可以讓元件在被摧毀前執行特定的程式碼。</p><p>但是這個 Hook 的使用機會比較少，大部分的情況元件裡面的記憶體通常都會自動回收。</p><p>所以不需要特別地去寫程式處理這一塊，但是在少數的情況下像是搭配 Rxjs 去做一些非同步事件的訂閱，有些時候確實就必須在這個時間點做處理。</p><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>關於元件的生命週期還有很多沒有介紹到，同樣也是可以等用到時在了解即可，在撰寫這篇的過程中也找到一些前輩整理好的資料：</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10203203" rel="external nofollow noopener noreferrer" target="_blank">[Angular 大師之路] Day 04 - 認識 Angular 的生命週期</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10194566" rel="external nofollow noopener noreferrer" target="_blank">[功能介紹-3] Hooks的生命週期</a></li></ul><p><img src="https://i.imgur.com/eMUPWsS.png" alt="Lifecycle Hooks"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      每一個 Angular 元件都有自己的生命周期，元件隨時會被建立也有可能隨時被註銷，之前介紹到結構性指令的時候也有稍微提到一些。而這一篇文章主要介紹的是，元件被建立的過程中程式碼運行的順序是如何？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.27 定義 Angular 元件的輸入介面 - @input()</title>
    <link href="http://pvt5r486.github.io/f2e/20190530/1773530928/"/>
    <id>http://pvt5r486.github.io/f2e/20190530/1773530928/</id>
    <published>2019-05-30T10:47:24.000Z</published>
    <updated>2019-06-09T05:30:24.168Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>承接上一篇文章，目前資料是存放於父元件的，但卻是子元件需要這份資料做輸出，那要如何將父元件的資料傳遞給子元件呢？</p><p><img src="https://images.unsplash.com/photo-1559032806-99a331d600b4?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1498&amp;q=80" alt></p><h2 id="input"><a href="#input" class="headerlink" title="@input()"></a>@input()</h2><p>現在專案內發生的問題就是:</p><ul><li>兩個子元件 ArticleHeader 與 ArticleBody 的 Template 內有使用到 item 變數<ul><li>但是 <code>item</code> 變數並沒有被傳進來，它仍然存在於 ArticleList 內</li></ul></li></ul><p><strong>如何把 <code>item</code> 變數傳入這兩個子元件呢？</strong></p><h3 id="在子元件的-class-內加入-input-裝飾器"><a href="#在子元件的-class-內加入-input-裝飾器" class="headerlink" title="在子元件的 class 內加入 @input() 裝飾器"></a>在子元件的 class 內加入 @input() 裝飾器</h3><p>如同先前提到的，要將父元件的資料傳遞到子元件，必須透過屬性繫結的方式。</p><blockquote><p>意味著子元件必須要有一個屬性可以承接，於是在這邊宣告屬性 item ，並且不賦予任何值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  item;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但這麼做還不夠，因為目前這個 item 只隸屬於 ArticleHeader 元件，在預設的情況下 <code>item</code> 是無法被父元件透過屬性繫結注入資料的。</p><p><strong>還必須加入 @input() 這個 declarator 裝飾器</strong>，並且匯入相依模組才可以使用。</p><p>而這個步驟同樣也有自動完成可以使用，因此修正後如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit, Input &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-article-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./article-header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./article-header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleHeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  @Input()</span><br><span class="line">  item;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>我們必須也在 ArticleBody 的 class 進行相同的操作，就不贅述了。</p></blockquote><p>而經過上述這些步驟可以發現原本的錯誤已經不見了。</p><p>原因是我們已經定義了 <code>item</code> ，但是這樣還不算完成，先看一下目前網頁的狀態。</p><p><img src="https://i.imgur.com/dHqzlMO.png" alt></p><p><strong>可以看到目前是沒有資料傳進來的，還需要做一些處理。</strong></p><h3 id="透過屬性繫結傳入資料"><a href="#透過屬性繫結傳入資料" class="headerlink" title="透過屬性繫結傳入資料"></a>透過屬性繫結傳入資料</h3><p>回到 ArticleList 的 Template 內，並且對兩個子元件加入屬性繫結。</p><p><strong>居然有支援自動完成，太神啦！</strong></p><p><img src="https://i.imgur.com/JtmlJ7D.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-header</span> [<span class="attr">item</span>]=<span class="string">item</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-article-body</span> [<span class="attr">item</span>]=<span class="string">item</span>&gt;</span><span class="tag">&lt;/<span class="name">app-article-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我們就完成了子元件的屬性繫結，中括號 [] 裡面的 <code>item</code> 是剛才在子元件內定義的屬性，而等號後面接的是要傳入的資料也就是區域變數 <code>item</code> 。</p></blockquote><p>來測試看看吧！</p><p><img src="https://i.imgur.com/3qkwND0.png" alt></p><p>至此，我們就完成了一個功能模組的建立，並且這個功能模組內有三個元件，其中父元件為 ArticleList 與它的兩個子元件 ArticleHeader 、 ArticleBody 。</p><p><img src="https://i.imgur.com/pVrmA9I.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Angular 應用程式的架構，就是把網頁變成一個個大大小小的元件，這是屬於元件化的架構。</p><p>在元件化的架構下只要能妥善規劃，在開發、維護、管理層面上複雜度可以大幅地降低。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      承接上一篇文章，目前資料是存放於父元件的，但卻是子元件需要這份資料做輸出，那要如何將父元件的資料傳遞給子元件呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.26 建立 Angular 功能模組</title>
    <link href="http://pvt5r486.github.io/f2e/20190530/2381478941/"/>
    <id>http://pvt5r486.github.io/f2e/20190530/2381478941/</id>
    <published>2019-05-30T07:53:56.000Z</published>
    <updated>2019-06-09T05:30:28.146Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當專案的架構越來越龐大時，此時會將一些較相關的元件與服務元件獨立封裝成一個 Angular 的模組，像這種根據特定功能建立的模組，有時候也被稱為<strong>功能模組 (Feature Module)</strong></p><p><img src="https://images.unsplash.com/photo-1559056427-6fe5ce77f06d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="事前規劃"><a href="#事前規劃" class="headerlink" title="事前規劃"></a>事前規劃</h2><p>假使我想要逐步地將目前部落格版型改成這張圖片上畫的那樣，該怎麼做呢？</p><p><img src="https://i.imgur.com/qRLnhnv.png" alt></p><blockquote><p>目前專案內並沒有 Article 相關的三個元件， ArticleModule 也還沒建立，讓我們一一的完成它吧。</p></blockquote><h2 id="建立-ArticleModule-模組-Feature-Module"><a href="#建立-ArticleModule-模組-Feature-Module" class="headerlink" title="建立 ArticleModule 模組 (Feature Module)"></a>建立 ArticleModule 模組 (Feature Module)</h2><p>我要建立一個 Article 的模組，而這個模組在建立完成後，必須匯入到 AppModule 內，如此一來 Angular 才知道有 ArticleModule 的存在。</p><h3 id="透過-Angular-CLI-建立模組並加入根模組"><a href="#透過-Angular-CLI-建立模組並加入根模組" class="headerlink" title="透過 Angular CLI 建立模組並加入根模組"></a>透過 Angular CLI 建立模組並加入根模組</h3><p>這裡有兩種方式可以建立模組，則一即可：</p><ul><li><code>ng generate Module article</code></li><li><code>ng g m article</code></li></ul><p><strong>模組名稱打小寫就可以了，不用特地加上 Module 字樣</strong></p><p>執行成功後 app 資料夾內會產生一個 article 的資料夾</p><p><img src="https://i.imgur.com/jNME8ll.png" alt><br><img src="https://i.imgur.com/vDY17aw.png" alt></p><p>比較一下 app.module 與 article.module 的內容差異</p><p><strong>app.module</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeaderComponent &#125; <span class="keyword">from</span> <span class="string">'./header/header.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FooterComponent &#125; <span class="keyword">from</span> <span class="string">'./footer/footer.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    HeaderComponent,</span><br><span class="line">    FooterComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>article.module</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [],</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p>app.module 是根模組、 article.module 是功能模組</p><ul><li>article.module 內的 declarations 是空的，因為目前還沒有任何元件</li></ul><p><strong>而下一步則是把 article.module 加入 app.module</strong>，讓 Angular 知道我們新增了功能模組。</p><p>調整如下：<br><img src="https://i.imgur.com/8I5SEx5.png" alt="自動完成"></p><p><img src="https://i.imgur.com/2nhRZAF.png" alt="不費吹灰之力"></p><blockquote><p>這是因為新版的 VS Code 內建 TypeScript 新的版本，而 TypeScript 新版支援 Auto Import 的功能。</p></blockquote><p>存檔後確認有無任何錯誤。</p><p><img src="https://i.imgur.com/4mW7bDU.png" alt></p><p><strong>非常好，沒有任何問題產生！</strong></p><h2 id="其實剛剛做的事情只需要一行就完成"><a href="#其實剛剛做的事情只需要一行就完成" class="headerlink" title="其實剛剛做的事情只需要一行就完成"></a>其實剛剛做的事情只需要一行就完成</h2><p>剛才介紹了如何透過 Angular CLI 建立模組，但其實這些指令後面還可以加入一些參數，例如：</p><ul><li><code>ng generate Module article -m app</code></li><li><code>ng g m article -m app</code></li></ul><blockquote><p><code>-m</code> 後面可以接一個模組名稱，像是上面的指令示範。</p></blockquote><p><strong>這麼做就會使 Angular CLI 建立 article 模組後自動地向 app.module 註冊。</strong></p><p><img src="https://i.imgur.com/vixBlID.png" alt></p><p><img src="https://i.imgur.com/5W8R2ji.png" alt></p><blockquote><p><strong>超棒的功能，不是嗎？</strong></p></blockquote><h2 id="將現有的元件加入功能模組"><a href="#將現有的元件加入功能模組" class="headerlink" title="將現有的元件加入功能模組"></a>將現有的元件加入功能模組</h2><p>目前這個功能模組內是空的，因此要開始拆解部落格內關於 Article 的 HTML 並封裝成元件了。</p><p>將 Article 的 HTML 拆分為以下三個元件：</p><ul><li>ArticleList<ul><li>ArticleHeader</li><li>ArticleBody</li></ul></li></ul><p>最後向 ArticleModule 註冊這些元件。</p><h3 id="ArticleList-元件拆解"><a href="#ArticleList-元件拆解" class="headerlink" title="ArticleList 元件拆解"></a>ArticleList 元件拆解</h3><p>首先將 AppComponent 底下 Article 的部分，全部拆解成一個新的元件 - ArticleList</p><ul><li>輸入 <code>ng g c articleList</code> 建立 ArticleList 元件。</li></ul><p>但此時我們不能直接輸入這道命令，因為預設 Angular CLI 會把元件註冊到 app.module ，但事實上必須將其註冊到 article.module 才正確。</p><p><strong>因此應該先使用 CD 指令，將資料夾切換至 article 資料夾底下</strong></p><p><img src="https://i.imgur.com/X5HpCAz.png" alt></p><p>接著就可以一如往常地建立元件了～</p><p><img src="https://i.imgur.com/ChJehi5.png" alt></p><blockquote><p>而且也會發現元件在 article.module 內被註冊了。</p></blockquote><p><strong>除了在 app.module 內註冊 article.module 外， article.module 也必須匯出元件才行！</strong></p><p>因此修改 article.module<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ArticleListComponent &#125; <span class="keyword">from</span> <span class="string">'./article-list/article-list.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [ArticleListComponent],</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule</span><br><span class="line">  ],</span><br><span class="line">  exports: [ArticleListComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>接著開始搬運 AppComponent 底下 Article 的 HTML</strong></p><ul><li>在 app.component.html 剪下 HTML ，並補上 <code>&lt;app-article-list&gt;</code></li><li>把剪下的 HTML 貼到 article-list.component.html</li><li>之前文章的資料存放於 app.component.ts ，因此也必須移轉到 article-list.component.ts</li></ul><blockquote><p>搞定！執行看看吧～</p></blockquote><p><img src="https://i.imgur.com/oHlKsrc.png" alt></p><h3 id="把剩餘的兩個元件拆完"><a href="#把剩餘的兩個元件拆完" class="headerlink" title="把剩餘的兩個元件拆完"></a>把剩餘的兩個元件拆完</h3><p>跟剛才建立 article-list 元件一樣，必須將目錄切換過去才能開始建立元件，過程就不贅述了。</p><ul><li>輸入指令建立 article-header 、 article-body</li></ul><p><img src="https://i.imgur.com/0FY1nmC.png" alt></p><p><strong>這時我們可能會想要把這些元件給匯出，畢竟記取剛才的教訓嘛～</strong></p><blockquote><p>從外部的角度而言，只需要看到 article-list 元件，並不需要看到 article-header 、 article-body 。<br>因為這兩個子元件是被封裝在 article-list 元件內的，所以僅匯出 article-list 元件即可。</p></blockquote><p>接著就繼續搬動 HTML 囉，過程就不贅述了</p><ul><li>拆分 article-list.component.html 內的 HTML 給<ul><li>article-header.component.html</li><li>article-body.component.html</li></ul></li></ul><p>最後於 article-list.component.html 內補上對應的元件標籤就完成了。</p><p>至此已經將架構大致完成，但細部還需要做調整。</p><p><strong>此時網頁會是壞掉的，因為目前 article 的資料仍停留在 article-list 並未向下傳遞</strong>，</p><p>下一篇將介紹如何把資料往子元件傳遞。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      當專案的架構越來越龐大時，此時會將一些較相關的元件與服務元件獨立封裝成一個 Angular 的模組，像這種根據特定功能建立的模組，有時候也被稱為功能模組 (Feature Module)
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.25 Angular 元件架構</title>
    <link href="http://pvt5r486.github.io/f2e/20190530/3387203766/"/>
    <id>http://pvt5r486.github.io/f2e/20190530/3387203766/</id>
    <published>2019-05-30T07:06:02.000Z</published>
    <updated>2019-06-09T05:30:31.947Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Angular 是採用元件化模組開發的框架，可以想像就是不同大大小小元件堆砌而成的網頁，這樣的情況下元件架構又是如何呢？</p><p><img src="https://images.unsplash.com/photo-1558713089-d1aad46c19bf?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Angular-元件架構"><a href="#Angular-元件架構" class="headerlink" title="Angular 元件架構"></a>Angular 元件架構</h2><p><img src="https://i.imgur.com/Z3wEIRK.png" alt></p><p>從這張圖可以看出完整個的 Angular 應用程式，是由不同的元件所組成。</p><p>最上層的根元件預設名稱為 AppComponent ，而底下可能包含了 Header 元件與 ArticleList 元件。</p><ul><li>而 Header 元件裡面可能只有單純的 HTML 或一些互動</li><li>而元件內可以放入其他元件，如 ArticleList 元件可以在包含其他不同的元件，像是<ul><li>ArticleHeader 元件</li><li>ArticleBody 元件</li></ul></li></ul><p><strong>也就是說在 Angular 的世界，網頁是由一層層的元件所組成。</strong></p><p>而元件跟元件之間就有父子的關係，像是</p><ul><li>ArticleList 元件可以說是 ArticleHeader 、 ArticleBody 的父元件<ul><li>反過來就是 ArticleHeader 、 ArticleBody 元件是 ArticleList 的子元件</li></ul></li></ul><h2 id="元件之間的溝通"><a href="#元件之間的溝通" class="headerlink" title="元件之間的溝通"></a>元件之間的溝通</h2><p>元件與元件之間是可以互相溝通的，例如：</p><ul><li>資料存放於 ArticleList 元件上，而需要把資料往下傳送給子元件 ArticleBody<ul><li>此時會在 ArticleBody 建立一個屬性準備接收資料，因此就能形成屬性繫結的關係</li></ul></li></ul><p>相反的，如果是子元件往父元件溝通呢？</p><ul><li>ArticleHeader 、 ArticleBody 有一個共同的父元件 ArticleList<ul><li>此時可以透過事件繫結的方式來通知父元件<ul><li>具體來說就是會在子元件內寫一些屬性、程式來通知父元件</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/F3XGWYO.png" alt></p><h2 id="服務元件？"><a href="#服務元件？" class="headerlink" title="服務元件？"></a>服務元件？</h2><p>進階的元件與元件的溝通會藉由建立服務元件來達成。</p><p>而服務元件有可能會透過一種稱為<strong>相依注入 ( Dependency Injection ) 簡稱 DI</strong> 的技術，把預先設計好的服務元件直接注入到某個特定得元件內。</p><p><strong>舉例來說，可以透過 DI 技術將某個服務元件注入到 ArticleList 元件內，或者是 ArticleHeader 元件等等。</strong></p><blockquote><p>而服務元件內封裝的就是不同元件之間需要共用的資料、方法等等</p></blockquote><h2 id="模組化"><a href="#模組化" class="headerlink" title="模組化"></a>模組化</h2><p>雖然這個架構看起來相當不錯，當網站越來越大時，通常會將相關的元件像是：</p><ul><li>ArticleList</li><li>ArticleHeader</li><li>ArticleBody</li><li>服務元件</li></ul><p>把這些相關的元件封裝起來，獨立成為一個 Angular 的模組，像這種根據特定功能建立的模組，有時候也被稱為<strong>功能模組 (Feature Module)</strong>。</p><p><img src="https://i.imgur.com/FPb4bnF.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>好的，現在我了解在 Angular 內不同元件間是如何溝通的了，而且也覺得蠻熟悉的，儘管方法可能完全不同，但卻有點類似。</p><ul><li>像是在 Vue 中 父子元件溝通的方式可以透過 props 傳入 、 emit 傳出，來達成父子元件溝通</li><li>也可以使用 event bus 或者 Vuex 來管理元件間的溝通</li></ul><p><strong>好了，讓我們繼續探索 Angular 吧。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Angular 是採用元件化模組開發的框架，可以想像就是不同大大小小元件堆砌而成的網頁，這樣的情況下元件架構又是如何呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.24 避免在範本中出現 TypeScript 型別錯誤</title>
    <link href="http://pvt5r486.github.io/f2e/20190529/3182105266/"/>
    <id>http://pvt5r486.github.io/f2e/20190529/3182105266/</id>
    <published>2019-05-29T11:51:46.000Z</published>
    <updated>2019-06-09T05:30:36.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從我開始學習 Angular 到現在雖然不是很久，但也有一段時間了。蠻容易在 Template 內跑出 TypeScript 的型別錯誤，那麼又該如何避免呢？</p><p><img src="https://images.unsplash.com/photo-1559056408-94245a95e30e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Template-內跑出-TypeScript-的型別錯誤"><a href="#Template-內跑出-TypeScript-的型別錯誤" class="headerlink" title="Template 內跑出 TypeScript 的型別錯誤"></a>Template 內跑出 TypeScript 的型別錯誤</h2><p>像這樣，這種類似的情況其實蠻容易發生的，很容易看到類似像這樣 TypeScript 型別的錯誤。</p><p><img src="https://i.imgur.com/wFFr3qI.png" alt></p><p>這段錯誤的意思是說，這個 item 的區域變數並沒有定義它有個屬性叫做 subjec ，所以它認不得這是什麼。</p><p>這種情況下有兩個解法：</p><ul><li>使用中括號選取屬性的方式，透過這種方式 TypeScript 就沒辦法檢查 item 下是否有 subjec 這個屬性，此時就會回傳 任意 ( any ) 型別<br><img src="https://i.imgur.com/9HokSjx.png" alt></li><li>另一個解法則是官網提供的<a href="https://angular.cn/guide/template-syntax#the-any-type-cast-function-any-expression-" rel="external nofollow noopener noreferrer" target="_blank">類型轉換函式</a></li></ul><h2 id="類型轉換函式"><a href="#類型轉換函式" class="headerlink" title="類型轉換函式"></a>類型轉換函式</h2><p><a href="https://angular.cn/guide/template-syntax#the-any-type-cast-function-any-expression-" rel="external nofollow noopener noreferrer" target="_blank">類型轉換函數</a>的用法的則是在一個區域變數或者屬性的前後加上一個 <code>$any()</code> 的函式將其包覆，而官網的範例是這樣的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Accessing an undeclared member --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  The hero's marker is &#123;&#123;$any(hero).marker&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>透過這個函式回傳的型別的一定是 any 型別，這樣也能使 Angular 跳過 TypeScript 型別的檢查</p><p>於是我們依樣畫葫蘆的嘗試看看</p><p><img src="https://i.imgur.com/lwvZfv7.png" alt></p><p><strong>這時會發現出現錯誤 Unknown Method ，原因是目前 Angular language service 這個擴充套件還不支援 $any()</strong>，未來等這個套件更新後這個問題應該會自然消失。</p><p>不過網頁仍然可以正常運行沒有錯誤，代表這個語法其實是可以用的。</p><p><img src="https://i.imgur.com/2aNQsEz.png" alt></p><p><strong>如果真的覺得這個錯誤很礙眼，那還是使用第一種介紹的方法吧～</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      從我開始學習 Angular 到現在雖然不是很久，但也有一段時間了。蠻容易在 Template 內跑出 TypeScript 的型別錯誤，那麼又該如何避免呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.23 在範本中使用安全導覽運算子</title>
    <link href="http://pvt5r486.github.io/f2e/20190529/3651132835/"/>
    <id>http://pvt5r486.github.io/f2e/20190529/3651132835/</id>
    <published>2019-05-29T10:50:15.000Z</published>
    <updated>2019-06-09T05:30:40.380Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安全導覽運算子 (Safe Navigation Operator) ，又是一個讓人摸不著頭緒的新名詞，讓我們一起看看吧。</p><p><img src="https://images.unsplash.com/photo-1555932339-5d13d6a9ae5e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="安全導覽運算子-Safe-Navigation-Operator"><a href="#安全導覽運算子-Safe-Navigation-Operator" class="headerlink" title="安全導覽運算子 (Safe Navigation Operator)"></a>安全導覽運算子 (Safe Navigation Operator)</h2><p>直接在官網上搜尋 「template syntax」，這被官網歸納在模板的語法，相關說明如下：</p><ul><li><a href="https://angular.cn/guide/template-syntax#the-safe-navigation-operator----and-null-property-paths" rel="external nofollow noopener noreferrer" target="_blank">安全導覽運算子</a></li></ul><p><strong>這個運算子可以使用在 Template 內，語法相當的特別是一個問號在加上一個點 「?.」</strong></p><p>直接從範例來了解如何使用吧！</p><h3 id="前置準備"><a href="#前置準備" class="headerlink" title="前置準備"></a>前置準備</h3><ul><li>今天有一個情境，需要改變原先我們 ngFor 使用的資料，因此修改如下：</li></ul><p><strong>app.component.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">atticleData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">    <span class="string">"subject"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">      <span class="string">"subtitle"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...略</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>因為資料結構改變了，所以 Template 也必須跟著調整</p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>測試看看是否仍能正常運行。</p><p><img src="https://i.imgur.com/fsoJeFL.png" alt></p><p><strong>此時，如果還需要額外輸出一個副標題的話該怎麼做？</strong></p><ul><li>很直覺的會回答可以使用內嵌繫結來達成</li></ul><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;&#123;item.subject.subtitle&#125;&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>接著回到 <strong>app.component.ts</strong> 補一下第一筆資料的 subtitle 。</p><p>運行開發伺服器，觀察畫面呈現。</p><p><img src="https://i.imgur.com/DMoawul.png" alt></p><p>很好，一切都如預期執行。</p><h3 id="使用安全導覽運算子-Safe-Navigation-Operator"><a href="#使用安全導覽運算子-Safe-Navigation-Operator" class="headerlink" title="使用安全導覽運算子 (Safe Navigation Operator)"></a>使用安全導覽運算子 (Safe Navigation Operator)</h3><p>前置作業準備完成後，現在要模擬另一種情境。</p><p>這些資料在正式開發的時候，都會藉由 API 向後端取得資料，而從前端的角度來看，沒有辦法確保後端給我們的資料一定是完整的。</p><p>舉例來說，<strong>可能第一筆資料內有 subject 屬性，但第二筆就沒有 subject 屬性了，此時就會產生問題。</strong></p><p>像是這樣，第一筆資料之後的文章都沒有顯示出來。</p><p><img src="https://i.imgur.com/0mM0zsx.png" alt></p><p>該怎麼辦呢？</p><p>這時候<strong>安全導覽運算子 (Safe Navigation Operator)</strong>就派上用場啦！</p><p><strong>使用方式就是在可能會是 <code>null</code> 或是 <code>undefined</code> 的這些屬性或者是變數名稱後面加上一個問號而已。</strong></p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.subject?.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;&#123;item.subject?.subtitle&#125;&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在這個情境裡 <code>subject</code> 不存在，所以當嘗試存取 <code>subject</code> 時會跳出 <code>undefined</code> ，而 <code>undefined</code> 並不是物件，所以沒有屬性 <code>subtitle</code> 。</p><blockquote><p>因此必須於 <code>subject</code> 後面補上一個 <code>?</code></p></blockquote><p>接著運行開發伺服器，觀察情況吧！</p><p><img src="https://i.imgur.com/YIN6vq0.png" alt></p><p>搞定！只要在屬性後方補上問號，就會形成安全導覽屬性。</p><p>這個語法可以幫助 Angular 去判斷如果該屬性為 <code>null</code> 或是 <code>undefined</code> 的話，會直接回傳 <code>null</code> 就不會嘗試讀取這個屬性，也就不會出錯了。</p><p><strong>這就是安全導覽運算子好用的地方，可以避免 Template 出現諸如此類的問題，另外安全導覽運算子只能使用在 Template 內。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      安全導覽運算子 (Safe Navigation Operator) ，又是一個讓人摸不著頭緒的新名詞，讓我們一起看看吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.22 使用 Pipes 管線元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190529/2426750085/"/>
    <id>http://pvt5r486.github.io/f2e/20190529/2426750085/</id>
    <published>2019-05-29T07:18:45.000Z</published>
    <updated>2019-06-09T05:30:44.344Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這是一個我之前沒聽過的新名詞 Pipes 管線元件 ( Pipes Component )，究竟這是一個什麼樣的元件呢？</p><p><img src="https://images.unsplash.com/photo-1555685812-4b943f1cb0eb?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Pipes-管線元件"><a href="#Pipes-管線元件" class="headerlink" title="Pipes 管線元件"></a>Pipes 管線元件</h2><p>當我們對一項東西不了解的時候，很直覺的我們會想要上網去查資料。</p><p>幸運的， Angular 官方就可以找到相關資訊，而且還是中文的</p><ul><li><a href="https://angular.cn/guide/pipes" rel="external nofollow noopener noreferrer" target="_blank">Pipes 管線元件</a></li></ul><blockquote><p>Pipes 管線元件主要是讓我們在透過內嵌繫結或者是屬性繫結時可以透過 Pipes 的符號 <code>|</code> 將我們原本的輸出丟給另一個 Pipes 元件處理，再把新的結果輸出到畫面上。</p></blockquote><p><strong>聽到這裡，我又有一種似曾相似的感覺。</strong></p><blockquote><p>在 Vue 裡面可以使用 <a href="https://cn.vuejs.org/v2/guide/filters.html" rel="external nofollow noopener noreferrer" target="_blank">filters</a> ，同樣也是會使用到 Pipes 的符號 <code>|</code> 將原本的輸出丟給某個東西處理後，在把新的結果呈現在畫面上。</p></blockquote><p>扯遠了。</p><p>Angular 內有幾個內建的 Pipes 元件</p><ul><li>DatePipe</li><li>UperCase</li><li>LowerCase</li><li>Currency</li><li>PercentPipe</li></ul><p><strong>未羅列出全部，詳細請參考<a href="https://angular.cn/api?type=pipe" rel="external nofollow noopener noreferrer" target="_blank">這裡</a></strong></p><p>這幾個 Pipes 元件預設就可以讓我們使用在任何的 Template 上，若這些內建的 Pipes 元件不符合需求，也可以自行撰寫 Pipes 元件哦。</p><h2 id="UperCase"><a href="#UperCase" class="headerlink" title="UperCase"></a>UperCase</h2><p>顧名思義這個 UperCase 的 Pipes 元件，就是幫我們把原本輸出有英文的部分全部轉換成大寫。</p><p>這是還沒有套用 UperCase 前，標題的英文有大寫有小寫</p><p><img src="https://i.imgur.com/BFEh906.png" alt></p><p>因此我要把這個 Pipes 元件套用到目前的 Template 上。</p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|uppercase &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/7j2rhVz.png" alt></p><blockquote><p>如此簡單的一行就搞定，而且有支援自動完成功能，很方便！</p></blockquote><h2 id="LowerCase"><a href="#LowerCase" class="headerlink" title="LowerCase"></a>LowerCase</h2><p>與 UperCase 相同，顧名思義就是有英文的部分全部轉換成小寫，使用方式也非常簡單:</p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|lowercase &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/o8F4nc6.png" alt></p><h2 id="DecimalPipe"><a href="#DecimalPipe" class="headerlink" title="DecimalPipe"></a>DecimalPipe</h2><p>關於 DecimalPipe 的使用同樣可以在官方文件找到</p><ul><li><a href="https://angular.cn/api/common/DecimalPipe" rel="external nofollow noopener noreferrer" target="_blank">DecimalPipe</a></li></ul><p>使用方式如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value_expression | number [ : digitsInfo [ : locale ] ] &#125;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>value 是輸入值</li><li>number 是這個 Pipes 元件的名稱</li><li>digitsInfo 為字串型態的參數，非必填項目<ul><li>格式如 <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code></li><li>minIntegerDigits：在小数点前的最小位数。默认为 1。</li><li>minFractionDigits：小数点后的最小位数。默认为 0。</li><li>maxFractionDigits：小数点后的最大为数，默认为 3。</li></ul></li><li>locale 為字串型態的參數，非必填項目<ul><li>用來設定這一串數字要用哪一個地區的數值格式呈現</li></ul></li></ul><p>因此可以按照官方提供的範例，複製一份並且在 Template 內隨意找個地方貼上玩看看：</p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--output '2.718'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>e (no formatting): &#123;&#123;e | number&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '002.71828'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>e (3.1-5): &#123;&#123;e | number:'3.1-5'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '0,002.71828'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>e (4.5-5): &#123;&#123;e | number:'4.5-5'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '0 002,71828'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>e (french): &#123;&#123;e | number:'4.5-5':'fr'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '3.14'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>pi (no formatting): &#123;&#123;pi | number&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '003.14'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>pi (3.1-5): &#123;&#123;pi | number:'3.1-5'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '003.14000'--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>pi (3.5-5): &#123;&#123;pi | number:'3.5-5'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--output '-3' / unlike '-2' by Math.round()--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>-2.5 (1.0-0): &#123;&#123;-2.5 | number:'1.0-0'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>Template 有用到 <code>e</code> 以及 <code>pi</code> 這兩個內嵌繫結，因此必須在 class 內補上這兩個屬性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  inputValue = <span class="string">''</span>;</span><br><span class="line">  pi: number = <span class="number">3.14</span>;</span><br><span class="line">  e: number = <span class="number">2.718281828459045</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>運行開發伺服器，看看效果如何～</p></blockquote><p><img src="https://i.imgur.com/zqZBBLG.png" alt></p><ul><li>第一個結果 e 輸出是 2.718 ，對照後也就是說預設的情況下 DecimalPipe 會輸出小數點後三位的數字，其餘全部捨去。<ul><li>而這個結果是因為沒有填寫任何參數，是參數的默認值導致</li></ul></li><li>第二個結果傳入一個參數 <code>3.1-5</code> ，對照上面的格式與參數解釋後，得到結果 e 為 002.71828</li></ul><blockquote><p>可透過修改第一個參數達成想要的數字格式。</p></blockquote><ul><li>第四個結果，傳入的第二個參數為 fr ，代表採用法國的數值格式<ul><li>在法國，小數點是當作千分號使用，而千分號則是使用空白替代</li><li>透過不同的國家的 locale id 就可以轉換成對應的地區數值格式<ul><li>台灣為 zh-TW</li><li>日本為 jp</li></ul></li></ul></li></ul><p><strong>不僅僅第一個參數可以利用，配合第二個參數一起使用才是王道。</strong></p><blockquote><p>而這個 Pipes 元件好玩的地方是，它的名稱叫做 DecimalPipe ，但實際使用卻是輸入 number ，這是容易搞混的地方要特別注意。</p></blockquote><h2 id="CurrencyPipe"><a href="#CurrencyPipe" class="headerlink" title="CurrencyPipe"></a>CurrencyPipe</h2><p>這是個貨幣格式的 Pipe 元件，官網文件如下：</p><ul><li><a href="https://angular.cn/api/common/CurrencyPipe" rel="external nofollow noopener noreferrer" target="_blank">CurrencyPipe</a></li></ul><p>用法跟先前介紹的 DecimalPipe 蠻類似的，使用方式如下：</p><p>使用方式如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value_expression | currency [ : currencyCode [ : display [ : digitsInfo [ : locale ] ] ] ] &#125;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>value 是輸入值</li><li>currency 是這個 Pipes 元件的名稱</li><li>currencyCode 是貨幣代碼，比如 USD 表示美元，這部分是選填的，且格式須遵守 <a href="https://en.wikipedia.org/wiki/ISO_4217" rel="external nofollow noopener noreferrer" target="_blank">ISO4217</a></li><li>display 是貨幣的符號，同樣是可選的，預設是顯示貨幣的符號。</li><li>digitsInfo 為字串型態的參數，非必填項目<ul><li>格式如 <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code></li><li>minIntegerDigits：在小数点前的最小位数。默认为 1。</li><li>minFractionDigits：小数点后的最小位数。默认为 0。</li><li>maxFractionDigits：小数点后的最大为数，默认为 3。</li></ul></li><li>locale 為字串型態的參數，非必填項目<ul><li>用來設定這一串數字要用哪一個地區的數值格式呈現</li></ul></li></ul><p><strong>直接參考官網範例：</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'currency-pipe'</span>,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;!--output '$0.26'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;A: &#123;&#123;a | currency&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output 'CA$0.26'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;A: &#123;&#123;a | currency:'CAD'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output 'CAD0.26'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;A: &#123;&#123;a | currency:'CAD':'code'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output 'CA$0,001.35'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | currency:'CAD':'symbol':'4.2-2'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output '$0,001.35'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | currency:'CAD':'symbol-narrow':'4.2-2'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output '0 001,35 CA$'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | currency:'CAD':'symbol':'4.2-2':'fr'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--output 'CLP1' because CLP has no cents--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | currency:'CLP'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrencyPipeComponent</span> </span>&#123;</span><br><span class="line">  a: number = <span class="number">0.259</span>;</span><br><span class="line">  b: number = <span class="number">1.3495</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>這部分因為跟 DecimalPipe 很類似，所以就不一個個解釋了。</p></blockquote><h2 id="PercentPipe"><a href="#PercentPipe" class="headerlink" title="PercentPipe"></a>PercentPipe</h2><p>這是一個百分比的 Pipe 元件，官網文件如下：</p><ul><li><a href="https://angular.cn/api/common/PercentPipe" rel="external nofollow noopener noreferrer" target="_blank">PercentPipe</a></li></ul><p>使用方式如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value_expression | percent [ : digitsInfo [ : locale ] ] &#125;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>value 是輸入值</li><li>percent 是這個 Pipes 元件的名稱</li><li>digitsInfo 為字串型態的參數，非必填項目<ul><li>格式如 <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code></li><li>minIntegerDigits：在小数点前的最小位数。默认为 1。</li><li>minFractionDigits：小数点后的最小位数。默认为 0。</li><li>maxFractionDigits：小数点后的最大为数，默认为 3。</li></ul></li><li>locale 為字串型態的參數，非必填項目<ul><li>用來設定這一串數字要用哪一個地區的數值格式呈現</li></ul></li></ul><p><strong>直接參考官網範例：</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'percent-pipe'</span>,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;!--output '26%'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;A: &#123;&#123;a | percent&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    &lt;!--output '0,134.950%'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | percent:'4.3-5'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    &lt;!--output '0 134,950 %'--&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;B: &#123;&#123;b | percent:'4.3-5':'fr'&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PercentPipeComponent</span> </span>&#123;</span><br><span class="line">  a: number = <span class="number">0.259</span>;</span><br><span class="line">  b: number = <span class="number">1.3495</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>從這邊可以發現， DecimalPipe 、 CurrencyPipe 、 PercentPipe 使用方式感覺上其實都差不多</strong></p><h2 id="DatePipe"><a href="#DatePipe" class="headerlink" title="DatePipe"></a>DatePipe</h2><p>這是一個關於日期的 Pipe 元件，關於這個元件的官網說明如下:</p><ul><li><a href="https://angular.cn/api/common/DatePipe" rel="external nofollow noopener noreferrer" target="_blank">DatePipe</a></li></ul><p>使用方式如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value_expression | date [ : format [ : timezone [ : locale ] ] ] &#125;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>value 是輸入值，可以是 Date 物件、數字（从 UTC 时代以来的毫秒数）或 <a href="https://www.w3.org/TR/NOTE-datetime" rel="external nofollow noopener noreferrer" target="_blank">ISO 字符串</a></li><li>date 是這個 Pipes 元件的名稱</li><li>format 為字串型態的參數，為非必填項目<ul><li>要包含的日期、時間部分的格式，或者是使用預先定義好的格式</li><li>預設值是 ‘mediumDate’.</li></ul></li><li>timezone 為字串型態的參數，為非必填項目<ul><li>可以加上一個時區偏移（比如 ‘+0430’）或使用標準的 UTC/GMT</li><li>預設為本地系統時區</li></ul></li><li>locale 為字串型態的參數，非必填項目<ul><li>用來設定日期要用哪一個地區的日期格式呈現</li></ul></li></ul><blockquote><p>接著利用 DatePipe 來修改部落格文章上的日期格式吧</p></blockquote><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/uLsDMpj.png" alt="修改前"></p><p><img src="https://i.imgur.com/cBZmn1L.png" alt="修改後"></p><p>這樣子的用法是直接轉換成我們希望的格式，但其實 format 參數內有一些已經預先定義好的格式可以使用，例如：</p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'shortDate'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/dyLOgal.png" alt="shortDate"></p><h2 id="JsonPipe"><a href="#JsonPipe" class="headerlink" title="JsonPipe"></a>JsonPipe</h2><p>JsonPipe 可以把任意值全部轉換成 Json 的格式，所以這些值可以是字串、數字、物件。</p><p>而官網的文件如下：</p><ul><li><a href="https://angular.cn/api/common/JsonPipe" rel="external nofollow noopener noreferrer" target="_blank">JsonPipe</a></li></ul><blockquote><p>JsonPipe 的功能主要是拿來偵錯，像是輸出之前在練習 ngFor 時的用到的資料。</p></blockquote><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|lowercase &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-body text"</span> [<span class="attr">innerHTML</span>]=<span class="string">"item.summary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>如果直接把 <code>item</code> 進行內嵌繫結輸出的話，只會得到奇怪的結果</p><p><img src="https://i.imgur.com/AAMZcs2.png" alt></p><blockquote><p>如果想要得到 <code>item</code> 物件序列化之後的 Json 資料，則可以使用 JsonPipe 來達成。</p></blockquote><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;item|json&#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/qIAN6xH.png" alt></p><h2 id="SlicePipe"><a href="#SlicePipe" class="headerlink" title="SlicePipe"></a>SlicePipe</h2><p>Slice 這個單字有切割的意思，所以這個 SlicePipe 可以幫助我們把某個物件、集合切割出其中的某一塊資料出來。</p><p>而官網的文件如下：</p><ul><li><a href="https://angular.cn/api/common/SlicePipe" rel="external nofollow noopener noreferrer" target="_blank">SlicePipe</a></li></ul><p>使用方式如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value_expression | slice : start [ : end ] &#125;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>value 是輸入值，可以是陣列或字串</li><li>slice 是這個 Pipes 元件的名稱</li><li>start 必填參數，表示要返回的子集的初始索引，數值型別<ul><li>正整數的情況：從列表或字符串表達式中返回從 start 索引處及之後的所有項目</li><li>負整數的情況：從列表或字符串表達式中返回從结尾开始的第 start 索引處及之後的所有項目</li><li>如果是正整數而且大於表達式的項目數：返回空列表或空字符串</li><li>如果是正整數而且大於表達式的項目數：返回整個列表或字符串</li></ul></li><li>end 非必填參數，表示所要返回的子集的结尾索引，數值型別<ul><li>省略：返回结尾之前的全部項目</li><li>正整數的情況：從列表或字符串中返回 end 索引之前的所有項目</li><li>負整數的情況：從列表或字符串末尾返回 end 索引之前的所有項目</li></ul></li></ul><blockquote><p>看完這些敘述似乎有點混亂，可以先試著把 SlicePipe 用在部落格的標題看看情況。</p></blockquote><p><strong>順帶一提， Pipe 與 Pipe 之間是可以串接的。</strong></p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|lowercase|slice:0:20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>這麼寫的意思代表，我希望標題的英文可以是小寫，且字數可以從 0 取到第 20 的位置</strong></p><p>觀察一下情況</p><p><img src="https://i.imgur.com/7px4gGO.png" alt></p><blockquote><p>可以看到標題顯示到 visual st 就結束了，因為前面加起來剛好是 20 個字元。</p></blockquote><p>如果想要取標題從後面數來第 20 個字元後的內容，也是辦的到的：<br><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/SOU69Z1.png" alt></p><blockquote><p>可以看到標題顯示從 「o code 如何避免顯示惱人的偵錯訊息」，這邊數來剛好 20 個字元。</p></blockquote><p><strong>以上是 SlicePipe 用在字串上的範例</strong> ，而 SlicePipe 還可以用在陣列上。</p><p>舉例來說，之前在練習 ngFor 時傳入的資料總共有六筆，而傳入的資料型態是個陣列。</p><p><strong>這代表可以將 SlicePipe 用在這個地方，像是一頁只顯示二筆資料這樣。</strong></p><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData|slice:0:2; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title|lowercase|slice:-20 &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date|date:'yyyy-MM-dd HH:mm'&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-body text"</span> [<span class="attr">innerHTML</span>]=<span class="string">"item.summary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/2N5rZar.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>介紹了這麼多的 Pipes 元件，一時之間想必很難完全記起來，好在這些資料全部都可以在官方文件上查到，而且全部都具有範例程式碼。</p><p>所以不用死背這些東西，只需要記幾個最常用的像是 DatePipe 、 PercentPipe 、 CurrencyPipe 就可以了，其餘的等有用到再查也不遲。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這是一個我之前沒聽過的新名詞 Pipes 管線元件 ( Pipes Component )，究竟這是一個什麼樣的元件呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.21 Angular 結構型指令 (Structural Directives)</title>
    <link href="http://pvt5r486.github.io/f2e/20190528/504997113/"/>
    <id>http://pvt5r486.github.io/f2e/20190528/504997113/</id>
    <published>2019-05-28T11:58:10.000Z</published>
    <updated>2019-06-09T05:30:48.355Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>總算到介紹到最後一個 Angular 的指令 - 結構型指令 (Structural Directives) 啦，打起精神繼續往下學習吧！</p><p><img src="https://images.unsplash.com/photo-1519052537078-e6302a4968d4?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="結構型指令-Structural-Directives"><a href="#結構型指令-Structural-Directives" class="headerlink" title="結構型指令 (Structural Directives)"></a>結構型指令 (Structural Directives)</h2><p>這種結構型的指令會透過新增或刪除 DOM 的元素動態改變 DOM 的結構，內建有三種語法：</p><ul><li>ngIf</li><li>ngSwitch</li><li>ngFor</li></ul><blockquote><p>相信看到這些語法大概也猜得出七八成是在做什麼的，以下一一示範如何使用。</p></blockquote><h2 id="ngIf"><a href="#ngIf" class="headerlink" title="ngIf"></a>ngIf</h2><p>ngIf 的用法相當簡單，可以透過這個指令動態的新增或者是刪除一整段 HTML 的內容。</p><p>假設這個 ICON 區塊會根據 Counter 的數字動態的顯示或隱藏，那該怎麼做呢？<br><img src="https://i.imgur.com/75oo2zQ.png" alt></p><p>首先找到 Template 內對應的 HTML 區塊，並進行修改<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"social-icons"</span> <span class="attr">class</span>=<span class="string">"pull-right social-icon"</span> *<span class="attr">ngIf</span>=<span class="string">"counter % 2 == 0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/facebook.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/twitter.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/googleplus.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/plurk.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/weibo.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">title</span>=<span class="string">"RSS 訂閱"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/rss.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>特別的是 ngIf 前面必須加上一個 * 號，這個星號是結構型指令專屬的語法，算是語法糖的一種。</p><p><strong>只要是結構型指令，記得加上 * 號就對了。</strong>，不過我們也不需要真的死背，可以善用 code snippet 來輔助。</p><p>而 <code>*ngIf</code> 的等號後方同樣也是接布林值，因此在這裡我們填入 <code>counter % 2 == 0</code> 這樣就可以了。</p><ul><li>只要回傳 True ，那麼就新增這個 HTML 區塊，反之則刪除</li></ul><blockquote><p>測試看看吧！</p></blockquote><p><img src="https://i.imgur.com/xW7JaSG.png" alt="新增"></p><p><img src="https://i.imgur.com/7L0XvQy.png" alt="刪除"></p><p><strong>這邊要強調的是 ngIf 是真的操作 DOM 元素動態改變結構進行新增或是刪除，也就是當回傳 False 時該區塊是完全不存在網頁中的，並非單純的隱藏。</strong></p><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><p>使用 ngif 時，雖然語法相當的簡單，可是有生命週期的細節需要注意。</p><p>使用 ngif 新增或刪除某個區塊的 HTML 時，那些區塊可能含有其他的 Component</p><ul><li>當 <code>*ngif = false</code> 時 Component 會一起被刪除</li><li>當 <code>*ngif = True</code> 時 Component 被新增回來</li></ul><p>也就是說這樣的情況下會影響到 Component 的生命週期，當 Component 被刪除時生命週期也就跟著結束了。</p><p><strong>因此下一次新增回來的 Component 狀態肯定會跟之前的不同，這點需要特別注意</strong></p><blockquote><p>這個 Component 狀態好比 HeaderComponent 內的 counter ，假如目前 <code>counter = 5</code> 當元件被刪除又新增後，這個時候的 <code>counter</code> 已經被重置了。</p></blockquote><h2 id="ngSwitch"><a href="#ngSwitch" class="headerlink" title="ngSwitch"></a>ngSwitch</h2><p>ngSwitch 也是個結構型指令，假設我們有個需求是這樣：</p><ul><li>根據 ngSwitch 去切換前三個 ICON 與後三個 ICON 的內容</li><li>切換的條件根據 <code>counter % 2</code> 產生的不同的餘數來切換</li></ul><p>首先找到 Template 內對應的 HTML 區塊，並進行修改<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"social-icons"</span> <span class="attr">class</span>=<span class="string">"pull-right social-icon"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngSwitch</span>]=<span class="string">"counter % 2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/facebook.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/twitter.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/googleplus.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/plurk.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/weibo.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">title</span>=<span class="string">"RSS 訂閱"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/rss.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchDefault</span>&gt;</span>N / A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><code>[ngSwitch]</code> 後面接的是條件，在這裡我們的條件設定為 <code>counter % 2</code> ，而 <code>*ngSwitchCase</code> 後面接的是「當遇到 0 或 1 時要顯示哪些東西」，那如果都不符合的話的則顯示 <code>*ngSwitchDefault</code> 的結果。</p><blockquote><p>存檔測試看看吧！</p></blockquote><p><img src="https://i.imgur.com/xYwqq38.png" alt></p><p><img src="https://i.imgur.com/f7LyRPF.png" alt></p><p><strong>成功是成功了，但這時會發現使用 ngSwitch 導致 HTML 結構不一致。</strong></p><p><img src="https://i.imgur.com/ERC9ezY.png" alt></p><h3 id="使用-ngSwitch-導致-HTML-結構不一致"><a href="#使用-ngSwitch-導致-HTML-結構不一致" class="headerlink" title="使用 ngSwitch 導致 HTML 結構不一致"></a>使用 ngSwitch 導致 HTML 結構不一致</h3><p>這該怎麼修正呢？</p><blockquote><p>可以使用 <code>ng-container</code> 來取代使用 ngSwitch 時產生的 div 標籤</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"social-icons"</span> <span class="attr">class</span>=<span class="string">"pull-right social-icon"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-container</span> [<span class="attr">ngSwitch</span>]=<span class="string">"counter % 2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/facebook.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/twitter.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/googleplus.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngSwitchCase</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/plurk.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/weibo.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">title</span>=<span class="string">"RSS 訂閱"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/images/rss.png"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngSwitchDefault</span>&gt;</span>N / A<span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>再次觀察 DOM 結構</p></blockquote><p><img src="https://i.imgur.com/QS3vLtz.png" alt></p><p>此時就沒有多餘的 DIV 標籤了。</p><p><strong>從這邊我們知道，當使用結構型指令時可以使用 ng-container 標籤，使其不會產生出額外的 HTML 標籤。</strong></p><h2 id="ngFor"><a href="#ngFor" class="headerlink" title="ngFor"></a>ngFor</h2><p>ngFor 的功能相當強大，使用的時機也相當頻繁。</p><p>舉例來說，當我們串接 API 的時候，會取得一份資料。此時可能會透過迴圈的方式顯示在畫面上，這時後就有機會用上 ngFor 。</p><p>因為目前網頁的文章是寫死的，接下來要透過 ngFor 動態的把文章的資料呈現在網頁上。</p><h3 id="處理資料部分"><a href="#處理資料部分" class="headerlink" title="處理資料部分"></a>處理資料部分</h3><p>先整理好要給 ngFor 跑的陣列資料，可以先寫死一份假資料在 app.component.ts 內。</p><p><strong>app.component.ts</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* tslint:disable */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  inputValue = <span class="string">''</span>;</span><br><span class="line">  atticleData = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">      <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">      <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">      <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">      <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">      <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/03/22/Does-Certification-Exam-Useful.aspx"</span>,</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"考證照真的沒用嗎？一個從業 20 年的 IT 主管告訴你他怎麼看！"</span>,</span><br><span class="line">      <span class="string">"date"</span>: <span class="string">"2016/03/22 19:28"</span>,</span><br><span class="line">      <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">      <span class="string">"category"</span>: <span class="string">"心得分享"</span>,</span><br><span class="line">      <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB.aspx"</span>,</span><br><span class="line">      <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;其實無論在哪個國家都有推行證照制度，且行之有年，台灣當然也不例外，這件事一開始的立意都是好的，就是希望透過一套公平的考試制度，評估一個人的技術能力是否達到一定程度水準，不但能當成一個人的能力指標，也可以讓大家有個明確目標朝專業之路邁進。其他的行業我不清楚，但就我本身熟悉的 IT 產業來說，不知何年何月開始，大家開始對證照制度嗤之以鼻、不屑一顧，甚至覺得是一個人能力的&lt;strong&gt;負指標&lt;/strong&gt; (也就是能力不好的人才需要靠證照證明自己)。你說這現象是何等的詭異？是什麼樣的天時、地利、人和，可以讓一個原本立意良善的制度，變成人人喊打的落水狗，可能連有張證照都還不敢承認的地步。今天，就來談談我的個人見解。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/03/22/Does-Certification-Exam-Useful.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/03/14/ASPNET-MVC-Developer-Note-Part-28-Understanding-ModelState.aspx"</span>,</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"ASP.NET MVC 開發心得分享 (28)：深入瞭解 ModelState 內部細節"</span>,</span><br><span class="line">      <span class="string">"date"</span>: <span class="string">"2016/03/14 12:14"</span>,</span><br><span class="line">      <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">      <span class="string">"category"</span>: <span class="string">"ASP.NET MVC"</span>,</span><br><span class="line">      <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/ASPNET-MVC.aspx"</span>,</span><br><span class="line">      <span class="string">"summary"</span>: <span class="string">"&lt;p&gt;在 ASP.NET MVC 的 &lt;strong&gt;模型繫結&lt;/strong&gt; (Model Binding) 完成之後，我們可以在 Controller / Action 中取得 &lt;span style='font-family: Consolas;'&gt;ModelState&lt;/span&gt;                  物件，一般來說我們都會用 &lt;span style='font-family: Consolas;'&gt;&lt;strong&gt;ModelState.IsValid&lt;/strong&gt;&lt;/span&gt; 來檢查在「模型繫結」的過程中所做的&lt;strong&gt;輸入驗證&lt;/strong&gt; (Input Validation) 與 &lt;strong&gt;模型驗證&lt;/strong&gt; (Model Validation) 是否成功。不過，這個 &lt;span style='font-family: Consolas;'&gt;ModelState&lt;/span&gt;物件的用途很廣，裡面存有非常多模型繫結過程的狀態資訊，不但在 Controller 中能用，在 View 裡面也能使用，用的好的話，可以讓你的 Controller 更輕、View 也更乾淨，本篇文章將分享幾個 ModelState 的使用技巧。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/03/14/ASPNET-MVC-Developer-Note-Part-28-Understanding-ModelState.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  cleanInput() &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputValue = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在這邊因為 tslint 要求我把所有的雙引號改成單引號，為了開發方便，我先暫時把 tslint 給關閉。</p><p>就這樣我們新增了一個 <code>atticleData</code> 屬性，裡面是一個陣列，陣列內又有一個個物件，而每一個物件又有相關的屬性。</p><p><strong>接著我們透過 ngFor 這個結構型指令來把這些通通顯示在畫面上吧！</strong></p><h3 id="處理-Template-的-HTML-部分"><a href="#處理-Template-的-HTML-部分" class="headerlink" title="處理 Template 的 HTML 部分"></a>處理 Template 的 HTML 部分</h3><p>回過頭來處理 HTML 部分，同樣我們使用 code snippet 幫助撰寫程式碼</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post0"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-body text"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.summary&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p>這裡的 <code>*ngFor</code> 後面接的語法有點像是 JavaScript 中 ForEach() 的感覺， <code>item</code> 代表當前陣列的元素而 <code>atticleData</code> 則是要遍歷的目標陣列。</p><p>蠻像 Vue 中的 <code>v-for</code> 指令的，如果有學習過 Vue 肯定對這個部分不陌生。</p><blockquote><p>運行開發伺服器，觀察結果吧！</p></blockquote><p><img src="https://i.imgur.com/bJU48Re.png" alt></p><p><img src="https://i.imgur.com/TwIZCvw.png" alt></p><p>至此，我們已經成功地透過 ngFor 快速的把資料轉換成網頁的內容，而且程式碼相當的簡潔。</p><p><strong>不過還需要修正最後一個小地方，那就是文章 summary 部分的 HTML 標籤居然直接被輸出了，這該怎麼辦呢？</strong></p><h3 id="透過屬性繫結的方式"><a href="#透過屬性繫結的方式" class="headerlink" title="透過屬性繫結的方式"></a>透過屬性繫結的方式</h3><p>先把 HTML 中的 <code></code> 這段內嵌繫結刪除，並且套用屬性繫結</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post0"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-body text"</span> [<span class="attr">innerHTML</span>]=<span class="string">"item.summary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>這一段的作法是將屬性繫結在 section 標籤的 DOM 物件內的 innerHTML 屬性上，這麼一來 HTML 的標籤就會直接寫入 innerHTML 這個屬性內。</strong></p><p><img src="https://i.imgur.com/mKprMp1.png" alt></p><blockquote><p>如此一來就全部搞定啦～</p></blockquote><p>值得注意的是這個作法是有風險的，因為這些 HTML 可能含有一些惡意的內容，可能會導致 <strong>Cross-Site Script</strong> 的攻擊。</p><p>不過 Angular 有幫我們做到一些很基本的防護，例如在資料的部分偷偷的加一些料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">atticleData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx"</span>,</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息"</span>,</span><br><span class="line">    <span class="string">"date"</span>: <span class="string">"2016/04/30 18:05"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"GHJKL"</span>,</span><br><span class="line">    <span class="string">"category"</span>: <span class="string">"Visual Studio"</span>,</span><br><span class="line">    <span class="string">"category-link"</span>: <span class="string">"http://blog.miniasp.com/category/Visual-Studio.aspx"</span>,</span><br><span class="line">    <span class="string">"summary"</span>: <span class="string">"&lt;script&gt;alert('XSS!!!')&lt;/script&gt;&lt;p&gt;由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 &lt;strong&gt;&lt;font color='#ff0000' face='Consolas'&gt;code .&lt;/font&gt;&lt;/strong&gt;就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。&lt;/p&gt;&lt;p&gt;... &lt;a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'&gt;繼續閱讀&lt;/a&gt;...&lt;/p&gt;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>回到網頁上會發現 Angular 自動的把 script 標籤過濾掉了，所以什麼都事情都沒發生，而且還很智慧的顯示這一段提示</strong></p><p><img src="https://i.imgur.com/sLhRAtb.png" alt></p><blockquote><p>意思是 Angular 幫我們從 HTML內了清除了一些有害的內容，而後面的連結則是關於 XSS 的資安文件。</p></blockquote><h3 id="替-ngFor-加上索引值"><a href="#替-ngFor-加上索引值" class="headerlink" title="替 ngFor 加上索引值"></a>替 ngFor 加上索引值</h3><p>最後我們要替每一篇文章的 id 補上索引值，而 ngFor 裡面提供了一個好用的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Article START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"post&#123;&#123;idx&#125;&#125;"</span> *<span class="attr">ngFor</span>=<span class="string">"let item of atticleData; let idx = index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"post-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"item.href"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-info clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-calendar"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-author"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/author/will.aspx"</span>&gt;</span>&#123;&#123;item.author&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-folder-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          [<span class="attr">href</span>]=<span class="string">"item['category-link']"</span>&gt;</span>&#123;&#123;item.category&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-body text"</span> [<span class="attr">innerHTML</span>]=<span class="string">"item.summary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Article END--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>只有在 ngFor 指令下才可以使用，能自行宣告一個變數 <code>idx</code> ，並且賦值為 <code>index</code> ，如此一來就能取得目前的索引值。</strong></p><p>這時的文章 id 就會按照索引值增加了。</p><p><img src="https://i.imgur.com/C9y8wIn.png" alt></p><blockquote><p>當然這邊也可以直接使用屬性繫結把資料內的 id 綁上去即可，只是這邊要介紹索引值的用法。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>總算是介紹完 Angular 的三種類型的指令了，有沒有覺得這些指令都似曾相似呢？就我來說的話肯定是有的，而大部分的用法都蠻接近的，只是細節上有不同之處。</p><p>希望能早日把 Angular 給掌握起來！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      總算到介紹到最後一個 Angular 的指令 - 結構型指令 (Structural Directives) 啦，打起精神繼續往下學習吧！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.20 Angular 屬性型指令 (Attribute Directives)</title>
    <link href="http://pvt5r486.github.io/f2e/20190528/1619485620/"/>
    <id>http://pvt5r486.github.io/f2e/20190528/1619485620/</id>
    <published>2019-05-28T10:20:02.000Z</published>
    <updated>2019-06-09T05:30:52.940Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>學完元件型指令後，接著介紹第二種 Angular 指令 - 屬性型指令 (Attribute Directives)</p><p><img src="https://images.unsplash.com/photo-1482066490729-6f26115b60dc?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1002&amp;q=80" alt></p><h2 id="屬性型指令-Attribute-Directives"><a href="#屬性型指令-Attribute-Directives" class="headerlink" title="屬性型指令 (Attribute Directives)"></a>屬性型指令 (Attribute Directives)</h2><p>這種 Directives 有個特性，就是本身不會有自己的 Template ，但是套用這個 Directives 的地方，會修改那一個元素或者是那一個標籤的外觀或者是行為。</p><p>在 Angular 內建的屬性型指令內有三種：</p><ul><li>ngModule - 雙向繫結</li><li>ngStyle - 動態設置 CSS 的 Style</li><li>ngClass - 動態設置 CSS 的 className</li></ul><blockquote><p>透過第二與第三個 Directives 可以很容易地去修改現有 HTML 的外觀、 CSS 的 Style 、 或動態的套用一些 class 。</p></blockquote><h2 id="如何使用-ngStyle"><a href="#如何使用-ngStyle" class="headerlink" title="如何使用 ngStyle"></a>如何使用 ngStyle</h2><p>現在我們替 HeaderComponent 內加入一個新功能，當點擊網站 LOGO 時，計算被點了幾下。</p><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><ul><li>首先我們在 HeaderComponent 的 <code>class</code> 內做調整，加入 <code>counter</code> 屬性並補上點擊時 counter++ ：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>並且修改 HeaderComponent 的 Template 使用內嵌繫結</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>搞定！運行開發伺服器確認功能是否正常運作</p></blockquote><p><img src="https://i.imgur.com/VvXEOpn.png" alt></p><h3 id="動態調整-h3-標籤內的字體大小"><a href="#動態調整-h3-標籤內的字體大小" class="headerlink" title="動態調整 h3 標籤內的字體大小"></a>動態調整 h3 標籤內的字體大小</h3><p><strong>修改 HeaderComponent 的 Template</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">ngStyle</span>]=<span class="string">"&#123;'font-size': (12 + counter) + 'px'&#125;"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這邊做了一個 ngStyle 的屬性繫結，但是 ngStyle 並不是 h3 標籤的 Property 也不是 Attribute 。</p><p><strong>ngStyle 本身就是一個 Diretive ，這個 Diretive 可以透過 [] 繫結一個物件，然後這個物件的屬性就是要套用的 CSS 的 Style ，而值就是我們希望套用的值。</strong></p><p>因此再次運行開發伺服器確認功能是否正常運作</p><p><img src="https://i.imgur.com/ke5GTnN.png" alt></p><blockquote><p>這樣就有隨著點擊次數字體越來越大的感覺了！</p></blockquote><h3 id="進階用法"><a href="#進階用法" class="headerlink" title="進階用法"></a>進階用法</h3><p>值得注意的是， ngStyle 後面跟著的是一個物件，這代表其實可以傳入多組 CSS 的 Style ，但是通通寫在 HTML 內會顯得很難看，所以我們也可以這麼處理：</p><p><strong>在 <code>class</code> 內撰寫方法並回傳</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">ngStyle</span>]=<span class="string">"getStyle()"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">  getStyle() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'font-size'</span>: (<span class="number">12</span> + <span class="keyword">this</span>.counter) + <span class="string">'px'</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這麼處理的結果會跟剛才的結果一模一樣。</p><p><img src="https://i.imgur.com/B42rfw4.png" alt></p><p><strong>或者是直接透過屬性</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">ngStyle</span>]=<span class="string">"getStyle"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  getStyle = &#123;</span><br><span class="line">    <span class="string">'font-size'</span>: <span class="number">20</span> + <span class="string">'px'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>這麼做也是沒問題的！</p></blockquote><h3 id="ngStyle-的簡單用法"><a href="#ngStyle-的簡單用法" class="headerlink" title="ngStyle 的簡單用法"></a>ngStyle 的簡單用法</h3><p>ngStyle 還有更簡單的使用方式，像是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">style.font-size</span>]=<span class="string">"(12+counter) + 'px'"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接在中括號內輸入 <code>style</code> 後面接上 <code>.</code> 直接加上想要套用的樣式即可，而等號後面則與剛才設定相同。</p><p>而如果你想要同時套用多種，可以這麼做：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">style.font-size</span>]=<span class="string">"(12+counter) + 'px'"</span></span></span><br><span class="line"><span class="tag">  [<span class="attr">style.color</span>]=<span class="string">"'red'"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>而這個方法也可以使用 class 內的屬性或方法使其更易讀</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">style.font-size</span>]=<span class="string">"fontSize"</span> [<span class="attr">style.color</span>]=<span class="string">"fontColor"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  fontSize = <span class="number">16</span> + <span class="string">'px'</span>;</span><br><span class="line">  fontColor = <span class="string">'red'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果如下</p><p><img src="https://i.imgur.com/Mx54siL.png" alt></p><p><strong>這些方式可以選擇一種使用即可，看哪個順手就用哪個吧。</strong></p><h2 id="如何使用-ngClass"><a href="#如何使用-ngClass" class="headerlink" title="如何使用 ngClass"></a>如何使用 ngClass</h2><p>如果已經知道如何使用 ngStyle ，那麼 ngClass 肯定難不倒我們，兩者的用法幾乎是一樣的。</p><p>我們將剛才設定過 ngStyle 的地方全部刪除，並且加上 ngClass ：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">ngClass</span>]=<span class="string">"&#123;cssClass: expression&#125;"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到整體結構上基本同於 ngStyle ，等號後方一樣是接收一個物件，因此<strong>剛才介紹的簡化方法 (寫在 class 的屬性、方法內) 同樣適用於 ngClass 。</strong></p><p><strong>於是可以修改成這樣</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">ngClass</span>]=<span class="string">"&#123;'highlight': counter % 2 == 0&#125;"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>物件屬性就是要設定的 className ， 而不同於 ngStyle 的是，這個地方的值要輸入布林值。</strong></p><ul><li>當值為 True 時套用這個 className ，反之則不套用</li></ul><blockquote><p>接著新增 highlight 這個 className 吧</p></blockquote><p>header.component.scss<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>搞定，接著測試看看吧！</p></blockquote><p><img src="https://i.imgur.com/yLyoVkn.png" alt="當 counter 除以 2 餘數等於 0 時套用 highlight"></p><p><img src="https://i.imgur.com/Aglsviq.png" alt="當 counter 除以 2 餘數不等於 0 時不套用 highlight"></p><h3 id="ngClass-的簡單用法"><a href="#ngClass-的簡單用法" class="headerlink" title="ngClass 的簡單用法"></a>ngClass 的簡單用法</h3><p>聰明如你，想必已經猜到了如何使用，不囉嗦直接看範例！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> [<span class="attr">class.highlight</span>]=<span class="string">"counter % 2 == 0"</span>&gt;</span>Lorem ipsum dolor sit amet. &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>等號後方直接給布林值就可以了，這樣是不是更簡單了呢？</strong></p><blockquote><p>也就是說等號後方可以直接寫一個布林值、或者透過 class 內的屬性、方法回傳布林值，這些都是合法的。只要是 <code>True</code> 就套用這個 className ，反之則不套用。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>終於介紹完屬性型指令了，整理這些東西的時候不禁讓我回想起 Vue 裡面的 <code>:class</code> 、 <code>:style</code> 這些東西，而新學會的這些東西也是相當的好記，語法本身也是蠻簡單的。</p><p>接下來就是 Angular 的第三種指令 - 結構型指令囉！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      學完元件型指令後，接著介紹第二種 Angular 指令 - 屬性型指令 (Attribute Directives)
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.19 Angular 元件型指令 (Componemt Directives)</title>
    <link href="http://pvt5r486.github.io/f2e/20190528/2420780077/"/>
    <id>http://pvt5r486.github.io/f2e/20190528/2420780077/</id>
    <published>2019-05-28T08:16:56.000Z</published>
    <updated>2019-06-09T05:31:01.619Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接下來要介紹三種不同的 Angular 指令，而這裡的指令就是之前一直提到的 Directives 。 Angular 指令有元件型、屬性型、結構型這三種指令，接下來會一一介紹當中差異。</p><p><img src="https://images.unsplash.com/photo-1466618786657-4df462be674e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="三種-Angular-指令-Directives"><a href="#三種-Angular-指令-Directives" class="headerlink" title="三種 Angular 指令 ( Directives )"></a>三種 Angular 指令 ( Directives )</h2><ul><li>元件型指令<ul><li>預設的元件就是一個含有樣板的指令</li></ul></li><li>屬性型指令<ul><li>這種指令會修改元素的外觀或行為</li><li>如 ngStyle 、 ngClass 指令可以自由的調整樣式</li></ul></li><li>結構型指令<ul><li>這種指令會透過新增或者刪除 DOM 元素改變 DOM 結構</li><li>例如 ngIf 、 ngFor 、 ngSwitch 就可以控制 DOM 結構<ul><li>特別注意 ngSwitch 前面不要加上星號</li><li>ngIf 、 ngFor 、 ngSwitchDefault 、 ngSwitchCase 前面要加上 * 號</li></ul></li></ul></li></ul><h2 id="元件型指令"><a href="#元件型指令" class="headerlink" title="元件型指令"></a>元件型指令</h2><p>之前建立的 HeaderComponent 就是屬於元件型指令，它是 Component 同時也是 Directives 。</p><p>接下來再次新建一個 Component 練習吧，輸入 <code>ng g c footer</code> ，這次我們建立 FooterComponent 。</p><ul><li>同先前建立 HeaderComponent 步驟，在此不贅述，把程式碼搬運到對應檔案即可</li></ul><p>最後別忘了在 AppComponent 內輸入 FooterComponent 的元件型指令，也就是<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>接著測試看看是否正常運行</p></blockquote><p><img src="https://i.imgur.com/I91XvML.png" alt></p><h2 id="觀察-footer-component-ts"><a href="#觀察-footer-component-ts" class="headerlink" title="觀察 footer.component.ts"></a>觀察 footer.component.ts</h2><p>觀察 FooterComponent 的 <code>class</code> ，可以發現只要這是一個 Conponent ，那麼就一定會有一個 裝飾器 ( decorater ) 宣告在上方，如：</p><p><strong>FooterComponent</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-footer'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./footer.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./footer.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="裝飾器-decorater"><a href="#裝飾器-decorater" class="headerlink" title="裝飾器 ( decorater )"></a>裝飾器 ( decorater )</h3><ul><li>裝飾器的語法為 <code>@</code> 開頭，後面接一個 decorater 的名稱。<ul><li>所有的 Conponent 都會有一個名為 Conponent 的 decorater</li></ul></li><li>然後傳入一個物件，這個物件用來描述 Conponent 有哪些特性，如<ul><li><code>selector</code> 選取器</li><li><code>templateUrl</code> - 指出 template 路徑在哪裡，如果不輸入路徑也可以使用 <code>template</code> 屬性，直接輸入該 template 內容即可</li><li><code>styleUrl</code> - 與 <code>templateUrl</code> 不同，後面接的是一個陣列的型態，意思也就是可以輸入多個不同的 CSS 檔</li></ul></li></ul><h4 id="template-的例子，如果不想把-template-獨立成一個檔案，可以這麼寫"><a href="#template-的例子，如果不想把-template-獨立成一個檔案，可以這麼寫" class="headerlink" title="template 的例子，如果不想把 template 獨立成一個檔案，可以這麼寫"></a>template 的例子，如果不想把 template 獨立成一個檔案，可以這麼寫</h4><p><img src="https://i.imgur.com/MZkt7zW.png" alt="擷取畫面片段"></p><p>可以發現這麼做之後，網頁的 footer 仍然是正常的。<br><img src="https://i.imgur.com/D6TCONp.png" alt></p><blockquote><p>不過還是建議獨立成一個檔案比較好，畢竟這樣子實在是不容易閱讀。</p></blockquote><p><strong>事實上裝飾器內可以使用的屬性還有非常多，用到時再查文件就可以了。</strong></p><h4 id="styleUrl-的例子，來寫一點-CSS"><a href="#styleUrl-的例子，來寫一點-CSS" class="headerlink" title="styleUrl 的例子，來寫一點 CSS"></a>styleUrl 的例子，來寫一點 CSS</h4><p>這個檔案是由 Angular CLI 自動幫我們產生的，因此預設是空白的，讓我們隨意寫一點樣式吧。</p><ul><li>把 footer 底下的 copyright 字樣改成黃色<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-muted credit"</span>&gt;</span></span><br><span class="line">  Copyright © 2016 by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.facebook.com/will.fans"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>XCVGYU<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  @ <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.miniasp.com/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>XCVGYUXCVGYU<span class="tag">&lt;/<span class="name">a</span>&gt;</span> -</span><br><span class="line">  Powered by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://dotnetblogengine.net/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>BlogEngine.NET<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 3.2.0.3 -</span><br><span class="line">  Design by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://seyfolahi.net/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"Farzin Seyfolahi - UI/UX Designer at BlogEngine.NET"</span>&gt;</span>FS<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>調整 <code>credit</code> ，這邊為了方便示範所以直接使用 <code>!important</code> 強制覆蓋。<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.credit</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著執行開發伺服器查看效果：<br><img src="https://i.imgur.com/KAhwMgt.png" alt></p><h2 id="元件內的-CSS-不會影響到其他元件？"><a href="#元件內的-CSS-不會影響到其他元件？" class="headerlink" title="元件內的 CSS 不會影響到其他元件？"></a>元件內的 CSS 不會影響到其他元件？</h2><p>之前有提到，在這裡設定的 CSS 只會套用到該元件，不會影響到其他元件，超出 FooterComponent 範圍外的通通不會吃到這裡設定的 CSS 樣式。</p><p>這可以透過開發者工具觀察 Angular 是如何辦到的！</p><p><img src="https://i.imgur.com/acBHG8e.png" alt></p><p>Angular 在這些動態產生的 diretive 下所有的標籤全都被加上了一個底線開頭的 attribute 屬性，而且有一定的規律可循。</p><p><strong>像是根元件上的 <code>_nghost-tij-c0</code> ， 0 是個編號，只要遇到不重複的 Component 就會有一個唯一的、不重複的編號。</strong></p><blockquote><p>.credit 類別被動態注入到頁面上時，它的選取器並不是單純的 .credit ，而是 .credit 後面加上中括號包覆 attribute 的選取器。</p></blockquote><p>而這個 attribute 剛才說過是個<strong>唯一</strong>的值，這也是為什麼寫在元件內的 CSS 不會影響到其他元件的原因。</p><p><img src="https://i.imgur.com/XEsLNeF.png" alt></p><h2 id="讓元件內的-CSS-會影響到其他元件"><a href="#讓元件內的-CSS-會影響到其他元件" class="headerlink" title="讓元件內的 CSS 會影響到其他元件"></a>讓元件內的 CSS 會影響到其他元件</h2><p>可以在裝飾器內新增一個屬性 <code>encapsulation</code> ，要把這部分的封裝調整成 <code>none</code> ，具體設定如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-footer'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./footer.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./footer.component.scss'</span>],</span><br><span class="line">  encapsulation: ViewEncapsulation.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/pt2v0H9.png" alt></p><ul><li>預設是 <code>Emulated</code> ，也就是模擬的意思，就是指 CSS Style 的封裝，<ul><li>在此要把它改成 <code>none</code> ，意思是不需要進行 CSS Style 的封裝。</li></ul></li></ul><p><strong>如此一來，這個 .credit 就會渲染到整個網頁了。</strong></p><p><img src="https://i.imgur.com/bDBRwp7.png" alt="Image"></p><blockquote><p>設定後，現在當 .credit 類別被動態注入到頁面上時，它的選取器已經是單純的 .credit 了，也就是說這個網頁所有用到 .credit 這個 class 都會吃到字體顏色變成黃色的設定。</p></blockquote><p><strong>以上就是元件型指令在使用上可能會用到的一些設定與注意事項，接下來要介紹的是屬性型指令。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接下來要介紹三種不同的 Angular 指令，而這裡的指令就是之前一直提到的 Directives 。 Angular 指令有元件型、屬性型、結構型這三種指令，接下來會一一介紹當中差異。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.18 認識範本參考變數</title>
    <link href="http://pvt5r486.github.io/f2e/20190528/591780736/"/>
    <id>http://pvt5r486.github.io/f2e/20190528/591780736/</id>
    <published>2019-05-28T07:03:37.000Z</published>
    <updated>2019-06-09T05:31:07.258Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>結束資料繫結的學習後，接著介紹關於範本參考變數 ( Template Reference Variables ) ，讓我們一起看看吧！</p><p><img src="https://images.unsplash.com/photo-1494256997604-768d1f608cac?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1101&amp;q=80" alt></p><h2 id="範本參考變數-Template-reference-variables"><a href="#範本參考變數-Template-reference-variables" class="headerlink" title="範本參考變數 ( Template reference variables )"></a>範本參考變數 ( Template reference variables )</h2><p>從字面上來解讀，這是一種可以用在 Template 上的一種設定變數的方式。</p><ul><li><p>它的語法就是在任意的標籤裡面使用一個 # 字號加上一個變數名稱，如 <code>#name</code> 。</p><ul><li>會在這個 Template 中建立一個名為 name 的區域變數</li><li>該變數僅存在於目前這個元件 Template 中</li><li>而這個區域變數會儲存這個標籤的 DOM 物件</li><li>可以透過<strong>事件繫結</strong>將任意 DOM 物件傳回元件類別中 ( Component Class )</li></ul></li><li><p>以下語法完全相等，差別在於使用 # 字號是語法糖</p><ul><li><code>#name</code></li><li><code>ref-name</code></li></ul></li></ul><h2 id="實際宣告範本參考變數"><a href="#實際宣告範本參考變數" class="headerlink" title="實際宣告範本參考變數"></a>實際宣告範本參考變數</h2><p>我們將修改上次那份計算輸入字數的 Template ，觀察當中的差異。</p><blockquote><p>需要特別注意的是，替範本參考變數取名時，盡量不要與之前設定過的屬性 ( Property ) 重複名稱，否則可能會有一些問題產生。</p></blockquote><p><strong>Template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"請輸入搜尋關鍵字"</span> <span class="attr">accesskey</span>=<span class="string">"s"</span></span></span><br><span class="line"><span class="tag">      #<span class="attr">tinputValue</span></span></span><br><span class="line"><span class="tag">      [(<span class="attr">ngModel</span>)]=<span class="string">"inputValue"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keydown.escape</span>)=<span class="string">"cleanInput()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"搜尋"</span> <span class="attr">id</span>=<span class="string">"searchbutton"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  輸入文字：&#123;&#123;inputValue&#125;&#125; 目前字數 <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;tinputValue.value.length&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>於是在普通的 input 上設定一組範本參考變數 <code>#tinputValue</code> ，此時 <code>#tinputValue</code> 的值會是這個 input 的 DOM 物件。</strong></p><p>因此可以直接操作 DOM 物件，取得當中的 <code>value</code> 屬性並且計算其長度，而這個部分就是所謂的範本參考變數。</p><p>而且可在任何標籤上，設定唯一的範本參考變數，只要名稱不同即可。</p><h2 id="建立一個新元件-HeaderComponent"><a href="#建立一個新元件-HeaderComponent" class="headerlink" title="建立一個新元件 HeaderComponent"></a>建立一個新元件 HeaderComponent</h2><p>範本參考變數除了使用在一般的 HTML 標籤上，也可以使用在 Directive ，具體來說怎麼做呢？</p><ul><li>建立一個新的 Component<ul><li>輸入 <code>ng g c header</code> 建立新的 Component ，並且取名叫 header</li></ul></li><li>將網頁中 header 區塊移入這個 Component ，並將新的 Component 加到 AppComponent 的 template 內</li><li>因為 HeaderComponent 內有使用到一些屬性，因此還需要調整 <code>class</code> 內的程式碼<ul><li>到 app.component.ts 內把有用到的屬性都搬到 header.component.ts</li></ul></li></ul><p><strong>調整完畢後 header.component.ts 內容如下</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-header'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著運行開發伺服器，確認 HeaderComponent 是否正確執行。</p><p><img src="https://i.imgur.com/FFXIzam.png" alt></p><blockquote><p>看來是設定成功了，接著我們要在這個 Directive 上使用範本參考變數。</p></blockquote><h3 id="在-Directive-上使用範本參考變數"><a href="#在-Directive-上使用範本參考變數" class="headerlink" title="在 Directive 上使用範本參考變數"></a>在 Directive 上使用範本參考變數</h3><p>首先一樣在 <code>&lt;app-header #tHeader&gt;&lt;/app-header&gt;</code> 上加入 <code>#tHeader</code> ，意思是建立一個範本參考變數。</p><p>接著我們隨意找一個 HTML 標籤上加入事件繫結，如：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span> (<span class="attr">click</span>)=<span class="string">"tHeader."</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>這時會發現 VS Code 會跳出 HeaderComponent 內所有的屬性給我們選取。</p><p><img src="https://i.imgur.com/HxNDtCn.png" alt></p><p><img src="https://i.imgur.com/HpTtvaJ.png" alt="HeaderComponent 內所有的屬性"></p><p>之前說如果把範本參考變數使用在普通的 HTML 標籤上，則代表的值是該標籤的 DOM 物件。</p><p><strong>而如果把範本參考變數使用在 directive 上，則代表的值就是背後所對應的 Component ，在這個範例內也就是 HeaderComponent 。</strong></p><p>因此可以存取這個 Component 底下所有的屬性，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span> (<span class="attr">click</span>)=<span class="string">"tHeader.title='Title Change'"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接著運行開發伺服器，並且任意的點一下，觀察標題是否改變。</p><p><img src="https://i.imgur.com/DVAoHNV.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上就是範本參考變數在 Directive 上的應用，值得一提的是<strong>範本參考變數只能在範本( Template ) 內使用，在 Component 內預設是沒辦法使用的</strong>。不過還是有一些進階的技巧可以幫助我們在 Component 中取用範本參考變數，但眼下還是先學習其他基礎的部分吧，進階技巧等之後碰到再來談。</p><p>directive 看了很多次但卻不太清楚是什麼意思，接下來要好好針對這個名詞做了解囉。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      結束資料繫結的學習後，接著介紹關於範本參考變數 ( Template reference variables ) ，讓我們一起看看吧！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.17 資料繫結的四種方法 - 雙向繫結</title>
    <link href="http://pvt5r486.github.io/f2e/20190527/2547380556/"/>
    <id>http://pvt5r486.github.io/f2e/20190527/2547380556/</id>
    <published>2019-05-27T12:15:02.000Z</published>
    <updated>2019-06-09T05:31:11.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>終於來到資料繫結的第四種方法 - 雙向繫結 ( Two-way Binding ) 了，而這種繫結方式跟其他三種有何不同呢？</p><p><img src="https://images.unsplash.com/photo-1509092909911-0dbb345f4de9?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1004&amp;q=80" alt></p><h2 id="雙向繫結-Two-way-Binding"><a href="#雙向繫結-Two-way-Binding" class="headerlink" title="雙向繫結 ( Two-way Binding )"></a>雙向繫結 ( Two-way Binding )</h2><p>到目前為止介紹了三種資料繫結的方法，分別是內嵌繫結、屬性繫結、事件繫結，這三種的前兩種都是屬於從 Component 單向將資料傳送到 Template 的繫結方式。而事件繫結也算是單向的繫結方式，這是從 Template 內透過瀏覽器的事件觸發之後呼叫 Component 內的方法。</p><p>而我們這次要介紹的繫結方式就是雙向的繫結方式，這種繫結方式會自動的做到屬性繫結與事件繫結，也因此我們寫的程式碼會更少、更精簡。</p><h3 id="拿上一篇的練習改寫，使其具有雙向繫結效果"><a href="#拿上一篇的練習改寫，使其具有雙向繫結效果" class="headerlink" title="拿上一篇的練習改寫，使其具有雙向繫結效果"></a>拿上一篇的練習改寫，使其具有雙向繫結效果</h3><p>我們將之前的練習改寫，見識見識雙向繫結的威力。</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"請輸入搜尋關鍵字"</span> <span class="attr">accesskey</span>=<span class="string">"s"</span></span></span><br><span class="line"><span class="tag">      [(<span class="attr">ngModel</span>)]=<span class="string">"inputValue"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">input</span>)=<span class="string">"calcLength($event.target.value)"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keydown.escape</span>)=<span class="string">"cleanInput($event.target)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"搜尋"</span> <span class="attr">id</span>=<span class="string">"searchbutton"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  目前字數 <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputStrLen&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>要使用雙向繫結的話辦法相當簡單，使用 <code>[(ngModel)]</code> 語法後面接一個想要雙向繫結並且在 component 內的屬性即可。</p></blockquote><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  inputValue = <span class="string">''</span>;</span><br><span class="line">  inputStrLen = <span class="number">0</span>;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  calcLength(str: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputStrLen = str.length;</span><br><span class="line">  &#125;</span><br><span class="line">  cleanInput(inputEl: HTMLInputElement) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputStrLen = <span class="number">0</span>;</span><br><span class="line">    inputEl.value = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>當運行開發伺服器後會發現， Angular 又掛掉了。</p></blockquote><p><img src="https://i.imgur.com/wWIBDi1.png" alt></p><p><strong>意思就是 Angular 看不懂 ngModel 這個屬性是什麼。</strong></p><p>也就是說如果我們想要使用雙向繫結，還有一個步驟要做，那就是把 Angular 表單的模組匯入到 AppModule 內。</p><p><strong>於是打開 AppModule 這支檔案進行修改</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>修改完成後，再次運行開發伺服器，發現可以成功運行網頁了，但我們還需要調整程式碼的部分。</p></blockquote><p>可以透過內嵌繫結，測試一下剛才設置的雙向繫結 <code>inputValue</code> 有沒有成功</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"請輸入搜尋關鍵字"</span> <span class="attr">accesskey</span>=<span class="string">"s"</span></span></span><br><span class="line"><span class="tag">      [(<span class="attr">ngModel</span>)]=<span class="string">"inputValue"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">input</span>)=<span class="string">"calcLength($event.target.value)"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keydown.escape</span>)=<span class="string">"cleanInput($event.target)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"搜尋"</span> <span class="attr">id</span>=<span class="string">"searchbutton"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  輸入文字：&#123;&#123;inputValue&#125;&#125; 目前字數 <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputStrLen&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/ezQ1Zwd.png" alt></p><p><strong>藉由這個測試知道，目前這個 input 的輸入框跟 component 內的 <code>inputValue</code> 已經建立了雙向繫結。</strong></p><h2 id="完成這個練習"><a href="#完成這個練習" class="headerlink" title="完成這個練習"></a>完成這個練習</h2><p>我們已經成功地建立了雙向繫結，接著把其他地方的程式碼也修改一下吧。</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"請輸入搜尋關鍵字"</span> <span class="attr">accesskey</span>=<span class="string">"s"</span></span></span><br><span class="line"><span class="tag">      [(<span class="attr">ngModel</span>)]=<span class="string">"inputValue"</span></span></span><br><span class="line"><span class="tag">      (<span class="attr">keydown.escape</span>)=<span class="string">"cleanInput()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"搜尋"</span> <span class="attr">id</span>=<span class="string">"searchbutton"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  輸入文字：&#123;&#123;inputValue&#125;&#125; 目前字數 <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputValue.length&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  inputValue = <span class="string">''</span>;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cleanInput() &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputValue = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>搞定！最後運行開發伺服器，測試功能是否仍然正常。</p></blockquote><p><img src="https://i.imgur.com/KxfP696.png" alt></p><h2 id="雙向繫結不是萬靈丹"><a href="#雙向繫結不是萬靈丹" class="headerlink" title="雙向繫結不是萬靈丹"></a>雙向繫結不是萬靈丹</h2><p>雙向繫結既然這麼好用，我們是不是應該不管怎麼樣都使用雙向繫結呢？</p><p>事實上，過度濫用雙向繫結也會給網頁效能造成一些負擔，可能導致網頁的反應會變慢，但具體來說還是得看實際狀況而定就是了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這裡我們已經學會了 Angular 內四種資料繫結的方式了，接下來要介紹的是範本參考變數。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      終於來到資料繫結的第四種方法 - 雙向繫結 ( Two-way Binding ) 了，而這種繫結方式跟其他三種有何不同呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.16 實作練習</title>
    <link href="http://pvt5r486.github.io/f2e/20190527/1236863731/"/>
    <id>http://pvt5r486.github.io/f2e/20190527/1236863731/</id>
    <published>2019-05-27T11:43:24.000Z</published>
    <updated>2019-06-09T05:31:15.216Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>學習完三種資料繫結方法後，雖然還有一種尚未提到，但是我們已經可以嘗試寫一點有趣的東西了，因此弄了 2 題小問題來測試自己有沒有完全吸收。</p><p><img src="https://images.unsplash.com/photo-1522793626404-2103bc5bbf7d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="題目需求"><a href="#題目需求" class="headerlink" title="題目需求"></a>題目需求</h2><p><img src="https://i.imgur.com/P38xdP9.png" alt><br>如圖所示，希望實作出兩個小功能</p><ul><li>能自動計算輸入的字數</li><li>按下 ESC 鍵時能清空輸入</li></ul><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><p>沒有遇到太多的困難，主要是查詢有什麼事件可以使用。</p><ul><li>輸入這部分我使用了 <a href="http://www.runoob.com/jsref/event-oninput.html" rel="external nofollow noopener noreferrer" target="_blank">oninput 事件</a></li><li>然而要求按下 ESC 鍵時能清空輸入，這部分則是使用 <a href="http://www.runoob.com/jsref/event-onkeydown.html" rel="external nofollow noopener noreferrer" target="_blank">onkeydown 事件</a><ul><li>而這部分一開始我沒想到原來有類似 Vue 的事件修飾符可以使用，所以是使用 if 判斷，後來才改用事件修飾符</li></ul></li><li>在目前字數那一區塊使用內嵌繫結來計算字數</li></ul><p><strong>因此調整後的 template 如下：</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"請輸入搜尋關鍵字"</span> <span class="attr">accesskey</span>=<span class="string">"s"</span> </span></span><br><span class="line"><span class="tag">      (<span class="attr">input</span>)=<span class="string">"calcLength($event.target.value)"</span> </span></span><br><span class="line"><span class="tag">      (<span class="attr">keydown.escape</span>)=<span class="string">"cleanInput($event.target)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"搜尋"</span> <span class="attr">id</span>=<span class="string">"searchbutton"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  目前字數 <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputStrLen&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line">**接著來到 component 補上適當的程式碼**</span><br><span class="line">```js</span><br><span class="line">import &#123; Component &#125; from '@angular/core';</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: 'app-root',</span><br><span class="line">  templateUrl: './app.component.html',</span><br><span class="line">  styleUrls: ['./app.component.scss']</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  title = 'firstAngular';</span><br><span class="line">  link = 'http://www.google.com';</span><br><span class="line">  imgUrl = '/assets/images/logo.png';</span><br><span class="line">  inputStrLen = 0;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    if (altKey) &#123;</span><br><span class="line">      this.title = 'changeTitle';</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  calcLength(str: string) &#123;</span><br><span class="line">    this.inputStrLen = str.length;</span><br><span class="line">  &#125;</span><br><span class="line">  cleanInput(inputEl: HTMLInputElement) &#123;</span><br><span class="line">    this.inputStrLen = 0;</span><br><span class="line">    inputEl.value = '';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>程式碼的部分，卡最久的地方卻是「不知道怎麼定義型別符合 TypeScript 的規則又能清除 input」。</p></blockquote><p>因為我以為 <code>$event.target</code> 要填的是 <code>KeyboardEvent</code> ，因為我使用的是 onkeydown 事件，後來發現不是這麼一回事。而是要根據傳入參數的型別來寫，折騰了好一陣才知道要寫 <code>HTMLInputElement</code> 。</p><p>其實可以不要定義型別就沒有這些問題。但我想既然都要寫 TypeScript 了，就還是好好的學習如何正確撰寫 TypeScript ，才是正道。</p><h2 id="成果截圖"><a href="#成果截圖" class="headerlink" title="成果截圖"></a>成果截圖</h2><p><img src="https://i.imgur.com/t8jRsYy.png" alt="成功計算字數"></p><p><img src="https://i.imgur.com/GYpoN3u.png" alt="按下 ESC 清空"></p><p><a href="https://github.com/pvt5r486/firstAngular" rel="external nofollow noopener noreferrer" target="_blank">成果範例 GitHub</a></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>嗯，看起來是沒有什麼大問題，只是還不太熟 TypeScript 以及 Angular 的語法。</p><p>接下來要講到最後一種繫結方式囉！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      學習完三種資料繫結方法後，雖然還有一種尚未提到，但是我們已經可以嘗試寫一點有趣的東西了，因此弄了 2 題小問題來測試自己有沒有完全吸收。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.15 資料繫結的四種方法 - 事件繫結</title>
    <link href="http://pvt5r486.github.io/f2e/20190527/2149510389/"/>
    <id>http://pvt5r486.github.io/f2e/20190527/2149510389/</id>
    <published>2019-05-27T08:38:10.000Z</published>
    <updated>2019-06-09T05:31:19.130Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Angular 內，第三種資料繫結的方法是事件繫結 ( Event Binding )，具體來說怎麼實踐，讓我們繼續看下去。</p><p><img src="https://images.unsplash.com/photo-1473849353781-2533844cec8d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=967&amp;q=80" alt></p><h2 id="事件繫結-Event-Binding"><a href="#事件繫結-Event-Binding" class="headerlink" title="事件繫結 ( Event Binding )"></a>事件繫結 ( Event Binding )</h2><p>這是我們目前網頁上的一張 Q 版的 chrome LOGO ，假設我們要在這張圖片加上 Click 點擊事件，點下去之後網站標題會跟著改變。</p><p><img src="https://i.imgur.com/TyNJYHP.png" alt></p><h3 id="事件繫結語法-一"><a href="#事件繫結語法-一" class="headerlink" title="事件繫結語法 (一)"></a>事件繫結語法 (一)</h3><p>在事件中間加上 「-」，代表這是 Angular 的語法，並且在雙引號內放入 function ，但是在 <strong>Angular 內並沒有 function 只有類別</strong>，而<strong>類別內只有屬性以及方法</strong>。</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">on-click</span>=<span class="string">"changeTitle()"</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span> [<span class="attr">attr.data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>讓我們宣告一個方法叫做 <code>changeTitle</code> 。</p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  changeTitle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="事件繫結語法-二"><a href="#事件繫結語法-二" class="headerlink" title="事件繫結語法 (二)"></a>事件繫結語法 (二)</h3><p>除了上述的作法外，也可以使用這種方式添加事件繫結。</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> (<span class="attr">click</span>)=<span class="string">"changeTitle()"</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span> [<span class="attr">attr.data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>這樣的方式跟上一篇提到的屬性繫結是不是有點相似呢？</p><p><strong>差別在於屬性繫結是使用中括號 [] 表示，而事件繫結是使用小括號 () 表示。</strong></p><p>而大部分的 Angular 開發者都是使用第二種方法來進行事件綁定，較少使用第一種方法。</p><h3 id="接著運行開發伺服器，測試看看結果。"><a href="#接著運行開發伺服器，測試看看結果。" class="headerlink" title="接著運行開發伺服器，測試看看結果。"></a>接著運行開發伺服器，測試看看結果。</h3><p><img src="https://i.imgur.com/5shPMfI.png" alt="點擊 LOGO 後"></p><p>標題的確被更新了，但這是怎麼辦到的呢？</p><h3 id="事件繫結的背後"><a href="#事件繫結的背後" class="headerlink" title="事件繫結的背後"></a>事件繫結的背後</h3><p>我們在 LOGO 上執行了 Click 動作，然後註冊 Angular 的事件繫結，而這個事件繫結到了 <code>changeTitle</code> 方法，因此當有人點了 LOGO 時，就會跳到 AppComponent 內去執行 <code>changeTitle</code> 方法。</p><p>而這個方法會藉由執行 <code>this.title = &#39;changeTitle&#39;;</code> 來變更 class 內的 <code>title</code> 屬性，又因為先前我們對網站標題使用了內嵌繫結，所以當 class 內的 <code>title</code> 屬性有異動時， Angular 就會管理頁面 DOM 的狀態，也就是所有頁面中有繫結 <code>title</code> 屬性的地方一起改變。</p><h2 id="事件繫結-使用-event-參數"><a href="#事件繫結-使用-event-參數" class="headerlink" title="事件繫結 - 使用 $event 參數"></a>事件繫結 - 使用 $event 參數</h2><p>當撰寫事件繫結時必須要傳入一個方法，預設可以不用傳入任何參數，但是在這裡確實可以傳入一個很特別的參數 <code>$event</code> ，讓我們觀察看看。</p><p><strong>這個 <code>$event</code> 可以幫助我們取得事件的詳細資訊</strong></p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> (<span class="attr">click</span>)=<span class="string">"changeTitle($event)"</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span> [<span class="attr">attr.data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  changeTitle($event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log($event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著運行開發伺服器，按下 F12 開啟開發者工具並點擊 LOGO 圖案。</p><p><img src="https://i.imgur.com/bIwuT8k.png" alt></p><blockquote><p>可以看到跑出了很多東西，而這個 MouseEvent 其實就是 DOM 的 MouseEvent ，因此這一次觸發的滑鼠事件內可以找到相當多的屬性。</p></blockquote><h3 id="event-參數內-target"><a href="#event-參數內-target" class="headerlink" title="$event 參數內 - target"></a>$event 參數內 - target</h3><p><code>target</code> 屬性代表的是剛剛點下去的那個 DOM 物件，例如說剛剛我們是點擊 img 觸發的，也就是說它的 <code>target</code> 屬性會是：</p><p><img src="https://i.imgur.com/xWBHVGL.png" alt="img 標籤的 DOM"></p><h3 id="event-參數內-altkey"><a href="#event-參數內-altkey" class="headerlink" title="$event 參數內 - altkey"></a>$event 參數內 - altkey</h3><p><code>altkey</code> 屬性代表的是點擊時有沒有按下 「alt」 這個按鍵，因此我們可以替剛剛那個範例加上一個新的需求，必須要按下 「alt」 這個按鍵才可以更改標題。</p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  changeTitle($event) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($event.altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log($event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我在這邊踩到了一的雷，那就是 altKey 的 K 是大寫，因此這部分要特別注意英文的大小寫部分。</p><blockquote><p>搞定！運行開發伺服器測試看看</p></blockquote><p><img src="https://i.imgur.com/vz5vUD6.png" alt></p><p><strong>但是這個部分可以有更好的寫法，那就是使用具有型別的 $event 參數</strong></p><h2 id="事件繫結-使用具有型別-event-參數"><a href="#事件繫結-使用具有型別-event-參數" class="headerlink" title="事件繫結 - 使用具有型別 $event 參數"></a>事件繫結 - 使用具有型別 $event 參數</h2><p>在上一個範例裡，因為英文的大小寫導致程式沒有按我們預期的跑，但我們現在是使用 TypeScript 進行開發，所以我們可以利用 TypeScript 帶來的好處，利用型別來標註參數的型別，具體來說我們可以這麼做:</p><ul><li>由剛才範例可知 <code>$event</code> 的內容其實是 MouseEvent<ul><li>也就是說傳入方法的參數其實是 MouseEvent 的型別</li></ul></li></ul><p>因此可以在 <strong>Component</strong> 內這麼寫：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  changeTitle($event: MouseEvent) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($event.altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log($event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著神奇的事情發生了，當我們輸入 <code>$event</code> 並按下 <code>.</code> 時，VS Code 會列出所有 MouseEvent 內所有可以選擇的屬性。</p><p><img src="https://i.imgur.com/KcPe3tN.png" alt></p><h3 id="巧妙的利用型別重構"><a href="#巧妙的利用型別重構" class="headerlink" title="巧妙的利用型別重構"></a>巧妙的利用型別重構</h3><p>我們知道可以在事件繫結中傳入 <code>$event</code> 參數，但其實這個部分可以更進一步的改寫，並且結合剛才的提到的型別，例如：</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> (<span class="attr">click</span>)=<span class="string">"changeTitle($event.altKey)"</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span> [<span class="attr">attr.data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>可以直接在這個地方就傳入 <code>$event.altKey</code> 。</p></blockquote><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">  changeTitle(altKey: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (altKey) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'changeTitle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然而因為 <code>$event.altKey</code> 的值是 true 或 false ，因此型別是布林。</p><p>接著可以再次確認運作是否正常。</p><p><img src="https://i.imgur.com/9MUzB9n.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在事件繫結中，有些同樣的事情會有不同的方法可以實作，至於要用哪種方式撰寫就見仁見智了。對我來說，怎麼樣的寫法是易懂又容易維護的，那就是值得學習的好方法。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在 Angular 內，第三種資料繫結的方法是事件繫結 ( Event Binding )，具體來說怎麼實踐，讓我們繼續看下去。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.14 資料繫結的四種方法 - 屬性繫結</title>
    <link href="http://pvt5r486.github.io/f2e/20190527/2295068610/"/>
    <id>http://pvt5r486.github.io/f2e/20190527/2295068610/</id>
    <published>2019-05-27T07:08:05.000Z</published>
    <updated>2019-06-09T05:31:23.911Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>學習完內嵌繫結後，接著介紹到 Angular 第二種資料繫結方式 屬性繫結 ( Property Binding )。話不多說讓我們馬上開始吧！</p><p><img src="https://images.unsplash.com/photo-1518467166778-b88f373ffec7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1489&amp;q=80" alt></p><h2 id="屬性繫結-Property-Binding"><a href="#屬性繫結-Property-Binding" class="headerlink" title="屬性繫結 ( Property Binding )"></a>屬性繫結 ( Property Binding )</h2><blockquote><p>值得注意的是屬性繫結 ( Property Binding ) 的屬性英文單字是 Property ，而 Attribute 的中文翻譯也叫做屬性。因此很有可能跟上一篇介紹到的內嵌繫結也可以應用在 HTML 標籤的屬性 ( Attribute ) 上搞混。</p></blockquote><p><strong>實際看個例子，這次我們不使用內嵌繫結來改變 <code>a</code> 標籤上的 <code>href</code> 屬性：</strong></p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> [<span class="attr">href</span>]=<span class="string">"link"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>打開開發伺服器，觀察 <code>a</code> 標籤上的 <code>href</code> 屬性，發現跟內嵌繫結是一模一樣的。</p><p><img src="https://i.imgur.com/TosD0M6.png" alt></p><p><strong>同理，也可以對 img 圖片做屬性繫結：</strong></p><p><strong>component</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">  imgUrl = <span class="string">'/assets/images/logo.png'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/oUPUBst.png" alt></p><h2 id="Property-與-Attribute-的差異"><a href="#Property-與-Attribute-的差異" class="headerlink" title="Property 與 Attribute 的差異"></a>Property 與 Attribute 的差異</h2><p>接下來透過一些範例，釐清 Property 與 Attribute 的差異。</p><h3 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h3><p>一般而言，要擴充 HTML 標籤上的 Attribute 會使用 <code>data-*</code> 自由的擴充 HTML 標籤上的 Attribute ，例如：</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span>　<span class="attr">data-title</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>接著我們可以實驗看看自訂的 HTML Attribute 可不可以使用屬性繫結。</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span>　[<span class="attr">data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>運行開發伺服器，可以發現錯誤訊息</p><p><img src="https://i.imgur.com/j9Xjjes.png" alt></p><blockquote><p>這段訊息大意上是說，綁定 Property 的時候， Angular 發現 <code>img</code> 底下並沒有 <code>data-title</code> 這個 Property ，因為 <code>data-title</code> 是我們自訂的 Attribute ，因此不能任意的使用屬性繫結，儘管它們中文翻譯都是<strong>屬性</strong>。</p></blockquote><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><p>運行開發伺服器，並且使用開發工具觀察 <code>img</code> 標籤，可以看到非常多的 attribute。</p><p><img src="https://i.imgur.com/JMcDMw0.png" alt="Image"></p><p>這個標籤裡面 <code>class</code> 、 <code>title</code> 、 <code>src</code> 都是 Attribute</p><p>然而什麼是 Property 呢？</p><blockquote><p>如果想知道 <code>img</code> 標籤的 Property ，可以查詢 <code>img</code> 的 DOM 物件所有的 Property 。</p></blockquote><p><strong>透過開發者工具查詢</strong><br>可以點選 Properties 頁籤，切換過去後就可以看到 <code>img</code> 標籤下所有的 Property 了。</p><p><img src="https://i.imgur.com/jXdpnzC.png" alt></p><p>而在這裡面可以發現如 <code>class</code> 、 <code>title</code> 、 <code>src</code> 的 Property 。</p><h3 id="什麼叫做-屬性繫結-Property-Binding"><a href="#什麼叫做-屬性繫結-Property-Binding" class="headerlink" title="什麼叫做 屬性繫結 ( Property Binding )"></a>什麼叫做 屬性繫結 ( Property Binding )</h3><p><strong>屬性繫結 ( Property Binding ) 真正的對象，其實是 HTML 標籤下 DOM 的 Property ，而不是指 HTML 標籤上的 Attribute 。</strong></p><blockquote><p>套用在剛才的範例上就是 <code>img</code> 標籤，這一個 DOM 的 Property。</p></blockquote><h3 id="透過標準的作法讓剛才自訂的-Attribute-也能使用屬性繫結"><a href="#透過標準的作法讓剛才自訂的-Attribute-也能使用屬性繫結" class="headerlink" title="透過標準的作法讓剛才自訂的 Attribute 也能使用屬性繫結"></a>透過標準的作法讓剛才自訂的 Attribute 也能使用屬性繫結</h3><p>其實方法也不困難，只需要在前面補上 <code>attr.</code> ，如：</p><p><strong>template</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> [<span class="attr">title</span>]=<span class="string">"title"</span> [<span class="attr">src</span>]=<span class="string">"imgUrl"</span>　[<span class="attr">attr.data-title</span>]=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"pull-left logo"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>這樣子就可以成功設定 data Attribute 的自動綁定。</p><p>這時我們可以再次回到網頁上觀察情況。</p><p><img src="https://i.imgur.com/HstJv91.png" alt></p><p>可以發現 data-title 這個 Attribute 被綁定，而且也可以使用屬性繫結方法了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>屬性繫結的用法也是蠻直觀的，沒有太多困難的語法要記憶，只是要搞清楚 Attribute 與 Property 的差異，而就算忘記了也沒關係，畢竟開發者工具是這麼的好用，只要到 Properties 頁籤上就可以看到這一個 DOM 所有的 Property 了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      學習完內嵌繫結後，接著介紹到 Angular 第二種資料繫結方式 屬性繫結 ( Property Binding )。話不多說讓我們馬上開始吧！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.13 資料繫結的四種方法 - 內嵌繫結</title>
    <link href="http://pvt5r486.github.io/f2e/20190527/123375935/"/>
    <id>http://pvt5r486.github.io/f2e/20190527/123375935/</id>
    <published>2019-05-27T06:22:10.000Z</published>
    <updated>2019-06-09T05:31:28.170Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接著介紹 Angular 中是如何進行資料繫結的，以及 Angular 內共有幾種資料繫結的方式呢？</p><p><img src="https://images.unsplash.com/photo-1556227834-c4b0b0f7d533?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1041&amp;q=80" alt></p><h2 id="何謂資料繫結"><a href="#何謂資料繫結" class="headerlink" title="何謂資料繫結"></a>何謂資料繫結</h2><p>在 Angular 內總共有四種資料繫結的方法，分別是</p><ul><li>內嵌繫結 ( interpolation )<ul><li>{{property}}</li></ul></li><li>屬性繫結 ( Property Binding )<ul><li>[property] = ‘statemant’</li></ul></li><li>事件繫結 ( Event Binding )<ul><li>(event) = ‘someMethod($event)’</li></ul></li><li>雙向繫結 ( Two-way Binding )<ul><li>[(ngModel)] = ‘property’</li></ul></li></ul><p><strong>接下來我們將分成好幾篇逐步介紹這些繫結的方法。</strong></p><h2 id="內嵌繫結-interpolation"><a href="#內嵌繫結-interpolation" class="headerlink" title="內嵌繫結 ( interpolation )"></a>內嵌繫結 ( interpolation )</h2><p>之前把靜態網頁版型加到 Angular 專案內以 Component 方式管理後就沒有再動過了，這回我們從 <code>app.component.ts</code> 這裡開始。</p><p><strong><code>app.component.ts</code> 內容</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到這個元件裡面除了一些必要的程式碼之外，沒有其他的東西了，相當的單純。而 <code>class</code> 裡面有一個 <code>title</code> 的屬性，這是一開始我們建立專案時 Angular CLI 自動幫我們添加的。</p><p>接著來到 <code>app.component.html</code> ，可將 <code>&lt;h1&gt;</code> 標籤處使用內嵌繫結 ( interpolation ) 的語法，替換成 <code>class</code> 內的 <code>title</code> 的屬性。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>打開 Angular 開發伺服器，可以觀察到 <code>&lt;h1&gt;</code> 標籤內容的確是 <code>title</code> 的屬性值。</p><p><img src="https://i.imgur.com/6PDNO3P.png" alt></p><p>內嵌繫結是屬於單向的繫結，也就是說<strong>畫面上呈現的 <code>title</code> 資料，只會從 Component 內把值傳送給 template 顯示。</strong></p><h2 id="把內嵌繫結用於屬性上"><a href="#把內嵌繫結用於屬性上" class="headerlink" title="把內嵌繫結用於屬性上"></a>把內嵌繫結用於屬性上</h2><p><strong>內嵌繫結的語法除了放在標籤內，也可以使用在 HTML 標籤的屬性上。</strong></p><p>舉個例子，我們在 <code>app.component.ts</code> 內的屬性上新增一個 <code>link</code> 屬性：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">  link = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著回到 <code>app.component.html</code> 將某一段 <code>a</code> 標籤的 <code>href</code> 內容給替換掉：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123;link&#125;&#125;"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>打開 Angular 開發伺服器，發現 <code>a</code> 標籤的 <code>href</code> 內容的確被替換了</p><p><img src="https://i.imgur.com/fYSK8KA.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2>這個單元讓我感到相當熟悉尤其是 {{}} 符號， Vue 裡面也有類似的用法。所以這一部分學習起來特別容易理解。<!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接著介紹 Angular 中是如何進行資料繫結的，以及 Angular 內共有幾種資料繫結的方式呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>擔任六角遠端助教的那一段日子</title>
    <link href="http://pvt5r486.github.io/life-note/20190524/3138494786/"/>
    <id>http://pvt5r486.github.io/life-note/20190524/3138494786/</id>
    <published>2019-05-24T06:14:50.000Z</published>
    <updated>2020-02-16T05:54:48.964Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不覺的快到五月的尾聲了，因受到洧杰老師邀請而擔任課程的遠端助教，用意是希望能幫助想轉職前端的學員們能夠用自己的知識賺回學費，並且能緩和轉職的陣痛期。因為我終於找到轉職前端後的第一份前端工作了，所以這個遠端助教的身分五月底就會交棒給之後的學員們，因此想藉由這篇把點點滴滴記錄下來。</p><p><img src="https://images.unsplash.com/photo-1557962677-131278db2213?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1100&amp;q=80" alt></p><h2 id="菜鳥助教起手式"><a href="#菜鳥助教起手式" class="headerlink" title="菜鳥助教起手式"></a>菜鳥助教起手式</h2><p>好的，既然答應老師的邀約了，那麼具體來說要做些什麼呢？</p><p>於是我跟老師敲了個時間當面討論細節，順便拜訪六角學院，我也是從那次才知道六角人力真的是很精簡。</p><p><strong>總結整理如下：</strong></p><ul><li>討論支援時段<ul><li>我被安排上午時段，周一至周五有 7 小時自由分配</li></ul></li><li>支援課程<ul><li>我主要負責 Vue 課程，而如果當天學員問題較少就支援 JavaScript 課程的問題</li></ul></li><li>教育訓練<ul><li>初期會有老師們挑選好的 30 道題目，要試著回答出來</li></ul></li></ul><h3 id="教育訓練"><a href="#教育訓練" class="headerlink" title="教育訓練"></a>教育訓練</h3><p>覺得自己可以當上助教蠻開心的，可以賺取學費又可以透過回答問題加深自己對 Vue 、 JavaScript 的掌握度，更重要的是可以培養溝通能力。</p><p>但對於如何擔任一個助教而言，我是沒有什麼頭緒的。</p><p>好在這部分也有考量到了，因為我主要負責 Vue 課程，所以我的 30 道問題是由該課程講者 - <a href="https://wcc723.github.io/" rel="external nofollow noopener noreferrer" target="_blank">卡斯伯老師</a> 挑選。</p><p>回覆這 30 道問題的時候，必須同時記錄一些項目：</p><ul><li>你的回答</li><li>回答耗時</li></ul><p>也因為需要紀錄花了多少時間回這道問題，所以我在做這些練習時反而因為緊張花掉很多時間，而且有些時候根據你的回答，還必須附上適當的文件佐證說明，所以整體而言是相當耗時的。</p><p>都完成後老師也會根據每一條問題給你回覆建議，並且視情況來安排。</p><p>這邊也附上我的練習截圖給各位參考</p><p><img src="https://i.imgur.com/K4vjkUg.png" alt></p><blockquote><p>幸好實力有被老師肯定，做完這些題目後沒有太大問題就直接上工了。</p></blockquote><h2 id="菜鳥助教上工初期"><a href="#菜鳥助教上工初期" class="headerlink" title="菜鳥助教上工初期"></a>菜鳥助教上工初期</h2><p>在很久之前，我有想過一個問題。<br>我花錢就是希望直接得到老師的指點，可是回答的都是助教，這樣感覺很虧欸。</p><blockquote><p>但是在我當上助教後才知道，代誌不是傻人想的那樣。</p></blockquote><h3 id="回覆審核機制"><a href="#回覆審核機制" class="headerlink" title="回覆審核機制"></a>回覆審核機制</h3><p>助教也不是想回學生什麼就任意回答的。</p><p>這個機制是為了保證助教的回答是正確且有一定品質，所以我們都會加入助教專屬的 Slack ，要回覆時需要把回覆內容貼到群組內，通過老師審核後才可以正式對外回覆。</p><p>具體大概像這個樣子：</p><p><img src="https://i.imgur.com/M6462I3.png" alt="非當事樹精"></p><p><strong>如果審核通過就會有個讚，反之老師會在你的留言下方給回覆建議，修正後重跑一次流程。</strong></p><h3 id="實際上陣"><a href="#實際上陣" class="headerlink" title="實際上陣"></a>實際上陣</h3><p>一開始肯定是非常手忙腳亂，因為畢竟是收人錢替人做事，效率肯定要有。</p><p>在這個心態的前提下，精神異常的緊繃，所以基本上我如果安排早上 9 點上工，我就會在 08:40 開始看題目，大概有個底。</p><blockquote><p>大多時候看到待回覆問題題數時，臉就黑一半了。</p></blockquote><p>工作時螢幕切分大概是這樣的，沒有雙螢幕所以很彆扭。</p><p><img src="https://i.imgur.com/XMWNwWF.png" alt></p><blockquote><p>左上是審核區；左下是回覆的內容；右上是問題敘述；右下是待命用的 VSCode</p></blockquote><p>這個時期的我回覆問題的速度真的很慢，一題 20 ~ 30 分、甚至有一題花到 1 小時的，當天沮喪到不行，還偷偷跑去跟卡斯伯老師 QQ</p><p><img src="https://i.imgur.com/h52FdOr.png" alt="幫 QQ"></p><p>結果後來就在直播上被公開處刑了(?</p><p><strong>後來我仔細反思後，變更了回覆問題的方式：</strong></p><ul><li>先掃一遍，沒有頭緒就先跳過，優先回答會的</li><li>花了 5 分鐘還是沒有頭緒時就直接回 Slack 求救</li><li>永遠不要把發問的人說的話當真，要跳出他的邏輯除錯</li></ul><h2 id="成為獨當一面的助教"><a href="#成為獨當一面的助教" class="headerlink" title="成為獨當一面的助教"></a>成為獨當一面的助教</h2><p>經過了大概一個多月的努力，老師們認為我的回覆水平有達一定水準，有把握回覆的問題就不需要特地貼到 Slack 審核。</p><p>而每小時回覆的問題數量也漸趨穩定，至少不像一開始這麼悲劇。</p><p>處刑用對照圖<br><img src="https://i.imgur.com/MrIpNqK.png" alt="初期"></p><p><img src="https://i.imgur.com/XSLiViq.png" alt="中後期"></p><p>後來我又有了另一個體悟<br>有些時候回答問題的效率除了自己可能不夠熟 Vue 之外，很大的一部分是因為</p><ul><li>學員不會描述問題，有些問題我看完都懷疑自己是不是中文不好</li><li>幾乎沒有描述問題，只貼了一張錯誤訊息的圖片，說了句「為什麼錯誤」，就沒後續了</li><li>絕大多數都是問問題不附程式碼，所以必須進行二次問答</li><li>貼上 codepen 連結，點開裡面全部都沒有排版 (瞬間眼神死</li></ul><blockquote><p>遺憾的是，在我成為助教之前也是其中問爛問題的其中一人</p></blockquote><p><strong>也就是因為這樣，助教常常必須通靈才有辦法回答問題。</strong></p><p>對我來說最好的問問題方式就是</p><ol><li>問程式的問題，一定要附上原始碼</li><li>有條理的敘述前因後果，提交問題的時候可以先自己讀個一二次在提交</li></ol><p>強烈推薦老師之前線上問答會的影片<a href="https://www.youtube.com/watch?v=ZzJOcFCxRXQ" rel="external nofollow noopener noreferrer" target="_blank">發問的智慧</a></p><p>雖然口頭上是這麼說，但請不要誤會，助教群們都很歡迎學員問問題哩 :D</p><p>只是希望透過這篇稍微提一下…這應該也是<strong>其他助教的心聲</strong>吧？</p><p>要知道一個問題被描述的越精確，那麼這個問題就會越快被解答，省下你我的時間<strong>這是雙贏的局面</strong>。</p><h2 id="畢業感想"><a href="#畢業感想" class="headerlink" title="畢業感想"></a>畢業感想</h2><p>雖然距離畢業還有快一個禮拜，但在擔任遠端助教的期間，我學到了</p><ul><li>如何問問題<ul><li>觀察學員提問方式反思如何正確的問一個問題</li></ul></li><li>如何與團隊溝通<ul><li>例如同時有助教回覆到同一題，如何避開撞車等等</li></ul></li><li>Vue 技術上的成長<ul><li>有時候學員遇到的 Bug 也是我從沒想過的，知道原因並解決時很有成就感</li></ul></li><li>如何與其他人溝通<ul><li>把你會的東西清楚的用文字表達給他人知道</li></ul></li></ul><p>我要謝謝所有我在轉職路上幫助過我的人，雖然我目前還很不成熟，不過我會繼續在這個領域努力下去。</p><p>特別感謝六角學院的 <strong><a href="https://www.facebook.com/sfismy" rel="external nofollow noopener noreferrer" target="_blank">廖洧杰</a></strong> 校長以及 <strong><a href="https://www.facebook.com/chihcheng.wang.3" rel="external nofollow noopener noreferrer" target="_blank">王志誠</a></strong> 副校長，在我轉職的路上給的幫助特別多，也很感謝有這一次的機會擔任遠端助教。</p><p>最後也要謝謝 Slack 群內的 <strong>Jackson</strong> 助教以及<strong>葉子</strong>，在我不知道怎麼回覆時給予建議、幫我坦了不少條難回的問題。</p><p><strong>希望我回的每個問題都有幫助到這些學員們！</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      不知不覺的快到五月的尾聲了，因受到洧杰老師邀請而擔任課程的遠端助教，用意是希望能幫助想轉職前端的學員們能夠用自己的知識賺回學費，並且能緩和轉職的陣痛期。因為我終於找到轉職前端後的第一份前端工作了，所以這個遠端助教的身分五月底就會交棒給之後的學員們，因此想藉由這篇把點點滴滴記錄下來。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
      <category term="自我投資" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8A%95%E8%B3%87/"/>
    
      <category term="里程碑" scheme="http://pvt5r486.github.io/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.12 升級 Angular 應用程式到新版的方法</title>
    <link href="http://pvt5r486.github.io/f2e/20190523/2615543464/"/>
    <id>http://pvt5r486.github.io/f2e/20190523/2615543464/</id>
    <published>2019-05-23T10:03:45.000Z</published>
    <updated>2019-06-09T05:31:32.027Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹完如何使用 Angular CLI 部屬 Angular 專案後，緊接著要提到如何更新 Angular CLI 或 Angular 的版本。但是這部分可能只有純介紹，因為我也是最近才剛開始開發 Angular ，所以環境基本上都是最新的，就不提供更新前後的對照圖了。</p><h2 id="確認目前版本"><a href="#確認目前版本" class="headerlink" title="確認目前版本"></a>確認目前版本</h2><p>使用 VSCode 開啟專案並打開終端機，我們可以輸入 <code>ng v</code> 或是 <code>ng --version</code> 指令確認目前專案的 Angular CLI 的版本。</p><p><img src="https://i.imgur.com/AT72QhJ.png" alt="Image"></p><p>可知</p><ul><li>我的 Angular 目前是 7.2.15 版</li><li>而 Angular CLI 則是 7.3.9 版</li></ul><h2 id="透過-Angular-CLI-進行版本升級"><a href="#透過-Angular-CLI-進行版本升級" class="headerlink" title="透過 Angular CLI 進行版本升級"></a>透過 Angular CLI 進行版本升級</h2><p>我們可以透過 Angular CLI 提供的指令進行 Angular 專案的升級<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng update</span><br></pre></td></tr></table></figure><p></p><blockquote><p>透過這個指令可以把 Angular CLI 以及 Angular 甚至 TypeScript 、 Webpack 、 Rxjs 等等直接升級到最新版本。</p></blockquote><p>所以我們不用擔心 Angular 要如何升級版本的問題，可以透過 <code>ng update</code> 輕鬆地把版本升級到最新版，而這個指令也會處理掉一些版本升級時可能會遇到的問題。</p><p><strong>而背後的原理就是 Angular CLI 修改了 package.json 內記載的版本號，然後執行 <code>npm update</code> 命令。</strong></p><p>當我們執行過 <code>ng update</code> 安裝完畢後，可以確認一次目前的版本，會發現到已經升級到最新了。</p><p>延伸讀物：</p><ul><li><a href="https://soarlin.github.io/2017/04/21/Composer-NPM-install-update/" rel="external nofollow noopener noreferrer" target="_blank">NPM 指令 Install 與 Update 的差異</a></li></ul><h2 id="如何更新-Global-的-Angular-CLI-版本"><a href="#如何更新-Global-的-Angular-CLI-版本" class="headerlink" title="如何更新 Global 的 Angular CLI 版本"></a>如何更新 Global 的 Angular CLI 版本</h2><p>如果想更新全域的 Angular CLI 版本，可以打開命令提示字元，並輸入 <code>npm list -g --depth=0</code></p><p>使用這個指令列出目前全域環境中，安裝了那些 npm 套件，並只顯示第一層目錄。</p><p><img src="https://i.imgur.com/9Cnw53J.png" alt></p><p>可以發現全域的 Angular CLI 版本同樣也是 7.3.9 版。</p><p>透過 <code>npm outdate -g</code> 指令查詢目前全域環境安裝的套件是否有最新版本</p><p><strong>如果沒有任何資訊出現，代表目前已經是最新版。</strong></p><blockquote><p>如有出現訊息，則透過 <code>npm install -g @angular/cli</code> 重新安裝一次即可。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>大部分的情況，如果是小幅度的升級，像是小數點後小版本的變更，基本上是不會動到程式碼的。</p><p>如果是大幅度的升級，像是 Angular 2 升級到 Angular 4 或者其他情況，可能就需要進行一些評估了。</p><p>而這部分 Angular 也很貼心的設有一個網站可以幫助我們快速查詢各個版本的 Angular 升級時需要注意的事項：</p><ul><li><a href="https://update.angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular Update Guide</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      介紹完如何使用 Angular CLI 部屬 Angular 專案後，緊接著要提到如何更新 Angular CLI 或 Angular 的版本。但是這部分可能只有純介紹，因為我也是最近才剛開始開發 Angular，所以環境基本上都是最新的，就不提供更新前後的對照圖了。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.11 發行與部屬 Angular 應用程式的方法</title>
    <link href="http://pvt5r486.github.io/f2e/20190523/2814372360/"/>
    <id>http://pvt5r486.github.io/f2e/20190523/2814372360/</id>
    <published>2019-05-23T07:22:12.000Z</published>
    <updated>2019-06-09T05:31:38.376Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在我們 Angular 專案內的環境非常的單純，只有一個 Component ，而未來如果我們開發完成時，要如何透過 Angular CLI 發行與部屬 Angular 應用程式呢？</p><p><img src="https://images.unsplash.com/photo-1558382487-0986fe3131b0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1051&amp;q=80" alt></p><h2 id="Angular-CLI-發行與部屬"><a href="#Angular-CLI-發行與部屬" class="headerlink" title="Angular CLI 發行與部屬"></a>Angular CLI 發行與部屬</h2><p>可以透過 Angular CLI 的指令辦到這件事情，叫出 VS Code 的終端機，並輸入以下指令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build</span><br></pre></td></tr></table></figure><p></p><p>這麼做 Angular CLI 會透過 webpack 幫我們把專案的內容通通打包並且輸出到 dist 資料夾內，而且是沒有進行 minify 的版本。</p><p>而如果是正式發布的產品版，則應該額外加入 <code>--prod</code> 參數，進行 minify 優化，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build --prod</span><br></pre></td></tr></table></figure><p></p><h2 id="讓我們看看有無-minify-的差距吧"><a href="#讓我們看看有無-minify-的差距吧" class="headerlink" title="讓我們看看有無 minify 的差距吧"></a>讓我們看看有無 minify 的差距吧</h2><p>首先是沒有加入 <code>--prod</code> 的結果<br><img src="https://i.imgur.com/rSD6XkM.png" alt="Image"></p><blockquote><p>vendor.js 居然約有 3.3 MB ，真是驚人！</p></blockquote><p>接著是有加入 <code>--prod</code> 的結果</p><p><img src="https://i.imgur.com/S3UaNlJ.png" alt="Image"></p><blockquote><p>從快 3.3 MB 的大小被壓縮到不到 200 KB ，而且剛才看到的 vendor.js 不見了，因為它跟 main.js 合併在一起了。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次的實驗告訴我們，一定一定要記得部屬時幫這些 .js 檔好好的進行 minify 瘦身一番！</p><p>看看這個差距，的確是蠻誇張的…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      現在我們 Angular 專案內的環境非常的單純，只有一個 Component ，而未來如果我們開發完成時，要如何透過 Angular CLI 發行與部屬 Angular 應用程式呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.10 將網頁加入 Angular 應用程式</title>
    <link href="http://pvt5r486.github.io/f2e/20190523/512922220/"/>
    <id>http://pvt5r486.github.io/f2e/20190523/512922220/</id>
    <published>2019-05-23T06:09:26.000Z</published>
    <updated>2019-06-09T05:31:42.162Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇提到了如何把靜態資源加入到以 Angular CLI 建立的專案內，但這樣子是不夠的。我們希望能夠把這個網頁版型加入到 Angular 內，以 Component 的形式被管理，那該怎麼做呢？</p><p><img src="https://images.unsplash.com/photo-1558497446-1fd7429d9be4?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="觀察-index-html"><a href="#觀察-index-html" class="headerlink" title="觀察 index.html"></a>觀察 index.html</h2><p>打開 index.html ，整份網頁大致上可以拆分成 head 區塊以及 body 區塊。head 區塊是沒辦法拆成 Component 的，只有在 body 區塊才可以拆 Component 。</p><p><strong>index.html</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>FirstAngular<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-root</span>&gt;</span><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>我用的網頁版型 HTML 部分還蠻多的，就不貼上來了。</p></blockquote><p>也就是說：</p><ul><li>可以直接將靜態網頁的版型 head 部分直接複製貼上到 index.html</li><li>把網頁版型中的 body 區塊貼到 AppComponent 的 HTML Template 內</li></ul><p>了解該怎麼做之後，我們就動手吧！</p><h2 id="head-部分的處理"><a href="#head-部分的處理" class="headerlink" title="head 部分的處理"></a>head 部分的處理</h2><p>這邊只有一點要注意，在 index.html 中有一個標籤很特別 <code>&lt;base&gt;</code> 。<br>base 標籤是用來控制網頁內的其他超連結，而這個標籤在這裡的用意是規定一個基準的 Url 路徑，也就是之後這張網頁內的其他超連結的基準都是從 / 開始找起。</p><ul><li><a href="https://www.wibibi.com/info.php?tid=418" rel="external nofollow noopener noreferrer" target="_blank">關於 base 標籤的詳細說明</a></li><li><a href="http://jartto.wang/2016/10/01/about-html-base-tag/" rel="external nofollow noopener noreferrer" target="_blank">base 標籤 應用例子</a></li></ul><p>所以我們把複製的內容放到 base 標籤下方，像這樣：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/assets/styles/mainapp.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"http://blog.miniasp.com/favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"Lorem, ipsum dolor."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"pvt5r486"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lorem, ipsum dolor.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-root</span>&gt;</span><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="body-部分的處理"><a href="#body-部分的處理" class="headerlink" title="body 部分的處理"></a>body 部分的處理</h2><p>這部分因為 HTML 很多，所以就不貼上來了，將網頁版型中的 body 區塊貼到 AppComponent 的 HTML Template 內。</p><p>這邊有個小技巧，可以按下 <code>Ctrl + E</code> 透過搜尋的方式快速找到檔案，找到後就整個取代貼上吧。</p><h2 id="實際執行看看"><a href="#實際執行看看" class="headerlink" title="實際執行看看"></a>實際執行看看</h2><p>執行 <code>npm start</code> 命令，觀察實際在瀏覽器上呈現的情形。</p><blockquote><p>但畫面上空空如也，為什麼？</p></blockquote><p>打開開發者工具發現一段錯誤：</p><p><img src="https://i.imgur.com/q87FA2W.png" alt></p><p>在 Angular 中，只能使用 HTML5 規範的 HTML 標籤，而我使用的這個版型用到的這個 hgroup 標籤並不符合 HTML5 規範。</p><p><strong>處理方式有很多種，其中最簡單的就是將其改成 div 標籤即可。</strong></p><p><a href="https://blog.miniasp.com/post/2016/09/19/Angular-2-Custom-Element-Tips" rel="external nofollow noopener noreferrer" target="_blank">以下轉自保哥 Blog</a></p><blockquote><p>關於 hgroup 標籤的補充：<br>早期在 HTML5 規格尚未發佈正式版的時候，當時是有 hgroup 元素的，但 HTML5 工作小組在 2013/4/2 的一次<a href="http://lists.w3.org/Archives/Public/public-html-admin/2013Apr/0003.html" rel="external nofollow noopener noreferrer" target="_blank">會議結論</a>中決定從規格中移除 hgroup 元素，因此請大家不要再用這個 hgroup 元素。</p></blockquote><p>這樣就搞定了！</p><p><img src="https://i.imgur.com/S5fx2NL.png" alt="Image"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這樣我們就成功地把一份網頁版型加入到 Angular 內並且以 Component 的方式管理，所以可以到上一篇提到的 angular.json 檔案內把之前加入到 <code>assets</code> 內的 <code>src/blog-index.html</code> 給移除囉，因為已經用不到了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇提到了如何把靜態資源加入到以 Angular CLI 建立的專案內，但這樣子是不夠的。我們希望能夠把這個網頁版型加入到 Angular 內，以 Component 的形式被管理，那該怎麼做呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.9 將靜態檔案加入 Angular CLI 建立的專案</title>
    <link href="http://pvt5r486.github.io/f2e/20190522/1867149427/"/>
    <id>http://pvt5r486.github.io/f2e/20190522/1867149427/</id>
    <published>2019-05-22T11:47:51.000Z</published>
    <updated>2019-06-09T05:31:45.546Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:53 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在有個狀況是，如果我們有一份靜態網頁的版型或者是一些靜態的圖片資源、 json 檔，那麼要如何地加入到 Angular 專案內呢？</p><p><img src="https://images.unsplash.com/photo-1555939765-9b78f509d500?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="將靜態檔案加入-src-資料夾"><a href="#將靜態檔案加入-src-資料夾" class="headerlink" title="將靜態檔案加入 src 資料夾"></a>將靜態檔案加入 src 資料夾</h2><p>首先我有一份靜態網頁的版型叫做 BlogSiteHtml ，解壓縮後的內容有：</p><ul><li>api 資料夾</li><li>assets 資料夾</li><li>blog-index 網頁版型</li></ul><p>接著把這些檔案全部貼到 Angular 專案的 src 資料夾內，並且輸入指令 <code>npm start</code> 重啟開發伺服器。</p><h2 id="這樣就完成了嗎？"><a href="#這樣就完成了嗎？" class="headerlink" title="這樣就完成了嗎？"></a>這樣就完成了嗎？</h2><p>重啟開發伺服器後，我們可以在網址列輸入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4200/blog-index.html</span><br></pre></td></tr></table></figure><p></p><p>會發現什麼事情都沒發生，畫面還是原本那樣。</p><p><strong>為什麼？</strong></p><p>因為當我們把這些新的靜態檔案加入到 src 目錄後，還需要設定 angular.json ，告訴這支檔案我們做了什麼異動。</p><h2 id="angular-json-的設定"><a href="#angular-json-的設定" class="headerlink" title="angular.json 的設定"></a>angular.json 的設定</h2><p>進入到這支檔案後，可以看到非常多密密麻麻的設定，而我們這次要修改的是 <code>assets</code> 區塊的內容，而它位於 <code>architect</code> 物件下的 <code>build</code> 物件下的 <code>options</code> 物件內。</p><p>修改前<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"assets": [</span><br><span class="line">  "src/favicon.ico",</span><br><span class="line">  <span class="string">"src/assets"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p></p><p><strong>修改的目的就是要告訴這支檔案我們在 src 資料夾內增加了什麼東西，希望它一起編譯。</strong></p><p>修改如下：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"assets": [</span><br><span class="line">  "src/favicon.ico",</span><br><span class="line">  "src/assets",</span><br><span class="line">  "src/api",</span><br><span class="line">  <span class="string">"src/blog-index.html"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p></p><p>接著再度重啟開發伺服器，並且重新輸入對應網址觀察。</p><p><img src="https://i.imgur.com/Xh1TIIQ.png" alt></p><p>這次就成功地看到一個漂亮的部落格版型囉。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過這樣的操作得知，如果未來開發時加入了一些新的靜態資源，除了將檔案複製進 src 外，也必須調整相關的設定檔，使其可以對應，這樣才能找到我們要的檔案哦。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      現在有個狀況是，如果我們有一份靜態網頁的版型或者是一些靜態的圖片資源、 json 檔，那麼要如何地加入到 Angular 專案內呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.8 使用 Angular CLI 快速建立元件與範本</title>
    <link href="http://pvt5r486.github.io/f2e/20190522/1258474476/"/>
    <id>http://pvt5r486.github.io/f2e/20190522/1258474476/</id>
    <published>2019-05-22T10:21:34.000Z</published>
    <updated>2019-06-09T05:31:49.210Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:53 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聽人家說 Angular CLI 相當的強大，可以幫助開發者在開發 Angular 時省下不少功夫。本篇要介紹 Angular CLI 是如何幫助我們快速建立元件與範本。</p><p><img src="https://images.unsplash.com/photo-1425082661705-1834bfd09dca?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1055&amp;q=80" alt></p><h2 id="透過-Angular-CLI-建立-Component"><a href="#透過-Angular-CLI-建立-Component" class="headerlink" title="透過 Angular CLI 建立 Component"></a>透過 Angular CLI 建立 Component</h2><p>可以使用 VSCode 下方的終端機 (按下 Ctrl + ` 開啟)，值得注意的是 Angular CLI Component 類型不只有一種，可以輸入以下指令查看它可以幫我們產生哪些 Component 範本：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate -h</span><br></pre></td></tr></table></figure><p></p><p>執行後可以得知它還能幫我們產生以下這些 Component 範本，是不是很方便呢？</p><p><img src="https://i.imgur.com/9S8VBbj.png" alt></p><p>如果要透過 Angular CLI 建立 Component ，並且把這個元件加到 AppComponent 下，以下指令擇一即可。</p><p>完整指令<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate component myFirstCompoent</span><br></pre></td></tr></table></figure><p></p><p>簡寫指令<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c myFirstCompoent</span><br></pre></td></tr></table></figure><p></p><p>執行後得到以下結果：</p><p><img src="https://i.imgur.com/2ZwTwkn.png" alt></p><p><strong>得知 Angular CLI 幫我們建立了 4 個檔案，並且更新了 app.module.ts 這支檔案。</strong></p><p>並發現於 app 資料夾中多出了剛才輸入的 myFirstCompoent 資料夾 (不一致是因為 Angular CLI 會自動轉換成適合的名稱)</p><p><img src="https://i.imgur.com/CSHd3fy.png" alt></p><blockquote><p>之後當我們使用這個方式來建立 Component 時，都會產生類似的檔案結構來建立 Angular 應用程式。</p></blockquote><h3 id="觀察-my-first-component-component-ts"><a href="#觀察-my-first-component-component-ts" class="headerlink" title="觀察 my-first-component.component.ts"></a>觀察 my-first-component.component.ts</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-my-first-component'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./my-first-component.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./my-first-component.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstComponentComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剛剛建立的 Component 的 selector 預設就叫做 <code>app-my-first-component</code> ，而 <code>class</code> 名稱就是 <code>MyFirstComponentComponent</code> ，第一個字母自動會變成大寫。</p><p>接著還有相對應的 HTML Template 與 SCSS ， SCSS 的內容是空的 、 Template 的預設內容如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  my-first-component works!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>而透過 Angular CLI 還有一支 my-first-component.component.spec.ts 檔，這主要是拿來做單元測試用的檔案。</p><p>所以<strong>一個 Component 預設會有 4 支檔案被建立</strong>，還記得剛才 Angular CLI 有更新 app.module.ts ，讓我們看看它做了什麼。</p><h3 id="觀察-app-module-ts"><a href="#觀察-app-module-ts" class="headerlink" title="觀察 app.module.ts"></a>觀察 app.module.ts</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MyFirstComponentComponent &#125; <span class="keyword">from</span> <span class="string">'./my-first-component/my-first-component.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    MyFirstComponentComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>Angular CLI 很智慧地幫在 <code>declarations</code> 內註冊了剛才建立的 <code>MyFirstComponentComponent</code> 元件，而且也自動的把 <code>MyFirstComponentComponent</code> 元件給 import 進 app.module.ts ，相當的便利。</p><p>那麼，接下來我們要如何把剛剛建立的 <code>MyFirstComponentComponent</code> 呈現在畫面上呢？</p><h2 id="把新建立的元件加到-AppComponent-下"><a href="#把新建立的元件加到-AppComponent-下" class="headerlink" title="把新建立的元件加到 AppComponent 下"></a>把新建立的元件加到 AppComponent 下</h2><p>如果我們直接運行開發伺服器，是看不見剛才建立的元件的。</p><p><img src="https://i.imgur.com/8IpnQoO.png" alt="Image"></p><p>如果要把 <code>MyFirstComponentComponent</code> 加入到 <code>AppComponent</code> 下，那麼就要把 <code>MyFirstComponentComponent</code> 的 directive 註冊到 <code>AppComponent</code> 的 HTML Template 內，像是這樣：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    Welcome to &#123;&#123; title &#125;&#125;!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--這邊有一張圖片進行 base64 編碼，太佔空間了所以我把它移除 .--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-my-first-component</span>&gt;</span><span class="tag">&lt;/<span class="name">app-my-first-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Here are some links to help you start: <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://angular.io/tutorial"</span>&gt;</span>Tour of Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://angular.io/cli"</span>&gt;</span>CLI Documentation<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://blog.angular.io/"</span>&gt;</span>Angular blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>而 VSCode 也很貼心的提供的自動完成的功能。</p><p><img src="https://i.imgur.com/wCWn09u.png" alt></p><p>於是可以到瀏覽器觀察修改過後的結果：</p><p><img src="https://i.imgur.com/fdIKu7x.png" alt></p><blockquote><p>接著可以把寫在 <code>AppComponent</code> 下的某幾段 HTML 全部搬到新建立的元件內</p></blockquote><h2 id="調整-MyFirstComponentComponent-元件"><a href="#調整-MyFirstComponentComponent-元件" class="headerlink" title="調整 MyFirstComponentComponent 元件"></a>調整 MyFirstComponentComponent 元件</h2><p>來到 <code>MyFirstComponentComponent</code> 的 HTML Template 進行如下修改：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Here are some links to help you start: <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://angular.io/tutorial"</span>&gt;</span>Tour of Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://angular.io/cli"</span>&gt;</span>CLI Documentation<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span> <span class="attr">href</span>=<span class="string">"https://blog.angular.io/"</span>&gt;</span>Angular blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>而 <code>AppComponent</code> 修改如下<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    Welcome to &#123;&#123; title &#125;&#125;!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--這邊有一張圖片進行 base64 編碼，太佔空間了所以我把它移除 .--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-my-first-component</span>&gt;</span><span class="tag">&lt;/<span class="name">app-my-first-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>接著看看是否能順利運行！</strong></p><p><img src="https://i.imgur.com/rHePY1o.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Angular CLI 真的是蠻強大的，而且提供了許多便利的功能，而本篇僅介紹了其中一個元件類型的範本，而之後我也會建立其他的元件範本玩玩看。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      聽人家說 Angular CLI 相當的強大，可以幫助開發者在開發 Angular 時省下不少功夫。本篇要介紹 Angular CLI 是如何幫助我們快速建立元件與範本。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.7 Angular 應用程式的啟動過程</title>
    <link href="http://pvt5r486.github.io/f2e/20190522/589237579/"/>
    <id>http://pvt5r486.github.io/f2e/20190522/589237579/</id>
    <published>2019-05-22T07:26:01.000Z</published>
    <updated>2019-06-09T05:31:53.263Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們透過 VSCode 的終端機執行 「npm start」 時，這段時間發生了什麼事情，讓我們好好地整理一下。</p><p><img src="https://images.unsplash.com/photo-1558433916-90a36b44753f?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="npm-start"><a href="#npm-start" class="headerlink" title="npm start"></a>npm start</h2><p>首先開啟一個之前就建立好的 Angular 專案範本，接著在 VSCode 的終端機執行 <code>npm start</code> 。</p><p><img src="https://i.imgur.com/yAmjSev.png" alt></p><p>透過這張圖可以觀察到，當執行 <code>npm start</code> 時，其實是呼叫執行 Angular CLI 的命令 <code>ng serve</code> ，這個過程會啟動一個開發伺服器，而這個開發伺服器在啟動之前，背後透過 Webpack 將目前的 Source Code 內所有的 TypeScript 進行編譯。</p><p>編譯之後把所有的 JavaScript 檔案合併在一起，而這個過程中產生了幾支檔案：</p><ul><li>es2015-polyfills.js, es2015-polyfills.js.map</li><li>polyfills.js, polyfills.js.map</li><li>runtime.js, runtime.js.map</li><li>styles.js, styles.js.map</li><li>vendor.js, vendor.js.map</li></ul><p><strong>那麼這些檔案會用在什麼地方呢？</strong></p><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>在首頁打開的時候，預設會把剛才編譯產生的這些檔案給載入，我們可以透過觀察原始碼來了解。</p><h3 id="對著-index-html-按右鍵-gt-檢視網頁原始碼"><a href="#對著-index-html-按右鍵-gt-檢視網頁原始碼" class="headerlink" title="對著 index.html 按右鍵 &gt; 檢視網頁原始碼"></a>對著 index.html 按右鍵 &gt; 檢視網頁原始碼</h3><p><img src="https://i.imgur.com/72OS6Vn.png" alt></p><p>首先我們看到一個</p><base>標籤，這個標籤可能比較少用，詳細的應用可以到<a href="https://www.wibibi.com/info.php?tid=418" rel="external nofollow noopener noreferrer" target="_blank">這邊</a>查看。<p></p><p>接著是<app-root>標籤，這個標籤事實上就是 Angular 裡面的根元件，也可以稱它為一個 directive ，關於 directive 之後會有更詳細的說明。</app-root></p><p>然後發現 之前被插入了剛剛編譯出來的 .js 檔，而 Angular 應用程式也在載入這些 .js 檔後正式開始運行。</p><p><strong>然而執行的過程中，也有一個啟動的流程。</strong></p><p>啟動的流程結束後，<app-root>標籤的內容就會被動態的插入一些 DOM 物件，最後顯示在畫面上。</app-root></p><h3 id="對著-index-html-按右鍵-gt-檢查"><a href="#對著-index-html-按右鍵-gt-檢查" class="headerlink" title="對著 index.html 按右鍵 &gt; 檢查"></a>對著 index.html 按右鍵 &gt; 檢查</h3><p>從 chrome 的開發者工具底下，可以看到<app-root>標籤包含了一些從剛剛的原始碼內看不到的標籤。</app-root></p><p><img src="https://i.imgur.com/3usbsPx.png" alt></p><p>因為這些內容全部都是透過 Angular 應用程式動態運算出來的結果。</p><h3 id="實際觀察專案內的-index-html-檔案"><a href="#實際觀察專案內的-index-html-檔案" class="headerlink" title="實際觀察專案內的 index.html 檔案"></a>實際觀察專案內的 index.html 檔案</h3><p>這支檔案也就是剛才 chrome 瀏覽器開啟的檔案，而裡面確實有個<app-root>標籤。</app-root></p><p>可以發現檔案內的</p><body>標籤內並沒有插入剛才那些 .js 檔，也就是說那是 <strong>Webpack 幫我們編譯後動態插入的</strong>。</body><p></p><blockquote><p>也就是說我們在開發 Angular 網頁時，它的 JavaScript 在開發時期是動態被注入的。</p></blockquote><h2 id="從哪支-js-檔開始跑呢？"><a href="#從哪支-js-檔開始跑呢？" class="headerlink" title="從哪支 .js 檔開始跑呢？"></a>從哪支 .js 檔開始跑呢？</h2><p>之前有提過， Angular 應用程式的進入點是 main.ts 檔案，而它的長相如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; enableProdMode &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; platformBrowserDynamic &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app/app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; environment &#125; <span class="keyword">from</span> <span class="string">'./environments/environment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (environment.production) &#123;</span><br><span class="line">  enableProdMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><p>前面 5 行主要是引用從某一些模組匯入程式運行時必要的物件進來。<br>而第 11 行的地方，則是透過 <code>platformBrowserDynamic().bootstrapModule(AppModule)</code> 去執行啟動模組這件事，接著會進入到 <code>AppModule</code> 裡面執行相關的程式碼，讓我們一起觀察下去吧。</p><blockquote><p>小提示：在 VSCode 內可以對著 <code>AppModule</code> 點一下接著按 F12 會自動追蹤到該檔案喔</p></blockquote><h3 id="AppModule-內"><a href="#AppModule-內" class="headerlink" title="AppModule 內"></a>AppModule 內</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>這支檔案可以說是在 Angular 應用程式裡面最重要的一支程式，而程式碼結構不難看出它是一個 <code>class</code> 而且被 export 出來，神奇的是裡面沒有任何的程式碼。</p></blockquote><p>在大部分的情況，我們寫 Angular 應用程式時確實是不需要寫程式在裡面的。</p><p>我們只需要套用一個 <code>declarator</code> ，而這個 <code>declarator</code> 要設定成 <code>NgModule</code> ，去宣告這個類別它是一個 Angular 的 Module ，然後我們在這個 Module 裡面又有好幾個 Property (屬性) 需要宣告：</p><ul><li>declarations - 用來宣告一些跟 view 有關的元件</li><li>imports - 用來匯入一些跟這個模組會用到的其他模組，而模組說穿了就是多個元件封裝後的東西<ul><li>而 <code>BrowserModule</code> 就是把 <code>BrowserModule</code> 內所有的元件一起匯入進來的意思</li></ul></li><li>providers - 註冊服務的提供者</li><li>bootstrap - 啟動根元件 <code>AppComponent</code> ，也就是 Angular 最上層的元件 (預設名稱為 <code>AppComponent</code>)</li></ul><p><strong>接著我們使用剛才介紹的追蹤方式，繼續追蹤 <code>AppComponent</code></strong></p><h3 id="AppComponent-內"><a href="#AppComponent-內" class="headerlink" title="AppComponent 內"></a>AppComponent 內</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppComponent 元件的程式碼結構也一樣是個被 export 的 <code>class</code> ，然後這個範例程式預設有一個屬性 <code>title</code> 。</p><p>這個元件一樣有使用到 <code>declarator</code> ，叫做 <code>Component</code> ，這個 <code>Component</code> 在 Angular 內有特殊的涵義，這是用來宣告這個 <code>class</code> 代表的是一個 Component 。</p><p>而這個 Component 同樣有一些屬性如：</p><ul><li>selector - 如果寫過 JQuery 肯定不會陌生，就是一個選取器，如同範例的 <code>app-root</code> 就是選取到 HTML 中 <code>app-root</code> 標籤，並且把這個標籤的內容，修改為這個元件執行的結果。<ul><li>同理，如果改寫成 <code>.app-root</code> 則是選取具有 <code>.app-root</code> 的 className</li></ul></li></ul><p>舉例來說可以這麼做，我們修改 AppComponent 與 index.html 如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'.app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;app-root class="app-root"&gt;&lt;/app-root&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app-root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之後回到瀏覽器觀察，發現仍然是可以運行的。</p><p><img src="https://i.imgur.com/pYc3KFD.png" alt></p><p>而 HTML 中不管是直接在元件寫上 className 或者是新建一個具有 <code>app-root</code> className 的 div 標籤都是有效果的。</p><p>在我們把 <code>selector</code> 修改成 <code>.app-root</code> 後，下方突然多出綠色的蚯蚓，這是因為我使用了 TSLint ，而 TSLint 這個套件是遵照 Angular 官方發布的 Style Guide 規範，這當中就包含了 Component 的 selector 最好都以 element 的 selector 為主。</p><p><img src="https://i.imgur.com/mGbaM2T.png" alt></p><ul><li>templateUrl - 指這個 AppComponent 的 HTML Template 的所在之處，而這堆內容就是我們在瀏覽器上看到的 HTML 內容</li></ul><p><img src="https://i.imgur.com/z22zGRb.png" alt></p><p><strong>所以我們的每一個 Component 都會有一個相對應的 HTML Template 做搭配，一個負責程式的邏輯、另一個負責呈現於瀏覽器。</strong></p><ul><li>styleUrls - 指 AppComponent 的 HTML Template 有用到的 CSS 樣式，需要注意的是這裡的樣式預設只針對這個 Component ，並不會與其他 Component 互相衝突，當然這個預設值也是可以調整的。</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上就是 Angular 應用程式的啟動流程，透過這樣的描述能讓自己更加地了解 Angular 的運作過程。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      當我們透過 VSCode 的終端機執行 「npm start」 時，這段時間發生了什麼事情，讓我們好好地整理一下。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.6 理解 Angular 應用程式與元件</title>
    <link href="http://pvt5r486.github.io/f2e/20190521/3465317465/"/>
    <id>http://pvt5r486.github.io/f2e/20190521/3465317465/</id>
    <published>2019-05-21T10:13:36.000Z</published>
    <updated>2019-06-09T05:31:56.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Angular 採用模組化的元件開發，因此一個 Angular 專案裡面會看到非常多不同種類、大大小小的元件，而網頁畫面的構成也都是透過 JavaScript 切換這些大大小小元件渲染而成。可見元件在 Angular 中有多麼重要，所以我們要來理解 Angular 與元件的部分。</p><p><img src="https://i.imgur.com/x0srOd1.png" alt></p><h2 id="Angular-應用程式的組成"><a href="#Angular-應用程式的組成" class="headerlink" title="Angular 應用程式的組成"></a>Angular 應用程式的組成</h2><p>一個完整的 Angular 應用程式，它會包含一個模組，通常稱它為 AppModule ，而一個模組下會包含非常多的元件，如以下這張圖：</p><p><img src="https://i.imgur.com/Fh3dlQw.png" alt></p><p>一個模組下可能會有:</p><ul><li>App Componet 根元件</li><li>Child Componet 子元件</li><li>Services Componet 服務元件</li><li>Pipe Componet 管道元件</li></ul><p>元件的類型可能會有很多種，我們會透過一個模組把這些元件封裝起來。</p><blockquote><p>因為一個完整的 Angular 應用程式至少會包含一個模組，也至少會有一個元件以上，因此我們可以說一個 Angular 應用程式就是由元件所組成的</p></blockquote><h2 id="Angular-頁面的組成"><a href="#Angular-頁面的組成" class="headerlink" title="Angular 頁面的組成"></a>Angular 頁面的組成</h2><p>今天我有一個頁面想要呈現在瀏覽器內，不外乎會有 HTML 、 CSS 、 JavaScript 這幾支檔案，最終瀏覽器呈現出完整的網頁。</p><p>而 Angular 的開發模式，全部都是元件化的開發模式跟以往我們使用 JQuery 的開發模式是不一樣的，我們不需要頻繁的操作 DOM 。在元件化的開發方式裡，我們鮮少會直接操作 DOM 元素，都是透過元件的切換來達成畫面的渲染。</p><p><strong>可以想像成一個網頁載入後， HTML 內的 body 都是空白的，只有 JavaScript 。</strong></p><p>所以頁面要如何渲染到瀏覽器上呢？</p><ul><li>JavaScript 呼叫 元件</li><li>元件 再呼叫 樣板</li><li>樣板呈現到畫面上</li></ul><p><strong>而這個過程是動態的透過 JavaScript 達成。</strong></p><p>我們可以再次想像一個 Angular 頁面：</p><ul><li>最外層是由一個 AppComponent 元件(或稱為根元件)包覆</li><li>最上方頁首的部分可以拆成 HeaderConponent 為獨立元件</li><li>左邊則是拆成子選單的部分 AsideCompoent</li><li>右邊則是網站主要內容 ArticleCompoent</li></ul><p><img src="https://i.imgur.com/KU2LunY.png" alt></p><blockquote><p>如圖，AppComponent 包覆著 HeaderConponent 、 AsideCompoent 、 ArticleCompoent 這些元件，也就是說 AppComponent 就是父元件，而被包覆在裡面的就稱為子元件，最後組合成一個完整的網頁。</p></blockquote><p>然而實際上的網頁開發可能元件架構上沒有這麼單純，一個元件內可能又包覆一個子元件，而這個子元件可能又有另一個子元件，這種狀況是蠻常見的。像這樣一層包著一層的開發方式，就是所謂的元件化的開發方式。</p><p>而這樣的開發方式，會幾乎碰不到 DOM 元素的操作，我們只需要專注頁面邏輯以及商業邏輯的撰寫就可以了，而且商業邏輯會跟 view (template) 的部分是分離的，所以可維護性也會提升。</p><p><strong>而這個部分就是 Angular 應用程式與元件之間的關係</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Angular 採用模組化的元件開發，因此一個 Angular 專案裡面會看到非常多不同種類、大大小小的元件，而網頁畫面的構成也都是透過 JavaScript 切換這些大大小小元件渲染而成。可見元件在 Angular 中有多麼重要，所以我們要來理解 Angular 與元件的部分。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.5 認識 TypeScript</title>
    <link href="http://pvt5r486.github.io/f2e/20190521/2979055715/"/>
    <id>http://pvt5r486.github.io/f2e/20190521/2979055715/</id>
    <published>2019-05-21T08:21:33.000Z</published>
    <updated>2019-06-09T05:32:00.862Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Angular 的世界中，並不是使用一般的 JavaScript 進行開發，而是使用 TypeScript 進行程式語言的撰寫。然而 TypeScript 與 JavaScript 又有什麼關係呢？</p><p><img src="https://i.imgur.com/Dk8VBHz.png" alt></p><h2 id="認識-TypeScript"><a href="#認識-TypeScript" class="headerlink" title="認識 TypeScript"></a>認識 TypeScript</h2><p>我們可以從一張圖了解 TypeScript 與 JavaScript 的關係：</p><p><img src="https://i.imgur.com/cpWoxQT.png" alt></p><p>從這張圖我們可以得知， TypeScript 是包覆著整個 JavaScript 的每個版本，換句話說， TypeScript 是 JavaScript 的超集合。</p><h3 id="如何撰寫-TypeScript"><a href="#如何撰寫-TypeScript" class="headerlink" title="如何撰寫 TypeScript"></a>如何撰寫 TypeScript</h3><p>而要撰寫 TypeScript 的語言並不困難，我們仍然使用 JavaScript 來撰寫 TypeScript ，差別在於多了一些語言特性，但很多時候都還是仰賴我們在 JavaScript 建立起的觀念，因此擁有扎實的 JavaScript 基礎是相當重要的。</p><h3 id="使用-TypeScript-的好處"><a href="#使用-TypeScript-的好處" class="headerlink" title="使用 TypeScript 的好處"></a>使用 TypeScript 的好處</h3><p>JavaScript 是動態型別的語言，也被稱為弱型別的程式語言，是在執行時期才真正擁有型別，而且會因為內容的不同而更改型別。相較於習慣靜態型別的程式語言(如 C#)的開發者來說，這樣是非常困惑的事情，因為沒有辦法很明確的知道某個變數是什麼型別。</p><blockquote><p>而 TypeScript 的其中一個特性是，可以讓 JavaScript 直接宣告某個變數應該是什麼型別。</p></blockquote><h3 id="不用擔心瀏覽器語法相容問題"><a href="#不用擔心瀏覽器語法相容問題" class="headerlink" title="不用擔心瀏覽器語法相容問題"></a>不用擔心瀏覽器語法相容問題</h3><p>在前端領域中往往要考量到瀏覽器的相容性，舉例來說我們可能使用 ES6、7 的某個語法，但是在 IE8、IE9 卻沒辦法支援這些語法，這時候就必須安裝額外的套件像是 Babel 來處理這個情況，或者乾脆改用別的語法。</p><blockquote><p>而 TypeScript 有 JavaScript 的編譯器，用來將 TypeScript 編譯成瀏覽器看得懂的 JavaScript ，而這個過程中 TypeScript 也會自動地幫我們把較高版本的 JavaScript 轉換成較低版本如 ES5 的語法，這是相當方便的。</p></blockquote><h3 id="親自體會"><a href="#親自體會" class="headerlink" title="親自體會"></a>親自體會</h3><p>到 TypeScript 的官方網站，有個 Playgrund，我們可以觀察 TypeScript 轉換成 JavaScript 後會是什麼樣子，這邊只是幫助我們了解 TypeScript 可以做些什麼，而一些 TypeScript 的語言特性等用到再說。</p><p>像這樣隨意地寫一個 ES6 的 <code>class</code><br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> greet &#123;</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> greet();</span><br><span class="line">obj.sayHello();</span><br></pre></td></tr></table></figure><p></p><p>會被編譯成這樣<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greet = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  greet.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> greet;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> greet();</span><br><span class="line">obj.sayHello();</span><br></pre></td></tr></table></figure><p></p><blockquote><p>因此我們只需要專注於 TypeScript 即可，不需要理會編譯出來的 JavaScript ，只需要知道 TypeScript 會幫我們搞定相容性的問題。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在 Angular 的世界中，並不是使用一般的 JavaScript 進行開發，而是使用 TypeScript 進行程式語言的撰寫。然而 TypeScript 與 JavaScript 又有什麼關係呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.4 Angular 的優點與特色</title>
    <link href="http://pvt5r486.github.io/f2e/20190521/724990059/"/>
    <id>http://pvt5r486.github.io/f2e/20190521/724990059/</id>
    <published>2019-05-21T07:21:18.000Z</published>
    <updated>2019-06-09T05:32:04.536Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新一代的 Angular 可以為我們做哪些事情，又相較於 AngularJS 而言有哪些特色呢？</p><p><img src="https://images.unsplash.com/photo-1558350310-4ec674fb415d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Angular-主要特色"><a href="#Angular-主要特色" class="headerlink" title="Angular 主要特色"></a>Angular 主要特色</h2><ul><li><p>跨平台</p><ul><li><a href="https://blog.techbridge.cc/2018/10/13/pwa-in-action/" rel="external nofollow noopener noreferrer" target="_blank">Progressive Web Apps</a><ul><li>結合網頁與應用程式優點</li></ul></li><li>Desktop Apps<ul><li>可搭配 <a href="https://zh.wikipedia.org/wiki/Electron" rel="external nofollow noopener noreferrer" target="_blank">Electron</a> 框架開發出跨越作業系統的桌面應用程式</li></ul></li><li>Native Apps<ul><li>可搭配 <a href="https://ionicframework.com/" rel="external nofollow noopener noreferrer" target="_blank">lonic Nactive</a>、 <a href="https://www.nativescript.org/" rel="external nofollow noopener noreferrer" target="_blank">NativeScript</a> 開發跨行動平台的原生應用程式</li></ul></li></ul></li><li><p>速度與效能</p><ul><li>Code generation (AOT)<ul><li>將元件範本預先編譯成 JS 程式碼</li></ul></li><li>Universal<ul><li>將開啟頁面的首頁預先產生完整的 HTML 與 CSS 原始碼，加快載入速度</li><li>可支援 Node.js 、 .NET 、 PHP 等等任何其他伺服器端網頁架構</li></ul></li><li>Code Splitting<ul><li>透過元件路由機制，讓使用者只載入需要的程式碼</li></ul></li></ul></li><li><p>生產力提升</p><ul><li>Templates<ul><li>使用簡易又強大的範本語法提高開發效率</li></ul></li><li><a href="https://cli.angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular CLI</a><ul><li>透過命令列快速建立 Angular 專案、新增元件、執行測試與部屬</li></ul></li><li>IDE<ul><li>可以在現有編輯器及開發工具中使用程式碼自動完成、即時錯誤提示、程式碼建議</li></ul></li></ul></li><li><p>完整的開發體驗</p><ul><li>Testing<ul><li>結合 Karma 執行單元測試，結合 Protractor 進行各種 E2E 測試情境</li></ul></li><li>Animation<ul><li>透過 Angular API 完成複雜的頁面動畫處理</li></ul></li><li>Accessibility<ul><li>透過 ARIA-enabled 元件、開發者指引與內建的 a11y 測試基礎架構，建構具有可行性的應用程式</li></ul></li></ul></li></ul><h2 id="與-AngularJS-相比"><a href="#與-AngularJS-相比" class="headerlink" title="與 AngularJS 相比"></a>與 AngularJS 相比</h2><ul><li><p>效能改進 (Performance)</p><ul><li>偵測變更：比 AngularJS 快 10 倍</li><li>更小的 Library Size 與 延遲載入</li><li>範本編譯：支援 Template 預先編譯機制</li><li>渲染速度：比 AngularJS 快 5 倍 (Render &amp; Re-render)</li><li>支援伺服器渲染機制 (PHP &amp; ASP.NET)</li></ul></li><li><p>高生產力 (Productivity)</p><ul><li>開發應用程式能用更簡潔的語法讓團隊更加上手與維護</li><li>更強大的開發工具 Augury</li><li>移除超過 40+ 個 directives</li></ul></li><li><p>多平台 (Versatility)</p><ul><li>支援 Broeser 、 Node.js 、 NativeScript and more …</li></ul></li></ul><h2 id="Angular-優勢"><a href="#Angular-優勢" class="headerlink" title="Angular 優勢"></a>Angular 優勢</h2><ul><li><p>熟悉的開發架構</p><ul><li>採用 TypeScript 開發語言，使用以類別為基礎的物件導向架構開發網頁應用程式，幫助 C# 、 Java 、 PHP 等開發人員快速上手。</li></ul></li><li><p>更低的學習門檻</p><ul><li>相較於 AngularJS 減少了許多抽象的架構與概念，對於剛入門的 Angular 開發者將更容易上手<ul><li>例如 AngularJS 的 directives 就有非常多抽象概念</li></ul></li></ul></li><li><p>更好的執行效率與行動化體驗</p><ul><li>不同行動裝置之間的各種特性接考量在內，例如觸控、螢幕大小、硬體限制等</li><li>內建伺服器渲染技術 (server rendering) 與 Web Worker 技術改善頁面載入效率</li><li>不僅僅做到預先產生 HTML 畫面，更能透過 NativeScript 或 Ionic 建立起網站框架與 Mobile App 之間的橋樑，開發效率與速度更好的行動瀏覽體驗。</li></ul></li><li><p>更清晰的專案架構與可維護性</p><ul><li>使用 ES6 模組管理機制，搭配 Webpack 或 SystemJS 等工具即可上手</li><li>元件模組化架構，幫助大家更快理解程式碼結構，降低維護成本</li><li>好的模組化架構能降低開發難度，也更適合開發大型的網站應用</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      新一代的 Angular 可以為我們做哪些事情，又相較於 AngularJS 而言有哪些特色呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.3 AngularJS 與 Angular</title>
    <link href="http://pvt5r486.github.io/f2e/20190521/292071729/"/>
    <id>http://pvt5r486.github.io/f2e/20190521/292071729/</id>
    <published>2019-05-21T06:28:11.000Z</published>
    <updated>2019-06-09T05:32:08.637Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在還沒正式踏入開始寫 Angular 時，身為一個初心者自然會在網上查詢很多關於 Angular 的資料。這時肯定會注意到，怎麼好像有兩種不一樣的 Angular 圖案呢？而名稱似乎也有點不同，一個叫 AngularJS、另一個叫 Angular，兩者之間是不是有什麼關係呢？</p><p><img src="https://i.imgur.com/Frf1uBI.png" alt></p><h2 id="Angular-前世今生"><a href="#Angular-前世今生" class="headerlink" title="Angular 前世今生"></a>Angular 前世今生</h2><p>Angular 最早是由 Google 團隊主導且全球領先的 JavaScript 應用程式框架，但在發展過程中都是由開源社群共同參與的。</p><h3 id="Angular-1-X"><a href="#Angular-1-X" class="headerlink" title="Angular 1.X"></a>Angular 1.X</h3><p>那為什麼 Angular 有兩個名字呢？</p><p>因為早期在第一代的時候，它的名字也被稱為 Angular ，所以我們稱 Angular 1.X 版是第一代產品。第一代產品剛推出的時候得到非常大的迴響，有非常多的開發者使用這一套框架建置他們的網站，由於 Angular 框架的問世，造福了不少開發者。</p><p><img src="https://i.imgur.com/vU23T0u.png" alt="AngularJS"></p><p>Angular 1.X</p><ul><li>有廣大的開發社群</li><li>透過全新的、抽象化的架構大幅簡化網頁應用程式的開發</li></ul><h3 id="Angular-2"><a href="#Angular-2" class="headerlink" title="Angular 2"></a>Angular 2</h3><p>但在發展了幾年之後發現有一點缺陷，後來 Angular 團隊花了兩年多的時間發展第二代的產品，我們稱它 Angular 2.X 。</p><p><img src="https://i.imgur.com/xPMdsCR.png" alt="Angular 2+"></p><p>Angular 2</p><ul><li>重新打造的下一代 AngularJS 開發框架</li><li>更高的執行效率、更佳的延展性架構</li><li>透過全新的元件化技術建構現代化的開發框架</li></ul><p>從兩者的比較來看，第二代與第一代的產品有相當大的差別，從開發架構、使用的開發工具、甚至於有些部分開發觀念也都修改了。</p><blockquote><p>換句話說，如果你使用的是第一代的 Angular 開發的網站，沒有辦法很快地升級成第二代的 Angular 。</p></blockquote><h3 id="AngularJS-與-Angular"><a href="#AngularJS-與-Angular" class="headerlink" title="AngularJS 與 Angular"></a>AngularJS 與 Angular</h3><p>這兩代產品差異這麼大但是名字又一樣，這對於大家討論 Angular 時造成很大的困擾。</p><p>因此大家就協議：</p><ul><li>使用 <strong>AngularJS</strong> 稱呼 Angular 第一代的產品，也就是 Angular 1.X 版</li><li>使用 <strong>Angular</strong> 稱呼 Angular 第二代的產品，也就是 Angular 2 版</li></ul><h2 id="後來的版本"><a href="#後來的版本" class="headerlink" title="後來的版本"></a>後來的版本</h2><p>在我寫這篇文章的時候 Angular 已經出到 7 版了，從 2 到 7 之間的版本差異會不會很大呢？</p><p>差異肯定是有的，但不像從 AngularJS 到 Angular 這種層級的大翻新，因此從 Angular 2 之後的版本幾乎都可以很快速的升級成新版本，而 Angular 2 之後的版本我們也都統稱為 Angular 。</p><p>甚至 Angular CLI 有個命令是 <code>ng update</code> ，可以幫助我們把現有的專案升級成新版本的 Angular ，所以我們可以放心地使用 Angular 開發網站哦。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在還沒正式踏入開始寫 Angular 時，身為一個初心者自然會在網上查詢很多關於 Angular 的資料。這時肯定會注意到，怎麼好像有兩種不一樣的 Angular 圖案呢？而名稱似乎也有點不同，一個叫 AngularJS、另一個叫 Angular ，兩者之間是不是有什麼關係呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.2 檔案架構</title>
    <link href="http://pvt5r486.github.io/f2e/20190520/3222844657/"/>
    <id>http://pvt5r486.github.io/f2e/20190520/3222844657/</id>
    <published>2019-05-20T10:44:05.000Z</published>
    <updated>2019-06-09T05:32:12.812Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>緊接著了解 Angular 專案內的檔案結構，我覺得這是相當重要的。畢竟只有在認識了這些檔案結構後，才有辦法因應日後專案的調整，也才知道要在哪裡修改對應的配置。</p><p><img src="https://images.unsplash.com/photo-1558147060-6849949a1b56?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="Angular-專案的檔案結構"><a href="#Angular-專案的檔案結構" class="headerlink" title="Angular 專案的檔案結構"></a>Angular 專案的檔案結構</h2><p>開啟 VS Code ，並且載入 Angular 專案，會看到旁邊一排的檔案結構。</p><p><img src="https://i.imgur.com/ccGlubr.png" alt></p><h3 id="angular-json"><a href="#angular-json" class="headerlink" title="angular.json"></a>angular.json</h3><p>angular.json 這隻檔案是 Angular CLI 的設定檔，所以這個檔案裡面可以看到有非常多的參數，未來我們也可能會到裡面調整一些參數，用到的時候再來了解就可以了。</p><h3 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h3><p>.editorconfig 是一個非常常見的編輯器設定檔，這個檔案會告訴我們目前使用的編輯器怎麼處理 tab 符號、斷行符號等等。</p><p>詳細的設定可以到<a href="https://editorconfig.org" rel="external nofollow noopener noreferrer" target="_blank">這裡</a>了解。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>.gitignore 是一個 git 專用的檔案，用來告訴 git 要忽略這個資料夾那些檔案不要加入版本控管。</p><h3 id="karma-conf-js"><a href="#karma-conf-js" class="headerlink" title="karma.conf.js"></a>karma.conf.js</h3><p><a href="https://karma-runner.github.io/latest/index.html" rel="external nofollow noopener noreferrer" target="_blank">karma</a> 是一個單元測試工具，當我們需要做單元測試時可能會需要用到它。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>目前專案 npm 的設定檔，這個檔案相當的重要，因為上面記載著這個專案用了哪些相依套件。</p><p>而其中的 <code>scripts</code> 區塊更是定義了未來在開發 Angular 時經常用到的命令，這邊也可以看到之前用過的命令。</p><h3 id="protractor-conf-js"><a href="#protractor-conf-js" class="headerlink" title="protractor.conf.js"></a>protractor.conf.js</h3><p>同樣也是測試時使用的設定檔，這是 Angular 實作 End-To-End Testing 時會用到的設定檔，到時候用到再來研究就好了。</p><h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>這個設定檔則是 TypeScript 的相關設定存放的地方，這個檔案通常也不太需要修改。</p><h3 id="tslint-json"><a href="#tslint-json" class="headerlink" title="tslint.json"></a>tslint.json</h3><p><a href="https://palantir.github.io/tslint/" rel="external nofollow noopener noreferrer" target="_blank">TSLint</a> 是一套開源的 TypeScript 程式碼風格檢查器，白話點就是類似 ESLint ，這個設定檔就是用來設定 TSLint 所有檢查的規則。</p><h3 id="node-modeles-資料夾"><a href="#node-modeles-資料夾" class="headerlink" title="node_modeles 資料夾"></a>node_modeles 資料夾</h3><p>這個資料夾非常肥大，主要內容為我們使用 <code>npm install</code> 後所有被下載下來所有的套件，基本上這個資料夾的內容都是透過 npm 來管理的，不太需要自己管理它。</p><h3 id="e2e-資料夾"><a href="#e2e-資料夾" class="headerlink" title="e2e 資料夾"></a>e2e 資料夾</h3><p>跟先前提到的 protractor.conf.js 有關，是一個 End-To-End Testing 所有測試的指定檔都被放在這裡。而在 Angular ，所有 End-To-End Testing 的程式碼都是使用 TypeScript 撰寫，如果未來會用到再回過頭來寫這些檔案吧。</p><h2 id="重頭戲-src-資料夾"><a href="#重頭戲-src-資料夾" class="headerlink" title="重頭戲 src 資料夾"></a>重頭戲 src 資料夾</h2><p>src 顧名思義就是整個 Angular 應用程式主要的原始碼，全部都放在這個資料夾底下。而這個資料夾的目錄結構完全按照 Angular 官網的 Style Guide 建立而成，所以我們只要按照這些規範來開發基本上不會出什麼大錯。</p><blockquote><p>接著我們來看 src 底下的目錄結構</p></blockquote><h3 id="app-資料夾"><a href="#app-資料夾" class="headerlink" title="app 資料夾"></a>app 資料夾</h3><p>這個資料夾裡面就是應用程式的主要檔案。</p><h3 id="index-html、style-css"><a href="#index-html、style-css" class="headerlink" title="index.html、style.css"></a>index.html、style.css</h3><p>畢竟 Angular 還是一個 web 的應用程式，既然是 web 就有 HTML，檔名預設就是 index.html。</p><p>同理，自然也會有 style.css ，所以當我們需要 CSS 定義時，可以修改這隻檔案，但是這支並不是單純的 CSS ，在這裡它是 「global styles」也就是整個應用程式都會套用到的 CSS 定義，全部都可以寫在這裡。</p><h3 id="main-ts"><a href="#main-ts" class="headerlink" title="main.ts"></a>main.ts</h3><p>在 Angular 內，我們只能寫 TypeScript，所以這個 main.ts 就是 Angular 中 JavaScript 程式的進入點，也就是主程式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; enableProdMode &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; platformBrowserDynamic &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app/app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; environment &#125; <span class="keyword">from</span> <span class="string">'./environments/environment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (environment.production) &#123;</span><br><span class="line">  enableProdMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><p>其中 <code>platformBrowserDynamic().bootstrapModule(AppModule)</code> 傳入了 <code>AppModule</code> 參數，而這個參數我們循著它的路徑找到位於 app 資料夾內的 app.module.ts 檔。</p><p>發現這隻檔案同樣的引用了其他的檔案：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p>從這邊我們可以看出一些端倪，看起來 app.module.ts 像是在管理要載入那些元件。<br>而從程式碼看來又載入了 <code>AppComponent</code> ，於是順著追查找到了 app.component.ts 檔案，而這支檔案裡面記載著對應那些 template、style 的路徑，如：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'firstAngular'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>回到 app.module.ts ，這裡的 <code>bootstrap</code> 是啟動的意思，意思就是要啟動 <code>AppComponent</code> 。</p><blockquote><p>也就是說 app.module.ts 指定了 <code>AppComponent</code> 當成整個 Angular 應用程式的根元件。</p></blockquote><p>而目前我們看到的這些東西都是透過 Angular CLI 自動產生的範本，之後會一一的修改這些檔案。</p><p>最後還有一個 app.component.spec.ts 檔案，這是一個單元測試的定義檔，我們可以透過 component 附屬的 spec 檔來去定義要如何測試這個 component，所以當我們之後要寫單元測試時，我們就會需要修改這個檔案。</p><h3 id="assets-資料夾"><a href="#assets-資料夾" class="headerlink" title="assets 資料夾"></a>assets 資料夾</h3><p>這個 assets 在英文上有資產的意思，通常意味著所有的靜態檔案，當 Angular 應用程式需要一些靜態檔案，如額外的 JavaScript、JQery、CSS、圖片等等，我們可以統一放置在這個資料夾下。</p><p>而這個資料夾底下的 .gitkeep 是給 Git 看的，因為我們在做 Git 版控時，如果有一個資料夾底下一個檔案都沒有，這個資料夾是不會進入版控的。因此這個 .gitkeep 檔是為了這個目的設計的，讓 assets 資料架內就算沒有任何檔案也能被加入 Git 版控。</p><h3 id="environments-資料夾"><a href="#environments-資料夾" class="headerlink" title="environments 資料夾"></a>environments 資料夾</h3><p>這個資料夾裡面所定義的是 Angular 專案內的環境變數，而這裡面的檔案也都是由 TypeScript 寫成，也就是說我們會透過 TypeScript 定義一些環境變數。說白一點就只是個物件，我們可以在裡面新增一些額外的屬性。</p><p>這個資料夾內有兩個檔案，分別是 environment.ts 與 environment.prod.ts ，差別在於 environment.prod.ts 是只有當 build 出 production 版的應用程式時才用得上，否則在開發時期都是使用另一個設定檔。</p><h3 id="polyfills-ts"><a href="#polyfills-ts" class="headerlink" title="polyfills.ts"></a>polyfills.ts</h3><p>polyfills 代表的是，當 Angular 執行時，如果使用者使用相對較舊的瀏覽器像是萬惡的 IE 系列，有些功能由於使用了一些全新的瀏覽器特性，所以有可能導致程式碼無法順利執行。而這個 polyfills 就是幫助 Angular 在這些比較舊的瀏覽器也能順利運行的關鍵。</p><h3 id="test-ts"><a href="#test-ts" class="headerlink" title="test.ts"></a>test.ts</h3><p>這個檔是被前面介紹到的 Karma.conf.js 檔案使用，是拿來做單元測試才會用到的。</p><h3 id="tsconfig-app-json"><a href="#tsconfig-app-json" class="headerlink" title="tsconfig.app.json"></a>tsconfig.app.json</h3><p>剛才我們講過一個類似的，不過那個是在根目錄下的 tsconfig.json ，而這個設定檔是繼承 tsconfig.json 並做出一些額外的定義。而這個檔案就是針對 app 資料夾裡面所有 TypeScript 來進行一些設定，比起最外層的設定，我們比較有可能修改到這一份，一樣是有用到再來修改即可。</p><h3 id="tsconfig-spec-json"><a href="#tsconfig-spec-json" class="headerlink" title="tsconfig.spec.json"></a>tsconfig.spec.json</h3><p>是我們在寫單元測試的 TypeScript 程式碼的時候可能會需要用到的一些設定檔。</p><h3 id="typings-d-ts"><a href="#typings-d-ts" class="headerlink" title="typings.d.ts"></a>typings.d.ts</h3><p>這個也是 TypeScript 會用到的設定檔，主要的用途是定義那些額外的 TypeScript 型別定義，比方說當我們想把 JQuery 也整合進 Angular ，我們就很有可能修改到這隻檔案，可以在這隻檔案內宣告一些 Angular 內會用到的全域變數，例如 $ ：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> $: any;</span><br></pre></td></tr></table></figure><p></p><p>這麼做之後，所有 Angular 內的 TypeScript 程式碼都可以使用 $ 這個全域變數，於是在編譯時就不會出錯了，而這部分也是需要用到時才要修改的。</p><p>不過這支檔案，我的 Angular CLI 版本是 7.3.9 版，似乎沒有自動產生這隻檔案，因此這隻檔案很可能之後要自己手動增加或是已經捨棄不用了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>總算是介紹完 Angular 的檔案結構了，除了 TypeScript 相關的檔案之外，其他都是蠻眼熟的檔案，然後也明白 Angular 也是元件、元件、元件堆起來的網站，這點跟 Vue 蠻像的，目前比較在意 TypeScript 的部分，設定檔這麼多支感覺起來頗複雜，再加上不熟 Angular 語法，可以預期是場硬仗。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      緊接著了解 Angular 專案內的檔案結構，我覺得這是相當重要的。畢竟只有在認識了這些檔案結構後，才有辦法因應日後專案的調整，也才知道要在哪裡修改對應的配置。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.1 建立專案</title>
    <link href="http://pvt5r486.github.io/f2e/20190520/1704649665/"/>
    <id>http://pvt5r486.github.io/f2e/20190520/1704649665/</id>
    <published>2019-05-20T09:54:00.000Z</published>
    <updated>2019-06-09T05:32:16.855Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安裝好開發 Angular 需要的環境後，緊接著就是建立起 Angular 專案的骨架了，讓我們一塊來了解如何使用 Angular CLI 建立一個 Angular 的專案吧。</p><p><img src="https://images.unsplash.com/photo-1558254026-f13859e884d8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><h2 id="建立-Angular-專案資料夾"><a href="#建立-Angular-專案資料夾" class="headerlink" title="建立 Angular 專案資料夾"></a>建立 Angular 專案資料夾</h2><p>那麼，該如何 Angular 專案資料夾呢？</p><h3 id="手動建立一個空的資料夾"><a href="#手動建立一個空的資料夾" class="headerlink" title="手動建立一個空的資料夾"></a>手動建立一個空的資料夾</h3><p>首先，我們可以先手動替專案建立一個資料夾，像是我在 D 槽建立一個 learnAngular 的資料夾，這樣比較方便管理。</p><p><img src="https://i.imgur.com/5sDBaux.png" alt></p><h3 id="cd-切換到自訂的資料夾"><a href="#cd-切換到自訂的資料夾" class="headerlink" title="cd 切換到自訂的資料夾"></a>cd 切換到自訂的資料夾</h3><p>接著打開 CMD 並且輸入以下指令，切換到剛才建立的資料夾內。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d D:learnAngular</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/ru9HPDA.png" alt></p><h3 id="初始化專案環境"><a href="#初始化專案環境" class="headerlink" title="初始化專案環境"></a>初始化專案環境</h3><ul><li><code>ng new 專案名稱</code> - 透過指令建立 Angular 專案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new firstAngular</span><br></pre></td></tr></table></figure></li></ul><p>輸入後， Angular CLI 會問我們一些事項：</p><ul><li>要不要加入 Angular Routing (y/N) [在此我選 N]</li><li>要使用哪一種 CSS 預處理器 (多選) [在此我選 SCSS]</li></ul><blockquote><p>接著進入一連串的套件安裝，安裝完後可以發現多了 firstAngular 資料夾，且裡面建立了不少檔案。</p></blockquote><p><img src="https://i.imgur.com/kVlrz5e.png" alt></p><h2 id="執行專案"><a href="#執行專案" class="headerlink" title="執行專案"></a>執行專案</h2><p>然後再次使用 cd 指令，進入 firstAngular 資料夾。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd firstAngular</span><br></pre></td></tr></table></figure><p></p><p>正確切換到這個資料夾後，輸入 <code>npm start</code> 運行 Angular 專案。</p><p>如操作正確，應看到如下畫面，可複製網址至瀏覽器網址列貼上觀察。</p><blockquote><p>注意：此時 CMD 視窗不可關閉，因為執行 <code>npm start</code> 指令後，其實是透過 <code>ng serve</code> 的指令啟動 node.js 的 web server ，這樣我們才可以在瀏覽器上看到對應的網頁。</p></blockquote><p><img src="https://i.imgur.com/TX05iCF.png" alt></p><p><img src="https://i.imgur.com/8y4ZWKc.png" alt="專案正確執行"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>進行到這個階段，目前我們已經掌握了:</p><ul><li>知道開發 Angular 需要那些套件並且安裝他們</li><li>使用 Angular CLI 建立一個 Angular 專案</li><li>透過 <code>npm start</code> 運行 Angular 的開發伺服器，並透過瀏覽器觀察這個網頁</li></ul><p>接下來我們要了解 Angular 專案內的檔案結構。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      安裝好開發 Angular 需要的環境後，緊接著就是建立起 Angular 專案的骨架了，讓我們一塊來了解如何使用 Angular CLI 建立一個 Angular 的專案吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>[從 0 開始的 Angular 生活]No.0 環境準備</title>
    <link href="http://pvt5r486.github.io/f2e/20190520/1659785282/"/>
    <id>http://pvt5r486.github.io/f2e/20190520/1659785282/</id>
    <published>2019-05-20T08:14:18.000Z</published>
    <updated>2019-06-09T05:32:20.920Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本來是沒有打算要學習 Angular 的，目前前端的三大框架 Angular、React、Vue 我已經學習了 Vue ，想說應該是精通一種框架運用即可。但人算不如天算，在新的工作環境中需要掌握 Angular 的技術，當作給自己的挑戰，那就硬著頭皮上吧。</p><p><img src="https://images.unsplash.com/photo-1558216629-a2f7fe856792?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=967&amp;q=80" alt></p><h2 id="開發-Angular-前的環境準備"><a href="#開發-Angular-前的環境準備" class="headerlink" title="開發 Angular 前的環境準備"></a>開發 Angular 前的環境準備</h2><p>「工欲善其事，必先利其器」，下面這些軟體可以單獨到各自官網安裝，也可以透過 <strong>Chocolatey</strong> 一鍵安裝，總之讓我們先準備一下環境吧。</p><ul><li>安裝 node.js</li><li>安裝 Git</li><li>安裝 VS Code</li><li>透過 <strong>Chocolatey</strong> 安裝以上</li></ul><h3 id="安裝-Chocolatey"><a href="#安裝-Chocolatey" class="headerlink" title="安裝 Chocolatey"></a>安裝 Chocolatey</h3><p><a href="https://zh.wikipedia.org/wiki/Chocolatey" rel="external nofollow noopener noreferrer" target="_blank">Chocolatey</a> 是一個 Windows 下的軟體包管理器，可以像在類 Unix 系統中使用 Yum 和 APT 一樣使用它，在 Windows 中實現自動化輕鬆管理 Windows 軟體的所有方面（安裝，組態，更新和解除安裝）</p><p>首先進到 <a href="https://chocolatey.org/" rel="external nofollow noopener noreferrer" target="_blank">Chocolatey</a> 網站內，可以看到 install 的按鈕。<br><img src="https://i.imgur.com/dLT3Aj2.png" alt></p><p>接著往下捲一點，這邊有兩個選擇</p><ul><li>使用 CMD 並輸入指令安裝</li><li>使用 PowerShell 並輸入指令安裝</li></ul><p><img src="https://i.imgur.com/J6nPAyP.png" alt></p><p>這裡我使用 CMD 安裝，以「管理員身分」打開 CMD 後貼上這一串<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure><p></p><p>執行結束後，輸入 <code>choco /?</code> 確認版本號，若安裝成功則出現對應版本號，出現錯誤則代表沒有安裝成功。</p><p><img src="https://i.imgur.com/xnn3UAz.png" alt></p><h3 id="透過-Chocolatey-安裝開發-Angular-的其他必要工具"><a href="#透過-Chocolatey-安裝開發-Angular-的其他必要工具" class="headerlink" title="透過 Chocolatey 安裝開發 Angular 的其他必要工具"></a>透過 Chocolatey 安裝開發 Angular 的其他必要工具</h3><p>我們可以透過 Chocolatey 官網提共的<a href="https://chocolatey.org/packages" rel="external nofollow noopener noreferrer" target="_blank">搜尋</a>功能，快速找到我們要安裝的軟體，例如搜尋 node.js 。</p><p><img src="https://i.imgur.com/CAe58Q5.png" alt></p><p>由於我們要安裝 Git、VSCode、Node.js ，所以打開 CMD 並且輸入以下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install -y git nodejs vscode</span><br></pre></td></tr></table></figure><p></p><p><strong>參數說明</strong></p><ul><li><code>-y</code> - 安裝時默認同意，不再詢問是否同意安裝</li></ul><p><img src="https://i.imgur.com/zNLKbMc.png" alt></p><blockquote><p>透過這樣的方式，我們僅需要一行指令，就安裝好這些軟體，這是相當方便的，當然 Chocolatey 並非必要的，我們還是可以手動進行軟體的安裝。</p></blockquote><h3 id="測試上述軟體是否安裝成功"><a href="#測試上述軟體是否安裝成功" class="headerlink" title="測試上述軟體是否安裝成功"></a>測試上述軟體是否安裝成功</h3><p><strong>如果是使用 Chocolatey 方式安裝，必須先把當前的 CMD 關閉重啟，才可以正確執行指令。</strong></p><blockquote><p>依序輸入 <code>npm -v</code> 、 <code>node -v</code> 、 <code>git --version</code> ，若都有安裝成功則回應版本號。</p></blockquote><p><img src="https://i.imgur.com/O1vPkyh.png" alt></p><p>最後打開 VS Code ，就可以開始我們的第一個專案囉。</p><p><img src="https://i.imgur.com/xg0FHj7.png" alt></p><h2 id="安裝-Angular-CLI"><a href="#安裝-Angular-CLI" class="headerlink" title="安裝 Angular CLI"></a>安裝 Angular CLI</h2><p>接下來我們要安裝 <a href="https://cli.angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular CLI</a> ，看到這邊覺得蠻熟悉的， Vue 也有 CLI。</p><p>同樣是透過 npm 來安裝，打開 CMD 輸入指令如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure><p></p><blockquote><p>輸入 <code>ng --version</code> 檢測是否正確安裝</p></blockquote><p><img src="https://i.imgur.com/Fet4r8V.png" alt></p><h2 id="安裝-VS-Code-的擴充插件"><a href="#安裝-VS-Code-的擴充插件" class="headerlink" title="安裝 VS Code 的擴充插件"></a>安裝 VS Code 的擴充插件</h2><p>這部分就屬於非必需的了，這部分可以自由挑選喜歡的擴充插件讓開發 Angular 時更加得心應手。所以這裡推薦保哥的 Angular Extension Pack ，下載次數有 26 萬，評價也蠻高的，看來是個不錯的插件。觀察相依性的部分，也安裝了一些開發 Angular 時會用到的額外插件，算是安裝一套，就全部搞定的感覺。</p><p><img src="https://i.imgur.com/JOsg19d.png" alt></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上就是開發 Angular 時可能會用到的所有工具，接下來我們就可以著手建立 Angular 專案囉。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本來是沒有打算要學習 Angular 的，因為目前前端的三大框架 Angular、React、Vue 我已經學習了 Vue ，想說應該是精通一種框架運用即可。但人算不如天算，在新的工作環境中需要掌握 Angular 的技術，當作給自己的挑戰，那就硬著頭皮上吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="Angular" scheme="http://pvt5r486.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>HTTP_Game攻略(二)</title>
    <link href="http://pvt5r486.github.io/life-note/20190515/1070876814/"/>
    <id>http://pvt5r486.github.io/life-note/20190515/1070876814/</id>
    <published>2019-05-15T05:40:33.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重提一下 <strong><a href="https://lidemy-http-challenge.herokuapp.com/start" rel="external nofollow noopener noreferrer" target="_blank">Lidemy HTTP Challenge</a></strong><br>是 Huli 在程式導師計畫中推出來讓我們練習的小遊戲，用來加深對於 HTTP 通訊協定的觀念。</p><p>在 <a href="https://pvt5r486.github.io/note/20190513/2430981100">HTTP_Game攻略(一)</a> 中，我們完成了前面 10 關的挑戰，但是前面 10 關只是開胃菜，繼續往前邁進吧！</p><p><img src="https://images.unsplash.com/photo-1491193348662-47874a96c621?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1355&amp;q=80" alt></p><h2 id="LV-10"><a href="#LV-10" class="headerlink" title="LV.10"></a>LV.10</h2><p>休息關卡，前往下一關的網址為<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv11?token=&#123;IhateCORS&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="LV-11"><a href="#LV-11" class="headerlink" title="LV.11"></a>LV.11</h2><p>新的挑戰就要搭配新的 <a href="https://gist.github.com/aszx87410/0b0d3cabf32c4e44084fadf5180d0cf4" rel="external nofollow noopener noreferrer" target="_blank">API 文件</a></p><h3 id="關卡要求"><a href="#關卡要求" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>利用此 API 文件內提供的方法，跟伺服器打個招呼。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>這一題如果直接使用 GET 方法，會得到這段系統提示：</p><blockquote><p>您的 origin 不被允許存取此資源，請確認您是從 lidemy.com 送出 request</p></blockquote><p>因此，我們需要在 <code>header</code> 內偽造 <code>origin</code> ，具體作法如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">'https://lidemy-http-challenge.herokuapp.com/api/v3/hello'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'origin'</span>: <span class="string">'lidemy.com'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(body);</span><br><span class="line">&#125;</span><br><span class="line">request.get(options, callback);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>執行後得知 <code>token</code> 為 <code>{r3d1r3c7}</code></p></blockquote><h2 id="LV-12"><a href="#LV-12" class="headerlink" title="LV.12"></a>LV.12</h2><h3 id="關卡要求-1"><a href="#關卡要求-1" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>使用 API 文件提供的方法，獲得藏在其中的 <code>token</code></p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>這一關不需要寫程式碼，要考驗的是會不會使用 chrome 開發者工具，打開瀏覽器後，按下 F12 ，然後在 Network 分頁中預備觀察 request ，並於網址列中輸入以下網址，訪問 API<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/api/v3/deliver_token</span><br></pre></td></tr></table></figure><p></p><p>會發現當訪問該 API 後，我們被轉址到其他地方了。<br>順序如下:<br>deliver_token &gt; stopover &gt; deliver_token_result</p><blockquote><p>因此，中間的 stopover 就是關鍵！</p></blockquote><p>可以透過 Network 分頁觀察 stopover ，發現 header 內夾帶 <code>X-Lv13-Token: {qspyz}</code> 。</p><h2 id="LV-13"><a href="#LV-13" class="headerlink" title="LV.13"></a>LV.13</h2><h3 id="關卡要求-2"><a href="#關卡要求-2" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>這部份比較難敘述，因此直接引用題目內文：</p><blockquote><p>太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍<br>可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗<br>我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？<br>從系統日誌裡面應該可以找到一些端倪。</p></blockquote><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>如果直接使用 GET 方法，會得到這段系統提示：</p><blockquote><p>此 request 不是來自菲律賓，禁止存取系統資訊。</p></blockquote><p>沒什麼頭緒，代入 <code>hint=1</code> 看看提示吧：</p><blockquote><p>你有聽過代理伺服器 proxy 嗎？</p></blockquote><p>看來是要我們設定跟 proxy 有關的東西了。</p><p>我們可在 chrome 的設定頁面中搜尋 proxy ，即可開啟設定視窗<br><img src="https://i.imgur.com/K48UDGk.jpg" alt="設定視窗"><br><img src="https://i.imgur.com/1qaBsIw.jpg" alt="Imgur"></p><p>接著就是上網搜尋 proxy 的站點了：</p><ul><li><a href="http://free-proxy.cz/zh/proxylist/country/PH/http/ping/all" rel="external nofollow noopener noreferrer" target="_blank">菲律賓 proxy</a></li></ul><p><strong>勾選協議是 HTTP 按下搜尋，並挑選可用性高且速度快的設定上去吧。</strong><br>這個步驟可能要重複多次，畢竟不是每個 proxy 都能用。</p><p>接著在網址列輸入以下，訪問該 API<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/api/v3/logs</span><br></pre></td></tr></table></figure><p></p><blockquote><p>成功可以看到以下畫面，得知 <code>token</code> 為 <code>{SEOisHard}</code></p></blockquote><p><img src="https://i.imgur.com/K6UEAxO.jpg" alt="取得 token"></p><h2 id="LV-14"><a href="#LV-14" class="headerlink" title="LV.14"></a>LV.14</h2><h3 id="關卡要求-3"><a href="#關卡要求-3" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>同樣是很難敘述的一關，直接上文章敘述：</p><blockquote><p>跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！<br>不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的<br>為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了<br>他們的網站明明就什麼都沒有，怎麼會排在那麼前面？<br>難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？<br>算了，還是不要瞎猜好了，你幫我們研究一下吧！</p></blockquote><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>依然沒什麼頭緒，代入 <code>hint=1</code> 看看提示吧：</p><blockquote><p>伺服器是怎麼辨識是不是 Google 搜尋引擎的？仔細想想之前我們怎麼偽裝自己是 IE6 的。</p></blockquote><p>我們之前是透過修改 <code>User-Agent</code> 假裝自己是 IE6 ，所以這一題也是要從 <code>User-Agent</code> 著手。</p><p>但在這之前，我們需要先了解，所謂的 <code>User-Agent</code> 是什麼：</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10209356" rel="external nofollow noopener noreferrer" target="_blank">User-Agent 說明與使用</a></li></ul><p>在還沒接觸這個挑戰時，我一直以為 <code>User-Agent</code> 就是設定一串透過哪種瀏覽器名稱、瀏覽器版本號的字串，但解完這一題後，發現 <code>User-Agent</code> 其實還可以設定要使用哪種搜尋引擎。</p><ul><li><a href="http://www.lrxin.com/archives-325.html" rel="external nofollow noopener noreferrer" target="_blank">各个搜索引擎的User-Agent</a></li></ul><p>因此這題的答案也呼之欲出了，只需要修改之前偽裝 IE6 瀏覽器那一題的程式碼即可。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">'https://lidemy-http-challenge.herokuapp.com/api/v3/index'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'origin'</span>: <span class="string">'lidemy.com'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(body);</span><br><span class="line">&#125;</span><br><span class="line">request.get(options, callback);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>執行後得知 <code>token</code> 為 <code>{ILOVELIdemy!!!}</code></p></blockquote><h2 id="LV-15"><a href="#LV-15" class="headerlink" title="LV.15"></a>LV.15</h2><p>恭喜破關～謝謝你跟著本文一路前進到這裡。<br>如果覺得這個遊戲好玩，也請多多支持遊戲的開發者。</p><ul><li>HTTP 遊戲開發者 <a href="https://www.facebook.com/lidemytw/" rel="external nofollow noopener noreferrer" target="_blank">Huli</a></li><li>作者聯絡信箱 <a href="mailto:huli@lidemy.com" rel="external nofollow noopener noreferrer" target="_blank">huli@lidemy.com</a></li></ul><p>另外我也把這幾關有寫到程式的部份，放到 <a href="https://github.com/pvt5r486/HTTP_Challenge" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 中，有需要可以自行下載研究哩 :D</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在 HTTP_Game 攻略(一)中，我們完成了前面 10 關的挑戰，但是前面 10 關只是開胃菜，繼續往前邁進吧！
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="HTTP" scheme="http://pvt5r486.github.io/tags/HTTP/"/>
    
      <category term="程式導師計畫" scheme="http://pvt5r486.github.io/tags/%E7%A8%8B%E5%BC%8F%E5%B0%8E%E5%B8%AB%E8%A8%88%E7%95%AB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP_Game攻略(一)</title>
    <link href="http://pvt5r486.github.io/life-note/20190513/2430981100/"/>
    <id>http://pvt5r486.github.io/life-note/20190513/2430981100/</id>
    <published>2019-05-13T11:33:36.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://lidemy-http-challenge.herokuapp.com/start" rel="external nofollow noopener noreferrer" target="_blank">Lidemy HTTP Challenge</a><br>是 Huli 在程式導師計畫中推出來讓我們練習的小遊戲，用來加深對於 HTTP 通訊協定的觀念。在第三期還沒正式開始之前，我就已經先玩過一次了，不過當時是使用 POSTMAN 通關，這次我打算使用 Node.js 搭配 <a href="https://www.npmjs.com/package/request#promises--asyncawait" rel="external nofollow noopener noreferrer" target="_blank">Request 套件</a>通關。</p><p><img src="https://images.unsplash.com/photo-1445499348736-29b6cdfc03b9?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80" alt></p><h2 id="LV-0"><a href="#LV-0" class="headerlink" title="LV.0"></a>LV.0</h2><p>只是教學關卡，按照說明文建操作即可。</p><p><strong>參數部份</strong></p><ul><li><code>token={...}</code> ，當成功解決關卡就會得知 token 內容，代入即可前往下關。</li><li><code>&amp;hint=1</code> ，看提示用</li></ul><p>因此輸入下列網址，前往下一關。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv1?token=&#123;GOGOGO&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="LV-1"><a href="#LV-1" class="headerlink" title="LV.1"></a>LV.1</h2><ul><li>得到一份之後會用到的 <a href="https://gist.github.com/aszx87410/3873b3d9cbb28cb6fcbb85bf493b63ba" rel="external nofollow noopener noreferrer" target="_blank">API 文件</a></li></ul><h3 id="關卡要求"><a href="#關卡要求" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>使用 get 方法把自己的 namr 傳給 Server 。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>操作網址列帶入參數即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv1?token=&#123;GOGOGO&#125;&amp;name=Alvan</span><br></pre></td></tr></table></figure><p></p><blockquote><p>得知 <code>token</code> 為 <code>{HellOWOrld}</code></p></blockquote><h2 id="LV-2"><a href="#LV-2" class="headerlink" title="LV.2"></a>LV.2</h2><h3 id="關卡要求-1"><a href="#關卡要求-1" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>有本書的 id 是兩位數，介於 54 ~ 58 之間，找到是哪一本之後，把書的 id 傳給 Server 。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>操作網址列帶入參數 (id: 54 ~ 58 間) 即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv2?token=&#123;HellOWOrld&#125;&amp;id=56</span><br></pre></td></tr></table></figure><p></p><blockquote><p>用硬 A 法得知 <code>token</code> 為 <code>{5566NO1}</code></p></blockquote><h2 id="LV-3"><a href="#LV-3" class="headerlink" title="LV.3"></a>LV.3</h2><p>查看 LV.1 時得到的<a href="https://gist.github.com/aszx87410/3873b3d9cbb28cb6fcbb85bf493b63ba" rel="external nofollow noopener noreferrer" target="_blank">API 文件</a></p><h3 id="關卡要求-2"><a href="#關卡要求-2" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>新增一本書名是《大腦喜歡這樣學》，ISBN 為 9789863594475 ，接著把 id 傳給 Server</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">request.post(&#123;</span><br><span class="line">  url:<span class="string">'https://lidemy-http-challenge.herokuapp.com/api/books'</span>, </span><br><span class="line">  form: </span><br><span class="line">    &#123;</span><br><span class="line">      name:<span class="string">'《大腦喜歡這樣學》'</span>,</span><br><span class="line">      ISBN: <span class="number">9789863594475</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err,httpResponse,body</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'httpResponse'</span>, httpResponse);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'body:'</span>, body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>執行後獲得 <code>id</code> 為 1989 ，從網址列傳給 Server。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv3?token=&#123;5566NO1&#125;&amp;id=1989</span><br></pre></td></tr></table></figure><p></p><blockquote><p>得知 <code>token</code> 為 <code>{LEarnHOWtoLeArn}</code></p></blockquote><h2 id="LV-4"><a href="#LV-4" class="headerlink" title="LV.4"></a>LV.4</h2><p>之後的關卡大多都需要查看 API 文件，就不贅述了。</p><h3 id="關卡要求-3"><a href="#關卡要求-3" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>搜尋書名有：「世界」兩字，而且是村上春樹寫的，接著把 id 傳給 Server</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>直接代入參數 <code>q</code> 查詢是無效的，本題關鍵點在於使用 <code>encodeURI()</code> 轉換網址。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'世界'</span>;</span><br><span class="line"><span class="keyword">let</span> uri = <span class="built_in">encodeURI</span>(<span class="string">`https://lidemy-http-challenge.herokuapp.com/api/books?q=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">request.get(uri, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>執行後獲得 <code>id</code> 為 79 ，從網址列傳給 Server。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv4?token=&#123;LEarnHOWtoLeArn&#125;&amp;id=79</span><br></pre></td></tr></table></figure><p></p><blockquote><p>得知 <code>token</code> 為 <code>{HarukiMurakami}</code></p></blockquote><h2 id="LV-5"><a href="#LV-5" class="headerlink" title="LV.5"></a>LV.5</h2><h3 id="關卡要求-4"><a href="#關卡要求-4" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>刪除一本 id 是 23 的書</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>使用 delete 方法，得到系統回傳的 <code>token</code><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.delete(<span class="string">'https://lidemy-http-challenge.herokuapp.com/api/books/23'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>得知 <code>token</code> 為 <code>{CHICKENCUTLET}</code></p></blockquote><h2 id="LV-6"><a href="#LV-6" class="headerlink" title="LV.6"></a>LV.6</h2><p>獲得新的 <a href="https://gist.github.com/aszx87410/1e5e5105c1c35197f55c485a88b0328a" rel="external nofollow noopener noreferrer" target="_blank">API 文件</a>，往後都使用這一份。</p><h3 id="關卡要求-5"><a href="#關卡要求-5" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>獲得一組帳號密碼：</p><ul><li>帳號：admin</li><li>密碼：admin123<br>登入後，呼叫 /me 的 endpoint，得到一組 email 並傳給 Server</li></ul><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>由文件可知，必須準備好一組字串，內容為 <code>base64(username:password)</code> 。</p><p>所以要對帳號以及密碼進行 base64 編碼， Node.js 可使用 <code>Buffer.from()</code> 進行 base64 編碼。<br>得到 base64 編碼後，將其加入請求的 header 中。</p><ul><li>關鍵字 <code>http basic authorization</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">let</span> account = <span class="string">'admin'</span>;</span><br><span class="line"><span class="keyword">let</span> pwd = <span class="string">'admin123'</span>;</span><br><span class="line"><span class="keyword">let</span> base64Str = Buffer.from(<span class="string">`<span class="subst">$&#123;account&#125;</span>:<span class="subst">$&#123;pwd&#125;</span>`</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">//console.log(base64Str);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">'https://lidemy-http-challenge.herokuapp.com/api/v2/me'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;base64Str&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">request.get(options, callback);</span><br></pre></td></tr></table></figure></li></ul><p>執行後得知 <code>email</code> 為 <a href="mailto:lib@lidemy.com" rel="external nofollow noopener noreferrer" target="_blank">lib@lidemy.com</a> ，使用 <code>query string</code> 傳給 Server 。</p><blockquote><p>得知 <code>token</code> 為 <code>{SECurityIsImPORTant}</code></p></blockquote><h2 id="LV-7"><a href="#LV-7" class="headerlink" title="LV.7"></a>LV.7</h2><h3 id="關卡要求-6"><a href="#關卡要求-6" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>刪除 id 是 89 的書籍</p><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>與上題差別不大，修改方法以及 API 即可<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">let</span> account = <span class="string">'admin'</span>;</span><br><span class="line"><span class="keyword">let</span> pwd = <span class="string">'admin123'</span>;</span><br><span class="line"><span class="keyword">let</span> base64Str = Buffer.from(<span class="string">`<span class="subst">$&#123;account&#125;</span>:<span class="subst">$&#123;pwd&#125;</span>`</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">//console.log(base64Str);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">'https://lidemy-http-challenge.herokuapp.com/api/v2/books/89'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;base64Str&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">request.delete(options, callback);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>執行後得知 <code>token</code> 為 <code>{HsifnAerok}</code></p></blockquote><h2 id="LV-8"><a href="#LV-8" class="headerlink" title="LV.8"></a>LV.8</h2><h3 id="關卡要求-7"><a href="#關卡要求-7" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>修改某書內名稱有個「我」且作者的名字是四個字， 輸入錯的 ISBN 最後一碼為 7 ，只要把最後一碼改成 3 就行了。</p><h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><ul><li>查詢書籍，獲得正確 id 為 72</li><li>修改書籍<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">let</span> account = <span class="string">'admin'</span>;</span><br><span class="line"><span class="keyword">let</span> pwd = <span class="string">'admin123'</span>;</span><br><span class="line"><span class="keyword">let</span> base64Str = Buffer.from(<span class="string">`<span class="subst">$&#123;account&#125;</span>:<span class="subst">$&#123;pwd&#125;</span>`</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">//console.log(base64Str);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findBook</span>(<span class="params">queryStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> encodeUri = <span class="built_in">encodeURI</span>(<span class="string">`https://lidemy-http-challenge.herokuapp.com/api/v2/books?q=<span class="subst">$&#123;queryStr&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    url: encodeUri,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;base64Str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">  &#125;</span><br><span class="line">  request.get(options, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateISBN</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    url: <span class="string">'https://lidemy-http-challenge.herokuapp.com/api/v2/books/72'</span>,</span><br><span class="line">    contentType: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;base64Str&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    form: &#123;</span><br><span class="line">      name: <span class="string">'日日好日：茶道教我的幸福15味【電影書腰版】'</span>,</span><br><span class="line">      ISBN: content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">  &#125;</span><br><span class="line">  request.patch(options, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出符合的書籍</span></span><br><span class="line">findBook(<span class="string">'我'</span>);</span><br><span class="line"><span class="comment">// 修改資料</span></span><br><span class="line">updateISBN(<span class="number">9981835423</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>執行後得知 <code>token</code> 為 <code>{NeuN}</code></p></blockquote><h2 id="LV-9"><a href="#LV-9" class="headerlink" title="LV.9"></a>LV.9</h2><h3 id="關卡要求-8"><a href="#關卡要求-8" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>根據敘述，需要符合兩個條件才能使用這個 API</p><ul><li>帶上一個 <code>X-Library-Number</code> 的 header，我們圖書館的編號是 20</li><li>伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉<br>拿到系統資訊之後取得 version 欄位內的值，並傳回 Server</li></ul><h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><ul><li>補上對應的 header</li><li>偽造 IE6 的 <code>User-Agent</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">let</span> account = <span class="string">'admin'</span>;</span><br><span class="line"><span class="keyword">let</span> pwd = <span class="string">'admin123'</span>;</span><br><span class="line"><span class="keyword">let</span> base64Str = Buffer.from(<span class="string">`<span class="subst">$&#123;account&#125;</span>:<span class="subst">$&#123;pwd&#125;</span>`</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">//console.log(base64Str);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> encodeUri = <span class="built_in">encodeURI</span>(<span class="string">`https://lidemy-http-challenge.herokuapp.com/api/v2/sys_info`</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: encodeUri,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">`Basic <span class="subst">$&#123;base64Str&#125;</span>`</span>,</span><br><span class="line">    <span class="string">'X-Library-Number'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</span><br><span class="line">&#125;</span><br><span class="line">request.get(options, callback);</span><br></pre></td></tr></table></figure></li></ul><p>執行後得知 <code>version</code> 值為 1A4938Jl7 ， 使用 <code>query string</code> 傳給 Server 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv9?token=&#123;NeuN&#125;&amp;version=1A4938Jl7</span><br></pre></td></tr></table></figure><p></p><blockquote><p>執行後得知 <code>token</code> 為 <code>{duZDsG3tvoA}</code></p></blockquote><h2 id="LV-10"><a href="#LV-10" class="headerlink" title="LV.10"></a>LV.10</h2><h3 id="關卡要求-9"><a href="#關卡要求-9" class="headerlink" title="關卡要求"></a>關卡要求</h3><p>猜數字遊戲，規則如下：<br>出題者會出一個四位數不重複的數字，例如說 9487。<br>你如果猜 9876，我會跟你說 1A2B， 1A 代表 9 位置對數字也對， 2B 代表 8 跟 7 你猜對了但位置錯了。</p><p>把要猜的數字放在 <code>query string</code> 用 num 當作 key 傳給 Server 。</p><h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>就慢慢嘗試，這是邏輯問題<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lidemy-http-challenge.herokuapp.com/lv10?token=&#123;duZDsG3tvoA&#125;&amp;num=9876</span><br></pre></td></tr></table></figure><p></p><p>最後得知正確數字為 9613</p><blockquote><p>執行後得知 <code>token</code> 為 <code>{IhateCORS}</code></p></blockquote><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>到這邊基礎的 1 ~ 10 關已經全破了，然而後面還有 5 關比較進階的關卡可以挑戰，寫到這邊篇幅已經很長了，下一篇再繼續寫攻略。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Lidemy HTTP Challenge 是 Huli 在程式導師計畫中推出來讓我們練習的小遊戲，用來加深對於 HTTP 通訊協定的觀念。在第三期還沒正式開始之前，我就已經先玩過一次了，不過當時是使用 POSTMAN 通關，這次我打算使用 Node.js 搭配 Request 套件通關。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="HTTP" scheme="http://pvt5r486.github.io/tags/HTTP/"/>
    
      <category term="程式導師計畫" scheme="http://pvt5r486.github.io/tags/%E7%A8%8B%E5%BC%8F%E5%B0%8E%E5%B8%AB%E8%A8%88%E7%95%AB/"/>
    
  </entry>
  
  <entry>
    <title>參加程式導師計劃的前四周心得</title>
    <link href="http://pvt5r486.github.io/life-note/20190510/2820273868/"/>
    <id>http://pvt5r486.github.io/life-note/20190510/2820273868/</id>
    <published>2019-05-10T00:09:30.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因緣際會下參加了這個<a href="https://medium.com/hulis-blog/mentor-program-3rd-47a2e85e33b3" rel="external nofollow noopener noreferrer" target="_blank"><strong>計劃</strong></a>，開始不間斷的自主學習，這是我的<a href="https://github.com/Lidemy/mentor-program-3rd-pvt5r486" rel="external nofollow noopener noreferrer" target="_blank"><strong>計劃 repo</strong></a> ，有興趣的朋友可以點開來看看，每周我提交的作業也都會在上面。不過之後要是找到工作，可能就沒辦法兼顧這邊了，但我還是會想辦法完成它。</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*pfbQln0L5sgsQa91" alt></p><h2 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h2><p>這一周算是比較放鬆的週，主要就是拿來回顧、寫寫心得。</p><p>前面幾周因為自己並不是毫無程式基礎的人，所以就算因為被其他的事情耽擱到一些進度也不要緊，算是還可以處理的範圍，因此前面幾周並沒有感受到特別的壓力。</p><p>我也覺得自己真的很幸運，幾個月前我從來沒想到自己會走到這裡、參加這個第三期的實驗計劃，也不清楚自己是哪一點特質願意讓胡立免費讓我參加這一次的計劃，我只想說「<strong>謝謝</strong>」。</p><p>在轉職前端的路上，我有太多的人要感謝了，大家都很熱情的幫助我，在我做的到的範圍裡，我也會持續的分享自己學習的紀錄。</p><h2 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h2><p>因為自己是本科生的關係，所以計算機概論的知識算是有的，並沒有耗費太多時間在課程上，但我還是很認真的全部看完了。也算是複習了已經還給老師的排序法。</p><p>Git 的部份雖然我之前已經有先學習過了，但我覺得多聽幾次有益無害，而且也多認識到如何發一個 PR 給別人，這還蠻有趣的。也讓我知道從開分支起到一系列的操作過程、發 PR 給別人 Merge ，這樣子的過程就是所謂的 GitHub flow ，算是又多了解一個名詞。</p><p>Command Line 的部份我也很喜歡，就覺得工程師就是要用 Command Line 輸入指令才帥啊，雖然比較不直覺是真的，需要一點時間適應。</p><h2 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h2><p>這周開始進入到 基礎 JavaScript 的部份了，因為之前有學習過的關係，也沒有花太多時間在理解課程上，同樣是全部看過一次就開始練習寫題目了。透過這樣的題目練習，我明白果然學程式不能只用看的，還是要實際寫才能知道水深。</p><p>而且，把<strong>大問題逐步分解成一個個小問題</strong>的心法很受用，覺得這一周最重要的莫過於這個心法了。</p><h2 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h2><p>第三周是上一周的進階，而這一周的課程就是我比較欠缺的了，如:</p><ul><li>npm</li><li>Webpack</li><li>ES6 語法</li><li>Jest</li><li>Babel</li></ul><p>等等一些較進階的東西，所以我也在自己的部落格寫了 8 篇跟 Webpack 相關的應用：</p><ul><li><a href="https://pvt5r486.github.io/2019/04/30/Webpack/[Webpack]No.1%20%E6%A8%A1%E7%B5%84%E5%8C%96%20JavaScript%20%E7%9A%84%E6%96%B9%E6%B3%95/">[Webpack]No.1 模組化 JavaScript 的方法</a></li><li><a href="https://pvt5r486.github.io/2019/05/01/Webpack/[Webpack]No.2%20package.json%20%E8%A8%AD%E7%BD%AE%E5%B0%88%E5%B1%AC%E6%88%91%E5%80%86%E7%9A%84%E5%B0%8F%E5%92%92%E8%AA%9E/">[Webpack]No.2 package.json 設置專屬我倆的小咒語</a></li><li><a href="https://pvt5r486.github.io/2019/05/01/Webpack/[Webpack]No.3%20%E4%BD%BF%E7%94%A8%20Jest%20%E9%80%B2%E8%A1%8C%20Unit%20Test/">[Webpack]No.3 使用 Jest 進行 Unit Test</a></li><li><a href="https://pvt5r486.github.io/2019/05/02/Webpack/[Webpack]No.4%20Babel%20%E7%B5%90%E5%90%88%20Webpack%20%E9%80%B2%E8%A1%8C%E9%96%8B%E7%99%BC/">[Webpack]No.4 Babel 結合 Webpack 進行開發</a></li><li><a href="https://pvt5r486.github.io/2019/05/04/Webpack/[Webpack]No.5%20%E7%AC%AC%E4%BA%8C%E4%BB%BD%20webpack.config%20%E8%A8%AD%E5%AE%9A/">[Webpack]No.5 第二份 webpack.config 設定</a></li><li><a href="https://pvt5r486.github.io/2019/05/05/Webpack/[Webpack]No.6%20%E8%AE%93%20SCSS%20%E4%B9%9F%E5%8A%A0%E5%85%A5%E6%89%93%E5%8C%85%E7%9A%84%E8%A1%8C%E5%88%97/">[Webpack]No.6 讓 SCSS 也加入打包的行列</a></li><li><a href="https://pvt5r486.github.io/2019/05/09/Webpack/[Webpack]No.7%20%E6%8A%8A%20HTML%20%E4%B9%9F%E5%8A%A0%E5%85%A5%20Webpack/">[Webpack]No.7 把 HTML 也加入 Webpack</a></li><li><a href="https://pvt5r486.github.io/2019/05/10/Webpack/[Webpack]No.8%20%E4%BD%BF%E7%94%A8%20Webpack%20%E6%89%93%E5%8C%85%E5%9C%96%E7%89%87/">[Webpack]No.8 使用 Webpack 打包圖片</a></li></ul><p>花了不少時間，但我覺得很值得。用自己會一點點的技術去探索、到完成一個好像可以動的東西，這樣的成就感是非常巨大的。而這一周的作業也是相當的有挑戰性，我第一次寫大數加法，不過幸好沒遇到太大的瓶頸，因為提示蠻多的。</p><h2 id="Week-4"><a href="#Week-4" class="headerlink" title="Week 4"></a>Week 4</h2><p>這一周開始提到網路原理，不得不說我覺得這個章節比喻得很好，最驚訝的是居然有發大財的梗，還以為這是出很久的課程了。</p><p>而很巧的是，在這周之前我已經不知不覺地提早預習好了，原因是我有花 280 去買付費的講座，剛好有提到這些觀念。因此在本周的時候特別的得心應手，聽胡立講賣便當的故事時，也可以知道那些比喻的背後是在說些什麼，也更佳的佩服 Huli 怎麼可以把比喻成這樣 (稱讚意味)</p><p>這周的作業我最喜歡的莫過於串接 Twitch API 了，我本來就是一個很喜歡看實況、打電動的宅宅，覺得可以串接這些 API ，撈出這些遊戲、頻道的資料感到相當開心，亦從中學習了不少東西，像是如何在 header 內加入對方要求的東西，使得請求可以通過驗證。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      因緣際會下參加了這個計劃，開始不間斷的自主學習，這是我的計劃 repo ，有興趣的朋友可以點開來看看，每周我提交的作業也都會在上面。不過之後要是找到工作，可能就沒辦法兼顧這邊了，但我還是會想辦法完成它。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="程式導師計畫" scheme="http://pvt5r486.github.io/tags/%E7%A8%8B%E5%BC%8F%E5%B0%8E%E5%B8%AB%E8%A8%88%E7%95%AB/"/>
    
      <category term="自我投資" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.8 使用 Webpack 打包圖片</title>
    <link href="http://pvt5r486.github.io/f2e/20190510/3988138546/"/>
    <id>http://pvt5r486.github.io/f2e/20190510/3988138546/</id>
    <published>2019-05-09T19:47:51.000Z</published>
    <updated>2020-02-16T05:52:53.723Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>總算是來到這個系列最後一篇了，前面雖然有提到如何使用 Webpack 打包 SCSS ，但如果 SCSS 內的語法有使用到圖片相關資源的話，可是會編譯失敗的，因為這部份又需要另外的 loader 處理，讓我們趕快來看看吧。</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*hXoers0y8F6mARu7" alt></p><h2 id="先從-SCSS-內載入圖片開始"><a href="#先從-SCSS-內載入圖片開始" class="headerlink" title="先從 SCSS 內載入圖片開始"></a>先從 SCSS 內載入圖片開始</h2><h3 id="準備環境"><a href="#準備環境" class="headerlink" title="準備環境"></a>準備環境</h3><ul><li>新增資料夾 img 並放入圖片 A</li><li>安裝 file-loader 這樣才能在 SCSS 內載入圖片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure></li></ul><h3 id="接著到-webpack-config-進行調整"><a href="#接著到-webpack-config-進行調整" class="headerlink" title="接著到 webpack.config 進行調整"></a>接著到 webpack.config 進行調整</h3><ul><li>加入一組新的 <code>rules</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  test: /\.(png|jpg|gif|jpe?g|svg)$/,  </span><br><span class="line">  use: [  </span><br><span class="line">    &#123;  </span><br><span class="line">      loader: &apos;file-loader&apos;,  </span><br><span class="line">      options: &#123;  </span><br><span class="line">        name: &apos;[name].[ext]&apos;,  </span><br><span class="line">        publicPath: &apos;./img&apos;,  </span><br><span class="line">        emitFile: false  </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>file-loader</code> 有一些 <code>options</code> 可以設定，如果沒有特別設定圖檔名會是 hash 值，因此 <code>options</code> 內的設定分別為：</p><ul><li><code>name</code> ： <code>[name]</code> 為使用原本檔案的名稱； <code>[ext]</code> 則是副檔名，組合起來的意思就是，我們希望可以<strong>保留原本檔案的名稱以及副檔名</strong></li><li><code>publicPath</code> ：設定目標文件的路徑，白話說就是 SCSS 編譯後產生的 CSS 檔內圖檔的路徑</li><li><code>emitFile</code> ：默認為 <code>true</code> ，如果為 <code>true</code> ，則將該檔案輸出。如果為 <code>false</code> ，則僅在 CSS 內寫入 <code>publicPath</code> ，而不會輸出該檔案。</li></ul><p><strong>另外還有很多設定可以調整，<a href="https://github.com/webpack-contrib/file-loader" rel="external nofollow noopener noreferrer" target="_blank">詳見此</a></strong></p><p>設定完之後 webpack.config 如下：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*TLWcPfRY66ioEfpmVnKGEQ.png" alt></p><h2 id="測試看看"><a href="#測試看看" class="headerlink" title="測試看看"></a>測試看看</h2><ul><li>觀察 SCSS</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*IU9a534TdPdIHs_weUFl3g.png" alt="引用背景圖片"><br><img src="https://cdn-images-1.medium.com/max/1600/1*r_dBEns-ZpIk4tuS2-yXyg.png" alt="import 進 all.scss"></p><ul><li>執行指令 <code>npm run dev</code></li><li>觀察編譯後的 all.min.css</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*VJ9PHb1tDP4RxAKC4LHSpQ.png" alt="背景圖路徑成功替換"></p><ul><li>打開瀏覽器確認圖片是否成功載入</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*z5Gf9TRZO5ZfqVDNdwx_cQ.png" alt></p><blockquote><p>到此，開發環境的設定成功！但還沒結束，我們也必須對 webpack.prod.conf 進行特別的調整才行。</p></blockquote><h2 id="webpack-prod-conf-的調整"><a href="#webpack-prod-conf-的調整" class="headerlink" title="webpack.prod.conf 的調整"></a>webpack.prod.conf 的調整</h2><p>加入一組跟 webpack.config 一樣的 <code>rules</code> ，但在此我們必須做一些微調：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  test: /\.(png|jpg|gif|jpe?g|svg)$/,  </span><br><span class="line">  use: [  </span><br><span class="line">    &#123;  </span><br><span class="line">      loader: &apos;file-loader&apos;,  </span><br><span class="line">      options: &#123;  </span><br><span class="line">        name: &apos;[name].[ext]&apos;,  </span><br><span class="line">        publicPath: &apos;./img&apos;,  </span><br><span class="line">        outputPath: &apos;./img&apos;  </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>outputPath</code> ：檔案輸出的路徑</li></ul><h2 id="測試看看-1"><a href="#測試看看-1" class="headerlink" title="測試看看"></a>測試看看</h2><ul><li>輸入指令 <code>npm run build</code></li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*Y--2t8cXdf5GH8aDuxBB4w.png" alt="圖片輸出成功"><br><img src="https://cdn-images-1.medium.com/max/1600/1*dU0-eK28f3KK3mp8YCYWoQ.png" alt="CSS 內路徑也被替換了"><br><img src="https://cdn-images-1.medium.com/max/1600/1*G2v2SQYROKODEjvXY8PJIA.png" alt="瀏覽器運作正常"></p><blockquote><p>確認圖片輸出沒問題後，我們還要額外加上圖片壓縮的功能。</p></blockquote><h2 id="圖片壓縮"><a href="#圖片壓縮" class="headerlink" title="圖片壓縮"></a>圖片壓縮</h2><p>要<strong>部屬</strong>出去的圖片是需要進行<strong>壓縮</strong>的，否則圖片動輒幾 MB 哪受的了。</p><ul><li>安裝 <a href="https://www.npmjs.com/package/image-webpack-loader" rel="external nofollow noopener noreferrer" target="_blank">image-webpack-loader</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure></li></ul><p>比較不同的是，這個 loader 的執行必須在 <code>file-loader</code> 之前，畢竟要<strong>先壓縮後打包</strong>。因此修改配置如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  test: /\.(png|jpg|gif|jpe?g|svg)$/,  </span><br><span class="line">  use: [  </span><br><span class="line">    &#123;  </span><br><span class="line">      loader: &apos;file-loader&apos;,  </span><br><span class="line">      options: &#123;  </span><br><span class="line">        name: &apos;[name].[ext]&apos;,  </span><br><span class="line">        publicPath: &apos;./img&apos;,  </span><br><span class="line">        outputPath: &apos;./img&apos;  </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;,  </span><br><span class="line">    &#123;  </span><br><span class="line">      loader: &apos;image-webpack-loader&apos;,  </span><br><span class="line">      options: &#123;  </span><br><span class="line">        bypassOnDebug: true,  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="搞定，接著我們試試看吧！"><a href="#搞定，接著我們試試看吧！" class="headerlink" title="搞定，接著我們試試看吧！"></a><strong>搞定，接著我們試試看吧！</strong></h2><ul><li>觀察原始圖片大小</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*GXKYQQKLVxX4azxP4nST9g.png" alt></p><ul><li>執行指令 <code>npm run build</code></li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*68HlNYs6vuCIUPz_ag3MpQ.png" alt="壓縮成功"><br>壓縮成功</p><blockquote><p><strong>至此，設定全部成功，享受這份成果吧！</strong></p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>終於寫完 Webpack 系列了，這一系列並不是很深入研究 Webpack 每個細節的類型，我寫這些文章只是為了記錄自己如何把 Webpack 應用在實務上，並且逐步的探索有哪邊需要學習。</p><p>所以這一系列的起點從「如何模組化 JavaScript」開始，模組化之後我可以做什麼？模組化之後我可以進行單元測試，所以寫了「如何進行使用 Jest 進行單元測試」等等，諸如此類的小問題，最後完成這一整個系列。</p><p>當然 Webpack 還有很多很多我沒寫到而且很實用的東西，像是可以使用 Webpack merge 讓每個設定檔不會這麼又臭又長。</p><p>這部份推薦六角分享團內另外一個大大 <a href="https://medium.com/@cos214159" rel="external nofollow noopener noreferrer" target="_blank">慢慢變強的工程獅</a> 寫的 <a href="https://medium.com/@cos214159" rel="external nofollow noopener noreferrer" target="_blank">Webpack 筆記</a>，目前連載到第 15 篇了，還不趕快追起來 ~</p><p>我在寫這系列的文章時，有不少也是參考他的文章，真的對我幫助很大！</p><p>也深刻的體會到，學習東西時，如果有一份淺白易懂的文件可以參考，是多麼幸福的事情！</p><p>因此這可能不是一份高手向的 Webpack 文章，敘述用語、技巧可能不是非常正確，還請前輩們不吝指導分享。</p><blockquote><p>如果能夠幫助到跟我程度差不多的朋友，那就太好了。</p></blockquote><p><strong>以下附上文章連結 (按順序)</strong></p><ul><li><a href="https://pvt5r486.github.io/webpack/20190430/3052134826">[Webpack]No.1 模組化 JavaScript 的方法</a></li><li><a href="https://pvt5r486.github.io/webpack/20190501/1043079870">[Webpack]No.2 package.json 設置專屬我倆的小咒語</a></li><li><a href="https://pvt5r486.github.io/webpack/20190501/1835145669">[Webpack]No.3 使用 Jest 進行 Unit Test</a></li><li><a href="https://pvt5r486.github.io/webpack/20190502/2179081137">[Webpack]No.4 Babel 結合 Webpack 進行開發</a></li><li><a href="https://pvt5r486.github.io/webpack/20190504/374010663">[Webpack]No.5 第二份 webpack.config 設定</a></li><li><a href="https://pvt5r486.github.io/webpack/20190505/611388121">[Webpack]No.6 讓 SCSS 也加入打包的行列</a></li><li><a href="https://pvt5r486.github.io/webpack/20190509/2730949378">[Webpack]No.7 把 HTML 也加入 Webpack</a></li><li><a href="https://pvt5r486.github.io/webpack/20190510/3988138546">[Webpack]No.8 使用 Webpack 打包圖片</a></li></ul><p><strong>GitHub</strong></p><ul><li><a href="https://github.com/pvt5r486/0430module" rel="external nofollow noopener noreferrer" target="_blank">原始碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      總算是來到這個系列最後一篇了，前面雖然有提到如何使用 Webpack 打包 SCSS ，但如果 SCSS 內的語法有使用到圖片相關資源的話，可是會編譯失敗的，因為這部份又需要另外的 loader 處理，讓我們趕快來看看吧。 所以這一系列的起點從「如何模組化 JavaScript」開始，模組化之後我可以做什麼？模組化之後我可以進行單元測試，所以寫了「如何進行使用 Jest…
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.7 把 HTML 也加入 Webpack</title>
    <link href="http://pvt5r486.github.io/f2e/20190509/2730949378/"/>
    <id>http://pvt5r486.github.io/f2e/20190509/2730949378/</id>
    <published>2019-05-09T01:02:25.000Z</published>
    <updated>2020-02-16T05:52:53.742Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我們知道如何調整 SCSS 並且成功打包輸出後，接著要嘗試打包 HTML 檔。</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*KguC0HWFAVgh1Kdt" alt></p><h2 id="打包-HTML"><a href="#打包-HTML" class="headerlink" title="打包 HTML"></a>打包 HTML</h2><p>我們之前都是手動把 index.html 檔案加入到 dist 資料夾內，並且引用 CSS 與 JavaScript 檔案，現在我們要嘗試把 index.html 也一起打包。</p><h2 id="安裝-html-webpack-plugin"><a href="#安裝-html-webpack-plugin" class="headerlink" title="安裝 html-webpack-plugin"></a>安裝 html-webpack-plugin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>同樣的在檔案開頭 <code>require</code> 進來，並且在 <code>plugins</code> 區塊加入設定：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);  </span><br><span class="line">module.exports = &#123;  </span><br><span class="line">---略---  </span><br><span class="line">  plugins: [  </span><br><span class="line">    new MiniCssExtractPlugin(&#123;  </span><br><span class="line">      filename: &apos;../dist/all.min.css&apos;,  </span><br><span class="line">    &#125;),  </span><br><span class="line">    new HtmlWebpackPlugin(&#123;  </span><br><span class="line">      title: &apos;首頁&apos;,  </span><br><span class="line">      filename: &apos;index.html&apos;,  </span><br><span class="line">      template: &apos;./index.html&apos;  </span><br><span class="line">    &#125;)  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>title</code> - 輸出的 title 名稱</li><li><code>filename</code> - 輸出檔名</li><li><code>template</code> - 套用的模版</li></ul><p>這個輸出的檔案預設會引入 Webpack 打包之後的所有檔案(像是 .css 、 .js )，若是想要輸出多頁，則需要設定多個 <code>HtmlWebpackPlugin</code> 物件。</p><h3 id="調整路徑"><a href="#調整路徑" class="headerlink" title="調整路徑"></a>調整路徑</h3><p>接著還需要調整一下路徑， <code>HtmlWebpackPlugin</code> 打包後產生的 HTML 內，這兩隻檔案的路徑就是根據對應的 <code>filename</code> 上的路徑怎麼寫的。</p><blockquote><p><strong>做完這個步驟後，整體看起來會像是這樣：</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/1600/1*Fp0Rey1uMMkT_5Pt0_kGDQ.png" alt></p><h3 id="設定樣版"><a href="#設定樣版" class="headerlink" title="設定樣版"></a>設定樣版</h3><p>接著指定樣版為我們目前使用的 index.html ，然後把原先我們手動設定好的路徑全部都移除，不然會重覆。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*avPGQiMtsMn7UKPLAYI8Lg.png" alt></p><h3 id="設定好了，試試看吧！"><a href="#設定好了，試試看吧！" class="headerlink" title="設定好了，試試看吧！"></a>設定好了，試試看吧！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*-YSKiUaMFsqCqs0OWq2TWQ.png" alt></p><h2 id="美中不足的地方"><a href="#美中不足的地方" class="headerlink" title="美中不足的地方"></a>美中不足的地方</h2><p>雖然設定好了，但有個地方的問題沒有解決，列出問題點如下:</p><h3 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h3><ul><li>作為樣版的 index.html 裡面不可以手動引入 JS 、 CSS 檔案否則打包後 HTML 內會重覆</li><li>但如果 index.html 不手動引入 JS、 CSS 檔案，就沒辦法開發了</li><li>如果考慮開發的 config 檔也加入 <code>HtmlWebpackPlugin</code> 設定，並同樣使用 index.html 作為模版，也會陷入死胡同。</li></ul><blockquote><p>目前我有想到一個方式，但<strong>可能不是最好的辦法，僅供參考</strong>。</p></blockquote><h3 id="解決的辦法："><a href="#解決的辦法：" class="headerlink" title="解決的辦法："></a>解決的辦法：</h3><ul><li>調整檔案結構，讓開發時的結構與打包部屬時的結構一致</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*MegwDSxjdKTh5MD8p5sVrw.png" alt></p><p>把要當成樣版的 index.html 搬到 src 資料夾內，這樣就可以使用相對路徑 <code>./all.min.css</code> 、 <code>./all.min.js</code> 引入對應檔案。</p><ul><li>修改開發用的 config 檔 - 調整編譯後的 .js 檔案名稱</li></ul><p><strong>調整後的 webpack.config 如下：</strong></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ZjFYJuH39C-pko5ohfBn5g.png" alt="不使用 HtmlWebpackPlugin"></p><ul><li>因為做為樣版的 index.html 移動了，所以 webpack.prod.conf 內也需要相對的調整，並且在 <code>HtmlWebpackPlugin</code> 追加設定：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins: [  </span><br><span class="line">  new MiniCssExtractPlugin(&#123;  </span><br><span class="line">    filename: &apos;./all.min.css&apos;,  </span><br><span class="line">  &#125;),  </span><br><span class="line">  new HtmlWebpackPlugin(&#123;  </span><br><span class="line">    title: &apos;首頁&apos;, // 輸出的 title 名稱  </span><br><span class="line">    filename: &apos;index.html&apos;, // 輸出檔名  </span><br><span class="line">    template: &apos;./src/index.html&apos;, // 套用的模版  </span><br><span class="line">    inject: false　// 不引用 CSS、JS 檔  </span><br><span class="line">  &#125;)  </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="接著來測試看看吧"><a href="#接著來測試看看吧" class="headerlink" title="接著來測試看看吧"></a>接著來測試看看吧</h2><p>透過這樣的調整，讓開發環境與部屬打包後的路徑一致，就可以在開發時先把路徑寫好，只透過 <code>HtmlWebpackPlugin</code> 幫我們產生其他的部分。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*f771mfX1bK4zN8PGP3XEdQ.png" alt="dist 內的 index.html"></p><blockquote><p>這樣子就搞定了，雖然不確定這是不是最好的做法，但這是我目前想到的解法，就參考看看吧。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在我們知道如何調整 SCSS 並且成功打包輸出後，接著要嘗試打包 HTML 檔。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
      <category term="HTML" scheme="http://pvt5r486.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.6 讓 SCSS 也加入打包的行列</title>
    <link href="http://pvt5r486.github.io/f2e/20190505/611388121/"/>
    <id>http://pvt5r486.github.io/f2e/20190505/611388121/</id>
    <published>2019-05-05T00:13:35.000Z</published>
    <updated>2020-02-16T05:52:53.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接著我們要讓 Webpack 也支援 SCSS ，輸入指令後轉成 CSS 並且優化之後打包輸出，同樣地延續上一篇的專案資料夾。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Mk96FibxoYNY1zRT" alt></p><h2 id="建立-amp-調整部份檔案"><a href="#建立-amp-調整部份檔案" class="headerlink" title="建立 &amp; 調整部份檔案"></a>建立 &amp; 調整部份檔案</h2><ul><li>於 src 資料夾內建立 scss 的資料夾，並且在裡面建立一些 .scss 的檔案</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*r7AwkFRSF8e11IWHlJZjDQ.png" alt></p><ul><li>並且個別再 _a.scss 、 _b.scss 內寫了一些 CSS 語法，觀察變化。</li><li>index.html 也做一些微調，我希望使用 <code>dev</code> 指令時會輸出再 src 內，並且以 all.min.css 的檔名出現。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*kXHtVUoYJJrMmRCw4bHNzg.png" alt></p><h2 id="安裝對應的-loader-與-plugins"><a href="#安裝對應的-loader-與-plugins" class="headerlink" title="安裝對應的 loader 與 plugins"></a>安裝對應的 loader 與 plugins</h2><p>最基本的 Webpack 功能其實只有 Javascript 部份，因此若是希望 Webpack 也能幫我們做更多事情的話，就必須要仰賴相對應的 loader 與 plugins 。</p><h2 id="因此規畫之後我們需要以下的東西："><a href="#因此規畫之後我們需要以下的東西：" class="headerlink" title="因此規畫之後我們需要以下的東西："></a>因此規畫之後我們需要以下的東西：</h2><ul><li><code>css-loader</code> : 載入 .css 的檔案</li><li><code>mini-css-extract-plugin</code> : 將 CSS 輸出成檔案</li><li><code>sass-loader</code> : 載入 .scss 的檔案</li><li><code>node-sass</code> : Sass 的編譯器</li></ul><p><strong>順序大致上是這樣的</strong>：</p><blockquote><p>sass-loader 載入 .scss 檔 &gt; 編譯成 css 檔 &gt; css-loader 載入 .css 檔 &gt; 最後則是給 mini-css-extract-plugin 打包成檔案。</p></blockquote><p>全部串在一起下載回來吧！</p><p><img src="https://cdn-images-1.medium.com/max/800/1*9t4dj6-o8zYryPhskLucNA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*9CZU05MN_SrAnDQx7ZtV8A.png" alt></p><h2 id="webpack-config-添加對應的設定"><a href="#webpack-config-添加對應的設定" class="headerlink" title="webpack.config 添加對應的設定"></a>webpack.config 添加對應的設定</h2><p>由於上一篇提到的問題，所以我們將設定拆成了開發用以及部屬用的兩隻設定檔。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*b4squ4jGLBlf7dcii13giQ.png" alt="前情提要一下"></p><p>接下來我們要在開發用設定檔裡面增加 <code>loader</code> 設定，在物件 <code>module</code> 底下會有一個 <code>rules</code> 的陣列，在這個陣列裡面放置的每一個物件，是當 Webpack 無法辨識目前要載入的資源檔時，會到這邊去查找看看有沒有相對應的載入方式，在這個物件裡面會有兩個屬性：</p><ul><li><code>test</code> : 是一個正規表示式，主要是去查找目前要載入的檔案，有沒有跟這個正規表示式符合</li><li><code>use</code> : 表示我們載入檔案要使用的 <code>loader</code></li></ul><blockquote><p>值得注意的是， Webpack 調用 <code>loader</code> 的順序是從<strong>後面到前面</strong></p></blockquote><h3 id="動手設定如下"><a href="#動手設定如下" class="headerlink" title="動手設定如下"></a>動手設定如下</h3><ul><li><p>把 <code>mini-css-extract-plugin</code> 給 <code>require</code> 進來</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br></pre></td></tr></table></figure></li><li><p><code>use</code> 陣列內依序填入 <code>MiniCssExtractPlugin.loader</code> 、<code>css-loader</code>、 <code>sass-loader</code></p></li><li><code>test</code> 正則表達式的部份也要修改成 <code>test: /\.(scss|sass)$/,</code></li><li>於 <code>module</code> 區塊下方補上 <code>plugins</code> 區塊<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [  </span><br><span class="line">  new MiniCssExtractPlugin(&#123;  </span><br><span class="line">    filename: &apos;./src/all.min.css&apos;,  </span><br><span class="line">  &#125;)  </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p>這一段主要是使用 <code>MiniCssExtractPlugin</code> 指定 .css 檔案該輸出到哪裡。</p><p>做完這些調整後，會長的像這樣：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*D9gWyMUhqykh0-t6zycoAQ.png" alt></p><blockquote><p>別忘了我們的進入點是 all.js ，需要把 .scss 檔案給載入才會一起打包哦。</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*CSB8sIm_y5k5GUz1dTED_A.png" alt></p><blockquote><p>做到這邊先測試看看吧～ <code>npm run dev</code></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*2PNzxcmM8f_z_KL9bETtzQ.png" alt></p><p>網頁的部份也沒有問題哩！</p><p><img src="https://cdn-images-1.medium.com/max/800/1*nyX3NwYf0SHuybX0wSNKrQ.png" alt></p><blockquote><p>而且因為使用了 <code>--watch</code> ，每當檔案有異動、按下存檔時都會再度編譯，是不是跟 VS CODE 的插件 Live Sass Compiler 用起來體感相似呢？</p></blockquote><h2 id="部屬時的-config-檔-也需要補上設定"><a href="#部屬時的-config-檔-也需要補上設定" class="headerlink" title="部屬時的 config 檔 也需要補上設定"></a>部屬時的 config 檔 也需要補上設定</h2><p>所以我們將剛才設定的內容都複製一份到這裡，我們會覺得有很多重複的東西感覺很不智慧，事實上這可以利用 Webpack-merge 來處理重複的部份，但這不在這次的討論範圍內，為了控制篇幅，就不提了。</p><h3 id="這邊附上相關的介紹"><a href="#這邊附上相關的介紹" class="headerlink" title="這邊附上相關的介紹"></a>這邊附上相關的介紹</h3><ul><li><a href="https://medium.com/@cos214159/webpack-%E7%AD%86%E8%A8%98%E6%95%B4%E7%90%86-%E4%B8%83-webpack-merge-88b11227d180" rel="external nofollow noopener noreferrer" target="_blank">Webpack 筆記整理 (七) — Webpack merge</a></li></ul><h3 id="調整後檔案設定如下"><a href="#調整後檔案設定如下" class="headerlink" title="調整後檔案設定如下"></a>調整後檔案設定如下</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*qS_ptYBJNhhK30bD-cXMKA.png" alt></p><blockquote><p>別忘了輸出路徑也要調整一下，才會輸出到正確的地方唷。</p></blockquote><h3 id="確認一下輸出結果："><a href="#確認一下輸出結果：" class="headerlink" title="確認一下輸出結果："></a>確認一下輸出結果：</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*rYI1I5hnlUSpy4bVfRcPjA.png" alt></p><p>雖然結果是正確的，但不夠理想。</p><p>畢竟這是正式部屬的設定檔，我們需要針對 .css 做壓縮才行。</p><h3 id="使用-optimize-css-assets-webpack-plugin"><a href="#使用-optimize-css-assets-webpack-plugin" class="headerlink" title="使用 optimize-css-assets-webpack-plugin"></a>使用 <code>optimize-css-assets-webpack-plugin</code></h3><p>這個套件將幫助我們把 CSS 優化，馬上輸入指令下載回來<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p></p><ul><li>將 <code>optimize-css-assets-webpack-plugin</code> 載入</li><li>接著再 <code>module</code> 下方額外加入 <a href="https://webpack.docschina.org/configuration/optimization/" rel="external nofollow noopener noreferrer" target="_blank">optimization 物件</a>，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;  </span><br><span class="line">  minimizer: [  </span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin()  </span><br><span class="line">  ]  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="調整完之後，整體配置如："><a href="#調整完之後，整體配置如：" class="headerlink" title="調整完之後，整體配置如："></a>調整完之後，整體配置如：</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*uoANZzotPL2iVrBe5uzYIg.png" alt></p><p>看起來完成了，測試看看吧！</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PnZDS_UnFqjrhPuGuxmjFQ.png" alt></p><blockquote><p><strong>成功的壓縮了，但…事情沒這麼簡單，我們的原先由 Webpack 自動幫我們壓縮好的 all.min.js 失去壓縮了。</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*VHRlQNrrli0D1Y-y3QVaNA.png" alt></p><h2 id="為什麼-JavaScript-失去壓縮了"><a href="#為什麼-JavaScript-失去壓縮了" class="headerlink" title="為什麼 JavaScript 失去壓縮了"></a>為什麼 JavaScript 失去壓縮了</h2><p>因為 Webpack 預設是當我們使用部屬模式時，會自動的幫我們壓縮 .js 檔案，但是當我們自行加入 <code>optimization</code> 區塊時，它就會認為我們要自己管理，也就是說我們現在必須額外加入壓縮 JavaScript 的套件。</p><ul><li>加入 <code>terser-webpack-plugin</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></li></ul><p>如同加入 CSS 壓縮功能的步驟：</p><ul><li>將 <code>terser-webpack-plugin</code> require 進檔案</li><li>optimization 物件加入以下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;  </span><br><span class="line">  minimizer: [  </span><br><span class="line">    new TerserWebpackPlugin(),  </span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin()  </span><br><span class="line">  ]  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="調整完之後，整體配置如：-1"><a href="#調整完之後，整體配置如：-1" class="headerlink" title="調整完之後，整體配置如："></a>調整完之後，整體配置如：</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*jXYa6R7h9Fy5raND79ow-Q.png" alt></p><p>再次測試看看吧！</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Dhfo-FHpp18O9EpgWDMzuA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*7qv0As3Z2SXTG8oZCPLWCg.png" alt></p><blockquote><p><strong>至此，設定全部都完成了呢！</strong></p></blockquote><h2 id="替-CSS-加上前綴詞，讓開發更便利"><a href="#替-CSS-加上前綴詞，讓開發更便利" class="headerlink" title="替 CSS 加上前綴詞，讓開發更便利"></a>替 CSS 加上前綴詞，讓開發更便利</h2><p>現在瀏覽器這麼多種，為了相容各式各樣的瀏覽器，有些時候我們得在 CSS 語法前手動補上一些前綴詞，才能在相應的瀏覽器內生效，但是這樣子不夠智慧。</p><p>聰明的工程師想出了一套解決辦法：</p><ul><li><a href="https://postcss.org/" rel="external nofollow noopener noreferrer" target="_blank">postCSS</a> 和 <a href="https://autoprefixer.github.io/" rel="external nofollow noopener noreferrer" target="_blank">autoprefixer</a></li></ul><p>透過這兩個工具，自動的為我們補上前綴詞</p><p>事不宜遲，馬上下載安裝<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure><p></p><h2 id="順序"><a href="#順序" class="headerlink" title="順序"></a>順序</h2><p>我們知道在 Webpack 內 loader 載入的順序是有差別的，因此在加入這些套件後，順序應該調整為：</p><ul><li><code>sass-loader</code> 編譯</li><li>交由 <code>postcss-loader</code> 加上前綴詞</li><li>在給 <code>css-loader</code> 處理</li><li>最後由 <code>MiniCssExtractPlugin.loader</code> 打包輸出</li></ul><h2 id="調整設定"><a href="#調整設定" class="headerlink" title="調整設定"></a>調整設定</h2><p>得知順序後，開始著手調整設定吧。</p><p>調整後的設定檔如下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*BAd3HPGpfaXXh90RA6IJTQ.png" alt></p><h3 id="測試看看是否成功加上前綴"><a href="#測試看看是否成功加上前綴" class="headerlink" title="測試看看是否成功加上前綴"></a>測試看看是否成功加上前綴</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*lCArcUahGtARHNGRiW6NwQ.png" alt="_a.scss"><br><img src="https://cdn-images-1.medium.com/max/800/1*_vxyAYTtfO_0legyAy8nbg.png" alt="all.min.css"></p><blockquote><p>成功了！可喜可賀！別忘了把部屬用的設定檔也補上哦。</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>透過這樣一連串的設定，對於如何替 Webpack 加裝一些套件有更深刻的體驗，幸好這樣的設定只要做一次，後續就可以直接沿用，否則每次要做這麼多的設定也是很麻煩的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接著我們要讓 Webpack 也支援 SCSS ，輸入指令後轉成 CSS 並且優化之後打包輸出，同樣地延續上一篇的專案資料夾。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
      <category term="SCSS" scheme="http://pvt5r486.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.5 第二份 webpack.config 設定</title>
    <link href="http://pvt5r486.github.io/f2e/20190504/374010663/"/>
    <id>http://pvt5r486.github.io/f2e/20190504/374010663/</id>
    <published>2019-05-04T05:00:28.000Z</published>
    <updated>2020-02-16T05:52:53.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>延續之前的專案資料夾，我們目前不僅能<a href="https://pvt5r486.github.io/webpack/20190430/3052134826">模組化管理 JavaScript</a> 、<a href="https://pvt5r486.github.io/webpack/20190501/1835145669">使用 Jest 進行單元測試</a>、<a href="https://pvt5r486.github.io/webpack/20190502/2179081137">針對 JavaScript 語法使用 Babel 進行降版</a>、還能夠<a href="https://pvt5r486.github.io/webpack/20190501/1043079870">自訂一些看起來很酷的指令</a>，最後打包輸出 bundle.js 在 dist 資料夾中。</p><blockquote><p>但似乎有哪裡不對勁，不是嗎？</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/0*0uWax-8cprShITK3" alt></p><h2 id="問題在於開發與部屬的衝突"><a href="#問題在於開發與部屬的衝突" class="headerlink" title="問題在於開發與部屬的衝突"></a>問題在於開發與部屬的衝突</h2><ul><li>當設定好環境，準備要進行開發時，使用了 <code>npm run dev</code> ，打包出來的 .js 檔案居然放在 dist 資料夾內，而不是放在 src 資料夾內。</li><li>如果反過來將打包出來的 .js 檔案設置輸出在 src 資料夾內，就會變成部屬時 dist 資料夾沒有 .js 檔案了。</li></ul><blockquote><p><strong>這怎麼想都很奇怪，這樣肯定是不行的！</strong></p></blockquote><h2 id="從-package-js-中的-scripts-指令參數下手"><a href="#從-package-js-中的-scripts-指令參數下手" class="headerlink" title="從 package.js 中的 scripts 指令參數下手"></a>從 package.js 中的 scripts 指令參數下手</h2><p>還記得之前是如何自定指令的嗎？ <code>scripts</code> 內的指令可以透過設置參數的方式，套用客製的 webpack.config 設定：</p><ul><li><code>--config [config 檔案路徑]</code>：可指定要套用的 config 檔案路徑，使指令套用此設定檔</li></ul><h2 id="建立第二份-webpack-config-吧"><a href="#建立第二份-webpack-config-吧" class="headerlink" title="建立第二份 webpack.config 吧"></a>建立第二份 webpack.config 吧</h2><p>我們將原本那一份 webpack.config 當成開發時期用，接著建立一個新的資料夾 build ，並把原本那一份設定檔另存改名成 webpack.prod.conf 。</p><h3 id="調整-scripts-指令的設定："><a href="#調整-scripts-指令的設定：" class="headerlink" title="調整 scripts 指令的設定："></a>調整 scripts 指令的設定：</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*YDPmskH9kr3u8kZCTvoaDA.png" alt></p><p>如果檔名設定成 webpack.config 的話， Webpack 預設會認這個檔名，因此使用 <code>dev</code> 指令時不需要額外指定，而 build 指令我們希望套用別的設定檔，因此需要加上 <code>--config</code> 參數</p><h2 id="個別調整二份-config-檔的輸出位置"><a href="#個別調整二份-config-檔的輸出位置" class="headerlink" title="個別調整二份 config 檔的輸出位置"></a>個別調整二份 config 檔的輸出位置</h2><ul><li>webpack.config 方面，用於開發時，因此希望輸出在 src 資料夾內</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*X2EW1s52rhn1uKSPfQ2g2A.png" alt></p><p>調整了 path 路徑，使其不產生資料夾，並指定檔案輸出路徑。</p><ul><li>webpack.prod.conf 方面，用於部屬時，因此希望輸出在 dist 資料夾內</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*oiWnqAxI-io8a4frgoPO5A.png" alt></p><h2 id="實際執行看看"><a href="#實際執行看看" class="headerlink" title="實際執行看看"></a>實際執行看看</h2><ul><li>首先執行 <code>npm run dev</code> ，看看檔案是否打包輸出再預期的位置</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*VjS5vz3Q0r2FRrYyACvEzA.png" alt></p><ul><li>接著輸入 <code>npm run build</code> ，測試看看</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*rrz5V9DmRm4ICNdED8NIQw.png" alt></p><blockquote><p><strong>大功告成～距離完善整個開發環境又更靠近一步了。</strong></p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這麼一來，我們的開發環境又更完整了一些，但這樣子還不夠！</p><p>預期還要加入自動壓縮打包 SCSS 、圖片、網頁，這樣才能更貼近實務在開發網頁時的需求，因此這系列後面幾篇就會著墨在如何設定這些東西哩。要設定的東西真的蠻多的，幸好只要做好一次環境後，之後都可以用複製的。</p><p>寫這一系列的時候， slack 內也有一位大大跟我寫類似的東西，他目前專注於 Webpack 上，寫得相當仔細，目前已經完成高達 14 篇關於 Webpack ，內容與各參數的說明是相當的詳盡，做為自己文章的補充，將連結寫在這：</p><ul><li><a href="https://medium.com/@cos214159/webpack-%E7%AD%86%E8%A8%98%E6%95%B4%E7%90%86-%E4%B8%80-7fc63bcf1ecb" rel="external nofollow noopener noreferrer" target="_blank">Webpack 筆記整理 系列</a></li></ul><p>而我的這一系列文章的目標，主要是圍繞在「<strong>如何使用 Webpack 手把手搭起一個開發專案</strong>」，然而有些東西我也尚在探索，因此看到有相關文章可以參考是非常令人感到開心的！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      延續之前的專案資料夾，我們目前不僅能模組化管理 JavaScript 、使用 Jest 進行單元測試、針對 JavaScript 語法使用 Babel 進行降版、還能夠自訂一些看起來很酷的指令，最後打包輸出 bundle.js 在 dist …
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.4 Babel 結合 Webpack 進行開發</title>
    <link href="http://pvt5r486.github.io/f2e/20190502/2179081137/"/>
    <id>http://pvt5r486.github.io/f2e/20190502/2179081137/</id>
    <published>2019-05-02T05:17:29.000Z</published>
    <updated>2020-02-16T05:52:53.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們使用的 JavaScript 語法瀏覽器不支援時，大家想到的第一個解決方案可能就是 Babel ，那麼說歸說，到底要怎麼跟先前提到的 Webpack 做結合，實際運用在開發上呢？讓我們繼續看下去~</p><p><img src="https://cdn-images-1.medium.com/max/800/0*5jLUiGP_W-92K_ba" alt></p><h2 id="環境設置"><a href="#環境設置" class="headerlink" title="環境設置"></a>環境設置</h2><ul><li>可以使用 npm 的指令</li><li>有安裝 Webpack 並有 package.json 、 webpack.config.js</li></ul><blockquote><p>如果不知道這些是什麼，可參考</p><ul><li><a href="https://pvt5r486.github.io/webpack/20190430/3052134826">[Webpack]No.1 模組化 JavaScript 的方法</a></li><li><a href="https://pvt5r486.github.io/webpack/20190501/1043079870">[Webpack]No.2 package.json 設置專屬我倆的小咒語</a></li><li><a href="https://medium.com/@Mike_Cheng1208/webpack%E6%95%99%E5%AD%B8-%E5%9B%9B-javascript-%E8%88%87-babel-1d7acd911e63" rel="external nofollow noopener noreferrer" target="_blank">Webpack教學 (四)：JavaScript 與 Babel</a></li></ul></blockquote><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>現在有一支 all.js 的檔案為主要進入點，因為我們模組化管理 JavaScript 檔案的關係，所以在這支檔案內 <code>import</code> 了一些寫好的 JavaScript 檔案。</p><p>但這些 JavaScript 檔案有些是使用 ES6 以上的語法完成，因此可能在較低版本的瀏覽器會有不支援的情況發生，因此希望結合 Babel 把 ES6 以上的語法轉換成比較舊版本的寫法，並且透過 Webpack 打包輸出至 build 資料夾。</p><h2 id="使用-npm-將-babel-下載回來"><a href="#使用-npm-將-babel-下載回來" class="headerlink" title="使用 npm 將 babel 下載回來"></a>使用 npm 將 babel 下載回來</h2><p>為了達成這個需求，我們要下載以下的檔案</p><ul><li><code>@babel/core</code>：程式需要調用 Babel 的 API 進行編譯</li><li><code>@babel/preset-env</code>：告訴 Babel 幫我們轉換成什麼版本的 JS 語法</li><li><code>babel-loader</code>：Webpack 中要去讀取任何檔案格式都需要靠 loader 這個工具去做判讀，接著去做轉換。</li></ul><p>因此我們可以利用 npm 把語法通通組起來：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ybOsKQLYF2Nw3B9Pa6HZDQ.png" alt></p><ul><li><code>--save</code>：代表希望把安裝的資訊寫到 package.json 依賴內，這個部份在比較高版本的 npm 已經是預設值了，但我還是習慣加上。</li><li><code>-dev</code>：有特別寫上的話，代表這是開發時才會用到的依賴項目</li></ul><p>若是成功安裝，package.json 內會長得像這樣：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gB5Ifoqf9UZ4IJhzkBJk3Q.png" alt></p><h2 id="寫上自訂的指令"><a href="#寫上自訂的指令" class="headerlink" title="寫上自訂的指令"></a>寫上自訂的指令</h2><p>接著要在 package.json 內的 <code>script</code> 內自訂一些指令方便使用：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*dkiTd2ggWquDsIRRBT58zA.png" alt></p><ul><li><code>test</code>：是之前使用 Jest 進行測試的指令，與本次無關</li><li><code>build</code>：當專案完成時，使用這個指令將專案打包發布</li><li><code>dev</code>：開發時使用的指令</li></ul><h2 id="參數說明"><a href="#參數說明" class="headerlink" title="參數說明"></a>參數說明</h2><ul><li><code>--mode</code>：可設置開發版本 (development) 及產品版本 (production)，差別在於有沒有進行最小化壓縮。</li><li><code>--watch</code>：持續監控編譯後的檔案，當來源檔案有變動時立即重新編譯，執行後若想終止監控，則按下 <code>ctrl + c</code> 終止。</li></ul><h2 id="調整-package-json-檔案"><a href="#調整-package-json-檔案" class="headerlink" title="調整 package.json 檔案"></a>調整 package.json 檔案</h2><ul><li>調整<strong>程式的進入點</strong>以及要<strong>輸出的目的地</strong></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*oAghXPCnweyai9cPKCeJWA.png" alt></p><ul><li>加上 <code>module</code> 屬性</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*pABGKPbE_mFYM9t9h2V2Cg.png" alt></p><h2 id="準備一段含有-ES6-語法的程式"><a href="#準備一段含有-ES6-語法的程式" class="headerlink" title="準備一段含有 ES6 語法的程式"></a>準備一段含有 ES6 語法的程式</h2><p>在 all.js 內使用 <code>let</code> 以及 <code>const</code> 來宣告變數</p><p><img src="https://cdn-images-1.medium.com/max/800/1*73OzXZJsYRYnXWr8CkuBgA.png" alt></p><h2 id="試著編譯"><a href="#試著編譯" class="headerlink" title="試著編譯"></a>試著編譯</h2><p>先使用 <code>npm run dev</code> 觀察是否有透過 Babel 並且由 Webpack 編譯輸出：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*9d8BY_wF0sAgcIJVg-dfFw.png" alt></p><p>看起來是有順利輸出，來看看長什麼樣子</p><p><img src="https://cdn-images-1.medium.com/max/800/1*z97sgEHR7fneB-aCnXeesw.png" alt></p><p>產生了一大堆的程式碼，而我們也可以發現原本使用 <code>let</code> 以及 <code>const</code> 來宣告的變數都被換成 <code>var</code> 了。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*2_rRzZtPp8KDJMvn_PMsQw.png" alt></p><blockquote><p>而瀏覽器的部分也順利運行編譯後的程式碼。</p></blockquote><p>我們為了觀察而使用 <code>npm run dev</code> ，這會使編譯後的檔案並不是以優化的方式編譯，因此若做為正式發布，應該使用 <code>npm run build</code> ，這點要特別注意哦。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      當我們使用的 JavaScript 語法瀏覽器不支援時，大家想到的第一個解決方案可能就是 Babel ，那麼說歸說，到底要怎麼跟先前提到的 Webpack 做結合，實際運用在開發上呢？讓我們繼續看下去~
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
      <category term="Babel" scheme="http://pvt5r486.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.3 使用 Jest 進行 Unit Test</title>
    <link href="http://pvt5r486.github.io/f2e/20190501/1835145669/"/>
    <id>http://pvt5r486.github.io/f2e/20190501/1835145669/</id>
    <published>2019-05-01T04:11:08.000Z</published>
    <updated>2020-02-16T05:52:53.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在學會如何模組化管理 JavaScript 與自定指令後，接著我們可以結合這些觀念，進行有系統的測試。尚未接觸這些東西前，我們在開發時如何檢測自己的函式寫的正不正確呢？沒錯，就是老老實實的使用 <code>console.log</code> 印出來，確認完之後再刪除，但這樣子很不方便，而這篇的主題就是為此而生。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*BqPJ2rsAjCJkFNaj" alt></p><h2 id="讓我們先準備這篇文章的環境"><a href="#讓我們先準備這篇文章的環境" class="headerlink" title="讓我們先準備這篇文章的環境"></a>讓我們先準備這篇文章的環境</h2><ul><li><a href="https://pvt5r486.github.io/webpack/20190430/3052134826">[Webpack]No.1 模組化 JavaScript 的方法</a>：說明如何安裝 npm 與 Webpack</li><li><p><a href="https://pvt5r486.github.io/webpack/20190501/1043079870">[Webpack]No.2 package.json 設置專屬我倆的小咒語</a>：說明如何自定指令</p></li><li><p>index.html：引入一個使用 Webpack 打包後產生的 .js 檔案</p></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*ZQp7NhG_BbUX5YGyBzTwmQ.png" alt></p><ul><li>util.js：寫了一個待會測試的字串反轉函式，並將它 <code>export</code> 出去</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*FEY93nsdAT8vwruzKOjakQ.png" alt></p><ul><li>all.js：<code>require util.js</code> ，並且令 all.js 為進入點</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*BU_vt9-5LQ8LGIZ_jlTbpQ.png" alt></p><h2 id="使用-console-log-進行測試"><a href="#使用-console-log-進行測試" class="headerlink" title="使用 console.log 進行測試"></a>使用 console.log 進行測試</h2><p>這是最基礎也最常使用的，在還沒接觸更進階的知識前，我們要如何知道程式的結果是什麼、到底寫的正不正確、符不符合我們預期，就是使用 <code>console.log</code> 印出後自己判斷正不正確。</p><blockquote><p>於是我們使用指令打包後，到瀏覽器確認結果</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*wiCLy5JQTvAAJ8d0zKNokg.png" alt></p><p>在我們還沒掌握更進階的技術之前，都是透過這種方式來確保自己的函式輸出的結果如同自己預期，但是現在我們有更好的選擇了，透過 npm 來安裝別人寫好的測試 module ，本次要介紹的就是 Jest 。</p><blockquote><p>程式中最小的結構單位就是以 function 為劃分，像這樣測試每一個 function 的結果是否正確就是所謂的<strong>單元測試 (Unit Test)</strong></p></blockquote><h2 id="使用-Jest-進行測試"><a href="#使用-Jest-進行測試" class="headerlink" title="使用 Jest 進行測試"></a>使用 Jest 進行測試</h2><p>Jest 是個 Facebook 開源計劃的項目，我們只要知道這樣就夠了，直接來動手做看看吧。</p><ul><li><a href="https://jestjs.io/" rel="external nofollow noopener noreferrer" target="_blank">Jest 官網</a></li><li>透過 <code>npm install jest --save-dev</code> 安裝</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*UMiztIrCgbS41_8XrNrahw.png" alt></p><ul><li>使用 Jest 進行測試的好處是，測試的檔案是分開的，因此我可以額外開個資料夾放這些測試的檔案，而檔名按照慣例是「要測試的檔名加上 .test.js」，因此最後看起來會是這樣：</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*JKchHV_SyDnWZ7ObgTapJA.png" alt></p><ul><li>接著開始寫 util.test.js 的內容</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*y_t6HI3k6zzGNLH0_y-KTw.png" alt></p><p>其實蠻簡單明瞭的，這段程式大致說明如下：</p><ul><li><code>test()</code> 是 Jest 提供的 function，第一個參數為文字敘述，第二個參數則是傳入一個 function</li><li><code>expect()</code> 則是傳入要接受測試的函式</li><li><code>toBe()</code> 就是我們預期得到的結果</li></ul><h3 id="準備的差不多了，運行看看吧"><a href="#準備的差不多了，運行看看吧" class="headerlink" title="準備的差不多了，運行看看吧"></a>準備的差不多了，運行看看吧</h3><ul><li>使用 <code>npm run jest</code> - 測試所有的測試檔案</li><li>使用 <code>npm run jest 要測試的檔案</code> - 測試指定檔案</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*NOSJHIMXxq3yanHRUjAiSg.png" alt></p><p>馬上就得到錯誤，原因是我們並非全域的安裝 Jest ，所以沒辦法直接使用下指令的方式來運行。</p><p>因此有個做法是，當你的 npm 版本為 5.2 以上時，可以使用另一個指令：</p><ul><li>npx jest</li></ul><blockquote><p><strong>與 npm 不同的地方在於，npm 是從作業系統開始找這個套件，npx 則是從專案開始找。</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*VJSwxq6xGHKHVDVhg_QzQA.png" alt></p><p>像這樣，很快的發現了我的第一個錯誤， <code>require</code> 路徑寫錯了，讓我修改一下。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*BTAW7PpXNQ4dDOzfIfzlzw.png" alt></p><ul><li>如果你的 npm 版本不支援 npx ，你可以自訂指令</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*SKn8V3Kn8gXCn9hWyPxO3A.png" alt></p><p>像這樣，可以輸入 <code>npm run test</code> ，可獲得一樣的結果：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*tzDwYqw__22DNfm02zGFTA.png" alt></p><blockquote><p>而為什麼寫在 package.json 就可以呢？原因是因為寫在裡面的話， npm 就會知道要從專案開始找，因此就不會跳出找不到的錯誤訊息囉。</p></blockquote><h2 id="使用-Jest-進行多個測試"><a href="#使用-Jest-進行多個測試" class="headerlink" title="使用 Jest 進行多個測試"></a>使用 Jest 進行多個測試</h2><p>要測試一個函式是否沒有 Bug 自然需要多個極端的測試案例，像是：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*KfJce2iHwnHUu7NAMZ9uag.png" alt></p><p>雖然這樣沒什麼問題，但對於有強迫症的人來說這樣子太沒有組織性了，所以我們可以像這樣把這一坨包起來：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*pV6MiVuYJ5LlCU46hxvBjg.png" alt></p><ul><li><code>describe()</code> 也是 Jest 提供的函式，可以幫助我們整理這些零散的測試。</li></ul><blockquote><p>運行看看吧！</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*nL2vFocUt8JQUq_ImHBr7Q.png" alt></p><blockquote><p>而如果你故意寫錯的話～</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*6mp5yfzU_gRjOFHE8biQoQ.png" alt></p><p>你就會得到一大堆的錯誤，並且會告訴你「預期得到什麼」、「實際上輸出什麼」。</p><blockquote><p>這樣是不是讓人更清楚這些東西是在幹嘛的呢?</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>覺得自己似乎又朝著前端更成長了一點，以前聽到單元測試，總覺得是個很厲害但令人摸不著頭緒的名詞，沒想到現在我居然也是個知道怎麼寫單元測試的工程師了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在學會如何模組化管理 JavaScript 與自定指令後，接著我們可以結合這些觀念，進行有系統的測試。尚未接觸這些東西前，我們在開發時如何檢測自己的函式寫的正不正確呢？沒錯，就是老老實實的使用 console.log …
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
      <category term="Jest" scheme="http://pvt5r486.github.io/tags/Jest/"/>
    
      <category term="Unit Test" scheme="http://pvt5r486.github.io/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.2 package.json 設置專屬我倆的小咒語</title>
    <link href="http://pvt5r486.github.io/f2e/20190501/1043079870/"/>
    <id>http://pvt5r486.github.io/f2e/20190501/1043079870/</id>
    <published>2019-05-01T00:17:52.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>於<a href="https://pvt5r486.github.io/webpack/20190430/3052134826">[Webpack]No.1 模組化 JavaScript 的方法</a>我們知道了如何模組化 JavaScript ，但是每次只要有 .js 檔案有異動，就得輸入指令重新 bundle 一次，好麻煩啊。別擔心，工程師是最怕麻煩的生物，早就有措施囉，這篇要介紹的是其中一種方式，自訂專屬於自己的指令。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*xzJvKfQurAI5VNWE" alt></p><h2 id="首先，讓我們回到上一篇的環境"><a href="#首先，讓我們回到上一篇的環境" class="headerlink" title="首先，讓我們回到上一篇的環境"></a>首先，讓我們回到上一篇的環境</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*SOqn17fhYnaYwd9ss4_zoQ.png" alt></p><p>為了能順利的寫下自己的咒語，我們需要建立一個 package.json ，而且讓我們先閱讀一下課外讀物，了解之間的差異。</p><ul><li><a href="https://www.itread01.com/content/1543392248.html" rel="external nofollow noopener noreferrer" target="_blank">package.json 與 package-lock.json 的差異</a></li></ul><h2 id="建立一個-package-json"><a href="#建立一個-package-json" class="headerlink" title="建立一個 package.json"></a>建立一個 package.json</h2><ul><li>輸入 <code>npm init</code></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*HUs5nYb_JaafckXvK25dTg.png" alt></p><p>會詢問你這個專案名稱叫什麼、版本號、等等的，如果都不想設定就快速的按下 Enter 吧。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*TNoeisJEHVI_iXCLrx-OPw.png" alt></p><p>最後會再次詢問你，是不是真的要建立。輸入 <code>yes</code></p><p><img src="https://cdn-images-1.medium.com/max/800/1*VK88DV8GmBF43mvbFL1VGA.png" alt></p><blockquote><p>於是我們就建立了 package.json。</p></blockquote><h3 id="設置專屬我倆的小咒語"><a href="#設置專屬我倆的小咒語" class="headerlink" title="設置專屬我倆的小咒語"></a>設置專屬我倆的小咒語</h3><p>接著就到重頭戲啦，打開 package.json 可以發現有一段是這麼寫的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;  </span><br><span class="line">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p></p><p>這一段是預設給我們測試的，可以在下方輸入 <code>npm run test</code></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Px2wcsIOXWZ0RnN-R94kHA.png" alt></p><p>然後我們就會得到這樣的結果，聰明如你，應該知道怎麼運用了吧？</p><p>沒錯，我們接下來就是要把指令搬移到這邊。</p><p>修改如下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*UlI_PtT4whQFbKXrO4LLug.png" alt></p><blockquote><p>“指令名”: “指令內容”</p></blockquote><p>這邊輸入中文只是為了博君一笑，當然開發時才不會這麼做呢。</p><p>接著我們測試看看吧！輸入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run 重生吧前鬼我還你原形</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*d6_CKSP7vD4Y7ZfCC50zew.png" alt></p><p>看起來很順利的完成了！來看看瀏覽器的狀況吧～</p><p><img src="https://cdn-images-1.medium.com/max/800/1*MizD2emBy5yT2teDtT1v0g.png" alt></p><blockquote><p>運行也沒有問題，看來中文指令是大成功的哩～</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>當我們在開發 Vue 時，輸入的 <code>npm run dev</code> 、 <code>npm run serve</code> 其實不是魔法，現在你學會了這招，是不是也能來個有創意的指令呢？</p><blockquote><p>當學的越多，慢慢的知道框架其實就是個高度包裝過後的東西，本來覺得像魔法的東西也逐漸的了解，這種感覺真的很棒。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      於上一篇我們知道了如何模組化 JavaScript ，但是每次只要有 .js 檔案有異動，就得輸入指令重新 bundle 一次，好麻煩啊。別擔心，工程師是最怕麻煩的生物，早就有措施囉，這篇要介紹的是其中一種方式，自訂專屬於自己的指令。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>[Webpack]No.1 模組化 JavaScript 的方法</title>
    <link href="http://pvt5r486.github.io/f2e/20190430/3052134826/"/>
    <id>http://pvt5r486.github.io/f2e/20190430/3052134826/</id>
    <published>2019-04-30T05:29:09.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果網站的規模不大，可能單純寫一支 all.js 就能搞定了，但如果今天與別人合作或者網站規模比較大，這時若只單靠一支 all.js 肯定是落落長的程式碼，每次要修改就得找半天，這樣是非常辛苦的。所以我們需要模組化 JavaScript ，這樣會方便很多，而模組化的好處遠不只這些，就不贅述了。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*_QHMblw0Ma_I580v" alt></p><h2 id="把檔案分開就好嗎-這我以前就這麼做了！"><a href="#把檔案分開就好嗎-這我以前就這麼做了！" class="headerlink" title="把檔案分開就好嗎 ? 這我以前就這麼做了！"></a>把檔案分開就好嗎 ? 這我以前就這麼做了！</h2><p>這邊的模組化的意思並不是把程式碼拆成多支 .js 檔並且在 index.html 內引入，因為這麼做其實並不算真正的把檔案分開，在 JavaScript 內仍然把它們視為同一個檔案，只是堆疊在一起，就好比這樣：</p><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><ul><li>準備一支 index.html ，並且引入兩支檔案</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*VpcY9gQ7z5e5FYxyt-Jj_w.png" alt></p><ul><li>math.js 內容如下</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*zxM_Ww3IQVZsr0VppmeT-g.png" alt></p><ul><li>all.js 內容如下</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*x_LVX1uTAR3NeFnsX8R2bA.png" alt></p><p>於是輸出結果，會發現 all.js 會把寫在 math.js 內的全域變數給印出來，這代表程式執行時它們會拼合成一支檔案，而透過觀察這麼做會產生 2 次的 request ，因為用了兩次的 script 標籤。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*xUdpYGBLc89eiNjIjq1crA.png" alt></p><h2 id="使用-ES5-export-與-require"><a href="#使用-ES5-export-與-require" class="headerlink" title="使用 ES5 export 與 require"></a>使用 ES5 export 與 require</h2><p>接著我們使用 ES5 <code>module.exports</code> 與 <code>require</code> 試著將 math.js 模組化…。</p><blockquote><p><strong>你會發現根本不能運行，因為 module.exports 與 require 只有 node.js 環境下才可以使用</strong>。</p></blockquote><p>不管是 ES5 <code>module.exports</code> 與 <code>require</code> 或 ES6 <code>import</code> 與 <code>export</code> ，如果想在瀏覽器環境使用模組化 JavaScript 就必須透過 Webpack 來搞定！</p><h3 id="於是我們需要做一些事前準備："><a href="#於是我們需要做一些事前準備：" class="headerlink" title="於是我們需要做一些事前準備："></a>於是我們需要做一些事前準備：</h3><ul><li>下載安裝 npm - 可以到 <a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">node.js</a> 下載安裝包</li></ul><p>打開 CLI 輸入 <code>node -v</code> ，若出現版本號代表安裝成功。</p><ul><li>切換到上個範例的資料夾內，輸入 <code>npm install webpack webpack-cli — save -dev</code></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*cj1x8MHpdtxdIa3anExfYw.png" alt="可以看到版本號代表成功安裝"></p><p>接著可以到 <a href="https://webpack.js.org/" rel="external nofollow noopener noreferrer" target="_blank">webpack 官網</a>看看如何起手</p><p><img src="https://cdn-images-1.medium.com/max/800/1*vI7rVur9GO9xNWMxMlIyIw.png" alt></p><p>好的，我們要先在專案資料夾內建立一個叫做 webpack.config.js 的檔案，接著複製貼上這些程式碼，而這些程式碼的涵義也很簡單：</p><ul><li><code>entry</code> : 進入點，代表引用這些 modules 最主要的地方</li><li><code>path</code> : 檔案輸出的路徑</li><li><code>filename</code> : 檔名</li></ul><p>都設置完之後，大致上長這個樣子：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*9Qlhp4-XLbVxcmHq4UCtcg.png" alt></p><p>接著回到 index.html ，引用我們打包後的 bundle.js 檔案</p><p><img src="https://cdn-images-1.medium.com/max/800/1*oDIvVoSevJ3iL9T890Q9XA.png" alt></p><blockquote><p><strong>這樣事前準備就都完成了，終於可以進入使用 ES5 module.exports 與 require 的部分。</strong></p></blockquote><ul><li>首先在 math.js 內使用 module.exports 將函式匯出</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*cuCGS2VNRRLv9B7bxuvdtQ.png" alt></p><ul><li>接著 all.js 把檔案 require 進來</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*C1nHVS2JuDiE4B__EQ6Ncw.png" alt></p><ul><li>最後別忘了執行 <code>.\node_modules\.bin\webpack</code> 打包產生檔案</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*VvF356wcoDH6re6X32Y6kw.png" alt></p><blockquote><p>接著我們就可以到瀏覽器上觀察囉~</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*_RYwVUZr2-FcWidO2A-lbQ.png" alt></p><p><img src="https://cdn-images-1.medium.com/max/800/1*q_vMaJ0fCA8p-aJooU435Q.png" alt></p><blockquote><p>發現函式的確成功的呼叫了，而且並不會受到 math.js 內的全域變數干擾，而且也因為只有使用一次 script 標籤，因此 request 只有一次。</p></blockquote><h3 id="想匯出的不只一支函式？可以建立物件來達成！"><a href="#想匯出的不只一支函式？可以建立物件來達成！" class="headerlink" title="想匯出的不只一支函式？可以建立物件來達成！"></a>想匯出的不只一支函式？可以建立物件來達成！</h3><ul><li><p>math.js 內配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var math = &apos;我是全域變數，會影響到其他人&apos;;</span><br><span class="line"></span><br><span class="line">function double(num)&#123;  </span><br><span class="line">  return num*2;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function triple(num)&#123;  </span><br><span class="line">  return num*3;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;  </span><br><span class="line">  double: double,  </span><br><span class="line">  triple: triple,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>all.js 內配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myModule = require(&apos;./module/math&apos;);  </span><br><span class="line">console.log(myModule.double(10));  </span><br><span class="line">console.log(myModule.triple(10));  </span><br><span class="line">console.log(math);</span><br></pre></td></tr></table></figure></li></ul><p>因為匯出的東西是物件，所以我們也必須使用物件的方式來取用。</p><p>別忘了<strong>使用指令打包輸出</strong>，接著來看看結果：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Z-kEifw5_1IcsLXOxG9vpg.png" alt></p><blockquote><p>蠻簡單的，對嗎？</p></blockquote><h2 id="使用-ES6-export-與-import"><a href="#使用-ES6-export-與-import" class="headerlink" title="使用 ES6 export 與 import"></a>使用 ES6 export 與 import</h2><p>使用 ES6 比較尷尬的點是，有些流覽器並沒有完全支援 ES6 語法，因此必須使用 ES5 或者透過 Babel 來轉換 ES6 的語法，目前 <code>export</code> 與 <code>import</code> 支援的程度如下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*zyjtjc8s8ODDIPlKb_V84Q.png" alt></p><p>嗯…好像還是紅紅的，所以要使用之前還是得先查一下支援程度，或者就乾脆使用 Babel 搞定這一切。</p><h3 id="怎麼使用"><a href="#怎麼使用" class="headerlink" title="怎麼使用"></a>怎麼使用</h3><ul><li>math.js 配置</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*lJ_fTsDD2_eWxRguy1UoZQ.png" alt></p><ul><li>all.js 配置</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*_3Jl81F-WvsYqqyBFC25sg.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*h9N4UvLWK3KIAnWt8EWsRA.png" alt></p><p>可以看出跟 ES5 的差別在哪裡：</p><ul><li>函式前面可以加上 <code>export</code> 代表匯出該函式</li><li>使用 <code>import {}</code> 承接， {} 內變數名稱需與匯出的函式相同</li><li>可以 <code>export</code> 的東西不只函式，變數也可以</li></ul><h3 id="除了這樣子寫以外，還有一些變化"><a href="#除了這樣子寫以外，還有一些變化" class="headerlink" title="除了這樣子寫以外，還有一些變化"></a>除了這樣子寫以外，還有一些變化</h3><ul><li>import 可以使用 <code>*</code> 號配合 <code>as</code> 賦予別名</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*k92WrndwX-T5qJ9vysYKGg.png" alt></p><p>而這個 <code>myModules</code> 是什麼呢？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*iFu9yH-BxQ8jk8SjdtDP2g.png" alt></p><p>是個物件，所以可以像一般使用物件的方式一樣操作即可。</p><ul><li>不想每個函式都加上 <code>export</code> ，可以這麼做</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*bLkZpsbjy7xLWlWM5TNdRg.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*uQCzX6GbVAhMS0A2_97xGg.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*6lkmflCmHQnKDDg6r5c2Ng.png" alt></p><blockquote><p>這邊要特別注意的是 <code>export{ }</code> 並不是物件</p></blockquote><ul><li><code>export</code> 配合 <code>default</code> ，就可以 <code>import</code> 時不加 { } ，但只能有一個 <code>default。</code></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*GS4RwgGkaRy4oCjtNVY8JA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*2imC2ZcMtLFTI5Ub58oJ8A.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*QPco9BR1xUF-Z8sf4NyrYQ.png" alt></p><blockquote><p>是不是覺得 import 沒有 { } 感覺比較順手呢？</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>個人比較喜歡取 <code>import *</code> 號取別名配合 <code>export{ }</code> 的方式，感覺最順手。</p><p>ES6 雖然好用歸好用，不過這樣的方式似乎目前支援度還是蠻差的，還是得透過 Babel ，如果確定專案會用上 Babel 了，那就不用客氣的用吧！</p><p>如果不想使用 Babel 那就使用 ES5的 <code>require</code> + <code>module.exports</code> 囉。</p><p>這邊撞了蠻多牆的，因為一開始很單蠢，不知道模組化必須得透過 Webpack 才能進行，還很納悶的想說語法都沒錯怎麼不能跑。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      如果網站的規模不大，可能單純寫一支 all.js 就能搞定了，但如果今天與別人合作或者網站規模比較大，這時若只單靠一支 all.js 肯定是落落長的程式碼，每次要修改就得找半天，這樣是非常辛苦的。所以我們需要把模組化 JavaScript …
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="Webpack" scheme="http://pvt5r486.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>初級 JavaScript 題目練習</title>
    <link href="http://pvt5r486.github.io/uncategorized/20190428/910365601/"/>
    <id>http://pvt5r486.github.io/uncategorized/20190428/910365601/</id>
    <published>2019-04-28T01:02:30.000Z</published>
    <updated>2020-03-06T07:56:58.867Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這周是參加<a href="https://github.com/Lidemy/mentor-program-3rd-pvt5r486" rel="external nofollow noopener noreferrer" target="_blank"><strong>計劃</strong></a>的第二周，每一周都過得很充實，不斷為自己打底的同時，也期待未來能遇到好的公司。之前繳交 OK 的作業也都可以透過這個 repo 看到，放上來也算是一種督促自己的心裡吧。</p><p>這篇主要分享一些第二周時寫的一些初級 JavaScript 題目，題目是由 <a href="https://medium.com/u/f1fb3e40dc37" rel="external nofollow noopener noreferrer" target="_blank">Huli</a> 擬定的，剛接觸 JavaScript 的朋友可以寫看看。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*hSKVeaZpWgpIzvU3" alt></p><h2 id="練習-LV-1"><a href="#練習-LV-1" class="headerlink" title="練習 LV 1"></a>練習 LV 1</h2><ul><li><p>請你分別用 for loop 以及 while 迴圈，印出 1 ~ 9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1  </span><br><span class="line">// 2  </span><br><span class="line">// ...  </span><br><span class="line">// 9</span><br></pre></td></tr></table></figure></li><li><p>請寫一個函式叫做 print，接收一個是數字的參數 n，並且印出 1~n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1  </span><br><span class="line">// 2  </span><br><span class="line">// ...  </span><br><span class="line">// n</span><br></pre></td></tr></table></figure></li><li><p>寫一個函式 star，接收一個參數 n ，並印出 n 個 *</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// star(1) 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// star(5) 預期輸出：  </span><br><span class="line">// *****</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個叫做 starReturn 的 function 並且接受一個參數 n，能回傳 n 個 *</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// console.log(starReturn(1)); 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// console.log(starReturn(5)); 預期輸出：  </span><br><span class="line">// *****</span><br></pre></td></tr></table></figure></li><li><p>請寫一個叫做 isUpperCase 的 functuon，並且接收一個字串，回傳這個字串的第一個字母是否為大寫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// isUpperCase(&quot;abcd&quot;) 正確回傳值：false  </span><br><span class="line">// isUpperCase(&quot;Abcd&quot;) 正確回傳值：true</span><br></pre></td></tr></table></figure></li><li><p>請寫一個 function position，接收一個字串並回傳這個字串裡面的第一個大寫字母跟它的 index，若沒有則回傳 -1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position(&quot;abcd&quot;) 正確回傳值：-1  </span><br><span class="line">position(&quot;AbcD&quot;) 正確回傳值：A 0  </span><br><span class="line">position(&quot;abCD&quot;) 正確回傳值：C 2</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個函式 findSmallCount，接收一個陣列跟一個數字 n，回傳有多少個數小於 n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// findSmallCount([1, 2, 3], 2) 預期回傳值：1  </span><br><span class="line">// findSmallCount([1, 2, 3, 4, 5], 0) 預期回傳值：0</span><br></pre></td></tr></table></figure></li><li><p>請寫一個函式 findSmallerTotal，接收一個陣列以及數字 n，回傳陣列裡面所有小於 n 的數的總和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// findSmallerTotal([1, 2, 3], 3) 正確回傳值：3  </span><br><span class="line">// findSmallerTotal([1, 2, 3], 1) 正確回傳值：0  </span><br><span class="line">// findSmallerTotal([3, 2, 5, 8, 7], 999) 正確回傳值：25  </span><br><span class="line">// findSmallerTotal([3, 2, 5, 8, 7], 0) 正確回傳值：0</span><br></pre></td></tr></table></figure></li><li><p>請寫一個函式 findAllSmall，接收一個陣列跟一個數字 n，回傳一個裡面有所有小於 n 的數的陣列（需按照原陣列順序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// findAllSmall([1, 2, 3], 10) 正確回傳值：[1, 2, 3]</span><br><span class="line">// findAllSmall([1, 2, 3], 2) 正確回傳值：[1]</span><br><span class="line">// findAllSmall([1, 3, 5, 4, 2], 4) 正確回傳值：[1, 3, 2]</span><br></pre></td></tr></table></figure></li><li><p>請寫一個 function sum，接收一個陣列並回傳陣列中數字的總和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// sum([1, 2, 3]) 預期回傳值：6  </span><br><span class="line">// sum([-1, 1, 2, -2, 3, -3]) 預期回傳值：0</span><br></pre></td></tr></table></figure></li></ul><h2 id="練習-LV-2"><a href="#練習-LV-2" class="headerlink" title="練習 LV 2"></a>練習 LV 2</h2><ul><li><p>請寫出一個 function stars，接收一個參數 n，並且按照規律印出相對應的圖案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// stars(1) 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// stars(3) 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// **  </span><br><span class="line">// ***</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個 function makeStars，接收一個參數 n，並且根據規律「回傳」字串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// makeStars(1) 正確回傳值：*  </span><br><span class="line">// makeStars(2) 正確回傳值：*\n**  </span><br><span class="line">// makeStars(5) 正確回傳值：*\n**\n***\n****\n*****</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個函式 stars2 ，接收一個參數 n ，並依照規律印出圖形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// stars2(1) 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// stars2(3) 預期輸出：  </span><br><span class="line">// *  </span><br><span class="line">// **  </span><br><span class="line">// ***  </span><br><span class="line">// **  </span><br><span class="line">// *</span><br></pre></td></tr></table></figure></li><li><p>請寫一個函式 table，接收一個數字 n ，印出 n <em>1 ~ n </em>9 的結果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// table(1) 預期輸出：  </span><br><span class="line">// 1*1 = 1  </span><br><span class="line">// 1*2 = 2  </span><br><span class="line">// 1*3 = 3  </span><br><span class="line">// 1*4 = 4  </span><br><span class="line">// 1*5 = 5  </span><br><span class="line">// 1*6 = 6  </span><br><span class="line">// 1*7 = 7  </span><br><span class="line">// 1*8 = 8  </span><br><span class="line">// 1*9 = 9</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個 function table9to9，並列出 1 <em>1 ~ 9 </em>9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// table9to9() 預期輸出：  </span><br><span class="line">// 1*1 = 1  </span><br><span class="line">// 1*2 = 2  </span><br><span class="line">// 1*3 = 3  </span><br><span class="line">// .....  </span><br><span class="line">// 5*1 = 5  </span><br><span class="line">// 5*2 = 10  </span><br><span class="line">// 5*3 = 15  </span><br><span class="line">// ....  </span><br><span class="line">// 9*7 = 63  </span><br><span class="line">// 9*8 = 72  </span><br><span class="line">// 9*9 = 81</span><br></pre></td></tr></table></figure></li><li><p>費式數列的定義為：第 n 個數等於前兩個數的總和，因此這個數列會長的像這樣：1 1 2 3 5 8 13 21 ….</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// fib(0) = 0  </span><br><span class="line">// fib(1) = 1  </span><br><span class="line">// for n &gt;=2, fib(n) = fib(n-1) + fib(n-2)  </span><br><span class="line">// 現在，請你寫出一個 fib 的函式，回傳位在第 n 個位置的數字  </span><br><span class="line">// fib(1) 預期回傳值：1  </span><br><span class="line">// fib(2) 預期回傳值：1  </span><br><span class="line">// fib(8) 預期回傳值：21</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個函式 reverse，接收一個字串，並且回傳反轉過後的字串。（禁止使用內建函式 reverse）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// reverse(&quot;abcd&quot;) 預期回傳值：dcba  </span><br><span class="line">// reverse(&quot;12345aa&quot;) 預期回傳值：aa54321</span><br></pre></td></tr></table></figure></li><li><p>請寫一個函式 swap，接收一個字串，並且回傳大小寫互換後的字串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// swap(&quot;Peter&quot;) 預期回傳值：pETER  </span><br><span class="line">// swap(&quot;AbCdE&quot;) 預期回傳值：aBcDe</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個函式 findMin，接收一個陣列並回傳陣列中的最小值。（禁止使用內建函式 sort）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// findMin([1, 2, 5, 6, 99, 4, 5]) 預期回傳值：1  </span><br><span class="line">// findMin([1, 6, 0, 33, 44, 88, -10]) 預期回傳值：-10</span><br></pre></td></tr></table></figure></li><li><p>請寫一個 function findNthMin，接收一個陣列以及一個數字 n，找出第 n 小的數字。（禁止使用內建函式 sort）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// findNthMin(\[1, 2, 3, 4, 5\], 1) 預期回傳值：1  </span><br><span class="line">// findNthMin(\[1, 3, 5, 7, 9\], 3) 預期回傳值：5  </span><br><span class="line">// findNthMin(\[1, 1, 1, 1, 1\], 2) 預期回傳值：1</span><br></pre></td></tr></table></figure></li></ul><h2 id="練習-LV-3"><a href="#練習-LV-3" class="headerlink" title="練習 LV 3"></a>練習 LV 3</h2><ul><li><p>請寫一個 function sort，接收一個陣列並且回傳由小到大排序後的陣列。（禁止使用內建函式 sort）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// sort([ 6, 8, 3, 2]) 預期回傳值：[2, 3, 6, 8]  </span><br><span class="line">// sort([ 1, 2, 7 ,5]) 預期回傳值：[1, 2, 5, 7]</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個 function flatten，接收一個多維陣列並回傳「壓平」後的陣列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// flatten([1, 2, 3]) 預期回傳值：[1, 2, 3]  </span><br><span class="line">// flatten([1, 2, [1, 2], [1, 3], 6]) 預期回傳值：[1, 2, 1, 2, 1, 3, 6]  </span><br><span class="line">// flatten([1, [2, [3, [4]], 5], 6]) 預期回傳值：[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></li><li><p>請寫一個 function tree，接收一個數字 n，按照規律列印出大小為 n 的聖誕樹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 為方便顯示，因此把空白代換成底線，實際請輸出空白  </span><br><span class="line">// tree(2) 預期輸出：  </span><br><span class="line">// _*  </span><br><span class="line">// ***  </span><br><span class="line">// _*  </span><br><span class="line">// _*</span><br><span class="line"></span><br><span class="line">// tree(5) 預期輸出：  </span><br><span class="line">// ____*  </span><br><span class="line">// ___***  </span><br><span class="line">// __*****  </span><br><span class="line">// _*******  </span><br><span class="line">// *********  </span><br><span class="line">// ____*  </span><br><span class="line">// ____*  </span><br><span class="line">// ____*  </span><br><span class="line">// ____*  </span><br><span class="line">// ____*</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個 function winner，接收一個代表圈圈叉叉的陣列，並回傳贏的是 O 還是 X，如果平手或還沒下完，請回傳 draw</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// winner([  </span><br><span class="line">// [&apos;O&apos;, &apos;O&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;O&apos;, &apos;X&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;O&apos;, &apos;X&apos;, &apos;O&apos;]  </span><br><span class="line">// ]) 預期回傳值：O</span><br><span class="line"></span><br><span class="line">// winner([  </span><br><span class="line">// [&apos;O&apos;, &apos;O&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;O&apos;, &apos;X&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;X&apos;, &apos;X&apos;, &apos;O&apos;]  </span><br><span class="line">// ]) 預期回傳值：X</span><br><span class="line"></span><br><span class="line">// winner([  </span><br><span class="line">// [&apos;O&apos;, &apos;O&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;O&apos;, &apos;O&apos;, &apos;X&apos;],  </span><br><span class="line">// [&apos;X&apos;, &apos;X&apos;, &apos;&apos;]  </span><br><span class="line">// ]) 預期回傳值：draw</span><br></pre></td></tr></table></figure></li><li><p>請寫出一個 function isPrime，給定一個數字 n，回傳 n 是否為質數。（質數的定義：除了 1 以外，沒辦法被所有 &lt; n 的正整數整除）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isPrime(1) 正確回傳值：false  </span><br><span class="line">isPrime(5) 正確回傳值：true  </span><br><span class="line">isPrime(37) 正確回傳值：true</span><br></pre></td></tr></table></figure></li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>總共 25 題，目前的能力大概是 22 題能初見殺，不過用的時間比較多一些，還沒辦法秒解，有 3 題是不太熟或者完全沒想到所以放棄的。</p><p>解題的過程蠻有趣的，也是再練習如何把問題切碎切小，而有些題目彼此也有關聯性，這邊也附上我自己解完題的答案：</p><ul><li><a href="https://github.com/pvt5r486/JS_Practice" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這周是參加計劃的第二周，每一周都過得很充實，不斷為自己打底的同時，也期待未來能遇到好的公司。之前繳交 OK 的作業也都可以透過這個 repo 看到，放上來也算是一種督促自己的心裡吧。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="程式導師計畫" scheme="http://pvt5r486.github.io/tags/%E7%A8%8B%E5%BC%8F%E5%B0%8E%E5%B8%AB%E8%A8%88%E7%95%AB/"/>
    
      <category term="自我投資" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8A%95%E8%B3%87/"/>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.6 新手訓練告一段落</title>
    <link href="http://pvt5r486.github.io/b2e/20190424/607011541/"/>
    <id>http://pvt5r486.github.io/b2e/20190424/607011541/</id>
    <published>2019-04-24T06:19:11.000Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在經過了一些摧殘後，初學的菜鳥雖然對於 PHP 語法還不是相當熟，但起碼有些微的語感了，這篇沒有什麼重點，只是簡單交代一下最近用什麼小題目練習 PHP，而基礎的 PHP 大概就到此先告一段落。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*zf_eat52iQEtg1-o" alt></p><h2 id="PHP-小題目"><a href="#PHP-小題目" class="headerlink" title="PHP 小題目"></a>PHP 小題目</h2><p>我總共做了四種不同類型的應用，不過基本上都脫離不了 CRUD ， 兩種是純粹的 PHP 練習，另外兩種則是練習用 PHP 開 API 做前後端分離。</p><p>畫面都頗陽春，主要著重在功能面的實作練習。</p><h3 id="Job-Board-職缺報報"><a href="#Job-Board-職缺報報" class="headerlink" title="Job Board 職缺報報"></a>Job Board 職缺報報</h3><ul><li><a href="https://github.com/pvt5r486/jobBoard" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><p>這個題目是我剛接觸 PHP 的第一個題目，屬於純粹的 PHP 練習，沒有任何 JavaScript 。</p><p><strong>主要練習：</strong></p><ul><li>職缺的 CRUD</li><li>註冊與登入</li><li>Session 的身分驗證</li><li>管理員可以審核職缺</li></ul><h3 id="myBlog-部落格"><a href="#myBlog-部落格" class="headerlink" title="myBlog 部落格"></a>myBlog 部落格</h3><ul><li><a href="https://github.com/pvt5r486/myBlog" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><p>作為接觸 PHP 的第二個題目，同樣是屬於純粹的 PHP 練習。</p><p><strong>主要練習：</strong></p><ul><li>更多的 CRUD 操作、像是文章的評論等等</li><li>更複雜的資料庫關聯 - 一篇文章可以有多個分類</li><li>取得資料後的合併</li></ul><h3 id="ToDoList"><a href="#ToDoList" class="headerlink" title="ToDoList"></a>ToDoList</h3><ul><li><a href="https://github.com/pvt5r486/myTodoList" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><p>接著就是練習如何開 API 給前端接了，這個就是大家熟悉新技術通常都會拿來練手的題目，然後也重新複習一些 jQuery 。</p><p><strong>主要練習：</strong></p><ul><li>後端如何開 API 給前端</li><li>開 API 需要知道的一些小細節</li><li>透過 AJAX 做 CRUD</li><li>jQuery 一些好用的 API</li><li>資料的拖拉排序</li></ul><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul><li><a href="https://github.com/pvt5r486/myCalendar" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><p>最後就是練習開更多的 API ，做更多的 CRUD、寫更多的 PHP 。</p><p><strong>主要練習：</strong></p><ul><li>設定 HTTP Status Code</li><li>透過 AJAX 練習更多的 CRUD</li><li>練習更多的 jQuery</li><li>知道如何畫出月曆、並且計算日期並補上前面與後面的灰色空格</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>大概就是這樣吧，雖然不敢說非常熟悉 PHP 了，但至少有一點上手了。基礎的 PHP 到此告一段落，接著會想嘗試挑戰看看 Laravel 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在經過了一些摧殘後，初學的菜鳥雖然對於 PHP 語法還不是相當熟，但起碼有些微的語感了，這篇沒有什麼重點，只是簡單交代一下最近用什麼小題目練習 PHP，而基礎的 PHP 大概就到此先告一段落。
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MySQL" scheme="http://pvt5r486.github.io/tags/MySQL/"/>
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
      <category term="PHP" scheme="http://pvt5r486.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.5 遇到程式問題，如何把問題切細變得容易解決</title>
    <link href="http://pvt5r486.github.io/b2e/20190418/1009477553/"/>
    <id>http://pvt5r486.github.io/b2e/20190418/1009477553/</id>
    <published>2019-04-18T00:12:29.000Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>No.4 寫完之後，我果然還是很在意自己這樣子寫可不可以，於是我就請了一位大大來幫我看看，是不是有哪些地方可以調整，然後給了我三個建議。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*aWli5-QK3DLlx15d" alt></p><h2 id="前情提要一下"><a href="#前情提要一下" class="headerlink" title="前情提要一下"></a>前情提要一下</h2><p><a href="https://pvt5r486.github.io/b2e/20190416/4221665571">[初探後端]No.4 對文章加上多個分類</a></p><ul><li>ref 表名字可以換一下，太臭長了</li><li>更新的部份，因為知道原始分類、也知道目標所以可以想成這樣<ul><li>source: 1, 2, 3</li><li>target: 1, 3, 5, 7<blockquote><p>寫出來就能比較清楚知道要<strong>保留、刪除、新增</strong>哪些。<br>而我之前的做法是<strong>無差別刪除，然後新增 (比較簡單、偷吃步)</strong></p></blockquote></li></ul></li><li>取得文章可以不用連這麼多次資料庫，試著練習資料結構處理</li></ul><h2 id="從資料庫取得的資料"><a href="#從資料庫取得的資料" class="headerlink" title="從資料庫取得的資料"></a>從資料庫取得的資料</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*C_dJNsv-4nftt7UQz688qA.png" alt></p><p>因為本身還在學習 PHP ，所以對 PHP 語法可能不夠熟悉，因此不知道如何動手，所以才有那種相當耗資源的寫法。於是給我建議的大大說，那不然你把它想成這樣的結構<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;HTML&apos;&#125;,  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;JS&apos;&#125;,  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;CSS&apos;&#125;,  </span><br><span class="line">  &#123;id: 2, content: &apos;hi&apos;, category: &apos;CSS&apos;&#125;,  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 處理成下面這樣  </span><br><span class="line">[  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;HTML,JS,CSS&apos;&#125;,  </span><br><span class="line">  &#123;id: 2, content: &apos;hi&apos;, category: &apos;CSS&apos;&#125;,  </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>試著用 JavaScript 去把這個資料轉化成你想要的樣子</strong>。</p></blockquote><p>老實說我這題卡了 6 小時，看起來需求很簡單，不過實際上當真的要動手寫的時候，會發現腦袋幾乎是空白的，再次驗證程式不能只用<strong>看的、想的</strong>，要真的動手寫。</p><p>一開始，我把注意力都放在 ES5、6 的陣列方法上， 像是 <code>reduce</code> 、 <code>filter</code> 、 <code>foreach</code> 等等，怎麼樣就是不知道該怎麼繼續做下去。</p><p>也查了一些什麼物件合併、陣列合併的方法，但好像有看跟沒看一樣。</p><p>後來大大給了我其他的提示：</p><ul><li>不要想成直接把 A 轉成 B ，想成如何利用 A 的資訊，重新建構出一個你想要的 B</li><li>資料結構先改成以下，先想辦法拼湊成這樣</li><li>不要去想什麼陣列方法，這題用 <code>for</code> 迴圈就能解決<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;&#125;,  </span><br><span class="line">  &#123;id: 2, content: &apos;hi&apos;&#125;,  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 處理成下面這樣  </span><br><span class="line">&#123;  </span><br><span class="line">  1: &#123;  </span><br><span class="line">    content: &apos;hello&apos;  </span><br><span class="line">  &#125;,   </span><br><span class="line">  2: &#123;  </span><br><span class="line">    content: &apos;hi&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>於是我好不容易拼湊出來了，在卡了好一陣之後。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let dataLen = data.length;  </span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for(let i = 0; i &lt; dataLen; i++)&#123;  </span><br><span class="line">  id = data[i].id;  </span><br><span class="line">  obj[id] = &#123;content:  data[i].content&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*N3W7nxmUb4GDUlHnfkYIeg.png" alt></p><p>接著說也奇怪，我似乎慢慢地知道該怎麼做了，於是我把資料補回原本的那樣，然後繼續維持輸出成物件的形式。</p><ul><li>因為我要跑 <code>for</code> 迴圈，肯定要知道這個陣列的長度</li><li>接著最困難的點就是，要怎麼判斷「當前 <code>data</code> 陣列內 的這個物件跟下一個物件是不是一樣的」</li></ul><blockquote><p>如果一樣，需要對分類做合併；不一樣就新增</p></blockquote><p>對於第二點，我的做法是使用「<strong><code>type of</code> 檢查 <code>obj</code> 物件，如果物件內沒有對應的 <code>id</code> 屬性，會顯示 <code>undefined</code> ，代表這筆資料是不同的，必須新增</strong>」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let data = [  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;HTML&apos;&#125;,  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;JS&apos;&#125;,  </span><br><span class="line">  &#123;id: 1, content: &apos;hello&apos;, category: &apos;CSS&apos;&#125;,  </span><br><span class="line">  &#123;id: 2, content: &apos;hi&apos;, category: &apos;CSS&apos;&#125;,  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let dataLen = data.length;  </span><br><span class="line">let obj = &#123;&#125;;  </span><br><span class="line">for(let i = 0; i &lt; dataLen; i++)&#123;  </span><br><span class="line">  if(typeof obj[data[i].id] === &apos;undefined&apos;)&#123;  </span><br><span class="line">    obj[data[i].id] = &#123;  </span><br><span class="line">      content:  data[i].content,  </span><br><span class="line">      category: data[i].category  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    obj[data[i].id].category = `$&#123;obj[data[i].id].category&#125;,$&#123;data[i].category&#125;`;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*_Xo9EyH2n30aWZdjKs3syw.png" alt></p><p>後來我覺得還是把 <code>id</code> 也包進物件內好了，所以又自己補上去。</p><p>到這邊就整個都通了，接著要把它換成一開始要求的樣子，於是我查到一個好用的方法 <code>Object.values()</code> ，補上即可轉換。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = Object.values(obj)  </span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*EQSVSS_t-YpkqW-ODAYUAQ.png" alt></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>最困難的部分已經克服了，接著就是要回到 PHP 實作，邏輯基本上都沒變，只是語法要稍微調整一下，相信不是太大問題。</p><p>最後 PHP 部份我也順利的完成了，這一篇主要記錄的是「<strong>當遇到問題，如何把問題切細，變得容易解決</strong>」，非常感謝給我建議的大大，也花了不少時間引導我。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      No.4 寫完之後，我果然還是很在意自己這樣子寫可不可以，於是我就請了一位大大來幫我看看，是不是有哪些地方可以調整，然後給了我三個建議。
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MySQL" scheme="http://pvt5r486.github.io/tags/MySQL/"/>
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
      <category term="PHP" scheme="http://pvt5r486.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.4 對文章加上多個分類</title>
    <link href="http://pvt5r486.github.io/b2e/20190416/4221665571/"/>
    <id>http://pvt5r486.github.io/b2e/20190416/4221665571/</id>
    <published>2019-04-16T09:47:22.016Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>突然意識到似乎很久沒有上來這邊寫寫文章了，最近都在埋頭練習 PHP 與 MySQL ，實做了一個超級陽春的 job board 與 blog ，初期弄一個簡單的 blog ，自然是沒什麼問題。但隨著需求的提升，就困難許多了，像是「<strong>把一篇文章只能有一個分類，變成一篇文章允許多個分類</strong>」，這件事情就會讓難度高上不少，而這篇就是記錄這個過程哩，順便也描述一下自己遇到什麼困難。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*8Y9f6Uw-skvmSa0e" alt></p><h2 id="資料庫架構的調整"><a href="#資料庫架構的調整" class="headerlink" title="資料庫架構的調整"></a>資料庫架構的調整</h2><p>做這樣的改變，首當其衝的必然是資料表與資料表之間的關聯，如果「一篇文章只有一個分類」，我們只需要再 <code>article</code> 的資料表內新增一個 <code>categoryID</code> 的欄位，然後需要時，透過 <code>join</code> 查詢這樣就搞定了。</p><blockquote><p>但如果是「<strong>一篇文章有多個分類</strong>」呢？</p></blockquote><ul><li>在 <code>articles</code> 的資料表內新增一個 <code>categoryID</code> 的欄位，利用字串拼接的方式儲存？</li><li>多建立一張資料表以下簡稱 <code>ref</code> 表，儲存文章與類別的關聯性</li></ul><blockquote><p>我最後想想是選擇了第二種方式，感覺比較好。</p></blockquote><h2 id="於是使用-Workbench-規劃如下："><a href="#於是使用-Workbench-規劃如下：" class="headerlink" title="於是使用 Workbench 規劃如下："></a>於是使用 Workbench 規劃如下：</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*dgJEY1AIibcr5-2JO8AhEA.png" alt></p><h3 id="文章的新增-C"><a href="#文章的新增-C" class="headerlink" title="文章的新增 C"></a>文章的新增 C</h3><p>主要是 PHP 與 MySQL 與 HTML 上的調整。</p><ul><li>新增文章的網頁</li></ul><p>由於變成可以選擇多個類別，所以這部份的選單需要變成多選式的，而我也是第一次發現可以再 <code>name</code> 屬性內加上 [] ，使其傳回陣列。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select multiple=&quot;multiple&quot; name=&quot;category[]&quot; id=&quot;category&quot;&gt;  </span><br><span class="line"> ...  </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p></p><ul><li>PHP</li></ul><p>這部份我是選擇分開處理，因為根據畫的 modal 圖， <code>articles</code> 這張表其實跟類別已經沒什麼關係了，所以我選擇拆成兩段：</p><ul><li>先進行文章的新增，取得文章 <code>id</code></li><li>接著於 <code>ref</code> 表內新增文章與類別的關聯</li></ul><p>而資料庫部份使用 PDO 來連接，認為比較關鍵的語法就是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pdo-&gt;lastInsertId();</span><br></pre></td></tr></table></figure><p></p><p>這可以讓我取得最後一筆新增的 <code>id</code> ，這樣我就知道新增的那篇文章 <code>id</code> 是多少。</p><h3 id="文章的讀取-R"><a href="#文章的讀取-R" class="headerlink" title="文章的讀取 R"></a>文章的讀取 R</h3><p>主要是 PHP 與 MySQL 的調整。需要在 admin.php (後台) 把文章資料讀出來，但這部份也是我比較苦惱的，因為對於 SQL 的語法並不是很擅長，這一段雖然我有做出來，但總覺得如果我更熟悉 SQL 語法，應該可以更好做。</p><ul><li>MySQL</li></ul><p>這部份我試了好一陣，總是沒辦法單獨使用 MySQL 就把文章、類別、關聯表的資料漂亮的串好，頂多就串成下面這樣。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*, b.name  </span><br><span class="line">FROM articles as a, categories as b, articleandcategory_ref as c  </span><br><span class="line">WHERE a.id = c.articleID AND b.id = c.categoryID  </span><br><span class="line">ORDER BY a.created_at DESC</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*EHB9FTjjT1RLcotVvxIqpA.png" alt></p><p>但這樣我也不知道該怎麼用，因為我想要得到的結果是，每篇文章只有一筆資料，然後後面會帶上類別名稱這樣。</p><p><strong>這部份我卡了很久，後來決定用比較笨的方法，跟新增文章一樣分成兩段：</strong></p><ul><li>先取得全部的文章，存成陣列</li><li>對這個陣列進行 <code>foreach</code> ，取得每篇文章 <code>id</code> 後，再透過 SQL 語法取得該文章對應的類別，最後插入陣列。</li></ul><blockquote><p>因為不確定這麼做好不好，感覺這樣很沒有效率。</p></blockquote><h3 id="文章的更新-U"><a href="#文章的更新-U" class="headerlink" title="文章的更新 U"></a>文章的更新 U</h3><p>主要是 PHP 與 MySQL 與 HTML 上的調整，這部份的 HTML 畫面也讓我卡了好一陣子，原因是當類別變成多選後，進入編輯時需要將對應的類別設定預設選取，這部份會卡關主要是邏輯卡住了，因為我用了兩層的 <code>foreach</code> ，腦袋轉不過來，應該會有更好的解法但我不知道。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*zbIzqr6uvxhwTF2AKLFSkw.png" alt></p><blockquote><p>這部份我也是不知道有沒有比較好的做法，也不確定我這麼做對不對。因為如果是更新到類別的話，勢必得到 ref 表內做一些查詢、修改，也有可能把原本的 3 個類別改成 2 個類別，那這樣子要怎麼做出相應的處理呢？</p></blockquote><p><strong>所以這部份我後來想到的做法是</strong></p><ul><li>先更新文章本身</li><li>到 <code>ref</code> 表內刪除所有跟<strong>這篇文章的關聯並重建關聯</strong></li></ul><blockquote><p>這麼做的好處就是不用管要怎麼處理了，反正就是重建新的關聯，只是我不確定這麼做好不好就是了，只是這樣子做讓我輕鬆不少。</p></blockquote><h3 id="文章的刪除-D"><a href="#文章的刪除-D" class="headerlink" title="文章的刪除 D"></a>文章的刪除 D</h3><p>主要是 PHP 與 MySQL 的調整，不過也不是說想刪除文章就可以直接刪除文章，MySQL 是關聯式資料庫，從 modal 上看來，文章關係到了 <code>ref</code> 表與 <code>comment</code> 表，所以如果直接針對文章做刪除是肯定會失敗的。</p><p>所以這部份的做法是：<strong>逐一刪除有關聯的部份</strong></p><ul><li>透過該文章 <code>ID</code> 刪除 <code>comment</code> 內對應的資料</li><li>接著刪除 <code>ref</code> 表內對應的資料</li><li>最後才是刪除文章本體</li></ul><blockquote><p>刪除的部份是相對簡單的呢。</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>折騰了一陣子總算是把功能都做完了，不過卻也開始懷疑這樣的做法 O 不 OK 就是了，但有做出來總是好的！</p><p><strong>畢竟先求有再求好，對吧？</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*OETv7-2MquUM4M-AWPhHhQ.png" alt="非常非常陽春的界面"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      突然意識到似乎很久沒有上來這邊寫寫文章了，最近都在埋頭練習 PHP 與 MySQL ，實做了一個超級陽春的 job board 與 blog，初期弄一個簡單的 blog…
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MySQL" scheme="http://pvt5r486.github.io/tags/MySQL/"/>
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
      <category term="PHP" scheme="http://pvt5r486.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.3 PHP 與 MySQL 連線的方式</title>
    <link href="http://pvt5r486.github.io/b2e/20190406/3982341698/"/>
    <id>http://pvt5r486.github.io/b2e/20190406/3982341698/</id>
    <published>2019-04-06T03:51:21.000Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>開始進行 PHP 的練習後，最重要的大概就是資料庫的操作了吧，對後端而言與資料庫的關係像是魚跟水般密不可分，我在實作練習時發現 PHP 有三種方式可以跟 MySQL 連線，所以想記錄一下有哪些，不過這些大致上都有前輩寫過了，所以就只是單純記錄。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*y8Psgz0lPIgJN0j2" alt></p><h2 id="PHP-與-MySQL-連線的方式"><a href="#PHP-與-MySQL-連線的方式" class="headerlink" title="PHP 與 MySQL 連線的方式"></a>PHP 與 MySQL 連線的方式</h2><ul><li>PHP-MySQL</li><li>PHP-MySQLi</li><li>PDO</li></ul><h3 id="前人寫好的文章："><a href="#前人寫好的文章：" class="headerlink" title="前人寫好的文章："></a>前人寫好的文章：</h3><ul><li><a href="https://blog.roga.tw/2010/06/2403" rel="external nofollow noopener noreferrer" target="_blank">淺談 PHP-MySQL, PHP-MySQLi, PDO 的差異</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10209190" rel="external nofollow noopener noreferrer" target="_blank">MySQLi vs PDO 比較</a></li></ul><p>經過一輪的比較，似乎是 PDO 用途會比較廣，畢竟 PDO 連接資料庫時，透過 Data Source Name (DSN) 來決定要連接何種資料庫，只是我還有點不習慣 PHP ，所以寫起程式碼來綁手綁腳的。</p><p>因為 PDO 有支援 <code>try...catch</code> 所以也可以好好運用，找到一篇蠻完整的範例。</p><ul><li><a href="http://ps.hsuweni.idv.tw/?p=5061" rel="external nofollow noopener noreferrer" target="_blank">使用 try-catch 來撰寫 PDO 程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      開始進行 PHP 的練習後，最重要的大概就是資料庫的操作了吧，對後端而言與資料庫的關係像是魚跟水般密不可分，我在實作練習時發現 PHP 有三種方式可以跟 MySQL 連線，所以想記錄一下有哪些，不過這些大致上都有前輩寫過了，所以就只是單純記錄。
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MySQL" scheme="http://pvt5r486.github.io/tags/MySQL/"/>
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
      <category term="PHP" scheme="http://pvt5r486.github.io/tags/PHP/"/>
    
      <category term="PDO" scheme="http://pvt5r486.github.io/tags/PDO/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.2 使用 VS Code 開發 PHP 的 Debug 設定與 Composer 套件管理</title>
    <link href="http://pvt5r486.github.io/b2e/20190402/1330110113/"/>
    <id>http://pvt5r486.github.io/b2e/20190402/1330110113/</id>
    <published>2019-04-02T07:47:47.000Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正當我興高采烈的想說 MySQL 的環境都設定好、前端版型也都 OK 了，該是來好好的學習一下 PHP 了。這時才發現，PHP 的 Debug 環境需要特別去設定，不像 JavaScript 這麼佛心只要打開 chrome 就能除錯，又撞牆了好一陣，終於把開發環境都建立起來了。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*NTMQloMNCkf0hJTO" alt></p><h2 id="使用-VS-Code-開發-PHP-的-Debug-設定"><a href="#使用-VS-Code-開發-PHP-的-Debug-設定" class="headerlink" title="使用 VS Code 開發 PHP 的 Debug 設定"></a>使用 VS Code 開發 PHP 的 Debug 設定</h2><p>事前準備你需要：</p><ul><li>安裝好 VS Code</li><li>可以上網的環境</li></ul><h3 id="Step-1-打開-VS-Code-並且安裝兩套插件"><a href="#Step-1-打開-VS-Code-並且安裝兩套插件" class="headerlink" title="Step.1 打開 VS Code 並且安裝兩套插件"></a>Step.1 打開 VS Code 並且安裝兩套插件</h3><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bmewburn.vscode-intelephense-client" rel="external nofollow noopener noreferrer" target="_blank">PHP Intelephense</a> - 這是具有 PHP 語法智能提示的插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=felixfbecker.php-debug" rel="external nofollow noopener noreferrer" target="_blank">PHP Debug</a> - 讓 VS Code 可以進行 PHP 的 Debug</li></ul><p>下載好且安裝成功後重啟 VS Code，開始進行設定。</p><h3 id="Step-2-設定-PHP-Debug-與-MAMP-上的-PHP"><a href="#Step-2-設定-PHP-Debug-與-MAMP-上的-PHP" class="headerlink" title="Step.2 設定 PHP Debug 與 MAMP 上的 PHP"></a>Step.2 設定 PHP Debug 與 MAMP 上的 PHP</h3><p>隨便開一個空的 php ，並且在裡面寫上<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php   </span><br><span class="line"> phpinfo();  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p></p><p>進入到這個網頁，會看到這個畫面。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*HuZ7pDkKHjVAA5jhtu3A7w.png" alt></p><p>接著對著這個畫面直接全選複製 (Ctrl + A)</p><p>並且到 PHP Debug 的 <a href="https://xdebug.org/wizard.php" rel="external nofollow noopener noreferrer" target="_blank">XDebug installation wizard</a> 貼上。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*U-sOC1LnLp1cLg2Ue0e3FQ.png" alt></p><p>按下按鈕，讓程式偵測還需要設定什麼。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*5BiFT3CmKzPAxJ2cn9Mblw.png" alt></p><p>很顯然的必須照著這些步驟去做，分別是</p><ol><li>下載系統指定的檔案</li><li>放到它指定的路徑</li><li>打開指定路徑內的 php.ini 並且在最下方新增對應的路徑</li><li>[<strong>重點</strong>]程式這邊沒有提到，還需要在 php.ini 內新增這一段才能正確使用 PHP Debug ，因此須在 php.ini 內新增如下內容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zend_extension = C:\MAMP\bin\php\php7.2.10\ext\php_xdebug-2.7.0-7.2-vc15.dll</span><br><span class="line"></span><br><span class="line">[XDebug]  </span><br><span class="line">xdebug.remote_enable = 1  </span><br><span class="line">xdebug.remote_autostart = 1</span><br></pre></td></tr></table></figure></li></ol><p>存檔後重啟 MAMP ，另外路徑可能會有不同，適當做調整即可。</p><p>到這邊 PHP Debug 與 MAMP 的設定就結束了，不過還沒完，還有 VS Code的部份需要調整呢！</p><h3 id="Step-3-設定-VS-Code"><a href="#Step-3-設定-VS-Code" class="headerlink" title="Step.3 設定 VS Code"></a>Step.3 設定 VS Code</h3><p>打開 VS Code -&gt; 設定 - &gt; 搜尋設定 -&gt; 輸入 PHP</p><p><img src="https://cdn-images-1.medium.com/max/800/1*3Lui5G_Wk-xtjM3DR8avdg.png" alt></p><p>點擊「在 settings.json 內編輯」，然後順著裡面的格式補上這一段：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*JkUL05koY3nLPMPzEPDWMg.png" alt></p><p>後面的路徑也需要配合實際檔案位置作調整，儲存後就可以關閉囉。</p><p>至此，設定就全數完成囉，來使用看看吧！</p><h3 id="Step-4-使用-PHP-Debug"><a href="#Step-4-使用-PHP-Debug" class="headerlink" title="Step.4 使用 PHP Debug"></a>Step.4 使用 PHP Debug</h3><p>首先我們可以在寫好的程式上加入紅色的中斷點</p><p><img src="https://cdn-images-1.medium.com/max/800/1*o8pGrltegafNUCMlM7okAQ.png" alt></p><p>接著打開 VS Code 左手邊的偵錯工具，選擇「Listen for XDebug」，並且按下綠色的三角型播放鈕，開始偵錯。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*FVRHMwnEbdtEdyo7Bd5Qhw.png" alt></p><p>接下來可以切換到這支 php 網頁，實際運行看看。</p><p>會發現程式將停在我們設置的中斷點上，等待操作。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*_44z2vDbsYQ_VMIr3F73Bw.png" alt></p><p>此時因為尚未進入 <code>$foo = 1</code> ，因此 <code>$foo</code> 還是 <code>uninitialized</code> 的狀態，接著可以按下上方的逐步執行，觀察變化藉此除錯。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*7LMmDJBuJb0A9PK1bDraow.png" alt></p><blockquote><p>太棒啦~到這邊終於可以開始寫 PHP 了。</p></blockquote><h2 id="Composer-套件管理"><a href="#Composer-套件管理" class="headerlink" title="Composer 套件管理"></a>Composer 套件管理</h2><p>在前端常見的套件管理常常聽到「NPM」、「Yarn」之類的，然而在 PHP 也有類似的套件管理工具哦，那就是 Composer 。</p><p>根據作業系統不同有不一樣的安裝方法，我是 Windows 系統。</p><ul><li><a href="https://getcomposer.org/download/" rel="external nofollow noopener noreferrer" target="_blank">到官方下載安裝檔</a></li></ul><p>安裝過程中會有這個畫面</p><p><img src="https://cdn-images-1.medium.com/max/800/1*3OaC_9bTONMHM4hx_Vp6kg.png" alt></p><p>在這邊要選擇目前執行的是哪個版本的 PHP ，預設會是空白的，要自己點擊 Browse… 去尋找。</p><p>之後就一直按下一步維持預設值就行了。</p><h3 id="如何測試-Composer-有沒有安裝好"><a href="#如何測試-Composer-有沒有安裝好" class="headerlink" title="如何測試 Composer 有沒有安裝好"></a>如何測試 Composer 有沒有安裝好</h3><p>打開命令提示字元 (cmd) ，輸入 <code>composer</code> 看到以下畫面代表安裝成功。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*utMFT2DoSdtUd9DFQWR66Q.png" alt></p><h3 id="在-VS-Code-內實際使用看看吧"><a href="#在-VS-Code-內實際使用看看吧" class="headerlink" title="在 VS Code 內實際使用看看吧"></a>在 VS Code 內實際使用看看吧</h3><p>試著下載 kint-php/kint 這個套件，在 VS Code 內的終端機輸入指令即可。</p><p>關於這個套件的敘述：</p><ul><li><a href="https://github.com/kint-php/kint" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kint-php/kint</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require kint-php/kint</span><br></pre></td></tr></table></figure><p>接著會發現專案資料夾內多了這些檔案：</p><ul><li>vender 資料夾</li><li>composer.json</li><li>composer.lock</li></ul><p>最後在 php 檔案中引入即可使用囉！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require &apos;vendor/autoload.php&apos;;  </span><br><span class="line">$foo = \[1,2,3\];  </span><br><span class="line">d($foo);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*P5B8o4cUVQqo2BsxPJWdcg.png" alt></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>後端真的很坑啊，真心不騙。</p><p>PHP 對 MySQL 的資料庫連線我還有得撞牆呢…OTZ</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      正當我興高采烈的想說 MySQL 的環境都設定好、前端版型也都 OK 了，該是來好好的學習一下 PHP 了。這時才發現，PHP 的 Debug 環境需要特別去設定，不像 JavaScript 這麼佛心只要打開 chrome 就能除錯，又撞牆了好一陣，終於把開發環境都建立起來了。
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
      <category term="PHP" scheme="http://pvt5r486.github.io/tags/PHP/"/>
    
      <category term="VS Code" scheme="http://pvt5r486.github.io/tags/VS-Code/"/>
    
      <category term="Composer" scheme="http://pvt5r486.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>[初探後端]No.1 MySQL Workbench 同步到 MAMP 的 MySQL Server</title>
    <link href="http://pvt5r486.github.io/b2e/20190401/1024411092/"/>
    <id>http://pvt5r486.github.io/b2e/20190401/1024411092/</id>
    <published>2019-04-01T03:00:31.000Z</published>
    <updated>2019-05-21T11:02:32.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好不容易搞定 TodoList 前端部份，接著就是後端了。後端的部份我想使用 PHP + MySQL 來處理，但是這部份我幾乎完全沒有概念，到處碰壁，所以想要好好的記錄一下今天做了哪些事。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*ihjZwIp5DeCF9EeW" alt></p><h2 id="Workbench-是什麼"><a href="#Workbench-是什麼" class="headerlink" title="Workbench 是什麼"></a>Workbench 是什麼</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/MySQL_Workbench" rel="external nofollow noopener noreferrer" target="_blank"><strong>引用 WIKI 百科的解釋</strong></a> - MySQL Workbench 是一款資料庫設計和建模工具，專門為 MySQL 設計。</p></blockquote><p>而我實際操作起來的感受的確也是這樣，我們可以在上面規劃、管理資料庫，最後再利用同步的功能將我們在上面設計的東西推到資料庫上，過程中一行程式碼都不用打，因為都幫我們處理好了。</p><p>這感覺就好像，Workbench 是用來跟 MySQL 溝通的橋梁?</p><blockquote><p>也因為 Workbench 會自動生成對應的 MySQL 語法，因此 Workbench 內 Preferences 的 MySQL 版本以及目標的 MySQL Server 版本就很重要。</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*BdIhShaJxGuISqEsJOefgg.png" alt="MySQL Workbench 8.0 CE"></p><h2 id="MAMP-是什麼"><a href="#MAMP-是什麼" class="headerlink" title="MAMP 是什麼"></a>MAMP 是什麼</h2><p>簡單來說它就是一個初學者用的東西，因為幾乎不需要額外設定什麼就能使用，很適合一開始要接觸後端的人。</p><p>裝好大概長這樣，沒有什麼很複雜的設定。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*bOG-WXO6tD5fwQDsuFpdcQ.png" alt></p><h2 id="Workbench-同步到-MAMP-的-MySQL-Server"><a href="#Workbench-同步到-MAMP-的-MySQL-Server" class="headerlink" title="Workbench 同步到 MAMP 的 MySQL Server"></a>Workbench 同步到 MAMP 的 MySQL Server</h2><p>首先我們要準備一份 Models ，這是等等要同步到 MySQL Server 的東西。不過這部份就不是本篇文章的重點，就不贅述了。</p><h3 id="Step-1-設定-Workbench-上的-MySQL-Connections"><a href="#Step-1-設定-Workbench-上的-MySQL-Connections" class="headerlink" title="Step.1 設定 Workbench 上的 MySQL Connections"></a>Step.1 設定 Workbench 上的 MySQL Connections</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*nwNAYSFbNHLik0HdctD85w.png" alt="Workbench 上的 MySQL Connections"></p><p>目標是連到 MAMP 上的 MySQL**</p><ul><li>按下左下角的 New 新增一個連線</li><li>連線方式選 TCP / IP</li><li>Hostname 就是 127.0.0.1 (localhost)</li><li>Port 的部份就要看 MAMP 上 MySQL 使用的 Port 是多少而定</li><li>最後按下 Test Connection ，請確認 MAMP 上的 MySQL Server 有運行，否則會失敗，接著應該會要輸入密碼，預設值是 root 。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*aRfyiuM5k6-vN3bR85fkPg.png" alt="MAMP 上 MySQL 使用的 Port (每台電腦不盡相同)"></p><h3 id="Step-2-設定-Workbench-上指定的-MySQL-版本"><a href="#Step-2-設定-Workbench-上指定的-MySQL-版本" class="headerlink" title="Step.2 設定 Workbench 上指定的 MySQL 版本"></a>Step.2 設定 Workbench 上指定的 MySQL 版本</h3><p>這個步驟相當重要，就是因為這個步驟害我卡住…。</p><blockquote><p>原因是我下載的這個 Workbench 是 8.0 版本，裡面預設是較高版本的 MySQL ，因此 Workbench 自動生成的 MySQL 語法自然也是較高版本的。</p></blockquote><p>而 MAMP 上的 MySQL Server 版本是 5.7.24 ，自然不能相容較高版本，因此若沒有先行設定這邊，後面同步的操作可能會失敗，所以在這邊必須要先進行調整。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PofnqShCTMuXIfydomQLJQ.png" alt="MAMP 上的 MySQL Server"></p><p><img src="https://cdn-images-1.medium.com/max/800/1*MT_b5GczGLS2rywDzvLzMg.png" alt="設定 Workbench 上指定的 MySQL 版本"></p><p>最坑的莫過於指定 MySQL 版本居然不是做成下拉式選單，必須自己把版本輸入正確，輸入錯誤框框會反紅表示。</p><h3 id="Step-3-打開-Model-開始同步吧"><a href="#Step-3-打開-Model-開始同步吧" class="headerlink" title="Step.3 打開 Model 開始同步吧"></a>Step.3 打開 Model 開始同步吧</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*EHqrwe41UYR-kQfNDWdpCQ.png" alt></p><ul><li>接著應該會看到這個畫面，不過我們都設定完了，直接按下一步。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*c1zpICyKFk8ppcbSiStD0g.png" alt></p><ul><li>之後會連續按好幾個下一步，初學嘛…基本上暫時維持預設值就好。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*r6tHlKZ6z7gy6NRq6dKR4Q.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*k2bgfVTbyWk2BtOmNnSaqg.png" alt="寫文之前就做過了，所以沒有 Update"></p><blockquote><p>基本上如果前面有設定好的話，這邊就是一直 Next ，然後調整一下是哪邊要 Update 到哪邊，這樣就結束了。</p></blockquote><h3 id="Step-4-用-Workbench-連線到-MySQL-Server-看看內容"><a href="#Step-4-用-Workbench-連線到-MySQL-Server-看看內容" class="headerlink" title="Step.4 用 Workbench 連線到 MySQL Server 看看內容"></a>Step.4 用 Workbench 連線到 MySQL Server 看看內容</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*egaBkLyoNTHMHQMR2eR_vA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*Dx5o9lZQKjIxgrVi3rVkGQ.png" alt></p><p>嗯~看起來都有呢，真棒！</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>希望透過這樣的整理可以幫助到比我更菜的人，不會因為找到的文章都是一些艱深難懂的名詞而放棄學習。而我也可以透過這樣的方式加深自己的印象。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      好不容易搞定 TodoList 前端部份，接著就是後端了。後端的部份我想使用 PHP + MySQL 來處理，但是這部份我幾乎完全沒有概念，所以到處碰壁，所以想要好好的記錄一下今天做了哪些事。
    
    </summary>
    
      <category term="後端學習" scheme="http://pvt5r486.github.io/categories/b2e/"/>
    
    
      <category term="MySQL" scheme="http://pvt5r486.github.io/tags/MySQL/"/>
    
      <category term="MAMP" scheme="http://pvt5r486.github.io/tags/MAMP/"/>
    
  </entry>
  
  <entry>
    <title>自己對冒泡事件的誤解</title>
    <link href="http://pvt5r486.github.io/uncategorized/20190330/2715926777/"/>
    <id>http://pvt5r486.github.io/uncategorized/20190330/2715926777/</id>
    <published>2019-03-30T06:11:29.000Z</published>
    <updated>2020-03-06T07:57:25.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正著手往全端的技能樹點，然而又重新做了一份 TodoList 的練習，然後因為對冒泡事件的誤解，因此決定寫下來。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Jjq7EJMoU1iY6jua" alt></p><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><ul><li><a href="https://codepen.io/pvt5r486/pen/KYPRYZ?fbclid=IwAR1UlirCK1nRx53KRt9M-olreonixPrkGaShY81D9xbtnTS9DLPYMmTARus" rel="external nofollow noopener noreferrer" target="_blank">TodoList</a></li></ul><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>點擊 label 與 checkbox 時，會切換 complete 的狀態，但在 li 上有個雙擊事件，我不希望在快速切換 complete 狀態時會觸發雙擊的事件。</p><p>因此我最初的想法是「<strong>可能是因為冒泡事件導致的</strong>」，畢竟點擊的是包覆在 li 內的 label 與 checkbox 。</p><p>於是我在 complete 狀態切換的事件上加入 <code>e.stopPropagation();</code> 但是沒有效果。</p><h2 id="驗證與結果"><a href="#驗證與結果" class="headerlink" title="驗證與結果"></a>驗證與結果</h2><p>正當我不理解為何阻止冒泡事件不起作用時，我動手寫了個簡單的小範例，驗證自己的想法有沒有錯誤。</p><ul><li><a href="https://codepen.io/pvt5r486/pen/jRNXOq?fbclid=IwAR049000nSXifFMOL20WUIFNxmBYFY3Hq7Qge9eaCDUkRhcnmk7HLKXtWfw" rel="external nofollow noopener noreferrer" target="_blank">驗證冒泡事件</a></li></ul><blockquote><p><strong>神奇的事情發生了，果然就是我誤會它了…。</strong></p></blockquote><h2 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h2><ul><li>阻止冒泡事件僅限於同一種類型的事件，如範例中的 .box 與 body 若同樣都是 click 事件，那麼阻止冒泡事件就能發揮作用</li><li>然而不同類型的事件是無效的，如果將 body 改成雙擊事件觸發，那麼就算阻止了冒泡事件，還是會因為 body 被雙擊而觸發事件</li></ul><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>最後我在雙擊的事件中補上判斷，當雙擊的目標是 label 或 checkbox 就離開雙擊事件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(e.target.nodeName === &apos;INPUT&apos; || e.target.nodeName === &apos;LABEL&apos;) &#123; return &#125;;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      最近正著手往全端的技能樹點，然而又重新做了一份 TodoList 的練習，然後因為對冒泡事件的誤解，因此決定寫下來。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.76 觀察 jQuery 架構然後動手做一個簡易 library (二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190326/2856162764/"/>
    <id>http://pvt5r486.github.io/f2e/20190326/2856162764/</id>
    <published>2019-03-25T22:58:53.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一篇就是 JavaScript Weird 系列的最後一節了，接下來我們將繼續完成上一節沒有完成的部分～並且做一個很陽春的介面，選擇語言後按下按鈕就呈現對應的打招呼語句。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*3EAyjczLUDnxAizV" alt></p><p>繼續下個步驟之前，要先幫一個地方補上上一節寫好的驗證，這樣就能在一開始使用時就檢查出有沒有支援這個語系。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*V_BDe3mi3iQEX2NRmQZeAQ.png" alt></p><h2 id="STEP-4-做一個陽春的介面"><a href="#STEP-4-做一個陽春的介面" class="headerlink" title="STEP 4. 做一個陽春的介面"></a>STEP 4. 做一個陽春的介面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;loginblock&quot;&gt;  </span><br><span class="line">  &lt;select name=&quot;selectLang&quot; id=&quot;selectLang&quot;&gt;  </span><br><span class="line">    &lt;option value=&quot;TW&quot;&gt;繁體中文&lt;/option&gt;  </span><br><span class="line">    &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;  </span><br><span class="line">  &lt;/select&gt;  </span><br><span class="line">  &lt;button class=&quot;loginbtn&quot;&gt;登入&lt;/button&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">&lt;h1 id=&quot;sayHello&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h2 id="STEP-5-在-library-內使用-jQuery"><a href="#STEP-5-在-library-內使用-jQuery" class="headerlink" title="STEP 5. 在 library 內使用 jQuery"></a>STEP 5. 在 library 內使用 jQuery</h2><p>我們要將結果輸出到網頁上，這部分除了使用 jQuery 之外當然也可以透過原生 JavaScript 來達成，不過本次的目標是使用 jQuery。</p><p>在原型下新增這個方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTMLSayHello(selector)&#123;  </span><br><span class="line">  if (!$)&#123; throw &apos;沒有載入 jQuery！&apos;&#125;  </span><br><span class="line">  if (!selector)&#123; throw &apos;沒有找到 selector&apos;&#125;  </span><br><span class="line">  $(selector).html(this.hello());  </span><br><span class="line">  return this;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="STEP-6-都完成了！使用看看吧"><a href="#STEP-6-都完成了！使用看看吧" class="headerlink" title="STEP 6. 都完成了！使用看看吧"></a>STEP 6. 都完成了！使用看看吧</h2><p>接著我們就來使用看看吧，順便測試一下鏈式寫法</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gnrubS469e6rVC9zahOlKQ.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*ZVO9YVqCmsSsk8_pTl7dpw.png" alt></p><p>很順利的成功了~這樣我們就完成了一個非常陽春的 library ，當然還有很多細節沒有處理，不過這不是本次的目的。</p><p>本次的目的是在於</p><ul><li>研究 jQuery 並嘗試模仿一些好的技巧、架構</li><li>試著看開放原始碼不要抗拒它。</li></ul><h2 id="完坑心得"><a href="#完坑心得" class="headerlink" title="完坑心得"></a>完坑心得</h2><p>最後，JavaScript Weird 部分也結束了，沒想到我居然可以堅持這麼久，莫名的有成就感，總算是填坑完成啦！</p><p>透過寫作也間接強化了對 JavaScript 底層觀念的認知，甚至我連支線都一起寫進去了，這一切感覺起來是這麼的不真實。</p><p>翻著這些文章，想著原來這段時間我學了這麼多東西，這應該也是另類的學習歷程吧?</p><p>接下來的目標會放在接觸後端上，畢竟想在高雄求職似乎也會要求後端，所以大致上會以 PHP Laravel 為新坑目標～</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這一篇就是 JavaScript Weird 系列的最後一節了，接下來我們將繼續完成上一節沒有完成的部分～並且做一個很陽春的介面，選擇語言後按下按鈕就呈現對應的打招呼語句。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.75 觀察 jQuery 架構然後動手做一個簡易 library (一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190326/4107907530/"/>
    <id>http://pvt5r486.github.io/f2e/20190326/4107907530/</id>
    <published>2019-03-25T18:33:50.000Z</published>
    <updated>2020-02-16T05:58:30.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我跳過蠻多小節的，因為看起來沒什麼好紀錄的，這篇主要是紀錄看了 jQuery 的原始碼後，可以從中學習的技巧，以及綜合練習之前觀念。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*xllXzqosxRKyO3Ee" alt></p><h2 id="觀察-jQuery-並實際應用在-簡易-Library"><a href="#觀察-jQuery-並實際應用在-簡易-Library" class="headerlink" title="觀察 jQuery 並實際應用在 簡易 Library"></a>觀察 jQuery 並實際應用在 簡易 Library</h2><ul><li>用 IIFE 建立安全的執行環境，避免干擾</li><li>回傳時補上 new ，讓實例化時不需要再補上 new</li><li>將方法新增在原型上</li><li>讓方法實現鏈式操作</li><li>像 jQuery 一樣使用 $ 當成別名，不過這裡是使用 S$</li><li>在 library 內使用另一個 library</li></ul><p>大致上是這樣，那就讓我們開始吧。</p><h3 id="Step-1-確保-library-是安全的"><a href="#Step-1-確保-library-是安全的" class="headerlink" title="Step 1. 確保 library 是安全的"></a>Step 1. 確保 library 是安全的</h3><ul><li>這邊會使用 IIFE 包住整個程式碼，避免不同的 JavaScript 檔案影響到運作</li><li>接著傳入全域物件 <code>window</code> 、 <code>jQuery</code> (之後會用到)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(global, $)&#123;</span><br><span class="line"></span><br><span class="line">&#125;)(window, jQuery);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Step-2-建立基本架構"><a href="#Step-2-建立基本架構" class="headerlink" title="Step 2. 建立基本架構"></a>Step 2. 建立基本架構</h3><ul><li><p>建立 constructor 內容，並且在回傳時補上 new</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function(global, $)&#123;  </span><br><span class="line">  let sayHelloer = function(firstName, lastName, lang)&#123;  </span><br><span class="line">    return new sayHelloer.init(firstName, lastName, lang);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // constructor  </span><br><span class="line">  sayHelloer.init = function(firstName, lastName, lang)&#123;  </span><br><span class="line">    this.firstName = firstName || &apos;&apos;;  </span><br><span class="line">    this.lastName = lastName || &apos;&apos;;  </span><br><span class="line">    this.lang = lang || &apos;TW&apos;;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure></li><li><p>設置要加入到 prototype 的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHelloer.prototype = &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>設置原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHelloer.init.prototype = sayHelloer.prototype;</span><br></pre></td></tr></table></figure></li><li><p>設置外部如何取用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.S$ = global.sayHelloer = sayHelloer;</span><br></pre></td></tr></table></figure></li></ul><p>這樣外部就可以使用 <code>S$</code> 或是 <code>sayHelloer</code> 呼叫方法囉。</p><p>於是這一步驟的程式碼整理如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function(global, $)&#123;  </span><br><span class="line">  let sayHelloer = function(firstName, lastName, lang)&#123;  </span><br><span class="line">    return new sayHelloer.init(firstName, lastName, lang);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">　// constructor  </span><br><span class="line">  sayHelloer.init = function(firstName, lastName, lang)&#123;  </span><br><span class="line">    this.firstName = firstName || &apos;&apos;;  </span><br><span class="line">    this.lastName = lastName || &apos;&apos;;  </span><br><span class="line">    this.lang = lang || &apos;TW&apos;;  </span><br><span class="line">  &#125;  </span><br><span class="line">  sayHelloer.prototype = &#123;&#125;  </span><br><span class="line">  sayHelloer.init.prototype = sayHelloer.prototype;  </span><br><span class="line">  global.S$ = global.sayHelloer = sayHelloer;</span><br><span class="line"></span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure><p></p><p>運行並且試著印出來<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = S$(&apos;小明&apos;,&apos;王&apos;,&apos;TW&apos;);  </span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*5z9cuHVvgV-f7qUT1uH8dw.png" alt="雛形"></p><h3 id="Step-3-根據需求寫方法"><a href="#Step-3-根據需求寫方法" class="headerlink" title="Step 3. 根據需求寫方法"></a>Step 3. 根據需求寫方法</h3><p>這個 library 是拿來打招呼用的，所以大致擬訂一下需求：</p><ul><li>根據語系切換打招呼內容</li><li>驗證有沒有支援這個語系</li><li>可以直接切換語系，改變打招呼內容</li><li><strong><code>return this</code></strong> 實現鏈式寫法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 要加入至 prototype 的方法  </span><br><span class="line">  sayHelloer.prototype = &#123;  </span><br><span class="line">    fullName: function()&#123;  </span><br><span class="line">      return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    hello: function()&#123;  </span><br><span class="line">      return `$&#123;saySomething[this.lang]&#125; $&#123;this.firstName&#125; !`  </span><br><span class="line">    &#125;,  </span><br><span class="line">    vaild: function()&#123;  </span><br><span class="line">      if(langArray.indexOf(this.lang) === -1)&#123;  </span><br><span class="line">        throw &apos;未支援的語言！&apos;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    setLang: function(lang)&#123;  </span><br><span class="line">      this.lang = lang;  </span><br><span class="line">      this.vaild();  </span><br><span class="line">      return this;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    sayHello: function()&#123;  </span><br><span class="line">      let msg = this.hello();  </span><br><span class="line">      if (console)&#123;  </span><br><span class="line">        console.log(msg);  </span><br><span class="line">      &#125;  </span><br><span class="line">      return this;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>因為我們之前有 <code>return new</code> 的技巧，所以這邊不需要使用 <code>new</code> 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = S$(&apos;小明&apos;,&apos;王&apos;,&apos;TW&apos;);  </span><br><span class="line">console.log(s);  </span><br><span class="line">console.log(s.fullName());  </span><br><span class="line">s.sayHello().setLang(&apos;es&apos;).sayHello();</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*BAY19KBr19ElBUbX-hzYPA.png" alt></p><p>至此，大致上就快完成了，不過還剩下一些項目，我們將在下一節補齊。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我跳過蠻多小節的，因為看起來沒什麼好紀錄的，這篇主要是紀錄看了 jQuery 的原始碼後，可以從中學習的技巧，以及綜合練習之前觀念。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.74 Strict mode 嚴謹模式</title>
    <link href="http://pvt5r486.github.io/f2e/20190325/1527136485/"/>
    <id>http://pvt5r486.github.io/f2e/20190325/1527136485/</id>
    <published>2019-03-24T22:48:20.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好的，終於又回到主線了，趕緊把這個坑填好。這篇主要是介紹關於 JavaScript 的嚴謹模式 (Strict mode)，當開啟這個模式後，JavaScript 的部分行為就會比較不一樣了，就讓我們一塊來看看吧。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*GGBfBqR4xETznBxS" alt></p><h2 id="嚴謹模式-Strict-mode"><a href="#嚴謹模式-Strict-mode" class="headerlink" title="嚴謹模式 (Strict mode)"></a>嚴謹模式 (Strict mode)</h2><p>JavaScript 的特性就是比較彈性自由，但為人詬病的也是因為太過彈性自由導致缺乏規範，讓沒有經驗的開發者很容易就寫出預料外的 BUG。</p><p>而嚴謹模式就是在告訴 JavaScript 要用比較多的規範、限制來編譯這些程式碼，雖然這沒辦法完全改變 JavaScript 過於自由的問題，但還是幫助我們避免一些奇怪的錯誤。</p><ul><li>例如<strong>變數打錯字</strong>的問題<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person;  </span><br><span class="line">persom = &#123;&#125;;  </span><br><span class="line">console.log(persom);</span><br></pre></td></tr></table></figure></li></ul><p>像是把 <code>person</code> 打成 <code>persom</code> 的錯誤， JavaScript 會認為這是對的。</p><p>而這麼做不會錯誤的原因是，JavaScript 把 <code>persom</code> 設定為 全域 <code>window</code> 物件內的屬性，顯然地這並不是我們所預想的樣子。</p><p>因此我們需要告訴 JavaScript 打開<strong>嚴謹模式</strong>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">var person;  </span><br><span class="line">persom = &#123;&#125;;  </span><br><span class="line">console.log(persom);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*IfzO_NNCrQDKoY4ylbXObQ.png" alt></p><p>當然嚴謹模式能做的不只這些，更多<strong>特性</strong>可以到 MDN 的文件查看：</p><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode" rel="external nofollow noopener noreferrer" target="_blank">Strict mode</a></li></ul><h3 id="全域、個別使用嚴謹模式"><a href="#全域、個別使用嚴謹模式" class="headerlink" title="全域、個別使用嚴謹模式"></a>全域、個別使用嚴謹模式</h3><p>嚴謹模式允許<strong>全域使用</strong>以及<strong>個別地在函式</strong>使用，使用方法很簡單，就只需要在 JavaScript 檔案的第一行或者是在函式內的第一行內宣告使用即可。</p><h3 id="全域使用嚴謹模式"><a href="#全域使用嚴謹模式" class="headerlink" title="全域使用嚴謹模式"></a>全域使用嚴謹模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">var person;  </span><br><span class="line">persom = &#123;&#125;;  </span><br><span class="line">console.log(persom);</span><br></pre></td></tr></table></figure><h3 id="函式個別使用嚴謹模式"><a href="#函式個別使用嚴謹模式" class="headerlink" title="函式個別使用嚴謹模式"></a>函式個別使用嚴謹模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line"> &apos;use strict&apos;  </span><br><span class="line">  var person2;  </span><br><span class="line">  persom2 = &#123;&#125;;  </span><br><span class="line">  console.log(persom2);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person;  </span><br><span class="line">persom = &#123;&#125;;  </span><br><span class="line">console.log(persom);  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*zx-KzmVxKQY8OV84Qc1oGA.png" alt></p><h2 id="嚴謹模式似乎很少被使用"><a href="#嚴謹模式似乎很少被使用" class="headerlink" title="嚴謹模式似乎很少被使用"></a>嚴謹模式似乎很少被使用</h2><p>因為嚴謹模式並不是必要的，這只是一個額外的功能，而且並不是每個 JavaScript 引擎的嚴謹模式特性表現都一樣，因此在使用上會有比較多的限制。</p><p>但如果我們仍然希望讓 JavaScript 更嚴格，可以試著使用 ESlint 配合 TypeScript 讓程式碼的品質更上一層樓。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      好的，終於又回到主線了，趕緊把這個坑填好。這篇主要是介紹關於 JavaScript 的嚴謹模式 (Strict mode)，當開啟這個模式後，JavaScript 的部分行為就會比較不一樣了，就讓我們一塊來看看吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.73 學完物件導向後的 this (二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190324/3426590472/"/>
    <id>http://pvt5r486.github.io/f2e/20190324/3426590472/</id>
    <published>2019-03-23T19:49:44.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接續上一篇的 <code>this</code> ，我們將利用一種比較特別的方式來看 <code>this</code> 的值，以及介紹除了 <code>call()</code> 、<code>apply()</code> 之外還可以使用 <code>bind()</code> 強制綁定 <code>this</code> ，最後將提到 <code>this</code> 在箭頭函式下的特性。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*6P_kzNSY9Zom2F90" alt></p><h2 id="用另一種角度看-this-的值"><a href="#用另一種角度看-this-的值" class="headerlink" title="用另一種角度看 this 的值"></a>用另一種角度看 this 的值</h2><p>上一節提到 <code>this</code> 基本只有在跟物件導向扯上關係的時候才有意義。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  test: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p></p><p>而這個例子的輸出結果 <code>this</code> 指向的是 <code>obj</code> 。</p><blockquote><p>有沒有發現幾乎每次 <code>this</code> 有改變的時候都是 <code>ooo.xxx()</code> 之類的呼叫方式</p></blockquote><h2 id="this-的值與在哪邊呼叫函式、實際上寫在哪無關"><a href="#this-的值與在哪邊呼叫函式、實際上寫在哪無關" class="headerlink" title="this 的值與在哪邊呼叫函式、實際上寫在哪無關"></a>this 的值與在哪邊呼叫函式、實際上寫在哪無關</h2><ul><li>真正有關係的是，<strong>如何去呼叫它</strong></li></ul><p>同一個例子<strong>換個方式改寫</strong>結果就不同了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  test: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = obj.test;  </span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p></p><p>這個例子就是在說，明明是同樣的輸出結果，但只要改變了呼叫的方式， <code>this</code> 就不一樣了。</p><p><strong>是不是覺得要判斷 this 值是什麼有點困難？</strong></p><p>可以試著帶入 <code>call()</code> 的方式去想！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  test: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(這不是可以實際執行的 code )  </span><br><span class="line">obj.test(); =&gt; obj.test.call(obj)</span><br></pre></td></tr></table></figure><p></p><p><strong>透過帶入 call() 的方式去想將有助於理解 this 的值是什麼。</strong></p><p>以 <code>obj.test()</code> 來說，可以想像成在 <code>obj.test()</code> 後面補上 <code>call()</code> 並且填入呼叫 <code>test()</code> 之前的內容，就是 <code>this</code> 指向的地方。</p><p><strong>在來個例子</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  inner: &#123;  </span><br><span class="line">    test: function()&#123;  </span><br><span class="line">      console.log(this);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">(這不是可以實際執行的 code )  </span><br><span class="line">obj.inner.test() =&gt; obj.inner.test.call(obj.inner)</span><br></pre></td></tr></table></figure><p></p><p>一樣使用上面提到的方式去判斷，因此可以得知結果的 <code>this</code> 會指向 <code>obj.inner</code> 。</p><p><strong>所以現在就可以了解，第一個例子為什麼換個方式改寫輸出會是 undefined 了。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  test: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var func = obj.test;</span><br><span class="line"></span><br><span class="line">(這不是可以實際執行的 code )  </span><br><span class="line">func() =&gt; func.call(undefined)</span><br></pre></td></tr></table></figure><p></p><ul><li>因為 func 前面沒有任何東西可以放入 <code>call()</code> ，所以會指向 <code>undefined</code></li></ul><h2 id="做點小練習題複習一下-this-吧"><a href="#做點小練習題複習一下-this-吧" class="headerlink" title="做點小練習題複習一下 this 吧"></a>做點小練習題複習一下 <code>this</code> 吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function log() &#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &#123; a: 1, log: log &#125;;  </span><br><span class="line">var b = &#123; a: 2, log: log &#125;;</span><br><span class="line"></span><br><span class="line">log(); // 全域 window  </span><br><span class="line">a.log(); // a</span><br><span class="line"></span><br><span class="line">b.log.apply(a) // a</span><br></pre></td></tr></table></figure><h2 id="bind-讓-this-從此乖乖的"><a href="#bind-讓-this-從此乖乖的" class="headerlink" title="bind() 讓 this 從此乖乖的"></a>bind() 讓 this 從此乖乖的</h2><p>上一節介紹的 c<code>all()</code> 、 <code>apply()</code> 主要是呼叫該函式，並指定 <code>this</code> 值的指向。但是 <code>bind()</code>並不一樣：</p><ul><li><code>bind()</code> 會<strong>回傳一個一模一樣的函式，並且將 this 值強制綁定</strong></li><li><p>而且沒有辦法透過 <code>call()</code> 、 <code>apply()</code> 改變 <code>this</code> 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  test: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bindTest = obj.test.bind(&apos;aaa&apos;);  </span><br><span class="line">bindTest(); // aaa  </span><br><span class="line">bindTest.call(&apos;qweqwe&apos;); // aaa</span><br></pre></td></tr></table></figure></li><li><p><code>bind()</code> 的用法其實跟前面兩個蠻接近的，第一個參數都是指定 <code>this</code></p></li></ul><h2 id="this-在箭頭函式下的特性"><a href="#this-在箭頭函式下的特性" class="headerlink" title="this 在箭頭函式下的特性"></a>this 在箭頭函式下的特性</h2><p>在介紹之前做個小練習<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;  </span><br><span class="line">  run()&#123;  </span><br><span class="line">    console.log(&apos;run this:&apos; ,this);  </span><br><span class="line">    setTimeout(function()&#123;  </span><br><span class="line">      console.log(this);  </span><br><span class="line">    &#125;,100)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t = new Test();  </span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p></p><p>輸出的 log 分別為：</p><ul><li>Test{}</li><li>全域 window 物件</li></ul><p>但如果將 setTimeout 內的函式改成箭頭函式呢?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;  </span><br><span class="line">  run()&#123;  </span><br><span class="line">    console.log(&apos;run this:&apos; ,this);  </span><br><span class="line">    setTimeout(() =&gt; &#123;  </span><br><span class="line">      console.log(this);  </span><br><span class="line">    &#125;,100)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t = new Test();  </span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*ZuDKy-jysJbrZdVG71yoLg.png" alt></p><p>答案就會很明顯的不一樣囉。</p><p>與 this 的特性相反</p><ul><li>this 取決於函式如何被呼叫</li></ul><p>但箭頭函式內的 <code>this</code></p><ul><li>跟函式怎麼被呼叫沒有關係</li><li>表現跟 <strong>scope 的行為</strong>比較類似，取決於箭頭函式寫在哪</li></ul><h2 id="回到例子"><a href="#回到例子" class="headerlink" title="回到例子"></a>回到例子</h2><p>箭頭函式內的 <code>this</code> 取決於被寫在哪，來決定 <code>this</code> 是什麼。</p><p>以這個例子來說，因為這個方法是這樣被呼叫的 <code>t.run()</code> ，所以 run 函式內的 <code>this</code> 會指向 <code>t</code> ，而同樣在 <code>run</code> 函式中的箭頭函式 <code>this</code> 也會跟著變成 <code>t</code> 。</p><p>而我們也可以透過這樣來觀察<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;  </span><br><span class="line">  run()&#123;  </span><br><span class="line">    console.log(&apos;run this:&apos; ,this);  </span><br><span class="line">    setTimeout(() =&gt; &#123;  </span><br><span class="line">      console.log(this);  </span><br><span class="line">    &#125;,100)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t = new Test();  </span><br><span class="line">t.run.call(456);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*rczYcNwkIwiP7Jx6KVcaHA.png" alt></p><p>當我們指定 <code>this</code> 後，也會連帶的影響到箭頭函式內的 <code>this</code> 。</p><p>也就是說箭頭函式內的 <code>this</code> <strong>會是在被定義時那個區域的 <code>this</code> 值</strong>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(&apos;first &apos;, this);  </span><br><span class="line">  let arr = \[&apos;apple&apos;, &apos;banana&apos;, &apos;lemon&apos;, &apos;apple&apos;, &apos;watermelon&apos;, &apos;grape&apos;\];  </span><br><span class="line">  let result = arr.filter((item, index, array) =&gt;&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    //console.log(item, index, array);  </span><br><span class="line">    return item;  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">test.call(&apos;aa&apos;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Cm5sb2HnNM3nWj24cSp7bw.png" alt></p><p>像是這個例子來說，如果沒有使用 <code>call()</code> 指定 <code>this</code> ，這邊印出的 <code>this</code> 值會全部都是全域 <code>window</code> ，但因為現在有指定 <code>this</code> ，所以全部都是 ‘aa’ 。</p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>總算是把支線部分全部都讀完了，真的是對我的 JavaScript 底層的理解相當的有幫助，並且也把一些在奇怪部分 (我以為我懂但其實沒有) 的觀念釐清，像是我很喜歡模仿 JavaScript 引擎、找作用域、從 ECMA 理解 hosting 那些方式，像是偵探在找線索般，一層層的往回推，最後就可以理解為什麼會是這樣。</p><blockquote><p>接下來就是把剩下的主線完成， JavaScript 的坑就算完成啦。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接續上一篇的 this ，我們將利用一種比較特別的方式來看 this 的值，以及介紹除了 call() 、 apply() 之外還可以使用 bind() 強制綁定 this ，最後將提到 this 在箭頭函式下的特性。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.72 學完物件導向後的 this (一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190323/3824948085/"/>
    <id>http://pvt5r486.github.io/f2e/20190323/3824948085/</id>
    <published>2019-03-22T18:47:37.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>結束物件導向的學習後，最後才介紹到 <code>this</code> ，這個安排是相當特別的。在奇怪部分時，記得是直接學習 <strong><code>this</code> 是什麼</strong>以及什麼樣的情況下 <strong><code>this</code> 是什麼值</strong>，而沒有認知到 <strong><code>this</code> 這個關鍵字是為了物件導向存在</strong>的。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*qsrpY_XRbIQV0CGF" alt></p><h2 id="this-的意義在哪"><a href="#this-的意義在哪" class="headerlink" title="this 的意義在哪"></a>this 的意義在哪</h2><p>了解物件導向的觀念之後， <code>this</code> 就不是那麼困難了，雖然在講解物件導向的觀念時已經有使用 <code>this</code> ，但應該不難猜出 <code>this</code> 是什麼意思。</p><blockquote><p><code>this</code> 在英文裡面是「<strong>這個</strong>」的意思</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*jG943Wj--_r7df2wNbTpXw.png" alt></p><p>而 <code>this</code> 是給物件導向觀念內使用的關鍵字，目的是「<strong>代替現在對應到的實例(instance)</strong>」。</p><p>在這個範例中有變數 <code>d</code> 與 <code>c</code> 分別指向的兩個物件實例，而 <code>dog</code> 類別內的 <code>howling</code> 方法，裡面會印出 <code>this.name</code> 的值。</p><p>意思就是<strong>不同實例呼叫這個方法時，因為 <code>this</code> 指向不同會有不同的結果</strong>。</p><blockquote><p>所以說在物件導向裡面， <code>this</code> 是相當有用而且必要的。</p></blockquote><h2 id="非物件導向的情況下使用-this"><a href="#非物件導向的情況下使用-this" class="headerlink" title="非物件導向的情況下使用 this"></a>非物件導向的情況下使用 this</h2><p>現在我們知道 <code>this</code> 大概是為了物件導向而存在，那如果在非物件導向的情況下使用會發生什麼事呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><p>在一般情況下 <code>this</code> 會指向全域的 <code>window</code> 物件，而在 node.js 會印出 <code>global</code> 。</p><p>但這樣的情形其實蠻奇怪的，因為 <code>this</code> 在這個範例中實際上應該沒有任何東西才是，為什麼會指向全域的 <code>window</code> 物件呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其實是因為 JavaScript 預設是一般模式，切換到**嚴謹模式**就不同了。</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;  // 使用嚴謹模式  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); // undefined</span><br></pre></td></tr></table></figure><p></p><p>這樣子的結果就合理多了。</p><h2 id="複雜一點的例子"><a href="#複雜一點的例子" class="headerlink" title="複雜一點的例子"></a>複雜一點的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  var a = 1;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">  inner();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); // undefined</span><br></pre></td></tr></table></figure><p>這樣也會是 <code>undefined</code></p><p><code>this</code> 基本上跟函式沒有什麼太大的關連，也就是說 <code>this</code> 在非物件導向的情況下基本都會是預設值，只有<strong>一個例外</strong>。</p><ul><li>操作 DOM 元素處理瀏覽器事件的時候<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.btn&apos;).addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>這個時候的 <code>this</code> 就會是使用者實際操作到的東西。</p><p>像是這個例子是 click， <code>this</code> 的內容就會是使用者在網頁上點選到的元素。</p><h3 id="控制-this"><a href="#控制-this" class="headerlink" title="控制 this"></a>控制 this</h3><p>之前在介紹 <code>new</code> 的行為時有用到 <code>call()</code> 的方法，其實除了這個方法外還有其他的方法可以改變 <code>this</code> 的指向，像是之前寫的：</p><ul><li><a href="https://pvt5r486.github.io/javascript/20190130/538224560">[JavaScriptWeird]No.38 call()、apply()、bind()</a></li></ul><p>因此這邊稍微複習一下 <code>call()</code> 與 <code>apply()</code> 不同的地方<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.call(123); // 傳入什麼 this 就是什麼</span><br><span class="line"></span><br><span class="line">apply() 也可以做到一樣的事情</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.apply(123); // 傳入什麼 this 就是什麼</span><br></pre></td></tr></table></figure><p></p><p><strong>而差別在於</strong></p><ul><li><code>call()</code> 能接受<strong>多個用逗號隔開的參數</strong></li><li><code>apply()</code> 只能接受<strong>兩個參數且第二個必須是陣列</strong>。</li></ul><p><strong>共同的目的</strong></p><ul><li>控制 <code>this</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;  </span><br><span class="line">function test(a,b,c)&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">  console.log(a,b,c);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.call(123, 1, 2, 3);  </span><br><span class="line">test.apply(123, [1, 2, 3]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>支線終於也到尾聲了，還真是不容易啊…寫筆記居然堅持了這麼久。<br>還剩下一點點，請務必堅持到最後！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      結束物件導向的學習後，最後才介紹到 this ，這個安排是相當特別的。在奇怪部分時，記得是直接學習 this 是什麼以及什麼樣的情況下 this 是什麼值，而沒有認知到 this 這個關鍵字是為了物件導向存在的。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.71 物件導向的繼承：Inheritance</title>
    <link href="http://pvt5r486.github.io/f2e/20190322/3057702415/"/>
    <id>http://pvt5r486.github.io/f2e/20190322/3057702415/</id>
    <published>2019-03-21T23:52:59.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解原型與原型鏈的關係之後，可以發現 JavaScript 就是利用這樣子的關係來產生繼承概念的，而在 ES6 之後也有更方便的做法。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*JZ28rmzW4hcRxd4Q" alt></p><h2 id="物件導向的繼承"><a href="#物件導向的繼承" class="headerlink" title="物件導向的繼承"></a>物件導向的繼承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class dog&#123;  </span><br><span class="line">  constructor(name)&#123;  </span><br><span class="line">    this.name = name;  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 狗的天生技能：會吠叫  </span><br><span class="line">  howling()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 大聲吠叫&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;狗&apos;);  </span><br><span class="line">d.howling();  </span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><p>像這樣，先設定出普通品種的狗，而且牠們都會叫。</p><h2 id="狗藉由不斷的繁殖、演化最後產生了超級狗！"><a href="#狗藉由不斷的繁殖、演化最後產生了超級狗！" class="headerlink" title="狗藉由不斷的繁殖、演化最後產生了超級狗！"></a>狗藉由不斷的繁殖、演化最後產生了超級狗！</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class superDog extends dog&#123;  </span><br><span class="line">  // 超級狗的天生技能：會轉圈  </span><br><span class="line">  turnAround()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 在原地轉了一圈&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var c = new superDog(&apos;超級狗&apos;);  </span><br><span class="line">c.howling();  </span><br><span class="line">c.turnAround();  </span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure><ul><li>這個部分使用了 <code>extends</code> 使 <code>superDog</code> 繼承 <code>dog</code></li><li>而因為 <code>superDog</code> 內沒有 <code>constructor</code> 函式，所以會向上層尋找 (dog) <code>constructor</code> 函式並執行</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*haRP4-uaVO26dVmn160_-w.png" alt></p><h2 id="為什麼要繼承呢"><a href="#為什麼要繼承呢" class="headerlink" title="為什麼要繼承呢"></a>為什麼要繼承呢</h2><p>因為有些時候會有一些共同的行為，這時候可以透過<strong>繼承</strong>的方式，這樣不用重新寫。</p><h2 id="繼承的覆寫"><a href="#繼承的覆寫" class="headerlink" title="繼承的覆寫"></a>繼承的覆寫</h2><p>我們希望超級狗在被建立的時候立刻使出吠叫技能，於是我們想到可以在 superDog 的 constructor 函式內進行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class superDog extends dog&#123;  </span><br><span class="line">  constructor()&#123;  </span><br><span class="line">    this.howling();  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 超級狗的天生技能：會轉圈  </span><br><span class="line">  turnAround()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 在原地轉了一圈&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;狗&apos;);  </span><br><span class="line">var c = new superDog(&apos;超級狗&apos;);</span><br></pre></td></tr></table></figure><p></p><p>但這麼寫馬上就遇到問題了。</p><p>因為在 <code>superDog</code> 的 <code>constructor</code> 函式內呼叫的是 <code>dog</code> 的 <code>howling</code> 函式，而在 <code>dog</code> 還沒執行 <code>constructor</code> 之前是不能使用的，因此會出現如下警告。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*o0YZ8upb79upAdj0NHvOkQ.png" alt></p><p>這時需要補上 <strong><code>super()</code></strong> ，意思就是<strong>先執行上一層的 <code>constructor</code> 函式</strong></p><p>因此修正如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class superDog extends dog&#123;  </span><br><span class="line">  constructor()&#123;  </span><br><span class="line">    super();  </span><br><span class="line">    this.howling();  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 超級狗的天生技能：會轉圈  </span><br><span class="line">  turnAround()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 在原地轉了一圈&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var d = new dog(&apos;狗&apos;);  </span><br><span class="line">var c = new superDog(&apos;超級狗&apos;);</span><br></pre></td></tr></table></figure><p></p><p>而因為已經於 <code>superDog</code> 內<strong>覆寫</strong>了 <code>constructor</code> ，必須透過 <code>super</code> 函式把 <code>name</code> 傳入 <code>dog</code> 內的 <code>constructor</code> ，否則會顯示 <code>undefined</code> ，故修正如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class superDog extends dog&#123;  </span><br><span class="line">  constructor(name)&#123;  </span><br><span class="line">    super(name); // dog 的 constructor(name)&#123;&#125;  </span><br><span class="line">    this.howling();  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 超級狗的天生技能：會轉圈  </span><br><span class="line">  turnAround()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 在原地轉了一圈&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var d = new dog(&apos;狗&apos;);  </span><br><span class="line">var c = new superDog(&apos;超級狗&apos;); // 超級狗 大聲吠叫</span><br></pre></td></tr></table></figure><p></p><p>或者是<strong>我們希望超級狗的吠叫可以再更強一點</strong>，於是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class dog&#123;  </span><br><span class="line">  constructor(name)&#123;  </span><br><span class="line">    this.name = name;  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 狗的天生技能：會吠叫  </span><br><span class="line">  howling()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 大聲吠叫&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class superDog extends dog&#123;  </span><br><span class="line">  // 超級狗的天生技能：會轉圈  </span><br><span class="line">  turnAround()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 在原地轉了一圈&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  // 覆寫 吠叫  </span><br><span class="line">  howling()&#123;  </span><br><span class="line">    console.log(this.name + &apos; 更大聲吠叫&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;狗&apos;);  </span><br><span class="line">d.howling();</span><br><span class="line"></span><br><span class="line">var c = new superDog(&apos;超級狗&apos;);  </span><br><span class="line">c.howling();  </span><br><span class="line">c.turnAround();  </span><br><span class="line">console.log(d);  </span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*4llQM_vz02f1W6OAnT1z-g.png" alt></p><blockquote><p>如此一來是不是很方便呢～至此物件導向的觀念就了解得差不多囉，接著最後要了解的就是 this 啦～</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      了解原型與原型鏈的關係之後，可以發現 JavaScript 就是利用這樣子的關係來產生繼承概念的，而在 ES6 之後也有更方便的做法。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.70 new 到底做了什麼事</title>
    <link href="http://pvt5r486.github.io/f2e/20190322/317251769/"/>
    <id>http://pvt5r486.github.io/f2e/20190322/317251769/</id>
    <published>2019-03-21T22:23:18.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所以我說那個 <code>new</code> 到底做了什麼事，為什麼一定要加上 <code>new</code> 呢？</p><p><img src="https://cdn-images-1.medium.com/max/800/0*5zmo6UvVLNxNmWWO" alt></p><h2 id="函式建構子-new-做了什麼"><a href="#函式建構子-new-做了什麼" class="headerlink" title="函式建構子 new 做了什麼"></a>函式建構子 new 做了什麼</h2><p>我們沿用前面的範例<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function dog(name)&#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.getName = function()&#123;  </span><br><span class="line">  return this.name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.sayHello = function()&#123;  </span><br><span class="line">  console.log(this.name + &apos; say Hello&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;abc&apos;);  </span><br><span class="line">d.sayHello();</span><br></pre></td></tr></table></figure><p></p><p>在了解 <code>new</code> 做了什麼之前，我們需要先喚醒另個世界線的知識</p><ul><li><a href="https://pvt5r486.github.io/javascript/20190130/538224560">[JavaScriptWeird]No.38 call()、apply()、bind()</a></li></ul><h3 id="new-在背後偷偷做的事"><a href="#new-在背後偷偷做的事" class="headerlink" title="new 在背後偷偷做的事"></a>new 在背後偷偷做的事</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*VPHuyS-C_39sutM4Ebmbug.png" alt></p><ul><li>1486 行宣告 <code>newDog</code> 函式，並允許帶入參數 <code>name</code></li><li>1487 行宣告 <code>obj</code> 變數並令其指向空物件</li><li>1488 行使用 <code>.call()</code> 方法執行 <code>dog</code> 函式，<strong>令其 <code>this</code> 改指向為 <code>obj</code> 所指向的物件</strong></li><li>1489 行令 <code>obj.__proto__ = dog.prototype;</code></li><li>1490 行回傳 <code>obj</code></li></ul><p>這段程式執行的結果與原本使用 <code>new</code> 的結果輸出如下</p><p><img src="https://cdn-images-1.medium.com/max/800/1*bAyOpPTae-5BxODhICdWSg.png" alt></p><p>由觀察得知，兩者是一模一樣的。</p><h3 id="透過觀察-new-實際上做了這些事"><a href="#透過觀察-new-實際上做了這些事" class="headerlink" title="透過觀察 new 實際上做了這些事"></a>透過觀察 new 實際上做了這些事</h3><ul><li>會產生新的物件，於最後回傳它</li><li>會使用 <code>.call()</code> 去呼叫 <code>constructor</code> 函式，並將 <code>this</code> 指向至新產生的物件</li><li>設定新物件的「<code>.__proto__</code>」使其對應至相應的 <code>.prototype</code></li></ul><p>以上就是用狗的範例來說明函式建構子 <code>new</code> 在背後偷偷做的事情了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      所以我說那個 new 到底做了什麼事，為什麼一定要加上 new 呢？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.69 從 prototype 來看「原型鏈」</title>
    <link href="http://pvt5r486.github.io/f2e/20190322/1786194055/"/>
    <id>http://pvt5r486.github.io/f2e/20190322/1786194055/</id>
    <published>2019-03-21T21:24:14.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們用上一節的範例來解釋什麼是 <strong>原型 (prototype)</strong> 與 <strong>原型鏈 (prototype chain)</strong>，然後也不難發現 JavaScript 很多底層的觀念都是鏈狀的。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*SJaw-TLfk2tiMun8" alt></p><h2 id="回顧上一節的-ES5-範例"><a href="#回顧上一節的-ES5-範例" class="headerlink" title="回顧上一節的 ES5 範例"></a>回顧上一節的 ES5 範例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function dog(name)&#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.getName = function()&#123;  </span><br><span class="line">  return this.name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.sayHello = function()&#123;  </span><br><span class="line">  console.log(this.name + &apos; say Hello&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;abc&apos;);  </span><br><span class="line">d.sayHello();  </span><br><span class="line">console.log(d.__proto__);</span><br></pre></td></tr></table></figure><p>上一節的內容中，我們知道只要於 <code>dog.prototype</code> 上新增方法，這樣之後透過 <code>new</code> 產生的 <code>dog</code> 物件都具有 <code>sayHello</code> 方法。</p><p>以這個例子來說，當我們印出 <code>d</code> 的內容時，可以發現當中有個隱藏的屬性「<code>.__proto__</code>」，也發現寫在 <code>dog.prototype</code> 上的方法在這邊出現了。</p><p><strong>甚至會發現怎麼點開了「.<strong>proto</strong>」裡面還有一個「.<strong>proto</strong>」？</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*eERzZjuPQ00yT28IwVFFBg.png" alt></p><h2 id="「-proto」"><a href="#「-proto」" class="headerlink" title="「.proto」"></a>「.<strong>proto</strong>」</h2><p>以這個例子白話的說，意思就是當在<strong>變數 <code>d</code> 指向的物件身上找不到對應的方法時</strong>，便從「<code>.__proto__</code>」內尋找有沒有對應的方法，聽起來是不是跟之前解釋的 ScopeChain 有點像呢。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... 省略 ...  </span><br><span class="line">console.log(d.__proto__ === dog.prototype); // true</span><br></pre></td></tr></table></figure><p></p><p>而使用三等號來比較的話，可以得知兩者是一樣的。</p><h2 id="當呼叫-d-sayHello-的過程"><a href="#當呼叫-d-sayHello-的過程" class="headerlink" title="當呼叫 d.sayHello() 的過程"></a>當呼叫 <code>d.sayHello()</code> 的過程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... 省略 ...  </span><br><span class="line">d.sayHello();</span><br></pre></td></tr></table></figure><ul><li>檢查變數 <code>d</code> 指向的物件屬性內有沒有 <code>sayHello</code> ? 這個例子沒有。</li><li>接著找該物件的 <code>__proto__</code> 屬性內有沒有 <code>sayHello</code> ，<strong>若有就停止</strong>不會繼續往後找下去。</li></ul><p><strong>以這個例子來說，在步驟二時就找到了，那如果沒有的情況呢？</strong></p><p>還記得上面的一張圖嗎?</p><blockquote><p><strong>怎麼點開了「<code>.__proto__</code>」裡面還有一個「<code>.__proto__</code>」？</strong></p></blockquote><ul><li>如果還是找不到，便繼續往 <code>.__proto__</code> 尋找，如 <code>d.__proto__.__proto__</code></li></ul><p>此時先抽離這個步驟，從這邊可以觀察出「<code>.__proto__</code>」是一層一層的，而越後面的「<code>.__proto__</code>」就越接近「底」的部分。</p><p>而本例中 dog 物件的「<code>.__proto__</code>」下一層就是原始物件的 <code>prototype</code> ，所以下面程式碼為 <code>true</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(d.__proto__.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure><p></p><p>如何知道是不是已經找到底層了呢？只要輸出為 <code>null</code> 代表上一層就是頂層了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(d.__proto__.__proto__.__proto__); // null</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*HXaf4C_eqkCw3U9sqZzg-g.png" alt></p><h2 id="回到剛才的步驟"><a href="#回到剛才的步驟" class="headerlink" title="回到剛才的步驟"></a>回到剛才的步驟</h2><ul><li>如果還是找不到，便會繼續往 <code>.__proto__</code> 尋找，直到找到為止</li><li>如果找到底層了還是沒有，則跳出錯誤訊息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function dog(name)&#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.getName = function()&#123;  </span><br><span class="line">  return this.name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;abc&apos;);  </span><br><span class="line">d.sayHello();</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*80jbtICe_QcLRBnvBVrimw.png" alt></p><h2 id="整理一下對應的關聯"><a href="#整理一下對應的關聯" class="headerlink" title="整理一下對應的關聯"></a>整理一下對應的關聯</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*s4hdapViRiq5Z5c2x5KLQw.png" alt></p><p>可以得知這個過程是一層一層逐漸地往下找的，而這個過程被稱之為<strong>原型鏈 (prototype chain)</strong>，其實跟<strong>範圍鏈 (scope chain)</strong> 有點相似。</p><p>這邊也順手觀察一下 <code>dog.__proto__</code> 是什麼<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(dog.__proto__); // ƒ () &#123; \[native code\] &#125;  </span><br><span class="line">console.log(dog.__proto__ === Function.prototype); //true</span><br></pre></td></tr></table></figure><p></p><p>因為 dog 本身就是一個函式，出現這樣子是符合預期的。</p><blockquote><p>觀察至此，大部分的疑惑都解開，只剩下 <code>new</code> 了，接下來會提到 <code>new</code> 到底做了些什麼。</p></blockquote><h2 id="知道了這些可以做什麼？"><a href="#知道了這些可以做什麼？" class="headerlink" title="知道了這些可以做什麼？"></a>知道了這些可以做什麼？</h2><p>可以進行一些比較<strong>有趣</strong>的事情，像是我們可以在 <strong>String 的原型上</strong>增加一個自己寫的方法，這樣之後只要<strong>型別屬於 String</strong> 就可以使用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.getFirst = function()&#123;  </span><br><span class="line">  return this[0];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &apos;123&apos;;  </span><br><span class="line">console.log(a.__proto__ === String.prototype); // true  </span><br><span class="line">console.log(String.prototype);  </span><br><span class="line">console.log(a.getFirst()); // 1</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Jp8XtlueVEoh5n6yZmAQrw.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們用上一節的範例來解釋什麼是 prototype 與 原型鍊，然後也不難發現 JavaScript 很多底層的觀念都是鏈狀的。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.68 物件導向的基礎範例與 class</title>
    <link href="http://pvt5r486.github.io/f2e/20190317/3356736604/"/>
    <id>http://pvt5r486.github.io/f2e/20190317/3356736604/</id>
    <published>2019-03-16T19:03:15.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這節要來研究一下如何使用 ES6 新增的 class 實作出物件導向的範例，以及尚未出現 class 時，是如何處理這部分的？</p><p><img src="https://cdn-images-1.medium.com/max/800/0*yg7ONikNQfuLZ0EW" alt></p><h2 id="ES6-新增的-class"><a href="#ES6-新增的-class" class="headerlink" title="ES6 新增的 class"></a>ES6 新增的 class</h2><p>直接看程式碼<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class dog &#123;  </span><br><span class="line">  constructor(name) &#123;  </span><br><span class="line">    this.name = name;  </span><br><span class="line">  &#125;  </span><br><span class="line">  getName()&#123;  </span><br><span class="line">    return this.name;  </span><br><span class="line">  &#125;  </span><br><span class="line">  sayHello() &#123;  </span><br><span class="line">    console.log(this.name + &apos; say Hello&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;abc&apos;);  </span><br><span class="line">var b = new dog(&apos;qqq&apos;);  </span><br><span class="line">console.log(d);  </span><br><span class="line">console.log(d.getName());  </span><br><span class="line">d.sayHello();  </span><br><span class="line">console.log(d.sayHello === b.sayHello); // true</span><br></pre></td></tr></table></figure><p></p><p>ES6 新增的 <code>class</code> 就像是一張<strong>設計圖</strong>，沒使用建構子 <code>new</code> 之前是沒有辦法使用的。</p><p>以這個例子來說，我們要建立狗的類別，所以我們定義了三個函式，其中 <code>constructor</code> 函式比較特別，當使用建構子 <code>new</code> 實例化 <strong>(instance)</strong> 狗的 <code>class</code> 時，可在括號內放入參數，而 <code>constructor</code> 函式可以取得該參數。</p><p>這個例子中以這樣的方式初始化每隻狗的名字，而我們可以更進一步的觀察</p><ul><li>此時的變數 <code>d</code> 與變數 <code>b</code> 使用 <code>typeof</code> 觀察會是<strong>物件</strong></li><li>以此設計圖新增的每隻狗都有定義在設計圖內的函式</li><li>使用三等號比較兩者的 <code>sayHello</code> 方法，會回傳 <code>true</code> ，代表為<strong>同個函式</strong>。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*2qAMK_LAyHHc3IKVmBfdgw.png" alt></p><h2 id="ES5-沒有-class-的作法"><a href="#ES5-沒有-class-的作法" class="headerlink" title="ES5 沒有 class 的作法"></a>ES5 沒有 class 的作法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function dog(name)&#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.getName = function()&#123;  </span><br><span class="line">  return this.name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.sayHello = function()&#123;  </span><br><span class="line">  console.log(this.name + &apos; say Hello&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = new dog(&apos;abc&apos;);  </span><br><span class="line">var b = new dog(&apos;qqq&apos;);  </span><br><span class="line">console.log(d);  </span><br><span class="line">console.log(d.getName());  </span><br><span class="line">d.sayHello();  </span><br><span class="line">console.log(d.sayHello === b.sayHello); // true</span><br></pre></td></tr></table></figure><p>可以發現差別並不大，直觀來說下半部的程式碼幾乎是一樣的。</p><p>主要就是需要宣告一個函式，而這個函式其實就是 ES6 <code>class</code> 內的 <code>constructor</code> 函式。</p><p>而在 ES5 的時候，是看使用時<strong>有沒有加入建構子 <code>new</code></strong> 來決定是否為 <code>constructor</code> 函式或是一般的函式。</p><p>然後除了要宣告一個函式之外，也必須在該函式的 <code>prototype</code> 定義這些狗會做什麼。</p><p>接下來進行一些觀察，可以得知跟上面那個例子的結果是一樣的。</p><p>至於 <strong><code>prototype</code> 究竟是什麼</strong>，下一節才會提到。</p><h2 id="ES5-奇怪部份推薦的做法"><a href="#ES5-奇怪部份推薦的做法" class="headerlink" title="ES5 奇怪部份推薦的做法"></a>ES5 奇怪部份推薦的做法</h2><p>這部分我可能之後會去找一下答案，不太清楚箇中差異，但個人蠻喜歡這樣的做法，因為我覺得蠻好懂的，畢竟就是物件罷了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var cat = &#123;  </span><br><span class="line">  setName: function(name) &#123;  </span><br><span class="line">    this.name = name;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  getName: function()&#123;  </span><br><span class="line">    return this.name;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  sayHello: function()&#123;  </span><br><span class="line">    console.log(this.name + &apos; Meow&apos;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = Object.create(cat);  </span><br><span class="line">var q = Object.create(cat);</span><br><span class="line"></span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(typeof c);  </span><br><span class="line">c.setName(&apos;nice&apos;);  </span><br><span class="line">console.log(c.getName());  </span><br><span class="line">c.sayHello();</span><br><span class="line"></span><br><span class="line">console.log(c.sayHello === q.sayHello); // true</span><br></pre></td></tr></table></figure><p></p><p>像這樣，建立一個貓物件，然後裡面定義一些方法。</p><p>接著使用 <code>Object.create()</code> ，這樣就結束了。</p><p>觀察後半部印出的內容，結果也與使用 <code>class</code> 實作出來的差別無異。</p><p>對照一下兩者內容：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*TzXI5NDEUBnar1XXJNhhrg.png" alt></p><p>而我的疑問是：</p><ul><li>以這個範例來說，可以算是<strong>物件導向的範例</strong>嗎？<br>我想應該是，畢竟也有達成 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/OOP" rel="external nofollow noopener noreferrer" target="_blank">MDN 對於物件導向程式設計的敘述</a></li><li>從對照圖可以看出結構不太一樣，但我不太清楚這<strong>兩種實作方式的優劣</strong>，在實務上會推薦使用哪一種呢?</li></ul><p>後來我找到了這兩篇</p><ul><li><a href="https://pjchender.blogspot.com/2016/06/javascriptprototypal-inheritance.html" rel="external nofollow noopener noreferrer" target="_blank">[筆記] 談談JavaScript中最單純的原型繼承（prototypal inheritance）─ Object.create</a></li><li><a href="https://pjchender.blogspot.com/2016/06/javascriptfunction-constructornew.html" rel="external nofollow noopener noreferrer" target="_blank">談談 JavaScript 中的 function constructor 和關鍵字 new</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E7%94%A2%E7%94%9F%E7%89%A9%E4%BB%B6%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%8F%88%E7%9A%84%E5%B9%BE%E7%A8%AE%E6%96%B9%E6%B3%95" rel="external nofollow noopener noreferrer" target="_blank">繼承與原型鏈</a></li></ul><p>然而也想起為何奇怪部分的影片講師會比較推薦 <code>Object.create()</code> 的方式，以下截自上述連結文章內描述。</p><blockquote><p>在其它的程式語言中，會用 class 這個關鍵字來設定該物件要長什麼樣子，然後透過關鍵字 <code>new</code> 來建立物件。<br>然而，和其他程式語言不同的地方在於，JavaScript 實際上使用的是<strong>原型繼承 (Prototypal inheritance)</strong>而不是古典繼承 (Classical Inheritance)，所以為了讓 JavaScript 回歸單純的<strong>原型繼承</strong>，現在的瀏覽器大部分都支援 Object.create() 這種單純的方式來建立物件。</p></blockquote><p>後來也取得了胡立大大的回應，在這邊整理一下:</p><ul><li>第一個問題，這樣也是物件導向</li><li>第二個問題，實作上應該會以 class 為主， 無論是傳統的繼承方式還是原型繼承，兩者都是物件導向，而無論在哪個程式語言，就是用 class 這個語法，所以覺得最普遍而且也最容易懂</li></ul><blockquote><p>也就是說，為了方便與其他人溝通，最好還是使用 class 會是最普遍的做法。</p></blockquote><p>至於 <code>Object.creat</code> 的部分，如果搜尋的話應該會看到 <code>Object.create(null)</code>，意思就是要產生一個「純粹的」物件，不繼承任何的函式，所以佔用的空間最少也很乾淨，例如說只是單純想存資料的話就會使用這個方法。</p><p>後來也找到關於 <code>Object.create(null)</code> 的詳細敘述與範例，Vue 裡面也有運用到哦。</p><ul><li><a href="https://juejin.im/post/5acd8ced6fb9a028d444ee4e" rel="external nofollow noopener noreferrer" target="_blank">详解Object.create(null)</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這節要來研究一下如何使用 ES6 新增的 class 實作出物件導向的範例，以及尚未出現 class 時，是如何處理這部分的？
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.67 什麼是物件導向</title>
    <link href="http://pvt5r486.github.io/f2e/20190315/2454788646/"/>
    <id>http://pvt5r486.github.io/f2e/20190315/2454788646/</id>
    <published>2019-03-15T00:40:12.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JavaScript 的世界裡我們很容易聽見物件導向這樣的名詞，那麼究竟物件導向又是什麼東西呢？這是接下來要了解的內容，我們先從<strong>什麼是物件導向</strong>起手吧。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*7wINrKH2AfgsGt_K" alt></p><h2 id="什麼是物件導向"><a href="#什麼是物件導向" class="headerlink" title="什麼是物件導向"></a>什麼是物件導向</h2><p><strong>根據 MDN 的解釋是這樣的：</strong></p><blockquote><p><strong>物件導向程式設計</strong>（Object-Oriented Programming、OOP）是一種程式設計方法。其將資料封裝（encapsulate）於物件（<a href="https://developer.mozilla.org/en-US/docs/Glossary/object" title="objects: Object refers to a data structure containing data and instructions for working with the data. Objects sometimes refer to real-world things, for example a car or map object in a racing game. JavaScript, Java, C++, Python, and Ruby are examples of object-oriented programming languages." rel="external nofollow noopener noreferrer" target="_blank"><strong>objects</strong></a>）中，我們需透過物件間接操作這些被封裝的內部資料，而非直接操作資料本身。</p></blockquote><p>其實我們上一小節寫的閉包範例就有一點物件導向的味道了，讓我們回顧一下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*dYnLpV4_Ci_FVXkWhjSM6A.png" alt></p><p>1361 行的時候，此時的 <code>myWallet</code> 是個物件，而我們透過了這個錢包物件<strong>間接</strong>的操作了被封裝的內部資料(像是 <code>myMoney</code> )，而不是直接的操作資料本身。</p><ul><li>像是 1362 行，可以很好的讀懂，錢包內多了錢</li><li>1363 行，錢包的錢被用掉了</li></ul><p>透過了這個<strong>間接</strong>的行為，可以讓我們更清楚的知道</p><ul><li>「<strong>誰</strong>」多了錢</li><li>「<strong>誰</strong>」的錢被用掉了</li></ul><p>在這裡自然是 <code>myWallet</code> 這個物件。</p><p>可是如果我們不使用物件導向的概念來寫，就像一開始寫那樣：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*kHEFS3ZZSCTmbwnwkLdvFA.png" alt></p><p>有個很明顯的缺點，就是：</p><ul><li>沒辦法單獨於 1338 行看出「<strong>誰</strong>」多了錢</li><li>沒辦法單獨於 1339 行看出「<strong>誰</strong>」的錢被用掉了</li></ul><blockquote><p>儘管這兩種寫法都可以得到一樣的結果，但卻是有<strong>物件導向概念的</strong>比較容易被讀懂。</p></blockquote><p>以上就是關於<strong>什麼是物件導向</strong>的基本認知，下一節我們要學習更多物件導向的基礎範例～</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在 JavaScript 的世界裡我們很容易聽見物件導向這樣的名詞，那麼究竟物件導向又是什麼東西呢？這是接下來要了解的內容，我們先從什麼是物件導向起手吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.66 Closure 可以應用在哪</title>
    <link href="http://pvt5r486.github.io/f2e/20190315/3059385161/"/>
    <id>http://pvt5r486.github.io/f2e/20190315/3059385161/</id>
    <published>2019-03-14T22:58:30.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好的終於到閉包的最後一個章節了，前面有提到一個小範例是關於金魚腦的小明，那除了這樣的情境可以利用閉包之外，還有一個情境是可以利用閉包達成的，讓我們一起看看。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*c0CHVpAVQ3ooBohR" alt></p><h2 id="利用閉包達成私有變數"><a href="#利用閉包達成私有變數" class="headerlink" title="利用閉包達成私有變數"></a>利用閉包達成私有變數</h2><p>情境是這樣的，我有 100 元，如果我的錢變多了，就利用某個函式讓錢增加，如果支出超過 10 元，最多就只能付出10元。</p><p>讓我們看一段沒有利用閉包的程式碼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myMoney = 100;  </span><br><span class="line">function addMoney(addmoney)&#123;  </span><br><span class="line">  myMoney = myMoney + addmoney;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function payMoney(paymoney)&#123;  </span><br><span class="line">  if (paymoney &gt; 10)&#123;  </span><br><span class="line">    myMoney = myMoney - 10;  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    myMoney = myMoney - paymoney;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMoney(1);  </span><br><span class="line">payMoney(11);  </span><br><span class="line">console.log(myMoney); // 91</span><br></pre></td></tr></table></figure><p></p><p>好的，這樣我們就完成了這段情境的敘述。</p><p>但是有個問題，如果今天與別人協作，別人如果沒有遵照我們訂的函式下去做增減，是可以直接對 <strong><code>myMoney</code> 重新賦值</strong> 的，那這樣是不是不太 OK 呢？</p><p>因此我們要利用<strong>閉包將變數私有化</strong>，令別人無法在外部直接對變數賦值，只能透過我們提供的方法來變更值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function myWallet(InitMoney)&#123;  </span><br><span class="line">  var myMoney = InitMoney;  </span><br><span class="line">  return &#123;  </span><br><span class="line">    addMoney: function(addmoney)&#123;  </span><br><span class="line">      myMoney = myMoney + addmoney;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    payMoney: function(paymoney)&#123;  </span><br><span class="line">      if (paymoney &gt; 10)&#123;  </span><br><span class="line">        myMoney = myMoney - 10;  </span><br><span class="line">      &#125; else &#123;  </span><br><span class="line">        myMoney = myMoney - paymoney;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    showMoney: function()&#123;  </span><br><span class="line">      console.log(myMoney);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myWallet = myWallet(100);  </span><br><span class="line">myWallet.addMoney(1);  </span><br><span class="line">myWallet.payMoney(11);  </span><br><span class="line">myWallet.showMoney(); // 91</span><br></pre></td></tr></table></figure><p></p><p>透過閉包可以確保讓我們的變數不會突然被修改掉，而且只能用我們定義好的函式對內部的變數進行操作，這樣一來可以確保變數是安全的。</p><blockquote><p>朕不給的，你不能要！</p></blockquote><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>接著就是物件導向的部分啦～不知不覺也複習了這麼多東西呢，也是該好好的認識一下物件導向了，尤其是物件導向的部分，這個名詞該如何簡單又白話的解釋呢？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      好的終於到閉包的最後一個章節了，前面有提到一個小範例是關於金魚腦的小明，那除了這樣的情境可以利用閉包之外，還有一個情境是可以利用閉包達成的，讓我們一起看看。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.65 作用域陷阱</title>
    <link href="http://pvt5r486.github.io/f2e/20190314/3191948883/"/>
    <id>http://pvt5r486.github.io/f2e/20190314/3191948883/</id>
    <published>2019-03-14T00:12:15.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到了我最喜歡的部分囉～我滿喜歡透過小範例來討論一些寫程式可能會遇到的一些問題，這非常實用，在這個小節內我們要使用一些不一樣的做法來解決這個問題哦。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*vQqZS1szWBkPB-Dn" alt></p><h2 id="題目君-1-號"><a href="#題目君-1-號" class="headerlink" title="題目君 1 號"></a>題目君 1 號</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];  </span><br><span class="line">for (var i =0; i&lt;5; i++)&#123;  </span><br><span class="line">  arr[i] = function()&#123;  </span><br><span class="line">    console.log(i);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">arr[0](); // 5</span><br></pre></td></tr></table></figure><p>這是蠻容易遇到的問題，在此的輸出不會如我們所想會是 0 ，而是變成 5 ，而我們接下來要嘗試不同的方法把問題修正。</p><h3 id="產生非預期的原因為何"><a href="#產生非預期的原因為何" class="headerlink" title="產生非預期的原因為何"></a>產生非預期的原因為何</h3><ul><li>因為並沒有使用函式包覆，因此再迴圈內宣告的 <code>i</code> 變數相當於全域變數</li><li>而執行迴圈時，並沒有執行函式，僅將函式放入陣列</li><li>而呼叫後的函式由於在所屬作用域找不到 <code>i</code> ，轉而向上層尋找 <code>i</code></li></ul><h3 id="解法-A"><a href="#解法-A" class="headerlink" title="解法 A"></a>解法 A</h3><p>這邊提到第一種解法，可以<strong>多宣告一個函式並且使用閉包技巧</strong>來記住當前 <code>i</code> 的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];  </span><br><span class="line">for (var i =0; i&lt;5; i++)&#123;  </span><br><span class="line">  arr[i] = logN(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logN(num)&#123;  </span><br><span class="line">  return function()&#123;  </span><br><span class="line">    console.log(num);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[0](); // 0  </span><br><span class="line">arr[1](); // 1</span><br></pre></td></tr></table></figure><p></p><p>可以把它想像成這樣</p><p><img src="https://cdn-images-1.medium.com/max/800/1*cgNatSPzltdZ1jb6FVIuIw.png" alt></p><h3 id="解法-B"><a href="#解法-B" class="headerlink" title="解法 B"></a>解法 B</h3><p>如果不想要額外宣告函式，也可以透過 IIFE 配合閉包的技巧來達成，關於 IIFE 的部分可以喚醒另外一個世界線的記憶(?</p><ul><li><a href="https://pvt5r486.github.io/javascript/20190128/3130923936">[JavaScriptWeird]No.33 立即呼叫的函式表示式 IIFE</a></li></ul><p>所以這段程式其實可以改寫成這樣，跟解法 A 差不多，只是把額外宣告函式的部分用 IIFE 取代掉了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];  </span><br><span class="line">for (var i =0; i&lt;5; i++)&#123;  </span><br><span class="line">  arr[i] = (function(num)&#123;  </span><br><span class="line">    return function()&#123;  </span><br><span class="line">      console.log(num);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;)(i)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[0](); // 0  </span><br><span class="line">arr[1](); // 1</span><br></pre></td></tr></table></figure><p></p><h3 id="解法-C"><a href="#解法-C" class="headerlink" title="解法 C"></a>解法 C</h3><p>我個人比較喜歡的一種，因為最容易。那就是使用 ES6 新增的 <code>let</code> 來處理這個問題， <code>let</code> 的作用域是以 block 也就是大括號來劃分，而 let 在迴圈中的表現出的特性又有點不同，每次迴圈執行時都會產生一個不同的 i 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];  </span><br><span class="line">for (let i =0; i&lt;5; i++)&#123;  </span><br><span class="line">  arr[i] = function()&#123;  </span><br><span class="line">    console.log(i);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[0](); // 0</span><br></pre></td></tr></table></figure><p></p><p>使用 <code>let</code> 來處理這樣的問題其實相當容易，就只是把 <code>var</code> 替換掉而已。</p><p>然而我們可以把<strong>每當迴圈執行時</strong>的這段過程想像成這樣</p><p><img src="https://cdn-images-1.medium.com/max/800/1*puAl4Tg2xlr9eBXpRLK0Hw.png" alt></p><p>而實際把右邊的內容放到左邊執行，結果是一樣的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*0Z_kog_XkiW6dFwfLSdGCw.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      到了我最喜歡的部分囉～我滿喜歡透過小範例來討論一些寫程式可能會遇到的一些問題，這非常實用，在這個小節內我們要使用一些不一樣的做法來解決這個問題哦。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.64 再次 Cosplay JavaScript 引擎</title>
    <link href="http://pvt5r486.github.io/f2e/20190314/2550634754/"/>
    <id>http://pvt5r486.github.io/f2e/20190314/2550634754/</id>
    <published>2019-03-13T23:13:28.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接著我們繼續用類似的角度來觀察這一段閉包的程式碼。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*lDYLcfMYzVkMI3AK" alt></p><h2 id="簡單的-Closure-程式"><a href="#簡單的-Closure-程式" class="headerlink" title="簡單的 Closure 程式"></a>簡單的 Closure 程式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var v1 = 10;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  var vTest = 20;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    console.log(v1, vTest);  </span><br><span class="line">  &#125;  </span><br><span class="line">  return inner;  </span><br><span class="line">&#125;  </span><br><span class="line">var inner = test();  </span><br><span class="line">inner();</span><br></pre></td></tr></table></figure><p>首先進入創造全域執行環境階段，初始化 VO 、scopeChain 以及設定 <code>test</code> 函式的 <code>[[Scope]]</code>。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*-CQJIaYY-yVMguDcXMwEqA.png" alt></p><p>接著執行程式碼：</p><ul><li>於 1273 行變數 <code>v1</code> 賦值為 10</li><li>1274 ~ 1280 行跳過</li><li>於 1281 行執行 <code>test</code> 函式</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*yFGEQ70RhF-HTWRkoC9rYw.png" alt></p><p>進入 <code>test</code> 函式的創造執行環境階段，初始化 AO 、scopeChain 以及設定 <code>inner</code> 函式的 <code>[[Scope]]</code>。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Eqfek9l08VndHz5wVZKAlQ.png" alt></p><p>接著逐行執行 <code>test</code> 函式內的程式碼：</p><ul><li>於 1275 行變數 <code>vTest</code> 賦值為 20</li><li>1276 ~ 1278 跳過</li><li>於 1279 行 <code>return inner</code></li></ul><p>此時 testEC 執行完畢，被移出執行堆。</p><p>但<strong>因為 <code>inner.[[scope]]</code> 使用到 <code>testEC.AO</code> 所以 <code>testEC.AO</code> 不會被 JavaScript 的垃圾回收機制回收掉</strong>，因此會被保留在記憶體中。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*X8OWKa_fdfPm7yUHxIUisw.png" alt></p><p>最後回到全域執行環境，繼續運行程式碼：</p><ul><li>於 1282 行呼叫 <code>inner()</code></li></ul><p>進入 <code>inner</code> 函式的創造執行環境階段，初始化 AO 、scopeChain</p><p><img src="https://cdn-images-1.medium.com/max/800/1*V2rWJVS38U-5AhjSKztj5Q.png" alt></p><p>逐行執行 <code>inner</code> 函式內的程式碼</p><ul><li>於 1277 行印出 log， 因 <code>innerEC.AO</code> 內找不到變數 <code>v1</code> ，因此循著 <code>innerEC.scopeChain</code> 最後於 <code>globalEC.VO</code> 內找到，值為 10 。<ul><li>同理，變數 <code>vTest</code> 則為 20 。</li></ul></li><li><code>inner</code> 函式執行完畢，移出執行堆。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*TE3j08Kwj7XXom-3CeILcQ.png" alt></p><p>程式全部運行完畢，全域執行環境移出執行堆。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*EYRhdfB-N0GSE2Ybzs4Zew.png" alt></p><p>到此我們的 cosplay 就到一段落了。</p><h2 id="所有的函式都是閉包"><a href="#所有的函式都是閉包" class="headerlink" title="所有的函式都是閉包"></a>所有的函式都是閉包</h2><p>偷用一下聳動的<strong>殺人標題</strong>，其實這個標題是可以解釋的。</p><p>我們之前提到，閉包白話來說<strong>就是一個函式裡面回傳一個函式</strong>。</p><p>而透過觀察，發現無論有無回傳， JavaScript 引擎背後紀錄的東西都是一樣的，<strong>像是沒有回傳也有像是 AO、VO、scopeChain 這些東西。</strong></p><p>所以如果我們以這個角度「<strong>會記住這些周邊資訊的函式</strong>」來定義閉包，那就成了這次的殺人標題啦，所有的函式都是閉包，因為每個函式都會記錄這些東西。</p><p>不過一般提到閉包不會講到這種定義，一般來說都是講「<strong>一個函式內回傳一個函式</strong>」才是大家認知的閉包。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>至此，關於閉包的原理以及觀念已經學習完了，接著要來看<strong>日常生活中可能會遇到的作用域陷阱</strong>以及<strong>閉包可以運用在哪</strong>，我個人也是蠻關注這一塊的，畢竟學了武功就是希望能派上用場 ~ 要是學了卻不知道能用在哪也是怪怪的。</p><p>學習到現在，覺得能慢慢地看懂程式碼，了解這些程式碼在背後偷偷做些什麼，讓人有點感動也覺得踏實，勉勵自己繼續投入。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接著我們繼續用類似的角度來觀察這一段閉包的程式碼。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.63 從 ECMAScript 看作用域</title>
    <link href="http://pvt5r486.github.io/f2e/20190308/3093574974/"/>
    <id>http://pvt5r486.github.io/f2e/20190308/3093574974/</id>
    <published>2019-03-07T23:51:49.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我們已經在 hoisting 嘗試過從 ECMAScript 文件內找出其原理，然後假裝自己是 JavaScript 引擎，但那個時候我們描述的不夠完整，因此這一小節要補足剩餘的部分。閉包其實也與作用域、範圍鏈脫離不了關係，因此在繼續深入了解閉包之前，還是要先對這兩者之間有更多認識才行。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Ze7FQa0zL9t47eRd" alt></p><h2 id="作用域-amp-範圍鏈"><a href="#作用域-amp-範圍鏈" class="headerlink" title="作用域 &amp; 範圍鏈"></a>作用域 &amp; 範圍鏈</h2><h3 id="本節使用文件"><a href="#本節使用文件" class="headerlink" title="本節使用文件"></a>本節使用文件</h3><ul><li><a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript — Ecma-262 ,1999年12月</a></li></ul><p>於 hoisting 的章節時，我們有了執行環境 (EC)、變數物件 (VO) 的概念，本小節就繼續從這邊紀錄下去。</p><blockquote><p>Every execution context has associated with it a scope chain.</p></blockquote><ul><li><p>每個執行環境都有<strong>範圍鏈 (Scope Chain)</strong></p><blockquote><p>When control enters an execution context, a scope chain is created and populated with an initial set of objects</p></blockquote></li><li><p>大概的意思就是，當進入執行環境時，範圍鏈就會被建立</p><blockquote><p>When control enters an execution context, the scope chain is created and initialised, variable instantiation is performed, and the this value is determined</p></blockquote></li><li><p>當進入執行環境時，範圍鍊被建立且初始化，變數也被初始化並且確定其值</p></li></ul><p>接著跳到 Function Code 的段落</p><blockquote><p>The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object.</p><ul><li>當進入執行環境時，範圍鏈的初始化將包含 activation object ，以及函式的 <code>[[Scope]]</code> 屬性</li><li>當進入執行環境時，如有宣告函式，則將該函式的 <code>[[Scope]]</code> 屬性賦值為自身的範圍鏈</li></ul></blockquote><p>接著了解什麼是 <strong>activation object ，以下稱為 AO</strong></p><blockquote><p>When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name <strong>arguments</strong> and attributes { DontDelete }. The initial value of this property is the arguments object described below.</p></blockquote><blockquote><p>The activation object is then <strong>used as the variable object</strong> for the purposes of variable instantiation</p><ul><li>大致上的意思就是，當我們進入一個執行環境時，會產生一個 AO (之前都說 VO ，但實際上是AO)，而這個 AO 其實跟 VO 只有一些細微的差異，而大部分的行為都是相同的。</li><li>只有全域執行環境有 VO</li></ul></blockquote><p>接下來我們一樣假裝自己是 JS 引擎，分析一段簡單的程式碼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">function test() &#123;  </span><br><span class="line">  var b = 2;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    var c = 3;  </span><br><span class="line">    console.log(b);  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">  inner();  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><ul><li>創造全域執行環境，建立變數物件，並且初始化範圍鏈</li></ul><p>建立變數物件的時候，因為有宣告 <code>test</code> 函式，所以 <code>test.[[Scope]]</code> 被賦值為 自身執行環境的 scopeChain ，即為 <code>globalEC.scopeChain</code> 。</p><p>而初始化範圍鏈的時候，因為本身並不是函式，所以 ScopeChain 並沒有包含 <code>[[Scope]]</code> 屬性，僅有 <code>globalEC.VO</code>。</p><p>整理過後可以得到下圖，全域執行環境的範圍鏈就是自己的 VO 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*XmWbOWRPC2VJtRc1grcSkQ.png" alt></p><p>創造階段結束後接著是執行階段，開始逐行執行程式碼。</p><ul><li>1260 行將全域變數 <code>a</code> 賦值為 1</li><li>1261~1269 跳過</li><li>1270 呼叫 <code>test()</code> ，創造並進入另一個執行環境</li></ul><p>目前的狀況是這樣的</p><p><img src="https://cdn-images-1.medium.com/max/800/1*HK5RaYyCPBLosYrHww2jEQ.png" alt></p><h3 id="test-內發生的事"><a href="#test-內發生的事" class="headerlink" title="test () 內發生的事"></a>test () 內發生的事</h3><p>創造執行環境階段</p><ul><li>建立 AO ，並且初始化範圍鏈</li></ul><p>而 <code>testEC.scopeChain</code> 內的東西就是 <code>testEC.AO</code> 以及 <code>testEC.[[Scope]]</code> 屬性，透過代換後，可以發現 <code>testEC.[[Scope]]</code> 屬性就是 <code>globalEC.scopeChain</code> ，更進一步代換就是 <code>globalEC.VO</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Zs4Wl1zJbDeJo3aqL6Wdxg.png" alt></p><p>接著逐行運行程式碼</p><ul><li>1262 行將變數 <code>b</code> 賦值為 2</li><li>1263~1267跳過</li><li>1268 呼叫 <code>inner()</code> ，創造並進入另一個執行環境</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*g4NwunpvD_b2pACxxOICPw.png" alt></p><h3 id="inner-內發生的事"><a href="#inner-內發生的事" class="headerlink" title="inner () 內發生的事"></a>inner () 內發生的事</h3><p>創造執行環境階段</p><ul><li>建立 AO ，並且初始化範圍鏈</li></ul><p>如同在 <code>test()</code> 內發生的事一樣， <code>innerEC</code> 的 ScopeChain 會被初始化，裡面會有 <code>innerEC.AO</code> 與 <code>inner.[[Scope]]</code> ，接著可以透過不斷的代換，得知其實 <code>innerEC</code> 的 ScopeChain 會按照順序去找 <code>innerEC.AO</code> 、 <code>testEC.AO</code> 、<code>globalEC.VO</code> 內的東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*0It-5PpVvXE6a0U1KW-Bbw.png" alt></p><p>接著逐行運行程式碼</p><ul><li>1264 行將變數 <code>c</code> 賦值為 3</li><li>1265 行印出變數 <code>b</code> ，但自身 AO 內找不到，透過自身 ScopeChain 向 <code>testEC.scopeChain</code> 尋找，於 <code>testEC.AO</code> 內找到變數 <code>b</code> 為 2</li><li>1266 行印出變數 <code>a</code> ，但自身 AO 內找不到，且 <code>testEC.AO</code> 內也找不到，因此繼續往 <code>globalEC.scopeChain</code> 找，最後在 <code>globalEC.VO</code> 找到變數 <code>a</code> 為 1</li><li><code>inner</code> 函式結束，移出執行堆</li><li>回到 <code>test</code> 函式繼續執行</li><li><code>test</code> 函式結束，移出執行堆</li><li>回到全域執行環境繼續執行</li><li>程式碼執行完畢，全域執行環境移出執行堆</li></ul><p>透過這樣的方式可以更了解作用域以及範圍鏈，也明白範圍鏈在 JavaScript 中是如何一層一層的往外找到相應的變數。</p><p>而我們模仿 JS 引擎的這個行為，除了可以幫助我們了解 hoisting 以及 範圍鏈之外，還能夠幫助理解閉包的行為，下一節我們將繼續使用這樣的方式來解析閉包。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      之前我們已經在 hoisting 嘗試過從 ECMAScript 文件內找出其原理，然後假裝自己是 JavaScript 引擎，但那個時候我們描述的不夠完整，因此這一小節要補足剩餘的部分。閉包其實也與作用域、範圍鏈脫離不了關係，因此在繼續深入了解閉包之前，還是要先對這兩者之間有更多認識才行。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.62 Closure 是什麼</title>
    <link href="http://pvt5r486.github.io/f2e/20190307/4153660921/"/>
    <id>http://pvt5r486.github.io/f2e/20190307/4153660921/</id>
    <published>2019-03-06T23:51:49.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>結束了關於 hoisting 的學習，接下來要討論的是 <strong>Closure 閉包</strong>，之前在奇怪部分也有紀錄到關於閉包的部分，但我期待接下來的幾節能帶給我不同的切入點，讓自己更了解閉包。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*VPPhJwCsrl-3Eb5L" alt></p><h2 id="Closure-閉包"><a href="#Closure-閉包" class="headerlink" title="Closure 閉包"></a><strong>Closure 閉包</strong></h2><p>閉包也是個經常會被問到的問題，但我們在此先不要提理論，先使用一個簡單的例子來觀察閉包可以做些什麼事。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    a++;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">  inner();  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><p>這是一個結果顯而易見的程式，答案是 11 。</p><p>但是如果不在 <code>test</code> 函式內呼叫 <code>inner()</code> ，而使用 <code>return</code> 回傳 <code>inner</code> 呢？</p><p>在這之前我們要先複習一個小概念，函式呼叫。</p><blockquote><p>因為有沒有加上 () 是完全不同的兩件事。</p></blockquote><h2 id="函式呼叫-Funtion-Invocation"><a href="#函式呼叫-Funtion-Invocation" class="headerlink" title="函式呼叫 ( Funtion Invocation )"></a>函式呼叫 ( Funtion Invocation )</h2><ul><li>表示執行或者呼叫一個函式，在 JavaScript 我們用括號來表示這件事<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    a++;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">  return inner;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = test();  </span><br><span class="line">func(); // 11  </span><br><span class="line">func(); // 12</span><br></pre></td></tr></table></figure></li></ul><p>使用 <code>return</code> 回傳 <code>inner</code> 函式，需要用一個變數來指向這個函式，方便後續使用它，也因為回傳的是<strong>函式</strong>，所以能直接加上 括號 () 執行，最後一樣能得到相同的結果 11 。</p><blockquote><p><strong>而神奇的是變數 a 的值會保留，原因之後再提。</strong></p></blockquote><p>如果不想額外宣告一個變數，也可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    a++;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">  return inner;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()(); // 11</span><br></pre></td></tr></table></figure><p></p><p>意思是當 <code>test()</code> 執行完畢 <code>return inner</code> 時，馬上執行 <code>inner</code> 函式。</p><p>當寫習慣之後，可以簡短成這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  return function()&#123;  </span><br><span class="line">    a++;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = test();  </span><br><span class="line">func(); // 11  </span><br><span class="line">func(); // 12</span><br></pre></td></tr></table></figure><p></p><p>因為目的就是回傳被包在 <code>test</code> 函式內的<strong>那個函式</strong>，所以可以使用匿名函式的技巧表示被包在內部的函式。</p><h2 id="目前觀察到的特性"><a href="#目前觀察到的特性" class="headerlink" title="目前觀察到的特性"></a>目前觀察到的特性</h2><ul><li>首先觀察到，我們把本來在函式內部執行的另一個函式拉出來，變成在外面呼叫這個函式。</li><li>與先前的函式寫法不同，函式應該是執行完就釋放掉了，而這樣的做法，宣告在外層函式內變數指向的值會保留，似乎像是被鎖在函式內。</li></ul><p><strong>總結目前階段所認知的閉包</strong></p><blockquote><p>呃 … 大概就是一個函式內又回傳另一個函式 ?</p></blockquote><h2 id="以目前認知的閉包特性可以做些什麼事？"><a href="#以目前認知的閉包特性可以做些什麼事？" class="headerlink" title="以目前認知的閉包特性可以做些什麼事？"></a>以目前認知的閉包特性可以做些什麼事？</h2><p>有個情境是這樣的，我們用一個函式做重複的事情，例如複雜的計算，那麼可以這麼寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function openIcebox(item)&#123;  </span><br><span class="line">  console.log(&apos;打開冰箱看到&apos;);  </span><br><span class="line">  return item;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(openIcebox(&apos;蘋果&apos;));  </span><br><span class="line">console.log(openIcebox(&apos;蘋果&apos;));</span><br></pre></td></tr></table></figure><p></p><p>相當容易，不是嗎？</p><p>但是這麼做，<strong>每次呼叫都會執行一次 openIcebox 函式</strong>。</p><p>這麼做就好比</p><ul><li>小美請小明打開冰箱，確認裡面是否有一顆蘋果？</li><li>小明打開冰箱後確實看到了蘋果，並回答小美，有一顆蘋果在冰箱內。</li><li>接著大熊也請小明打開冰箱，確認裡面是否有一顆蘋果？</li><li>但小明金魚腦已經忘記了，所以小明又跑到冰箱前打開門看到了蘋果，並回答大熊，有一顆蘋果在冰箱內。</li></ul><blockquote><p>像小明這麼金魚腦的人，每次問相同的問題，就必須打開冰箱門確認一次，這樣是不是很浪費電？</p></blockquote><p><strong>所以小明需要一張便條紙把這些記起來。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function openIcebox(item)&#123;  </span><br><span class="line">  console.log(&apos;打開冰箱看到&apos;);  </span><br><span class="line">  return item;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function haveMemo(func)&#123;  </span><br><span class="line">  var memo = &apos;&apos;;  </span><br><span class="line">  return function(item)&#123;  </span><br><span class="line">    if (memo)&#123;  </span><br><span class="line">      console.log(&apos;便條紙上寫著冰箱內有&apos;);  </span><br><span class="line">      return memo;  </span><br><span class="line">    &#125;  </span><br><span class="line">    memo = func(item);  </span><br><span class="line">    return item;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ming = haveMemo(openIcebox);  </span><br><span class="line">console.log(ming(&apos;蘋果&apos;));   </span><br><span class="line">console.log(ming(&apos;蘋果&apos;));   </span><br><span class="line">console.log(ming(&apos;蘋果&apos;));</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*OGQMfPN8hlfO6GhaUytpwA.png" alt></p><p>對於金魚腦的小明來說，函式 <code>haveMemo</code> 內的變數 <code>memo</code> 就是小明的便條紙，因此上面那個小故事，我們可以想成：</p><ul><li>小美請小明打開冰箱，確認裡面是否有一顆蘋果？</li><li>小明打開冰箱，看到蘋果並寫在便條紙上，隨後回答小美冰箱有蘋果。</li><li>接著大熊也請小明打開冰箱，確認裡面是否有一顆蘋果？</li><li>小明這時拿出便條紙，肯定的說冰箱內有蘋果，所以不用跑到冰箱前打開確認了。</li></ul><p>透過這樣子的比喻，方便了解透過閉包的特性可以做到什麼樣的事情，而從這個比喻了解到，小明<strong>節省了反覆開冰箱浪費的電力以及自身的體力</strong>。回到程式來說，透過這樣子的<strong>設計</strong>，能夠讓程式的效能更好。</p><p>為什麼說是<strong>設計</strong>：</p><ul><li>因為<strong>笨的方法一樣能達成目的</strong>，只是小明可能會很累。而透過一連串巧妙的<strong>設計</strong>(如小明的便條紙)，可以使用聰明的方法達到同樣的目的。</li><li>而閉包我想就是一種<strong>設計</strong>，如果能巧妙地運用，相信能讓程式效能更好。</li></ul><blockquote><p>以上就是對於閉包 Closure 的初步概念，接下來我們要探討原理的部分。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      結束了關於 hoisting 的學習，接下來要討論的是 Closure 閉包，之前在奇怪部分也有紀錄到關於閉包的部分，但我期待接下來的幾節能帶給我不同的切入點，讓自己更了解閉包。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.61 let 、 const 、 TDZ</title>
    <link href="http://pvt5r486.github.io/f2e/20190307/3177998342/"/>
    <id>http://pvt5r486.github.io/f2e/20190307/3177998342/</id>
    <published>2019-03-06T18:03:50.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面三節提到的變數均使用 <code>var</code> 宣告，原因是 ES6 之後加入的 <code>let</code> &amp; <code>const</code> 在這部分的特性表現不一樣，本節將記錄它們有何不同之處。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*tIlmwt5NEIA2NFLm" alt></p><h2 id="let-amp-const-的-hoisting"><a href="#let-amp-const-的-hoisting" class="headerlink" title="let &amp; const 的 hoisting"></a>let &amp; const 的 hoisting</h2><p>當你看過之前的文章，或許你會試著觀察 <code>let</code> 與 <code>const</code> 對於 hoisting 上的表現，於是我們可能這樣子寫。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // a is not defined  </span><br><span class="line">let a = 10;</span><br></pre></td></tr></table></figure><p></p><p>或是這樣子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // a is not defined  </span><br><span class="line">const a = 10;</span><br></pre></td></tr></table></figure><p></p><p>然後我們可能就直接下了定論「 <code>let</code> 與 <code>const</code> 沒有 hoisting」</p><h2 id="但是這個小例子也許會讓我們更混淆"><a href="#但是這個小例子也許會讓我們更混淆" class="headerlink" title="但是這個小例子也許會讓我們更混淆"></a>但是這個小例子也許會讓我們更混淆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;  </span><br><span class="line">function test() &#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  let a = 10;  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // a is not defined</span><br></pre></td></tr></table></figure><p>混淆的點在於</p><ul><li>如果 <code>let</code> &amp; <code>const</code> 沒有 hoisting ，那麼變數 <code>a</code> 會往全域找到外部的變數 <code>a</code> ，但實際執行卻得到「<code>a is not defined</code>」</li><li>但如果 <code>let</code> &amp; <code>const</code> 有 hoisting，為什麼印出變數 <code>a</code> 時也會得到「<code>a is not defined</code>」而不是 「 <code>undefined</code> 」？</li></ul><p>於是假設 <code>let</code> &amp; <code>const</code> 有 hoisting，只是表現出來的特性不一樣，導致我們認為它們沒有 hoisting 。</p><blockquote><p><strong>那麼 let &amp; const 的 hoisting 特性是什麼呢？</strong></p></blockquote><h2 id="暫時性死區-Temporal-Dead-Zone"><a href="#暫時性死區-Temporal-Dead-Zone" class="headerlink" title="暫時性死區 (Temporal Dead Zone)"></a>暫時性死區 (Temporal Dead Zone)</h2><p>暫時性死區 (Temporal Dead Zone) 以下簡稱 TDZ，是 <code>let</code> &amp; <code>const</code> 在 進行 hoisting 過程中產生的一種現象。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;  </span><br><span class="line">  console.log(a); // a 的 TDZ 開始  </span><br><span class="line">  let a = 10; // a 的 TDZ 結束  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // a is not defined</span><br></pre></td></tr></table></figure><p></p><p>換句話說 <code>let</code> &amp; <code>const</code> 是有 hoisting 的，只是表現出來的特性不一樣</p><ul><li>與 <code>var</code> 宣告不同，這兩者不會於<strong>創造執行環境階段時</strong>被初始化為 <code>undefined</code></li><li><strong>創造執行環境階段後</strong>，對於 <code>let</code> 宣告如果沒有賦值，執行到該行時則賦值該變數為 <code>undefined</code> 。</li><li>在<strong>提升後～賦值前</strong>會產生一個稱為暫時性死區 (TDZ) 的區域，在這個區域中<strong>不能對該變數做任何的存取</strong>，否則就會發生錯誤。</li><li>必須等到<strong>賦值後</strong>，也就是 TDZ 結束後才能對變數進行存取。</li></ul><h2 id="使用-let-宣告但沒有賦值"><a href="#使用-let-宣告但沒有賦值" class="headerlink" title="使用 let 宣告但沒有賦值"></a>使用 let 宣告但沒有賦值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;  </span><br><span class="line">  // a 的 TDZ 開始  </span><br><span class="line">  let a; // a 的 TDZ 結束  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // undefined</span><br></pre></td></tr></table></figure><p>以上就是 <code>let</code> &amp; <code>const</code> &amp; TDZ 的簡單觀念，其實這部分還有相當多細部的觀念可以寫，其餘較詳細的部分可以參考<a href="https://github.com/aszx87410/blog/issues/34" rel="external nofollow noopener noreferrer" target="_blank">這一篇</a>。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>其實在寫這一篇的時候，因為<strong>糾結於部分觀念</strong>，導致寫作時花了很多時間。主要是為了確認：</p><ul><li>let 於 <strong>創造執行環境階段時會不會被初始化為</strong> undefined</li></ul><h3 id="遲疑的原因："><a href="#遲疑的原因：" class="headerlink" title="遲疑的原因："></a>遲疑的原因：</h3><ul><li>在奇怪部份時，講師提到 「<strong>創造執行環境階段時全部的變數都會被初始化為 <code>undefined</code> 」，</strong>但考量時間因素，這支影片是在 ES6 之前推出，因此待求證。</li><li>但本小節影片提到「 <code>let</code> 不會被賦予初始值 <code>undefined</code> 」</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;  </span><br><span class="line">  let a;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ul><li>如果 <code>let</code> 於創造執行環境階段時不會被初始化為 <code>undefined</code> ，那麼為什最後印出的結果會是 <code>undefined</code>?</li></ul><h3 id="因此我有以下兩個想法"><a href="#因此我有以下兩個想法" class="headerlink" title="因此我有以下兩個想法"></a>因此我有以下兩個想法</h3><ul><li>「創造執行環境階段後，對於 <code>let</code> 宣告如果沒有賦值，執行到該行時則賦值該變數為 <code>undefined</code> 」</li><li>「創造執行環境階段時全部的變數都會被初始化為 <code>undefined</code> ，只是 <code>let</code> 因為 TDZ 的關係，必須等到實際程式執行到宣告的那一行時才能對變數進行存取」</li></ul><h3 id="於是我寫信求指點～獲得回應如下："><a href="#於是我寫信求指點～獲得回應如下：" class="headerlink" title="於是我寫信求指點～獲得回應如下："></a>於是我寫信求指點～獲得回應如下：</h3><p>的確兩種情況都有可能，到底是哪一種只能看 spec 來確認。</p><p>我在<a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/" rel="external nofollow noopener noreferrer" target="_blank"><strong>《我知道你懂 hoisting，可是你了解到多深？》</strong></a>的最後面附了一大堆參考資料，其實都是很有用的資源。</p><p>這兩篇有你要的解答：</p><ul><li><a href="https://segmentfault.com/a/1190000008213835" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000008213835</a></li><li><a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified" rel="external nofollow noopener noreferrer" target="_blank">http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified</a></li></ul><p>連結內的文章有一段這麼寫：</p><blockquote><p><code>let</code> and <code>const</code> declarations define variables that are scoped to <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-execution-contexts" rel="external nofollow noopener noreferrer" target="_blank">the running execution context</a>’s <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-execution-contexts" rel="external nofollow noopener noreferrer" target="_blank">LexicalEnvironment</a>. The variables are created when their containing <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-lexical-environments" rel="external nofollow noopener noreferrer" target="_blank">Lexical Environment</a> is instantiated but may not be accessed in any way until <strong>the variable’s LexicalBinding is evaluated</strong>. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBindingin a <code>let</code> declaration does not have an Initializer the variable is assigned the value <code>undefined</code> when the LexicalBinding is evaluated.</p></blockquote><p>上面寫說執行環境被創建時，變數就被建立了，但是一直到「<strong>the variable’s LexicalBinding is evaluated</strong>」之前都沒辦法訪問，這就是 TDZ。</p><h3 id="那什麼是「the-variable’s-LexicalBinding-is-evaluated」？"><a href="#那什麼是「the-variable’s-LexicalBinding-is-evaluated」？" class="headerlink" title="那什麼是「the variable’s LexicalBinding is evaluated」？"></a>那什麼是「the variable’s LexicalBinding is evaluated」？</h3><ul><li>就是實際上宣告變數的那一行： <code>let a</code></li></ul><p>接著又提到「If a LexicalBindingin a let declaration does not have an Initializer the variable is assigned the value undefined <strong>when the LexicalBinding is evaluated</strong>.」</p><p>如果宣告變數時沒給值，預設值會是 <code>undefined</code> 。</p><ul><li>這邊的「宣告變數」指的是「<strong>when the LexicalBinding is evaluated</strong>」</li><li>也就是實際上 <code>let a</code> 這一行</li></ul><blockquote><p>所以總結以上，你的第一個理解才是正確的。</p></blockquote><p>到此我才確定自己的理解是正確的，感謝 Huli 大的熱心解答。</p><h2 id="結論是："><a href="#結論是：" class="headerlink" title="結論是："></a>結論是：</h2><ul><li><code>let</code> 在創造執行環境階段時，不會被賦予初始值 <code>undefined</code></li><li>創造執行環境階段後，對於 <code>let</code> 宣告如果沒有賦值，執行到該行時則賦值該變數為 <code>undefined</code></li></ul><p>本來是不用特地把這一段再補上來的，但我認為可能也有很多初學者跟我有一樣的疑問，所以把來龍去脈整理出來，也有助於加深自己的理解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前面三節提到的變數均使用 var 宣告，原因是 ES6 之後加入的 let &amp; const 在這部分的特性表現不一樣，本節將記錄它們有何不同之處。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.60 cosplay JS 引擎</title>
    <link href="http://pvt5r486.github.io/f2e/20190306/3610645134/"/>
    <id>http://pvt5r486.github.io/f2e/20190306/3610645134/</id>
    <published>2019-03-05T22:26:30.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好的，接著我們要假裝自己是 JS 引擎，然後用 ECMAScript 文件上的規則來找出上一節開頭問題的答案哦～</p><p><img src="https://cdn-images-1.medium.com/max/800/0*6IeGbybuSWzURKGQ" alt></p><h2 id="hoisting-amp-scope-小測驗"><a href="#hoisting-amp-scope-小測驗" class="headerlink" title="hoisting &amp; scope 小測驗"></a>hoisting &amp; scope 小測驗</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(&apos;1.&apos;, a);  </span><br><span class="line">  var a = 7;  </span><br><span class="line">  console.log(&apos;2.&apos;, a);  </span><br><span class="line">  a++;  </span><br><span class="line">  var a;  </span><br><span class="line">  inner();  </span><br><span class="line">  console.log(&apos;4.&apos;, a);  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    console.log(&apos;3.&apos;, a);  </span><br><span class="line">    a = 30;  </span><br><span class="line">    b = 200;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test();  </span><br><span class="line">console.log(&apos;5.&apos;, a);  </span><br><span class="line">a = 70;  </span><br><span class="line">console.log(&apos;6.&apos;, a);  </span><br><span class="line">console.log(&apos;7.&apos;, b);</span><br></pre></td></tr></table></figure><p>請依序寫出 log 答案是多少，在這邊我們要採用不一樣的觀點來找出這題的答案。</p><h2 id="如果我是-JavaScript-引擎"><a href="#如果我是-JavaScript-引擎" class="headerlink" title="如果我是 JavaScript 引擎"></a>如果我是 JavaScript 引擎</h2><p>我們說過當 JavaScript 執行時，會先<strong>創造全域執行環境</strong>。</p><ul><li>接著會找有沒有參數，但它不是函式所以跳過</li><li>再來會找有沒有宣告函式</li><li>最後才找有沒有宣告變數，有則初始化為 <code>undefined</code></li></ul><p>整理後可以得到這樣的結果<br><img src="https://cdn-images-1.medium.com/max/800/1*X14SN_1kjmwMQgYg1PDolw.png" alt></p><p>接下來開始逐行執行程式碼</p><ul><li>1163 行 全域變數 <code>a</code> 被賦值為 1</li><li>跳過 1164 ~ 1177 行的函式</li><li>1178 行呼叫 <code>test</code> 函式，建立並<strong>進入另一個執行環境</strong></li></ul><h3 id="test-函式內發生的事"><a href="#test-函式內發生的事" class="headerlink" title="test 函式內發生的事"></a>test 函式內發生的事</h3><p>基本上做的事情會跟創造全域執行環境時一樣，因此：</p><ul><li>於 1172 行發現宣告 <code>inner</code> 函式</li><li>於 1166 行發現宣告 <code>a</code> 變數</li></ul><p>整理後可得結果如下，至此 <code>test</code> 的執行環境建立完成。<br><img src="https://cdn-images-1.medium.com/max/800/1*0IFFv8BsLOav-ZFL8e5ZCw.png" alt></p><p>接著逐行執行 <code>test</code> 函式內的程式碼</p><ul><li>於 1165 行印出變數 <code>a</code> ，此時對照 <code>test</code> 的 VO ，得知目前 <code>a</code> 為 <code>undefined</code></li><li>於 1166 行變數 <code>a</code> 被賦值為 7 ，此時 <code>test</code> 內 VO 的 a 為 7</li><li>於 1167 行印出變數 <code>a</code> ，對照後得知目前 <code>a</code> 為 7</li><li>於 1168 行執行 <code>a++</code> ， 此時 <code>test</code> 內 VO 的 <code>a</code> 為 8</li><li>於 1169 行發現 <code>var a</code>，但已經有同名變數被宣告，直接跳過。</li><li>於 1170 行呼叫 <code>inner</code> 函式，建立並<strong>進入另一個執行環境</strong></li></ul><p>至此，狀態如下</p><p><img src="https://cdn-images-1.medium.com/max/800/1*1YEl6fVZvFLrLugBJaU-Xg.png" alt></p><h3 id="inner-函式內發生的事"><a href="#inner-函式內發生的事" class="headerlink" title="inner 函式內發生的事"></a>inner 函式內發生的事</h3><p>與前面介紹的一樣，會先創造執行環境，因此</p><ul><li>在這個函式內找不到任何的參數、宣告函式、宣告變數</li></ul><p>所以當前狀態是這樣的</p><p><img src="https://cdn-images-1.medium.com/max/800/1*_AHwnsE7jdkO6MNoKgZbcw.png" alt></p><p>接著逐行執行 <code>inner</code> 函式內的程式碼</p><ul><li>於 1173 行印出變數 <code>a</code> ，但所屬 VO 內找不到變數 <code>a</code> ，轉而向上一層尋找，此時會找到 test VO 的 <code>a</code> ，所以會印出 8</li><li>於 1174 行對變數 <code>a</code> 賦值，但所屬 VO 內找不到變數 <code>a</code> ，所以這邊的賦值其實是對 test VO 的 <code>a</code> ，因此被重新賦值為 30</li><li>於 1175 行對變數 <code>b</code> 賦值，但逐層往上找也找不到變數 <code>b</code> ，最後會在全域執行環境內產生變數 <code>b</code> ，並賦值 200</li></ul><p><strong>至此 <code>inner</code> 函式執行完畢，被移出執行堆。</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*2OA5ia1GnQbDR3TIBdHg3A.png" alt></p><p>目前執行堆最上方是 <code>test</code> 函式。</p><h3 id="因此會回到-test-函式內繼續進行沒執行的部分"><a href="#因此會回到-test-函式內繼續進行沒執行的部分" class="headerlink" title="因此會回到 test 函式內繼續進行沒執行的部分"></a>因此會回到 test 函式內繼續進行沒執行的部分</h3><ul><li>於 1171 行印出變數 <code>a</code> ，此時對照 <code>a</code> 為 30</li><li>1172 ~ 1177 跳過</li></ul><p><strong>至此 <code>test</code> 函式執行完畢，被移出執行堆。</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*4ZyKkQk9VmupFpj92yeAjw.png" alt></p><h3 id="回到全域執行環境，繼續進行沒執行的部分。"><a href="#回到全域執行環境，繼續進行沒執行的部分。" class="headerlink" title="回到全域執行環境，繼續進行沒執行的部分。"></a>回到全域執行環境，繼續進行沒執行的部分。</h3><ul><li>於 1179 行印出變數 <code>a</code> ， 此時對照 <code>a</code> 為 1</li><li>於 1180 行對變數 <code>a</code> 賦值，因此 <code>a</code> 被修改為 70</li><li>於 1181 行印出變數 <code>a</code> ， 此時對照 <code>a</code> 為 70</li><li>於 1182 行印出變數 <code>b</code> ，此時對照 <code>b</code> 為 200</li></ul><p>至此，程式碼執行完畢，全域執行環境被移出。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*C2ugWkHMLiBoW0bfd1eE6w.png" alt></p><p>接著我們可以實際運行這一段程式碼，會發現答案是吻合的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Pt0s_Swz5iW1oCohyqhCwQ.png" alt></p><p>是不是相當的神奇呢？</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>若要我說觀看影片到現在的心得，我覺得最屌的莫過於上一篇跟這一篇了，沒想到還可以用這樣子的方式了解 hoisting ，這是我上 JS 奇怪部份時完全沒有的體驗，真的是太棒了！</p><p>但我知道後面應該還有更多類似這樣的體驗，真的是很開心自己能有這樣的機會學習關於 JavaScript 底層。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      好的，接著我們要假裝自己是 JS 引擎，然後用 ECMAScript 文件上的規則來找出上一節開頭問題的答案哦～
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.59 hoisting 的原理為何</title>
    <link href="http://pvt5r486.github.io/f2e/20190306/3202359618/"/>
    <id>http://pvt5r486.github.io/f2e/20190306/3202359618/</id>
    <published>2019-03-05T20:02:17.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在受到前面兩小節的洗禮後，對於 hoisting 應該有更明確的認知，這節影片要帶領我們從 ECMAScript 了解 hoisting 的原理為何。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*R2Pp4BuJiptMIOC1" alt></p><h2 id="hoisting-amp-scope-小測驗"><a href="#hoisting-amp-scope-小測驗" class="headerlink" title="hoisting &amp; scope 小測驗"></a>hoisting &amp; scope 小測驗</h2><p>首先，讓我們打鐵趁熱，來份 hoisting 的考題吧，說不定面試會考哦？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(&apos;1.&apos;, a);  </span><br><span class="line">  var a = 7;  </span><br><span class="line">  console.log(&apos;2.&apos;, a);  </span><br><span class="line">  a++;  </span><br><span class="line">  var a;  </span><br><span class="line">  inner();  </span><br><span class="line">  console.log(&apos;4.&apos;, a);  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    console.log(&apos;3.&apos;, a);  </span><br><span class="line">    a = 30;  </span><br><span class="line">    b = 200;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test();  </span><br><span class="line">console.log(&apos;5.&apos;, a);  </span><br><span class="line">a = 70;  </span><br><span class="line">console.log(&apos;6.&apos;, a);  </span><br><span class="line">console.log(&apos;7.&apos;, b);</span><br></pre></td></tr></table></figure><p></p><p>請依序寫出印出來的答案是多少。</p><p>還沒看解答之前我的答案是這樣，我把內容調換過用來幫助自己思考。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    console.log(&apos;3.&apos;, a); // 8  </span><br><span class="line">    a = 30;  </span><br><span class="line">    b = 200;  </span><br><span class="line">  &#125;  </span><br><span class="line">  var a;  </span><br><span class="line">  console.log(&apos;1.&apos;, a); // undefined  </span><br><span class="line">  a = 7;  </span><br><span class="line">  console.log(&apos;2.&apos;, a); // 7  </span><br><span class="line">  a=a+1;  </span><br><span class="line">  var a;  </span><br><span class="line">  inner();  </span><br><span class="line">  console.log(&apos;4.&apos;, a); // 8</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">test();  </span><br><span class="line">console.log(&apos;5.&apos;, a); // 1  </span><br><span class="line">a = 70;  </span><br><span class="line">console.log(&apos;6.&apos;, a); // 70  </span><br><span class="line">console.log(&apos;7.&apos;, b); // 200</span><br></pre></td></tr></table></figure><p></p><p>後來對照答案後，發現<strong>第四題粗心寫錯了，應該是印出 30</strong> 才對。</p><p>但是其他都如同我想的，這代表先前的學習、寫文章記錄加深印象是有效的，往後我也會繼續這麼做。</p><h2 id="我判斷答案時用到的觀念有："><a href="#我判斷答案時用到的觀念有：" class="headerlink" title="我判斷答案時用到的觀念有："></a>我判斷答案時用到的<strong>觀念</strong>有：</h2><ul><li>ECMAScript基本觀念</li><li>hoisting 順序</li><li>變數作用域與範圍鏈</li><li>var 的特性<blockquote><p><strong>可…可惡，JavaScript 的陷阱真多！</strong></p></blockquote></li></ul><h2 id="ECMAScript-如何解釋-hoisting"><a href="#ECMAScript-如何解釋-hoisting" class="headerlink" title="ECMAScript 如何解釋 hoisting"></a>ECMAScript 如何解釋 hoisting</h2><p>ECMAScript 是制定 JavaScript 的標準，因此也可以說是 JavaScript 的聖經，本節影片的作者要帶領我們如何透過 ECMAScript 的文件了解 JavaScript 的行為。</p><p>隨著時間過去 ECMAScript 的文件也會越來越多，但並不會影響原作者想要傳達的目的，本節會使用較舊的版本介紹。</p><h3 id="本節使用文件"><a href="#本節使用文件" class="headerlink" title="本節使用文件"></a>本節使用文件</h3><ul><li><a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript — Ecma-262 ,1999年12月</a> 第 10 節</li></ul><h3 id="執行環境-Execution-Contexts"><a href="#執行環境-Execution-Contexts" class="headerlink" title="執行環境 (Execution Contexts)"></a>執行環境 (Execution Contexts)</h3><blockquote><p><strong>以下節錄自文件</strong><br>When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context</p></blockquote><p>不過我拿去 google 翻譯看完之後發現根本不懂這敘述再寫什麼 (汗</p><p>但就之前的筆記，我對於<strong>執行環境</strong>的認知是：</p><ul><li>當 JavaScript 開始運行時，會先建立一個全域執行環境</li><li>之後每進入一個函式 function 就會再度創造一個執行環境</li><li>而這些執行環境會按照執行順序被堆疊起來，稱為執行堆</li><li>執行堆最高的會優先被執行，執行完畢後將被移出執行堆</li><li>當全域執行環境也被移出時，代表 JavaScript 程式已經運行完畢</li></ul><p><strong>以圖片來總結上面那些話，大概就長這樣</strong>：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*cc85KDCTW5BzZ1sgCyKt1A.png" alt="資料來源: [我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)"><br>資料來源: <a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/" rel="external nofollow noopener noreferrer" target="_blank">我知道你懂 hoisting，可是你了解到多深？</a></p><h3 id="變數初始化-Variable-Instantiation"><a href="#變數初始化-Variable-Instantiation" class="headerlink" title="變數初始化 (Variable Instantiation)"></a>變數初始化 (Variable Instantiation)</h3><blockquote><p><strong>以下節錄自文件</strong><br>Every execution context has associated with it a <strong>variable object</strong>.Variables and functions declared in the source text are added as properties of the variable object.On entering an execution context, the properties are bound to the variable object in the following order:</p></blockquote><p>文件下面還有很多落落長的敘述，有興趣可以點進去看。</p><h3 id="我理解的大意是"><a href="#我理解的大意是" class="headerlink" title="我理解的大意是"></a>我理解的大意是</h3><ul><li>每一個執行環境都有一個<strong>變數物件</strong> (variable object)</li><li>在執行環境內宣告的函式或變數都會被加到變數物件內成為屬性 (properties)</li><li>當進入執行環境時，屬性會按照順序綁定到變數物件上</li><li>當進入執行環境時，會把函式的參數放到變數物件上，值就是當時呼叫這個函式所帶入的值，若未傳入值則初始化為 <code>undefined</code></li><li>對於函式，如果變數物件已經有同名的屬性，則取代裡面的值</li><li>對於變數，如果宣告的變數已經重複，則什麼事情都不會發生，若未重複則將該變數初始化為 <code>undefined</code></li></ul><p><strong>白話的用一些程式表示</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variableObject: &#123;  </span><br><span class="line">  a: 1  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test()&#123;  </span><br><span class="line">  var a = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><ul><li><p>當 <code>test</code> 函式被執行，執行環境建立並進入，裡面宣告的 <code>a</code> 會被加到變數物件內成為屬性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variableObject: &#123;  </span><br><span class="line">  a: 123,  </span><br><span class="line">  b: undefined  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(a, b)&#123;&#125;  </span><br><span class="line">test(123);</span><br></pre></td></tr></table></figure></li><li><p>當進入執行環境時，會把函式的參數放到變數物件上，如果未傳入參數的值，則初始化為 <code>undefined</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variableObject: &#123;  </span><br><span class="line">  a: point to function a,  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(a)&#123;  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test(123);</span><br></pre></td></tr></table></figure></li><li><p>對於函式，如果變數物件已經有同名的屬性，則取代裡面的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variableObject: &#123;  </span><br><span class="line">  a: 10  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(a)&#123;  </span><br><span class="line">  var a;  </span><br><span class="line">&#125;  </span><br><span class="line">test(10);</span><br></pre></td></tr></table></figure></li><li><p>對於變數，如果宣告的變數已經重複，則什麼事情都不會發生</p></li></ul><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>透過 ECMAScript 的文件解釋，我們可以理解原來 hoisting 背後的原理是這樣，相較於前面我們對於 hoisting 的觀察是較為表面的 (所以那個時候都說，我們可以把這一段程式碼想成 …)</p><p>但現在我們透過 ECMAScript 文件了解這些規則，接下來我們要嘗試用這一套規則來回答一開始的問題。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在受到前面兩小節的洗禮後，對於 hoisting 應該有更明確的認知，這節影片要帶領我們從 ECMAScript 了解 hoisting 的原理為何。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.58 hoisting 順序</title>
    <link href="http://pvt5r486.github.io/f2e/20190305/1172397453/"/>
    <id>http://pvt5r486.github.io/f2e/20190305/1172397453/</id>
    <published>2019-03-05T00:57:17.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hoisting 有<strong>順序</strong>? 抱歉我也不知道，不知道的東西就該好好記錄下來～</p><p><img src="https://cdn-images-1.medium.com/max/800/0*RFA8Udb3F6967pl-" alt></p><h2 id="hoisting-順序問題"><a href="#hoisting-順序問題" class="headerlink" title="hoisting 順序問題"></a>hoisting 順序問題</h2><p>前篇了解基礎觀念後，接著要來了解一些之前從來沒有想過的問題。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  var a = &apos;local&apos;;  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test();　// ƒ a()&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>宣告變數 <code>a</code> 之後，在宣告一個 <code>a</code> 的函式陳述式，結果居然會印出函式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">  var a = &apos;local&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">test();　// ƒ a()&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>再將順序調換，仍然印出函式。</p><blockquote><p>代表 hoisting 後的順序，<strong>函式的優先權是比變數高的</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">  var a;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  a = &apos;local&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // ƒ a()&#123;&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>可以把原本的程式碼想像成上面這樣，這邊也有個陷阱。</p><p>我們可能會想說：「<strong>明明下一行是 <code>var a</code> 可是為什麼印出來的 <code>a</code> 不是 <code>undefined</code></strong>」</p><p>然而 JavaScript 是這樣的：</p><ul><li>var 可以重複宣告變數</li><li>使用 var 宣告的變數如果<strong>已經存在</strong>，且<strong>新宣告同名的變數又未賦值</strong>時，則不會對原本變數造成影響。</li></ul><p>這段話的意思用程式碼表達是這樣的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;  </span><br><span class="line">var a;  </span><br><span class="line">var a;  </span><br><span class="line">console.log(a); // 10;  </span><br><span class="line">var a;  </span><br><span class="line">var a;  </span><br><span class="line">var a;  </span><br><span class="line">var a = &apos;安安&apos;;  </span><br><span class="line">console.log(a); // 安安;</span><br></pre></td></tr></table></figure><p></p><p>回到原本的例子，就可以明白為何還是印出函式了。</p><p><strong>同樣的例子，再度調換程式碼位置</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = &apos;local&apos;;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // local</span><br></pre></td></tr></table></figure><p></p><p>如果這邊回答印出函式，那麼代表又中陷阱啦～</p><p>根據剛剛的觀念，好好的來排一下順序:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  function a()&#123;&#125;  </span><br><span class="line">  var a;  </span><br><span class="line">  a = &apos;local&apos;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // local</span><br></pre></td></tr></table></figure><p></p><ul><li>函式有優先權，先提升</li><li>再來是變數，<strong>賦值不會提升</strong></li><li>同名變數又被<strong>重新賦值</strong></li></ul><p>所以結果才會是 local</p><h3 id="同名函式的-hoisting-優先順序"><a href="#同名函式的-hoisting-優先順序" class="headerlink" title="同名函式的 hoisting 優先順序"></a>同名函式的 hoisting 優先順序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  function a()&#123;  </span><br><span class="line">    console.log(1);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  function a()&#123;  </span><br><span class="line">    console.log(2);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  var a = &apos;local&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">test(); // ƒ a()&#123;console.log(2);&#125;</span><br></pre></td></tr></table></figure><p>由此可知，同名函式的情況下，很合理的是<strong>後面蓋前面</strong>。</p><h3 id="函式有參數的情況下"><a href="#函式有參數的情況下" class="headerlink" title="函式有參數的情況下"></a>函式有參數的情況下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  var a = 456;  </span><br><span class="line">&#125;  </span><br><span class="line">test(123); // 123</span><br></pre></td></tr></table></figure><p>此時相當於<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;  </span><br><span class="line">  var a;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  a = 456;  </span><br><span class="line">&#125;  </span><br><span class="line">test(123); // 123</span><br></pre></td></tr></table></figure><p></p><p>可知<strong>參數 hoisting 的優先權是大於變數的。</strong></p><p>接著來測試<strong>參數與函式的優先權</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">  function a()&#123;  </span><br><span class="line">      </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test(123); // ƒ a()&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>可知<strong>函式 hoisting 的優先權是大於參數的。</strong></p><h2 id="hoisting-優先順序總結"><a href="#hoisting-優先順序總結" class="headerlink" title="hoisting 優先順序總結"></a>hoisting 優先順序總結</h2><ul><li>函式 (function) 最優先</li><li>參數 (arguments) 其次</li><li>變數最後</li></ul><blockquote><p>除了考慮 hoisting 順序以外，也與程式碼的執行順序有關。<br>所以最後再來個例子，考考自己有沒有懂：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;  </span><br><span class="line">  console.log(a); // 123  </span><br><span class="line">  var a = 456;  </span><br><span class="line">  console.log(a); // 456  </span><br><span class="line">&#125;  </span><br><span class="line">test(123);</span><br></pre></td></tr></table></figure><p></p></blockquote><p>＝＝＝＝＝＝＝＝<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;  </span><br><span class="line">  var a;  </span><br><span class="line">  console.log(a); // 123  </span><br><span class="line">  a = 456;  </span><br><span class="line">  console.log(a); // 456  </span><br><span class="line">&#125;  </span><br><span class="line">test(123);</span><br></pre></td></tr></table></figure><p></p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一小節真的是太猛啦，根據前世的記憶（？），奇怪部分對於 hoisting 的補充並沒有這麼多範例，而且我也從來沒想過 hoisting 這邊可以有這麼多陷阱。</p><p><strong>真的是非常感謝這一系列影片，覺得自己又更認識 JavaSctipt 一點。</strong></p><p>然後，關於 hoisting 還不只這樣哦，還要繼續深～下去。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      hoisting 有順序? 抱歉我也不知道，不知道的東西就該好好記錄下來～
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.57 hoisting 基本觀念</title>
    <link href="http://pvt5r486.github.io/f2e/20190305/727543988/"/>
    <id>http://pvt5r486.github.io/f2e/20190305/727543988/</id>
    <published>2019-03-04T22:56:55.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hoisting (提升) 也是常常被拿出來詢問的觀念，所以我決定要好好地記錄下來，拆成多篇記錄，由淺入深。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*OmXqrUkiOUcfgHfL" alt></p><h2 id="hoisting-提升"><a href="#hoisting-提升" class="headerlink" title="hoisting (提升)"></a>hoisting (提升)</h2><p>使用一連串的範例來了解 hoisting 做了些什麼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(b); // b is not defined</span><br></pre></td></tr></table></figure><p></p><p>因為辦法使用未宣告的變數。</p><p>但如果改成這樣子寫，就不會出錯了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined  </span><br><span class="line">var a = 10;</span><br></pre></td></tr></table></figure><p></p><p>這裡就是 hoisting 的一個特性，可以想像成它把所有的宣告提升到第一行，也就是說這段程式碼與下列這段程式碼的結果是一樣的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">console.log(a); // undefined  </span><br><span class="line">a = 10;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>但必須注意的是，hoisting 並不是真的物理性的把程式碼給拉到第一行。</p></blockquote><h3 id="從這邊可以知道一些-hoisting-的特性："><a href="#從這邊可以知道一些-hoisting-的特性：" class="headerlink" title="從這邊可以知道一些 hoisting 的特性："></a>從這邊可以知道一些 hoisting 的特性：</h3><ul><li>變數宣告會被提升，賦值不會</li></ul><p>除了變數之外，其實函式也具有 hoisting 特性，但在介紹之前，先簡單複習一下函式陳述式 (Function Statements) 與函式表示式 (Function Expressions)，或者點一下<a href="https://pvt5r486.github.io/javascript/20190123/1596425308">[JavaScriptWeird]No.26 函式表示式與函式陳述句</a>複習。</p><h2 id="函式表示式與函式陳述式"><a href="#函式表示式與函式陳述式" class="headerlink" title="函式表示式與函式陳述式"></a>函式表示式與函式陳述式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是函式陳述式，下面是函式表示式<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anonymousGreet = function greet() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這邊只要知道這樣就可以了，接著來看範例。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test();  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(&apos;Hello&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這個範例的 hoisting 就算是 JavaScript 的初學者一定也遇過，因為 hoisting 的關係，所以允許把函式寫在呼叫該函式的下方，這在某些程式語言是做不到的，而我們也可以把這段程式想像成這樣，結果是一樣的:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  console.log(&apos;Hello&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><p><strong>但如果函式寫成表示式的話，就沒有提升的效果了。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(); // test is not a function  </span><br><span class="line">var test = function()&#123;  </span><br><span class="line">  console.log(&apos;Hello&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其實原因很簡單，因為我們一開始看的範例已經得知：</p><blockquote><p>只有變數宣告會被提升，賦值不會</p></blockquote><p>也就是說這段程式碼可以看成這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var test; // undefined  </span><br><span class="line">test();  </span><br><span class="line">test = function()&#123;  </span><br><span class="line">  console.log(&apos;Hello&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由於變數 <code>test</code> 的值是 <code>undefined</code> ，並不是函式所以無法被呼叫。</p><h2 id="對現況再做個總整理："><a href="#對現況再做個總整理：" class="headerlink" title="對現況再做個總整理："></a>對現況再做個總整理：</h2><ul><li>變數宣告會被提升，賦值不會</li><li>函式陳述式會被提升，<strong>函式表示式不會 (因為提升的是變數宣告)</strong></li></ul><h2 id="最後再來個陷阱題"><a href="#最後再來個陷阱題" class="headerlink" title="最後再來個陷阱題"></a>最後再來個陷阱題</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a); // undefined  </span><br><span class="line">  var a = &apos;local&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>可能會很直覺的回答變數 <code>a</code> 會印出 <code>global</code> ，因為 <code>test</code> 函式內並沒有看到變數 <code>a</code> 。</p><p>但這邊事實上會印出 <code>undefined</code> ，因為 hoisting 會發生在變數的 scope 裡面，也就是說我們可以想像成這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  var a;  </span><br><span class="line">  console.log(a); // undefined  </span><br><span class="line">  a = &apos;local&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><blockquote><p>可…可惡，陷阱真多！</p></blockquote><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>關於 hoisting 的基礎觀念大概是這樣，但其實 hoisting 背後還有相當深的觀念需要了解，特別推薦 Huli 大大的作品 - <a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/" rel="external nofollow noopener noreferrer" target="_blank"><strong>我知道你懂 hoisting，可是你了解到多深？</strong></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      hoisting (提升) 也是常常被拿出來詢問的觀念，所以我決定要好好地記錄下來，拆成多篇記錄，由淺入深。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.56 let 與 const 的生存範圍</title>
    <link href="http://pvt5r486.github.io/f2e/20190303/1243977741/"/>
    <id>http://pvt5r486.github.io/f2e/20190303/1243977741/</id>
    <published>2019-03-02T21:06:32.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇提到了在 ES6 之前變數的生存範圍，接著要提到的是於 ES6 時新增加的兩個變數宣告方式：let 與 const 。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*j3gXqe7cmTznRTl6" alt></p><h2 id="let-與-const-的生存範圍"><a href="#let-與-const-的生存範圍" class="headerlink" title="let 與 const 的生存範圍"></a>let 與 const 的生存範圍</h2><p>關於變數的作用域 (scope)：</p><ul><li>ES6 之前作用域的劃分都是以 函式 (function) 來界定</li><li>ES6 開始則增加了以區塊 (block) 來劃分的方式，其中區塊的表示方式使用大括號 { } 來表示。</li></ul><blockquote><p>而 <code>let</code> 與 <code>const</code> 的作用域就是屬於以 block 來劃分的方式。</p></blockquote><h3 id="作用域以函式-function-為劃分的例子"><a href="#作用域以函式-function-為劃分的例子" class="headerlink" title="作用域以函式 (function) 為劃分的例子"></a>作用域以函式 (function) 為劃分的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  if (a === 10)&#123;  </span><br><span class="line">    var b = 60;  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(b); // 60  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>這個例子因為所有的程式都被包覆在 <code>test</code> 函式內，所以 <code>console.log</code> 可以取用變數 <code>b</code> 。</p><h3 id="作用域以區塊-block-為劃分的例子"><a href="#作用域以區塊-block-為劃分的例子" class="headerlink" title="作用域以區塊 (block) 為劃分的例子"></a>作用域以區塊 (block) 為劃分的例子</h3><p>使用同一個例子當作對照組<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  if (a === 10)&#123;  </span><br><span class="line">    let b = 60;  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(b); // b is not defined  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><p>原因是因為「<strong>使用 <code>let</code> 、 <code>const</code> 宣告的變數作用域只存活在 { } 中</strong>」。</p><p>也就是說這個例子中的變數 <code>b</code> 只存活於 <code>if</code> 的 {} 內 。</p><h3 id="函式本身也是一個區塊-block"><a href="#函式本身也是一個區塊-block" class="headerlink" title="函式本身也是一個區塊 (block)"></a>函式本身也是一個區塊 (block)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  let a = 10;  </span><br><span class="line">  if (a === 10)&#123;  </span><br><span class="line">    console.log(a); // 10  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(a); // 10  </span><br><span class="line">&#125;  </span><br><span class="line">test()  </span><br><span class="line">console.log(a); // a is not defined</span><br></pre></td></tr></table></figure><p>意思就是如果像這樣把變數用 <code>let</code> 宣告在函式內的話，其實跟使用 <code>var</code> 來宣告變數是一樣的。</p><h3 id="原來可以這樣用的例子"><a href="#原來可以這樣用的例子" class="headerlink" title="原來可以這樣用的例子"></a>原來可以這樣用的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  &#123;  </span><br><span class="line">    let a = 10;  </span><br><span class="line">    console.log(a); // 10  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(a); // error  </span><br><span class="line">&#125;  </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>看影片才知道原來可以直接使用 {} 建立一個區塊 (block)，然後這邊得到的結果也與上面提到的觀念一致， {} 外嘗試取用變數 <code>a</code> 是沒辦法的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇提到了在 ES6 之前變數的生存範圍，接著要提到的是於 ES6 時新增加的兩個變數宣告方式： let 與 const 。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.5 全台空氣指標儀表板</title>
    <link href="http://pvt5r486.github.io/f2e/20190227/3856631838/"/>
    <id>http://pvt5r486.github.io/f2e/20190227/3856631838/</id>
    <published>2019-02-27T00:55:43.000Z</published>
    <updated>2020-02-16T05:52:53.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="預覽圖"><a href="#預覽圖" class="headerlink" title="預覽圖"></a>預覽圖</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*cn3Hm-H9keNfOc9Y7GTeIA.png" alt></p><h1 id="本層-BOSS-弱點"><a href="#本層-BOSS-弱點" class="headerlink" title="本層 BOSS 弱點"></a>本層 BOSS 弱點</h1><ul><li>【特定技術】必須使用 AJAX 技術串接資料 API，不可直接寫死資料在變數上</li><li>【特定技術】上方切換城市 (高雄、台北) 後，下方會切換該城市的各地區</li><li>【解決問題】糟糕，BOSS 使用屏蔽魔法將 API 出處移除了，身為勇者的你必須查出 API 的下落，才能順利擊敗此 BOSS。</li></ul><h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul><li>Vue.js</li><li>SCSS</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不知不覺小菜雞也挑戰到第五層了，這一層樓的版面看起來也是蠻輕鬆就能搞定，所以為了給自己一點點挑戰性，我稍微添加了一點互動回饋：</p><ul><li>使用 CSS animation 製作 Loading 畫面</li><li>點擊時補上內凹的陰影，使其更加真實</li></ul><p>接著就是寫程式的部分了，不得不說做這種跟資料相關的版面，使用 Vue 真的是輕鬆很多，只要專注在資料的處理上就好了，所以當我看到這次的題目是 AQI 儀表板，想都沒想就決定要用 Vue 寫了。</p><h3 id="所以我說那個-API-在哪？"><a href="#所以我說那個-API-在哪？" class="headerlink" title="所以我說那個 API 在哪？"></a>所以我說那個 API 在哪？</h3><p>身為一個前端菜雞，菜歸菜但基本的資料蒐集能力還是要有的，我下的關鍵字是「行政院環境保護署 API」，果不其然第一筆搜尋結果就是答案。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*58ZCea-VxO4Jm7eHM7RTIw.png" alt></p><p>一進網站就馬上發現目標了，空氣品質指標 AQI ，接著只要切到<strong>資料檢視頁籤</strong>，在選擇 <strong>JSON 格式</strong>就可以囉。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ifUbetf60c0tpmyhXTMlsA.png" alt></p><h3 id="CORS-怎麼處理？"><a href="#CORS-怎麼處理？" class="headerlink" title="CORS 怎麼處理？"></a>CORS 怎麼處理？</h3><p>以下引用自 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS" rel="external nofollow noopener noreferrer" target="_blank"><strong>MDN</strong></a> 的說明：跨來源資源共用 (Cross-Origin Resource Sharing (CORS)) 是一種使用額外 HTTP 標頭令目前瀏覽網站的使用者代理取得存取其他來源 (網域) 伺服器特定資源權限的機制。當使用者代理請求一個不是目前文件來源 - 例如來自於不同網域 (domain) 、通訊協定 (protocol) 或通訊埠 (port) 的資源時，會建立一個跨來源 HTTP 請求 (cross-origin HTTP request)</p><p>白話來說，就是這支空氣品質指標的 API 沒有打開 CORS ，所以如果我們把做好的網頁成品發佈到 GitHub 、 Codepen 的話是不能撈取資料的。</p><p>我之前的作法都是使用別人建立好的服務，像是這個：</p><ul><li><a href="https://cors-anywhere.herokuapp.com/http://opendata2.epa.gov.tw/AQI.json" rel="external nofollow noopener noreferrer" target="_blank">https://cors-anywhere.herokuapp.com/</a></li></ul><p>用法相當容易，只需要在後方加入要使用的 API 即可。</p><p>但是這一次，我在討論區上看到其他大神們分享這個方法，讓我躍躍欲試。</p><h3 id="使用-Google-Apps-Script-做中繼點跨網域遠端取得-API-資料"><a href="#使用-Google-Apps-Script-做中繼點跨網域遠端取得-API-資料" class="headerlink" title="使用 Google Apps Script 做中繼點跨網域遠端取得 API 資料"></a>使用 Google Apps Script 做中繼點跨網域遠端取得 API 資料</h3><p>使用這個服務必須要申請一個 Google 帳號，接著我們來到雲端硬碟的畫面。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*qkB49aKTyurqozWiU6yAKA.png" alt></p><p>左上角有個「新增」按鈕點進去即可看到這個畫面，因為之前我已經有操作過了，如果是第一次使用要點選「連結更多應用程式」，接著於搜尋欄輸入「script」即可找到這個服務囉。</p><p>接著可以在程式碼內貼上這一段程式碼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doGet(e)&#123;  </span><br><span class="line">  var param = e.parameter;  </span><br><span class="line">  var url = param.url;  </span><br><span class="line">  var response = UrlFetchApp.fetch(decodeURIComponent(url),&#123;  </span><br><span class="line">    headers: &#123; &quot;Content-type&quot; : &quot;application/json&quot; &#125;  </span><br><span class="line">  &#125;);  </span><br><span class="line">  var data = JSON.parse(response.getContentText());  </span><br><span class="line">  return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接著按下<strong>發布 &gt; 部署為網路應用程式</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*MoNuXlYH-tnXRFoskNdb_Q.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*d7v_jFCv3jICTdA4Pmf57Q.png" alt></p><blockquote><p>使用方式：部署的網址?參數名稱= API 網址</p></blockquote><p>這樣子只要一次工，之後練習的作品全部都可以透過這個服務解決掉 CORS 的問題唷</p><blockquote><p>如果是工作上遇到的 CORS ，可能就不適合這個方法囉。</p></blockquote><p><a href="https://mtwmt.github.io/blog/api_cors_error/" rel="external nofollow noopener noreferrer" target="_blank">本段圖片、程式碼引用自此</a>，感謝大大的分享。</p><h4 id="取得-API-資料的方式"><a href="#取得-API-資料的方式" class="headerlink" title="取得 API 資料的方式"></a>取得 API 資料的方式</h4><p>這方式也是有蠻多種的，如果想方便一點可以使用 <a href="https://github.com/axios/axios" rel="external nofollow noopener noreferrer" target="_blank">axios</a> 這個非常強大的套件，而且討論區中也非常多人使用，而且它本身也有 Promise 的功能了。</p><p>用法相當簡單，像是這樣即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;  </span><br><span class="line">  method:&apos;get&apos;,  </span><br><span class="line">  url:apiUrl,  </span><br><span class="line">&#125;)  </span><br><span class="line">.then(function (response) &#123;  </span><br><span class="line">  vm.allData = response.data;  </span><br><span class="line">  vm.updateTime = vm.getTime();  </span><br><span class="line">  vm.Detail = vm.initDetail();  </span><br><span class="line">  vm.isLoading = false;  </span><br><span class="line">&#125;)  </span><br><span class="line">.catch(function (error) &#123;  </span><br><span class="line">  vm.updateTime = vm.getTime();  </span><br><span class="line">  vm.isLoading = false;  </span><br><span class="line">  console.log(&apos;取得資料失敗:&apos; + error);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>更詳細可以參考 <a href="https://github.com/axios/axios" rel="external nofollow noopener noreferrer" target="_blank">axios</a> 的官方說明。</p><p>雖然說這樣就可以了，不過因為我不懂 Promise 是什麼，該如何與 Ajax 結合取得資料，所以決定自己動手做看看，用土法煉鋼的方式(?</p><p>首先因為我完全不懂，所以直接上網 google 了一下:</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10197529" rel="external nofollow noopener noreferrer" target="_blank">JavaScript — Promise</a></li><li><a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" rel="external nofollow noopener noreferrer" target="_blank">輕鬆理解 Ajax 與跨來源請求</a></li><li><a href="https://wcc723.github.io/life/2017/05/25/promise/" rel="external nofollow noopener noreferrer" target="_blank">JavaScript ES6 Promise</a></li></ul><p>所以大概對於 Promise 有一點點的概念，總之就大概長得像這樣?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;  </span><br><span class="line">  if (...) &#123;  </span><br><span class="line">    resolve();  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    reject();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">promise.then((res) =&gt; &#123;  </span><br><span class="line">   </span><br><span class="line">&#125;);  </span><br><span class="line">promise.catch((error) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>大概就是理解成，建立一個 Promise 然後可以用兩個函式 resolve 、 reject 分別代表兌現或是失敗。</p><ul><li>如果使用 <code>resolve()</code> ，接著程式會運行 <code>.then</code> 的部分</li><li>如果使用 <code>reject()</code> ，接著程式會運行 <code>.catch</code> 的部分</li></ul><p>然後搭配 <code>XMLHttpRequest()</code> 應該就沒問題了</p><p>並將程式碼修改如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;  </span><br><span class="line">  let xhr = new XMLHttpRequest();  </span><br><span class="line">  xhr.open(&apos;get&apos;, apiUrl, true);  </span><br><span class="line">  xhr.send(null);  </span><br><span class="line">  xhr.onload = () =&gt;&#123;  </span><br><span class="line">    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123;  </span><br><span class="line">      resolve(xhr.response);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">      reject(&quot;取得資料失敗: &quot; + xhr.status);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">promise.then((res) =&gt; &#123;  </span><br><span class="line">  vm.allData = JSON.parse(res);    </span><br><span class="line">&#125;);  </span><br><span class="line">promise.catch((error) =&gt; &#123;  </span><br><span class="line">  console.log(error);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>這樣就完成了呢，不過這邊有個小小的問題，就是用 <code>XMLHttpRequest()</code> 取到的結果會是字串，要額外透過 <code>JSON.parse()</code> 轉成 JSON 才可以使用。</p><blockquote><p><strong>所以結論就是 axios 好用</strong></p></blockquote><h2 id="使用-filter-方法取出不重複的值"><a href="#使用-filter-方法取出不重複的值" class="headerlink" title="使用 filter() 方法取出不重複的值"></a>使用 filter() 方法取出不重複的值</h2><p>處理好 API 的問題後，再來就要實作內容了，這個部份很基本，不過我卻每次都會忘記該怎麼處理，所以決定這一次把它寫下來。</p><p>而取出陣列中不重複的值做法有很多種，我習慣用 <code>filter()</code> 就是了。</p><p>基本的 <code>filter()</code> 起手式是這樣，會回傳一個新陣列：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;apple&apos;, &apos;banana&apos;, &apos;lemon&apos;, &apos;apple&apos;, &apos;watermelon&apos;, &apos;grape&apos;];  </span><br><span class="line">let result = arr.filter((item, index, array) =&gt;&#123;  </span><br><span class="line">  console.log(item, index, array);  </span><br><span class="line">  return item;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>而這些參數分別代表為：</p><ul><li><code>item</code>— 當前是 <code>arr</code> 陣列中的哪一個值，如「 <code>apple</code> 」</li><li><code>index</code>— 這個值在 <code>arr</code> 陣列中的索引，如「 <code>apple</code> 」的索引為 0</li><li><code>array</code>— 這個陣列的內容</li></ul><p>比方說想從陣列找出 apple ，可以在 <code>return</code> 後補上條件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;apple&apos;, &apos;banana&apos;, &apos;lemon&apos;, &apos;apple&apos;, &apos;watermelon&apos;, &apos;grape&apos;];  </span><br><span class="line">let result = arr.filter((item, index, array) =&gt;&#123;  </span><br><span class="line">  return item === &apos;apple&apos;  </span><br><span class="line">&#125;);  </span><br><span class="line">console.log(result); // [&quot;apple&quot;, &quot;apple&quot;]</span><br></pre></td></tr></table></figure><p></p><p>如果想找出陣列中的不重複值，則條件就複雜多了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;apple&apos;, &apos;banana&apos;, &apos;lemon&apos;, &apos;apple&apos;, &apos;watermelon&apos;, &apos;grape&apos;];  </span><br><span class="line">let result = arr.filter((item, index, array) =&gt;&#123;  </span><br><span class="line">  return array.indexOf(item) === index;  </span><br><span class="line">&#125;);  </span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p></p><p>使用了一個方法 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="external nofollow noopener noreferrer" target="_blank">indexOf()</a> ，這會回傳從陣列中<strong>第一個被找到的目標索引</strong>，若不存在於陣列中則回傳 -1。</p><p>也就是說這段程式碼實際上是這麼跑的：</p><ul><li><code>arr</code> 陣列的第一個元素是 <code>apple</code> ，<code>array.indexOf(&#39;apple&#39;)</code> 的結果為 0，所以實際上會像這個樣子 <code>0 === index</code> ，然而目前是陣列中的第一個元素，索引是 0 ，因此結果是 <code>true</code> ，將 <code>apple</code> 加入新陣列中。</li><li>第二、第三個元素也同第一個元素，以此類推。</li><li>當跑到第四個元素時，<code>array.indexOf(&#39;apple&#39;)</code> 的結果為 0，而當前的索引是 3 ，因此結果是 <code>false</code> ，不加入。</li><li>第五個元素時，<code>array.indexOf(&#39;watermelon&#39;)</code> 的結果為 4，而當前的索引是 4，因此結果是 <code>true</code> ，將 <code>watermelon</code> 加入新陣列中。</li><li>當所有元素都執行完時，回傳新陣列。</li></ul><p>所以才能找出陣列中不重複的值，透過這樣的方式，要找出陣列中重複的值也很容易，只要 === 改成 !== 就可以了。</p><h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><ul><li><a href="https://github.com/pvt5r486/JSD5_AQI" rel="external nofollow noopener noreferrer" target="_blank">線上DEMO</a></li><li><a href="https://pvt5r486.github.io/JSD5_AQI/index.html">DEMO</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      六角 JavaScriptDungeon 全台空氣指標儀表板
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.55 變數的生存範圍</title>
    <link href="http://pvt5r486.github.io/f2e/20190225/706037845/"/>
    <id>http://pvt5r486.github.io/f2e/20190225/706037845/</id>
    <published>2019-02-25T01:30:50.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇會提到一個相當重要的觀念，那就是 Scope 作用域，也就是變數的生存範圍。在 ES6 以前 ， JavaScript 的作用域界定都是以函式 function 來劃分，本小節會著重以 ES6 之前的作用域來講解。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*8gQBeRbLApC1lwot" alt></p><h2 id="變數的生存範圍"><a href="#變數的生存範圍" class="headerlink" title="變數的生存範圍"></a>變數的生存範圍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); // 10</span><br></pre></td></tr></table></figure><p>毫無疑問地會輸出 10 ，但如果我們試著於函式外印出變數 <code>a</code> 的值呢?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123; // test scope  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); // 10  </span><br><span class="line">console.log(a); // a is not defined</span><br></pre></td></tr></table></figure><p></p><p>會得到錯誤「<code>a is not defined</code>」，這是因為變數 <code>a</code> 屬於區域變數，在函式外的 <code>console.log(a)</code> 無法取用變數 <code>a</code>。</p><h2 id="全域變數？區域變數？"><a href="#全域變數？區域變數？" class="headerlink" title="全域變數？區域變數？"></a>全域變數？區域變數？</h2><p>如何判斷一個變數到底是屬於全域變數還是區域變數？</p><ul><li><strong>沒有被包在函式內的變數就是全域變數</strong></li><li>包在<strong>函式內的變數就是區域變數</strong></li></ul><p>更多的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  </span><br><span class="line">function test()&#123; // test scope  </span><br><span class="line">  console.log(a);　// 20  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();  </span><br><span class="line">console.log(a); // 20</span><br></pre></td></tr></table></figure><p></p><p><code>test</code> 函式內印出的 20 ，因為在 <code>test</code> 的作用域內沒有找到對應的變數 <code>a</code> 所以轉而向上一層尋找變數 <code>a</code> ，因此輸出為 20 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  </span><br><span class="line">function test()&#123; // test scope  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  console.log(a); // 10  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();  </span><br><span class="line">console.log(a); // 20</span><br></pre></td></tr></table></figure><p></p><p>接續上例，因為在 <code>test</code> 的作用域找到相應的變數 <code>a</code> ，因此就不會繼續往外尋找。由此可知：</p><ul><li>當自己的作用域有相應的變數時，就不會繼續往外找了</li></ul><p>進階的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  </span><br><span class="line">function test()&#123;　// test scope  </span><br><span class="line">  a = 10;  </span><br><span class="line">  console.log(a);　// 10  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();  </span><br><span class="line">console.log(a); // 10</span><br></pre></td></tr></table></figure><p></p><p>在這邊要注意的是 <code>test</code> 函式內並不是變數 <code>a</code> ，因為沒有透過 <code>var</code> / <code>let</code> / <code>const</code> 宣告，因此在<strong>函式內的 <code>a</code> 是掛載在全域 <code>window</code> 物件下的屬性 <code>a</code></strong> 。</p><p>然而，屬性<strong>通常</strong>是可以被 <code>delete</code> 刪除的。</p><p>但在此情形，如果我們宣告全域變數的話，<strong>全域變數會被掛載到 <code>window</code> 物件下成為屬性</strong>，而且<strong>不可以被刪除</strong>。</p><p>這題的執行流程是這樣的：</p><ul><li>全域變數 <code>a</code> 先被賦予初始值 <code>undefined</code> ，此時也成為全域 <code>window</code> 物件下的屬性</li><li>對屬性 <code>a</code> 賦值 20</li><li>執行 <code>test</code> 函式，對屬性 <code>a</code> 賦值 10 ，第一次印出 a ，結果為 10。</li><li>第二次印出時，因為屬性 <code>a</code> 已經被賦值 10 ，因此輸出為 10</li><li>注意：<strong>屬性</strong>是沒有作用域的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;  </span><br><span class="line">  a = 10;  </span><br><span class="line">  console.log(a);　// 10  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();  </span><br><span class="line">console.log(a); // 10</span><br></pre></td></tr></table></figure></li></ul><p>因為屬性是沒有作用域的，這麼寫相當於</p><ul><li>宣告全域變數 <code>var a</code></li></ul><p>雖然這麼寫很方便，但是我們應該盡量避免汙染全域變數，應使用 <code>var</code> / <code>let</code> / <code>const</code> 宣告變數。</p><p>需要更多例子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  var a = &apos;test scope a&apos;;  </span><br><span class="line">  var b= &apos;test scope b&apos;;  </span><br><span class="line">  console.log(a,b);　// test scope a test scope b  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    var b = &apos;inner scope b&apos;;  </span><br><span class="line">    console.log(a,b); // test scope a inner scope b  </span><br><span class="line">  &#125;  </span><br><span class="line">  inner();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();  </span><br><span class="line">console.log(a); // global</span><br></pre></td></tr></table></figure><p></p><p>一個較貼近實務的範例可能會長得像這樣，雖然比較結構複雜，但是只要掌握一個原則：</p><ul><li>作用域是以函式來劃分</li><li>當變數在自身作用域內找不到時，會往外一層尋找，最後找到全域作用域</li></ul><h2 id="範圍鏈-Scope-Chain"><a href="#範圍鏈-Scope-Chain" class="headerlink" title="範圍鏈 (Scope Chain)"></a><strong>範圍鏈 (Scope Chain)</strong></h2><p>延續上面的範例，如果我們把某一行註解掉：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  // var a = &apos;test scope a&apos;;  </span><br><span class="line">  var b= &apos;test scope b&apos;;  </span><br><span class="line">  console.log(a,b); // test scope a test scope b  </span><br><span class="line">  function inner()&#123;  </span><br><span class="line">    var b = &apos;inner scope b&apos;;  </span><br><span class="line">    console.log(a,b); // test scope a inner scope b  </span><br><span class="line">  &#125;  </span><br><span class="line">  inner();  </span><br><span class="line">&#125;  </span><br><span class="line">test();  </span><br><span class="line">console.log(a); // global</span><br></pre></td></tr></table></figure><p></p><p>我們把 <code>test</code> 函式內的 <code>a</code> 註解，此時 <code>test</code> 函式與 <code>inner</code> 函式的作用域內均找不到變數 <code>a</code> ，因此最終會在全域作用域內找到全域變數 <code>a</code> 。</p><p>其尋找路徑如下：</p><ul><li>test scope -&gt; global scope</li><li>inner scope -&gt; test scope-&gt; global scope</li></ul><p>像這樣逐層往外尋找某變數的方式，被稱為<strong>範圍鏈 (Scope Chain)</strong></p><h3 id="範圍鏈是如何決定的"><a href="#範圍鏈是如何決定的" class="headerlink" title="範圍鏈是如何決定的"></a>範圍鏈是如何決定的</h3><p>範圍鏈的判斷是以<a href="https://pvt5r486.github.io/javascript/20190109/3227448912"><strong>詞彙環境</strong></a>來決定， 指的是程式碼在整個程式中的「實際位置」，像是下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function change()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  test();  </span><br><span class="line">&#125;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a);　// global  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><p>像這樣，雖然看起來我們在 change 函式內宣告了變數 a 也在裡面呼叫了函式 test ，但是實際上， test 函式的詞彙環境並沒有包在 change 函式內，因此它的範圍鏈仍然是這樣的：</p><ul><li>test scope -&gt; global scope</li></ul><p><strong>另外在 change 函式內呼叫函式 test 絕對不會是這個樣子</strong>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function change()&#123;  </span><br><span class="line">  var a = 10;  </span><br><span class="line">  test();　// 呼叫後自動產生以下內容  </span><br><span class="line">  function test()&#123;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p></p><h3 id="如果想要建立出如下的範圍鏈："><a href="#如果想要建立出如下的範圍鏈：" class="headerlink" title="如果想要建立出如下的範圍鏈："></a>如果想要建立出如下的範圍鏈：</h3><ul><li>test scope -&gt; change scope -&gt; global scope<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global&apos;;  </span><br><span class="line">function change()&#123;  </span><br><span class="line">  function test()&#123;  </span><br><span class="line">    console.log(a);  </span><br><span class="line">  &#125;  </span><br><span class="line">  test();  </span><br><span class="line">&#125;  </span><br><span class="line">change();</span><br></pre></td></tr></table></figure></li></ul><p>則應該改變 <code>test</code> 函式的詞彙環境。</p><blockquote><p>因為範圍鏈是以<strong>詞彙環境</strong>、<strong>函式被宣告在哪裡</strong>來決定的，並不會因為在哪裡被呼叫而改變範圍鏈。</p></blockquote><p>以上就是 ES6 之前對於 scope 的概念，下一篇將記錄 ES6 之後對於 scope 有什麼新觀念要了解。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>本篇用到了相當多的範例來解釋不同作用域下輸出的值會是多少，比起「奇怪部分」來說，「奇怪部分」在這邊的解釋是使用一張大圖，搭配一個例子來解釋整個作用域與範圍鏈，而這邊是採用類似這樣的方式。</p><ul><li>test scope -&gt; change scope -&gt; global scope</li></ul><p>這麼做還蠻有用的，比起只看圖而言，透過這樣子寫出來也容易加深自己的印象！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇會提到一個相當重要的觀念，那就是 Scope 作用域，也就是變數的生存範圍。在 ES6 以前，JavaScript 的作用域界定都是以函式 function 來劃分，本小節會著重以 ES6 之前的作用域來講解。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.54 let 與 const</title>
    <link href="http://pvt5r486.github.io/f2e/20190221/393940861/"/>
    <id>http://pvt5r486.github.io/f2e/20190221/393940861/</id>
    <published>2019-02-20T21:54:25.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>let 與 const 是 ES6 之後才加入的宣告變數的方式，宣告出來的變數表現也不太相同，這篇記錄會比較著墨於 const 的表現上。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*vlLIbbWmLSiw9HPB" alt></p><h2 id="什麼是變數"><a href="#什麼是變數" class="headerlink" title="什麼是變數"></a>什麼是變數</h2><p>首先必須要先了解什麼是<strong>變數</strong>，這將有助於了解後續相關知識。</p><ul><li><strong>只有</strong>透過 <code>var</code> / <code>let</code> / <code>const</code> 宣告的才算是變數</li><li>變數只存在於當前範圍下，而且不能<strong>刪除</strong></li><li>變數<strong>指向物件的記憶體位址</strong>，不包含物件的內容亦不會有型別，換句話說<strong>變數內不會裝著字串「安安」或是數字「5」</strong>，變數只會儲存「<strong>要指向該物件的記憶體位址</strong>」</li><li>使用 <code>var</code> 建立一個全域變數 <code>a</code> ，這時的變數 <code>a</code> 會被掛到 <code>window</code> 物件下成為屬性，並且無法被刪除。</li></ul><p>一些關於變數、屬性的比較可以看<a href="https://pvt5r486.github.io/note/20190218/2040388115">初次參加保哥的 JavaScript 開發實戰：核心概念篇 感想</a>或者是看當天上課的簡報。</p><h2 id="var-與-let"><a href="#var-與-let" class="headerlink" title="var 與 let"></a>var 與 let</h2><p>這兩者的行為是比較接近的，但在<strong>範圍 (Scope)</strong> 以及一些表現上有點不同，之後會有比較詳細的介紹，或者是<a href="https://pvt5r486.github.io/javascript/20190113/3480376618">[JavaScriptWeird]No.10 範圍與 let</a>，如果不想思考的話，結論就是「<strong>從現在開始都用 let 取代 var</strong> 」。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code> 就是常數的意思，使用的時候必須直接賦予一個初始值，而且之後不能透過任何方式改變這個值，也無法重複宣告。</p><h3 id="透過例子了解以上這段話"><a href="#透過例子了解以上這段話" class="headerlink" title="透過例子了解以上這段話"></a>透過例子了解以上這段話</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a;  </span><br><span class="line">// Missing initializer in const declaration</span><br></pre></td></tr></table></figure><p>上面這個範例不能運作。</p><ul><li>原因是 <code>const</code> 使用的時候必須直接賦予一個初始值</li></ul><p>因此必須像下面這個例子一樣。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;  </span><br><span class="line">console.log(a); // 10</span><br></pre></td></tr></table></figure><p></p><ul><li><p><code>const</code> 使用的時候無法重複宣告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;  </span><br><span class="line">const a = 1;  </span><br><span class="line">// Identifier &apos;a&apos; has already been declared</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>const</code> 的話，不能透過任何方式改變變數的值，而這個「值」的意思其實就是說「<strong>不能改變變數指向的記憶體位址</strong>」，讓我們畫圖理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;  </span><br><span class="line">a = 15;  </span><br><span class="line">console.log(a);  </span><br><span class="line">// Assignment to constant variable.</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*ZL-VHLg4Us6ufuozEztOaA.jpeg" alt></p><p>在第一行，建立一個原始型別 (number) 的物件並且令使用 <code>const</code> 建立的變數 <code>a</code> 指向它。</p><p>第二行，同樣建立一個原始型別的物件，並且試圖令變數 <code>a</code> 指向它，如紅色箭頭所示，因為這個變數 <code>a</code> 是使用 <code>const</code> 宣告的，所以無法改變<strong>變數指向的記憶體位址。</strong></p><p>透過上面的例子，對於使用 <code>const</code> 宣告的變數有了初步的了解，接下來比較進階的例子。</p><h3 id="延伸範例"><a href="#延伸範例" class="headerlink" title="延伸範例"></a>延伸範例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;  </span><br><span class="line">  number: 1  </span><br><span class="line">&#125;;  </span><br><span class="line">obj.number = 2;  </span><br><span class="line">console.log(obj.number); // 2</span><br></pre></td></tr></table></figure><p>接著將例子做一點小調整，為什麼這裡的 <code>obj.number</code> 可以被修改呢？</p><ul><li>因為 <code>const</code> 只是「<strong>不能改變變數指向的記憶體位址</strong>」，而這個範例並沒有改變 <code>obj</code> 變數的指向，只有改變 <code>obj</code> 物件的 <code>number</code> 屬性指向的記憶體位址。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*6S-xAc7a1NIBJGBCRyUGCQ.jpeg" alt></p><p>到這邊，如果我們能正確地畫出這個圖，相信這邊的觀念已經了解囉。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>至此已經跑完第一部分的影片了，針對每個小節我都有寫一點點心得，當完成一個段落時，我發現小節與小節其實都是有相關性的。</p><p>而與其他課程不同的是，通常如果提到原始型別 (Primitive Type) 與物件型別 (Object Type) 的差異，可能會一次就把差異全部講完。</p><p>但在這邊則是把這些差異拆分出去到子小節內，透過不同的範例來解釋這些差異，我覺得這是很實用的。</p><p>人的<a href="https://ctld.ntu.edu.tw/fd/teaching_resource/page1-1_detail.php?bgid=1&amp;gid=8&amp;nid=457" rel="external nofollow noopener noreferrer" target="_blank">專注力曲線</a>大概是長這個樣子：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ZGU6JiLXLpmSULZ68SkPIQ.png" alt="台大教學資源網"></p><p>專注力不會一直都是維持最高的狀態，也就是學生會在影片一開始時專注力最高，接著在上的正精彩的時候掉到谷底，然後發現影片快結束了又回到最高。</p><p>也就是說，如果一支影片只講一個觀念，透過範例的方式就很好吸收，而且也比較容易控制影片的長度。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      let 與 const 是 ES6 之後才加入的宣告變數的方式，宣告出來的變數表現也不太相同，這篇記錄會比較著墨於 const 的表現上。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.53 「==」和「===」</title>
    <link href="http://pvt5r486.github.io/f2e/20190220/3373555318/"/>
    <id>http://pvt5r486.github.io/f2e/20190220/3373555318/</id>
    <published>2019-02-20T01:05:54.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接講結論：「不管什麼時候，都應該只使用三個等於來進行比較，除非是進行教學或者是－故意的。」</p><p><img src="https://cdn-images-1.medium.com/max/800/0*VUQ7qBRQEfTu1jQ0" alt></p><h2 id="「-」和「-」的差異"><a href="#「-」和「-」的差異" class="headerlink" title="「==」和「===」的差異"></a>「==」和「===」的差異</h2><h3 id="使用「-」進行比較"><a href="#使用「-」進行比較" class="headerlink" title="使用「==」進行比較"></a>使用「==」進行比較</h3><p>首先我們必須了解「==」實際上在做什麼，這部分的觀念其實在<a href="https://pvt5r486.github.io/javascript/20190120/2195525748">[JavaScriptWeird]No.16 強制型轉</a>、<a href="https://pvt5r486.github.io/javascript/20190121/1972610701">[JavaScriptWeird]No.17 比較運算子</a>都有提到一些。</p><p>使用「==」進行比較時，「==」會嘗試將左右兩邊的型別根據某個規則，嘗試將型別轉成一致並進行比較，最後回傳比較結果。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">var b = &apos;1&apos;;  </span><br><span class="line">console.log(a == b);　// true</span><br></pre></td></tr></table></figure><p></p><h3 id="使用「-」進行比較-1"><a href="#使用「-」進行比較-1" class="headerlink" title="使用「===」進行比較"></a>使用「===」進行比較</h3><p>如果使用「===」進行比較，就不會觸發型別轉換，因此結果會比較接近我們預期的那樣。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">var b = &apos;1&apos;;  </span><br><span class="line">console.log(a === b);　// false</span><br></pre></td></tr></table></figure><p></p><h3 id="「-」和「-」的比較表"><a href="#「-」和「-」的比較表" class="headerlink" title="「==」和「===」的比較表"></a>「==」和「===」的比較表</h3><p>可以上 <a href="https://dorey.github.io/JavaScript-Equality-Table/" rel="external nofollow noopener noreferrer" target="_blank">JS Comparison Table</a> 查詢各種比較結果。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ui95ilDc0WtuYo0W08tHOw.png" alt="雙等號比較表"></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Mdw6eSdU2LkBgWErtA0cWQ.png" alt="三等號比較表"></p><h4 id="為什麼我們應該只使用「-」比較"><a href="#為什麼我們應該只使用「-」比較" class="headerlink" title="為什麼我們應該只使用「===」比較"></a>為什麼我們應該只使用「===」比較</h4><p>因為使用「==」會觸發型別轉換，而且透過雙等號比較表可以得知其中規則相當複雜，可能會跑出一些非預期的結果。</p><p>而使用「===」的話，因為不會觸發型別轉換，較容易預測結果，而且比較表也相對好記憶。</p><h2 id="原始型別與物件型別的差異"><a href="#原始型別與物件型別的差異" class="headerlink" title="原始型別與物件型別的差異"></a><strong>原始型別與物件型別的差異</strong></h2><p>之前提到一些原始型別 (Primitive Types) 與物件型別 (Object Types) 的差異，這邊將提到另外一個差異：</p><ul><li>與原始型別不同，<strong>物件型別是比較記憶體位址</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; number: 1 &#125;  </span><br><span class="line">var obj2 = obj;  </span><br><span class="line">console.log(obj === obj2); // true</span><br></pre></td></tr></table></figure></li></ul><p>眼尖的你應該會發現，比較表上明明寫著兩個物件相比都是 false ，那麼為什麼這邊會是 true 呢？</p><p>我們可以把這段 code 在記憶體的樣子畫出來：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*_rVZXcbeIjNg5P9_u1hstg.jpeg" alt></p><p>可以發現變數 <code>obj</code> 與 <code>obj2</code> 都是指向同一個記憶體位址，因此第三行的比較其實是「比較兩個變數指向的記憶體位址」，既然兩個變數都指向同一個記憶體位址，那麼答案自然會是 true 。</p><p>同理，修改一下例子，並畫圖了解：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; number: 1 &#125;  </span><br><span class="line">var obj2 = &#123; number: 1 &#125;  </span><br><span class="line">console.log(obj === obj2); // false</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*v_IATWhckohsquizeVI0AQ.jpeg" alt></p><p>由前一個例子可知，物件型別之間的比較比的是記憶體的位址，從這張圖看來，兩個 {} 物件在記憶體中的位置並不相同，所以比較的結果才會是 false。</p><p>這樣就可驗證為什麼只要是物件型別之間的比較都會是 false 了，因為只要產生一個新物件，就會是不同的記憶體位址。</p><h2 id="而有哪些是物件型別呢？"><a href="#而有哪些是物件型別呢？" class="headerlink" title="而有哪些是物件型別呢？"></a>而有哪些是物件型別呢？</h2><p>只要不屬於原始型別的<a href="https://pvt5r486.github.io/javascript/20190214/2106705850">那六種</a>，都是物件型別。這倒是可以用很簡單的二分法來判斷。</p><h2 id="特殊的例子"><a href="#特殊的例子" class="headerlink" title="特殊的例子"></a>特殊的例子</h2><h3 id="NaN-Not-a-Number"><a href="#NaN-Not-a-Number" class="headerlink" title="NaN (Not a Number)"></a>NaN (Not a Number)</h3><p>顧名思義 NaN 就是非數字(Not a Number)，但是很弔詭的是：</p><ul><li><p>使用 <code>typeof NaN</code> 得到的結果會是數字型別 (number)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof NaN); // number</span><br></pre></td></tr></table></figure></li><li><p>而 NaN 本身也無法使用「===」或「==」與自己比較</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN === NaN); // false</span><br></pre></td></tr></table></figure></li><li><p>神奇的是如果你拿數字型別跟 NaN 相比也會是 false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof(1) === NaN); // false</span><br></pre></td></tr></table></figure></li></ul><h3 id="NaN-如何產生的"><a href="#NaN-如何產生的" class="headerlink" title="NaN 如何產生的"></a>NaN 如何產生的</h3><p>相當容易產生，只要 Javascript 發生自動型轉或者我們主動將值轉換成數字時，當中混有無法轉成數值的東西時，就會產生 NaN。</p><blockquote><p>因此 NaN 是個相當可怕的東西，我們應該避免產生 NaN。</p></blockquote><h3 id="使用-isNaN-檢查是否為-NaN"><a href="#使用-isNaN-檢查是否為-NaN" class="headerlink" title="使用 isNaN() 檢查是否為 NaN"></a>使用 isNaN() 檢查是否為 NaN</h3><p>因為我們沒辦法從上面任何方式判斷是否為 NaN ，但是幸好還有 isNaN() 可以使用，使用方法相當容易：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var test = 1 + &apos;s&apos;;  </span><br><span class="line">console.log(isNaN(test));　// true</span><br></pre></td></tr></table></figure><p></p><p>這樣子就能判斷是否為 NaN 了，另外這是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/isNaN#%E6%8F%8F%E8%BF%B0" rel="external nofollow noopener noreferrer" target="_blank">MDN 對於 NaN 的解釋</a></p><h3 id="不支援-isNaN-的瀏覽器的因應措施"><a href="#不支援-isNaN-的瀏覽器的因應措施" class="headerlink" title="不支援 isNaN() 的瀏覽器的因應措施"></a>不支援 isNaN() 的瀏覽器的因應措施</h3><p>很不幸的 <code>isNaN()</code> 好像不是所有瀏覽器都支援，但是我們可以透過 <a href="https://pvt5r486.github.io/javascript/20190211/53717031"><strong>polyfill</strong></a> 令不支援 <code>isNaN()</code> 的瀏覽器也可以使用。</p><p>而幸運的是，這可以在 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/isNaN" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 上找到。</p><blockquote><p>感恩 MDN 讚嘆 MDN</p></blockquote><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這是上完保哥課程後的第一篇記錄文，很高興能用到課堂上的知識來加深這些觀念的印象，而最棒的是我看的這支影片居然也用同樣的方式來介紹這些觀念，果然是高手所見略同呢。</p><p>我覺得對初心者來說，比起生硬的文字，最容易有印象的果然還是畫圖。</p><p>而且是必須要親自畫，不能只有看。而從「讀出程式碼」到畫出來的過程中，也可以了解自己觀念理解的正不正確，因為只要唸出來的是錯的，代表你想的也是錯的，自然畫出來的圖也會是錯的，這時候就會產生BUG。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      直接講結論：「不管什麼時候，都應該只使用三個等於來進行比較，除非是進行教學或者是－故意的。」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.4 時區</title>
    <link href="http://pvt5r486.github.io/f2e/20190219/29379803/"/>
    <id>http://pvt5r486.github.io/f2e/20190219/29379803/</id>
    <published>2019-02-19T04:13:58.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="預覽圖"><a href="#預覽圖" class="headerlink" title="預覽圖"></a>預覽圖</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*bV5tg42bME_poZGITHbjzw.png" alt></p><h2 id="本層-BOSS-弱點"><a href="#本層-BOSS-弱點" class="headerlink" title="本層 BOSS 弱點"></a>本層 BOSS 弱點</h2><ul><li>【特定技術】僅能使用原生 JS ，不能使用套件</li><li>【特定技術】特別注意必須用 JS 處理各國時區</li><li>【書寫能力】請寫一篇 Blog 來介紹你的挑戰過程，並介紹 JavaScript 如何提供 GMT、UTC 時區語法，以及何謂 TimeStamp</li></ul><h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul><li>原生 JavaScript</li><li>SCSS</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一層樓切版算容易，JavaScript 部分也不困難，我認為這一層樓要點在於「資料蒐集」，也就是當遇到不知道怎麼寫的時候，如何靠自己的力量找到答案。</p><p>因為這層樓只要找到 <code>toLocaleString()</code> 方法，並了解使用方式、有什麼參數可以使用，那麼這一題基本上就解完了。</p><p>當然這題還有其他解法，只是我認為使用 <code>toLocaleString()</code> 很方便，只要代入想要的時間格式、地區，就可以拿到資料了，省去蠻多計算的。</p><h3 id="過程"><a href="#過程" class="headerlink" title="過程"></a>過程</h3><p>我的想法滿簡單的，因為是關於時間的處理，自然而然想到 <code>Date()</code>，但我不清楚裡面有什麼方法可以幫助我，畢竟要做的是時區的轉換，從先前的經驗得知 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 可能會有我要的東西，於是關鍵字是這麼下的「<a href="https://www.google.com/search?q=JS+Date%28%29+MDN&amp;oq=JS+Date%28%29+MDN&amp;aqs=chrome..69i57j0l5.207j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="external nofollow noopener noreferrer" target="_blank">JS Date() MDN</a>」。</p><p>第一筆就是我要的結果，點開可以看到 MDN 對於 Date 物件的描述：</p><ul><li>Date 物件是基於世界標準時間（UTC） 1970 年 1 月 1 日開始的毫秒數值來儲存時間。</li><li>JavaScript <code>Date</code> 物件提供了若干 UTC (通用的) 以及本地時間方法。UTC，也被稱為格林威治標準時間（GMT）被指定作為世界時間的標準。本地時間指的是被設定在執行 JavaScript 電腦上的時間。</li></ul><p>基本上 MDN 就能得到相當充足的資訊，接著繼續往下看，可以知道更多掛在 Date 物件下的方法，最後找到</p><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString" rel="external nofollow noopener noreferrer" target="_blank">Date.prototype.toLocaleString()</a> - 回傳依系統的地區設定導出的日期時間字串。</li></ul><blockquote><p>就是這個了，還很佛心的附有範例呢 !</p></blockquote><p>但是還沒結束，因為根據 MDN 上的用法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dateObj.toLocaleString(\[locales\[, options\]\])</span><br></pre></td></tr></table></figure><p></p><p>需要填入一些參數像是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_%E5%8F%82%E6%95%B0" rel="external nofollow noopener noreferrer" target="_blank"><strong>locales</strong></a> 以及可選的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString#Parameters" rel="external nofollow noopener noreferrer" target="_blank"><strong>options</strong></a>， <code>locales</code> 需要的參數可以參考<a href="https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry" rel="external nofollow noopener noreferrer" target="_blank"><strong>這篇</strong></a>。</p><p>整合資料後，我得出這個結果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let d = new Date();  </span><br><span class="line">d.toLocaleString(&apos;zh-TW&apos;, &#123; timeZone: &apos;Asia/Taipei&apos;, hour12: false &#125;);</span><br></pre></td></tr></table></figure><p></p><p><code>zh-TW</code> 代表想使用的時間格式， <code>timeZone</code> 後面接著目標時區。</p><p>如果想要以同樣的格式指定取得澳洲雪梨的時間可以怎麼做?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.toLocaleString(&apos;zh-TW&apos;, &#123; timeZone: &apos;Australia/Sydney&apos;, hour12: false &#125;);</span><br></pre></td></tr></table></figure><p></p><p>基本上知道這些，這題已經快做完了，剩下就只要做一些字串處理就好了，最後補上 <code>setInterval</code> 就達成了。</p><h2 id="額外補充"><a href="#額外補充" class="headerlink" title="額外補充"></a>額外補充</h2><h3 id="何謂-UTC-GMT"><a href="#何謂-UTC-GMT" class="headerlink" title="何謂 UTC / GMT"></a>何謂 UTC / GMT</h3><p>其實從 MDN 上的這一段敘述就可略知一二，世界標準時間（UTC）也被稱為格林威治標準時間（GMT）被指定作為世界時間的標準。然而如果需要更精確的解釋則可以參考<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" rel="external nofollow noopener noreferrer" target="_blank">世界協調時間</a>、<a href="https://pansci.asia/archives/84978" rel="external nofollow noopener noreferrer" target="_blank">到底是 GMT+8 還是 UTC+8 ?</a>。</p><h3 id="何謂-TimeStamp"><a href="#何謂-TimeStamp" class="headerlink" title="何謂 TimeStamp"></a>何謂 TimeStamp</h3><p>可以透過這一篇<a href="http://codingpy.com/article/programmer-daily-story-about-timestamp-and-timezone/" rel="external nofollow noopener noreferrer" target="_blank"><strong>有趣的漫畫</strong></a>了解，於 JavaScript 中的使用方式是這樣的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let `timestamp =` Math.floor(Date.now() / 1000);  </span><br><span class="line">// 1550577930</span><br></pre></td></tr></table></figure><p></p><h3 id="如何還原成我們看得懂的時間呢？"><a href="#如何還原成我們看得懂的時間呢？" class="headerlink" title="如何還原成我們看得懂的時間呢？"></a>如何還原成我們看得懂的時間呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let time = new Date(1550577930 \* 1000);  </span><br><span class="line">// Tue Feb 19 2019 20:05:30 GMT+0800 (台北標準時間)</span><br></pre></td></tr></table></figure><h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><ul><li><a href="https://pvt5r486.github.io/JSD4_TimeZone/index.html">線上DEMO</a></li><li><a href="https://github.com/pvt5r486/JSD4_TimeZone" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      六角 JavaScriptDungeon 時區
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>初次參加保哥的《JavaScript 開發實戰：核心概念篇》感想</title>
    <link href="http://pvt5r486.github.io/life-note/20190218/2040388115/"/>
    <id>http://pvt5r486.github.io/life-note/20190218/2040388115/</id>
    <published>2019-02-17T23:06:57.000Z</published>
    <updated>2020-02-16T05:54:48.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><p><img src="https://cdn-images-1.medium.com/max/800/0*olYqHWntSo3gpCK5" alt></p><h2 id="報名前的猶豫不決"><a href="#報名前的猶豫不決" class="headerlink" title="報名前的猶豫不決"></a>報名前的猶豫不決</h2><p>2019/02/17 這是我嘗試投入前端領域的初次實體課程，老實說我本來是不太想參加的，畢竟大家也都看到價格了，對一個有經濟壓力的人來說，那不會是個太容易被接受的數字。</p><p>4000 對每個人來說有不同的解讀，或許對有些人來說「光講師是保哥就超過 4000 的價值了」，但對一個連業界的大神有誰、同時又是個前端菜雞、更遑論有經濟壓力的人來說，猶豫不決想必也是人之常情吧？</p><p>對，我很想參加。</p><p>但我也捨不得那 4000 ，或許是冥冥之中有注定？我一個在台北的朋友也參加了一模一樣的課程，並且也向我推坑。</p><p>我也趁勢向友人請教到底值不值 4000，他回應「以前腦補太多 JavaScript 的觀念了，如果想投入前端 JavaScript 必不可少，報名課程然後<strong>享受被打臉吧</strong>」(??</p><p>洧杰老師也於 Line 上鼓勵我要報名這次的課程，也表明自身亦參加多次，每次都有不同的收穫，後來牙一咬就去了。</p><h2 id="寫於課後"><a href="#寫於課後" class="headerlink" title="寫於課後"></a>寫於課後</h2><p>先說說我的 JavaScript 程度，我的程度不高，大概就是看完六角的《 JavaScript 入門篇 - 學徒試煉》、以及看了約 70% 進度的《克服 JS 的奇怪部分》</p><p>如果要建議至少要到什麼程度才可以參加，就我自己的感覺來說，注意喔僅代表我自己喔，那大概就是<strong>看完學徒試煉的前 8 章對 JavaScript 有初步了解就可以了</strong>。</p><p>這個意思並不是說這堂課很淺，而是我上完後的感受是，這堂課比較像是<strong>重新建立我們對 JavaScript 的一些基礎的解讀</strong></p><p>而很多人會因為這些東西太基礎而忽略、或者是因為曾經接觸過其他程式語言而自行腦補這些基礎觀念。</p><p>保哥於開課前是這麼說的「<strong>這堂課很特別，不管是初學也好、較為進階的也好，這堂課會因為自身在不同時期下對 JavaScript 的認知而有不同的收穫</strong>」</p><p>因為這是寫於課後的，當時的我沒有完全做到覺得很可惜，但是可以寫給未來的我以及可能看到這篇文章的路人甲，讓這堂課的價值遠超 4000 ，那就是：</p><ol><li>當講師丟出問題時，請盡可能地給予回應不要害羞</li><li><strong>講對很好但講錯更好</strong>，因為接下來會變成你的主場，保哥會開始引導讓你說出正確的答案，期間你會不斷跳針似的重複自己的答案，而<strong>在場的其他同學也會因為這個過程察覺這個答案本身的問題點，</strong>這個時候大家就會進入團體思考模式，最終靠學員自身的力量獲得答案。</li></ol><p>雖然這個過程很耗費時間，導致當天課程的下半段好像比較趕，但整體來說，得到的感受仍是好的，也因為這樣的感受讓我認為<strong>花這個錢很值得</strong>。</p><p>我想保哥也是認為打好基礎很重要，否則也不會特地花這麼多時間請同學上去畫圖並指導釐清觀念，而我就是其中一個幸運兒。</p><p>這樣的實體課程還有一個好處，散場結束時，利用時間向保哥提出了一個問題：「<strong>像這樣的課程，雖然當下同學們好像都會了，但是過沒多久就會忘光，如何把這些觀念變成長期記憶呢？</strong>」。</p><h3 id="印象中保哥給我的回答是這樣的"><a href="#印象中保哥給我的回答是這樣的" class="headerlink" title="印象中保哥給我的回答是這樣的"></a>印象中保哥給我的回答是這樣的</h3><ol><li>最重要的還是多寫程式，把這些觀念帶入到工作中。</li><li>如果目前工作並非前端領域，會建議我們將自身周遭營造出前端的環境，讓日常生活都充滿前端，當然如果可以找份前端的工作是更好的。</li></ol><p>相較於報名前的猶豫不決，或許這麼說是誇張了點，但我現在還是有「啊！有參加真是太好了」的感嘆，雖然我還是對 4000 的失去耿耿於懷，但對於結果而言，這算是筆相當划算的交易，我獲得的遠比想像中的還要多。</p><h3 id="最後也有和卡斯伯老師講到話，我說"><a href="#最後也有和卡斯伯老師講到話，我說" class="headerlink" title="最後也有和卡斯伯老師講到話，我說"></a>最後也有和卡斯伯老師講到話，我說</h3><p>「慘了，今天被這堂課打臉這麼多 JavaScript 觀念，那我之前寫的奇怪部分的紀錄文好像有部分都是錯的，我是不是要回頭去改呢，可是那超多篇的欸！」</p><h3 id="老師是這麼說的"><a href="#老師是這麼說的" class="headerlink" title="老師是這麼說的"></a>老師是這麼說的</h3><p>「其實這些都是過程，那些紀錄文也代表了你在那個階段的想法，在老師自己的部落格上也有很多篇文章，即使現在觀念更好了也不盡然會回頭去一篇篇改那些文章，畢竟真的是太多了。可以把那些文章留著當對照組，期許之後可以寫出品質更好的紀錄文」</p><p>感想的部分就到以上結束。</p><p>接下來的是課堂上「我還記得」的筆記，可能比較片段也比較雜亂，不過自己看得懂就好啦。</p><p>我很想記得課堂上保哥講的每一個觀念，不過人畢竟不是錄音機，就…能吸收多少就算多少囉。</p><h2 id="課堂筆記"><a href="#課堂筆記" class="headerlink" title="課堂筆記"></a>課堂筆記</h2><ul><li>所有的東西在 JavaScript 內都是物件，只有分原始型別和物件型別</li></ul><h3 id="物件的定義"><a href="#物件的定義" class="headerlink" title="物件的定義"></a>物件的定義</h3><ul><li>在電腦科學領域中，物件是個在記憶體中的資料且可以被一個識別符號所參考。</li></ul><h3 id="識別符號"><a href="#識別符號" class="headerlink" title="識別符號"></a>識別符號</h3><ul><li>合法的識別符號必須是<strong>英文字母、數字、金額符號 ( $ )、底線 ( _ )</strong></li><li>合法的識別符號不能以<strong>數字</strong>開頭</li></ul><p>例如取用 <code>car</code> 物件下的 <code>001</code> 屬性</p><ul><li>不能寫 <code>car.001</code> ，會得到 Error，因為 <code>.001</code> 是不合法的識別符號。</li><li>可以寫 <code>car.[&#39;001&#39;];</code></li></ul><h3 id="所有物件都是物件型別-Object-Type-，除了以下六種是「原始型別-Primitive-Type-」："><a href="#所有物件都是物件型別-Object-Type-，除了以下六種是「原始型別-Primitive-Type-」：" class="headerlink" title="所有物件都是物件型別 (Object Type)，除了以下六種是「原始型別 (Primitive Type)」："></a>所有物件都是物件型別 (Object Type)，除了以下六種是「原始型別 (Primitive Type)」：</h3><ul><li>number - 數值</li><li>string - 字串</li><li>boolean - 布林</li><li>null - 空值</li><li>undefined - 未定義</li><li>symbol - 符號 (ES6 +)</li></ul><h3 id="物件型別與原始型別的差異"><a href="#物件型別與原始型別的差異" class="headerlink" title="物件型別與原始型別的差異"></a>物件型別與原始型別的差異</h3><ul><li>原始型別無法自由擴增屬性，物件型別可以。</li></ul><h3 id="何時物件會被回收"><a href="#何時物件會被回收" class="headerlink" title="何時物件會被回收"></a>何時物件會被回收</h3><ul><li>JavaScript 內如果有物件沒被有任何的變數、屬性指向就會被立刻回收。</li></ul><h3 id="何時物件才有型別"><a href="#何時物件才有型別" class="headerlink" title="何時物件才有型別"></a>何時物件才有型別</h3><ul><li>JavaScript 執行時期才有型別，並用來標示物件的種類 (類型)</li></ul><h3 id="任何「兩」物件相比永遠都是-False"><a href="#任何「兩」物件相比永遠都是-False" class="headerlink" title="任何「兩」物件相比永遠都是 False"></a>任何「兩」物件相比永遠都是 False</h3><h3 id="變數與屬性"><a href="#變數與屬性" class="headerlink" title="變數與屬性"></a>變數與屬性</h3><h3 id="變數與屬性大部分的表現都相同，其中較為明顯的差異是："><a href="#變數與屬性大部分的表現都相同，其中較為明顯的差異是：" class="headerlink" title="變數與屬性大部分的表現都相同，其中較為明顯的差異是："></a>變數與屬性大部分的表現都相同，其中較為明顯的差異是：</h3><ul><li>屬性可透過 <code>delete</code> 刪除</li><li>變數不可透過 <code>delete</code> 刪除</li></ul><h3 id="關於變數與屬性"><a href="#關於變數與屬性" class="headerlink" title="關於變數與屬性"></a>關於變數與屬性</h3><ul><li>只有用 <code>var</code> / <code>let</code> / <code>const</code> 宣告的才能算變數</li><li>變數只存在於當前範圍下，而且不能刪除</li><li>變數指向物件的記憶體位址，不包含物件的內容亦不會有型別</li><li>屬性也是指向物件的記憶體位址，跟變數一樣。</li><li>使用 <code>var</code> 建立一個全域變數 <code>a</code> ，這時的變數 <code>a</code> 會被掛到 <code>window</code> 物件下成為屬性，並且無法被刪除。</li></ul><h3 id="例子驗證-變數和屬性之間的關係一"><a href="#例子驗證-變數和屬性之間的關係一" class="headerlink" title="例子驗證 - 變數和屬性之間的關係一"></a>例子驗證 - 變數和屬性之間的關係一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">window[&apos;a&apos;] = 2;  </span><br><span class="line">delete window.a;  </span><br><span class="line">console.log(a);  // 2</span><br></pre></td></tr></table></figure><h3 id="例子驗證-變數和屬性之間的關係二"><a href="#例子驗證-變數和屬性之間的關係二" class="headerlink" title="例子驗證 - 變數和屬性之間的關係二"></a>例子驗證 - 變數和屬性之間的關係二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = 2;  </span><br><span class="line">delete b;  </span><br><span class="line">console.log(b); // is not defined</span><br></pre></td></tr></table></figure><h3 id="Number-部分"><a href="#Number-部分" class="headerlink" title="Number 部分"></a>Number 部分</h3><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>JavaScript 的 Number 在一定位數以上的數字後就會失準，並轉變成科學符號，因此判斷最大安全整數非常重要。</p><h3 id="課堂練習一"><a href="#課堂練習一" class="headerlink" title="課堂練習一"></a>課堂練習一</h3><p>物件、變數與型別之間的關係<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">a = 1;  </span><br><span class="line">a = &quot;a&quot;;  </span><br><span class="line">a = &quot;a&quot; + a;</span><br></pre></td></tr></table></figure><p></p><p>上述四行程式碼在執行的過程中，請問：</p><ul><li>曾經在記憶體中建立過幾個變數 ? 1</li><li>曾經在記憶體中出現過幾種型別 ? 3</li><li>曾經在記憶體中出現過多少物件 ? 5</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*K7XCLm-pn4_WlMP4FSN4kA.png" alt></p><h3 id="課堂練習二"><a href="#課堂練習二" class="headerlink" title="課堂練習二"></a>課堂練習二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;x:1&#125;;  </span><br><span class="line">var b = a;  </span><br><span class="line">a.x = a = &#123;x:2&#125;;</span><br></pre></td></tr></table></figure><p>請問 b.x 、 a.x 結果為何？</p><ul><li>a.x ==&gt; 2</li><li>b.x ==&gt; {x:2}</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*Uc1M5H5u7yKFj0-GN7d2Fg.png" alt="讀懂每一行程式碼並畫圖了解實際運作"><br>讀懂每一行程式碼並畫圖了解實際運作</p><h3 id="課堂練習三"><a href="#課堂練習三" class="headerlink" title="課堂練習三"></a>課堂練習三</h3><p>利用閉包的特性，實作出每呼叫一次就 +1 的計數器<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function MyFunc() &#123;  </span><br><span class="line">   var i = 0;  </span><br><span class="line">   return &#123;   </span><br><span class="line">     GetCount: function()&#123;  </span><br><span class="line">       i++;  </span><br><span class="line">       return console.log(i);  </span><br><span class="line">     &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var o = MyFunc();  </span><br><span class="line">o.GetCount(); // 輸出 1  </span><br><span class="line">o.GetCount(); // 輸出 2  </span><br><span class="line">o.GetCount(); // 輸出 3 ( 依此類推 )</span><br></pre></td></tr></table></figure><p></p><h3 id="課堂練習四"><a href="#課堂練習四" class="headerlink" title="課堂練習四"></a>課堂練習四</h3><p>請利用 JS 閉包 (Closure) 特性實作私有變數的 get 與 set 存取子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function MyFunc() &#123;  </span><br><span class="line">  let a;  </span><br><span class="line">  let b = 0;  </span><br><span class="line">  return &#123;   </span><br><span class="line">    get_a: function()&#123;  </span><br><span class="line">      return console.log(a);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    set_a: function(input)&#123;  </span><br><span class="line">      a = input * input;     </span><br><span class="line">    &#125;,  </span><br><span class="line">    get_b: function()&#123;  </span><br><span class="line">      return console.log(b);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    set_b: function(input)&#123;  </span><br><span class="line">      b = input;     </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var o = MyFunc();  </span><br><span class="line">o.get_a() // 回傳 undefined  </span><br><span class="line">o.set_a(3);  </span><br><span class="line">o.get_a(); // 回傳 9  </span><br><span class="line">o.set_a(4);  </span><br><span class="line">o.get_a(); // 回傳 16  </span><br><span class="line">o.get_b(); // 回傳 0  </span><br><span class="line">o.set_b(99);  </span><br><span class="line">o.get_b(); // 回傳 99</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      2019/02/17 這是我嘗試投入前端領域的初次實體課程，老實說我本來是不太想參加的，畢竟大家也都看到價格了，對一個有經濟壓力的人來說，那不會是個太容易被接受的數字。
    
    </summary>
    
      <category term="生活雜記" scheme="http://pvt5r486.github.io/categories/life-note/"/>
    
    
      <category term="JavaScript" scheme="http://pvt5r486.github.io/tags/JavaScript/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="自我投資" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.52 運算子「=」</title>
    <link href="http://pvt5r486.github.io/f2e/20190216/2402595093/"/>
    <id>http://pvt5r486.github.io/f2e/20190216/2402595093/</id>
    <published>2019-02-15T20:54:29.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次提到 <strong>Primitive Types 與 object 的其中一個差別</strong>，接下來我們討論另一個差別，那就是對於運算子「=」，兩者的表現並不一樣。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*YLWytmR7G_njoz-r" alt></p><h2 id="使用運算子「-」賦值"><a href="#使用運算子「-」賦值" class="headerlink" title="使用運算子「=」賦值"></a>使用運算子「=」賦值</h2><p>賦值就像字面上的意思一樣，重新給予一個值，而我們也可以喚醒另外一個世界線的記憶：</p><ul><li><a href="https://pvt5r486.github.io/javascript/20190120/3157345522">[JavaScriptWeird]No.14 運算子</a></li><li><a href="https://pvt5r486.github.io/javascript/20190120/945735864">[JavaScriptWeird]No.15 運算子的相依性與優先性</a></li><li><a href="https://pvt5r486.github.io/javascript/20190124/2673002552">[JavaScriptWeird]No.27 觀念小叮嚀：傳值和傳參考</a></li></ul><p>這也達到了當初做筆記的目的，因為有之前的筆記，所以我在學習相同的觀念但不同講法時，我可以交叉驗證自己吸收得如何。</p><h2 id="由另個世界線的記憶我們可以知道："><a href="#由另個世界線的記憶我們可以知道：" class="headerlink" title="由另個世界線的記憶我們可以知道："></a>由另個世界線的記憶我們可以知道：</h2><ul><li>「=」的優先性為 3</li><li>「=」為「右相依」 (right-to-left)</li><li>Primitive Types 是傳值 (By Value) 的</li><li>Object 是傳參考 (By Reference) 的</li></ul><h2 id="例子驗證"><a href="#例子驗證" class="headerlink" title="例子驗證"></a>例子驗證</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;  </span><br><span class="line">var b = a;  </span><br><span class="line">console.log(a, b);　// 10 10  </span><br><span class="line">b = 200;  </span><br><span class="line">console.log(a, b); // 10 200</span><br></pre></td></tr></table></figure><p>上面這個如我們預期，因為 Primitive Types 是傳值的，我們創造一個新的變數 <code>a</code> ，並且令 <code>b = a</code> ，變數 <code>b</code> 會指向一個新的記憶體位址，並拷貝那個純值 10 ，放到<strong>新的記憶體位址</strong>。</p><p>接下來做點改變<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;  </span><br><span class="line">  num: 10  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = obj;  </span><br><span class="line">console.log(obj, obj2);  </span><br><span class="line">obj2.num = 20;  </span><br><span class="line">console.log(obj, obj2);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*JB-8NLKZO86s17Dz5Wo_aQ.png" alt></p><p>首先使用物件實體語法建立了 <code>obj</code> 物件，接著使用等號運算子將右邊的 <code>obj</code> 給 <code>obj2</code> ，而物件是傳參考的，也就是說這兩個物件目前指向的記憶體位址相同，所以結果才會是這樣。</p><p>上面算是一個小複習，畢竟在另個世界線有同樣的範例了。</p><h3 id="然而-Array-在最底層也是物件，所以傳參考的情況也適用："><a href="#然而-Array-在最底層也是物件，所以傳參考的情況也適用：" class="headerlink" title="然而 Array 在最底層也是物件，所以傳參考的情況也適用："></a>然而 Array 在最底層也是物件，所以傳參考的情況也適用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [];  </span><br><span class="line">var arr2 = arr1;  </span><br><span class="line">console.log(arr1, arr2); // [] []  </span><br><span class="line">arr2.push(&apos;arr2&apos;);  </span><br><span class="line">console.log(arr1, arr2); // [&quot;arr2&quot;] [&quot;arr2&quot;]</span><br></pre></td></tr></table></figure><p>以上就是 Primitive Types 與 object 的另一個差別。</p><h3 id="「-」的小陷阱"><a href="#「-」的小陷阱" class="headerlink" title="「=」的小陷阱"></a>「=」的小陷阱</h3><p>延續上面那個物件的例子，如果改成這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;  </span><br><span class="line">  num: 10  </span><br><span class="line">&#125;  </span><br><span class="line">var obj2 = obj;  </span><br><span class="line">console.log(obj, obj2);  </span><br><span class="line">obj2 = &#123;  </span><br><span class="line">  num: 20  </span><br><span class="line">&#125;;  </span><br><span class="line">console.log(obj, obj2);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*89QXBxrOCc1RR0nukUJ7IQ.png" alt></p><p>雖然上面提到物件是傳參考的，但是在這個例子中雖然 <code>obj2</code> 與 <code>obj</code> 一度指向同樣的記憶體位址，但是隨即又被等號運算子重新賦與一個新的物件，此時 <code>obj</code> 就與 <code>obj2</code> 指向不同的記憶體位址了。</p><h3 id="所以陷阱在哪裡"><a href="#所以陷阱在哪裡" class="headerlink" title="所以陷阱在哪裡"></a>所以陷阱在哪裡</h3><p>透過上下兩個相似例子的比較，我們需要搞清楚以下：</p><ul><li><code>obj2.num = 20;</code></li><li><code>obj2 = { num: 20 };</code></li></ul><p>雖然都是使用等號運算子，但是意義上是不太一樣的。</p><p><strong>回想一下第一點的那個例子，</strong></p><ul><li>一開始 <code>obj</code> 與 <code>obj2</code> 指向同一個位址</li><li>使用等號運算子把<strong>新的數值</strong>賦值給 <code>obj2</code> 內的屬性 <code>num</code></li><li><strong>新的數值</strong>產生也會被存放在某個記憶體位址，</li><li>但因為賦值的對象並不是 <code>obj2</code> ，所以沒有影響到 <code>obj2</code> 的位址。</li></ul><p><strong>第二點的例子，</strong></p><ul><li>一開始 <code>obj</code> 與 <code>obj2</code> 指向同一個位址</li><li>使用等號運算子把<strong>新的物件</strong>賦值給 <code>obj2</code></li><li><strong>新的物件</strong>產生也會被存放在某個記憶體位址</li><li>此時賦值的對象是 <code>obj2</code> ，等號運算子把新物件的記憶體位址給了 <code>obj2</code></li></ul><p>也就是說，此時 <code>obj</code> 與 <code>obj2</code> 就不相干了。</p><p>另外還有個初學者會遇到的例子，關於等號運算子的，也就是少打等號的問題，一般我們都會這樣寫<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">if (a === 1)&#123;  </span><br><span class="line">  console.log(123);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但如果少打了等號：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">if (a = 20)&#123;  </span><br><span class="line">  console.log(456);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>結果就會出現非預期的輸出，原因是這樣子寫就如同：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;  </span><br><span class="line">a = 20;  </span><br><span class="line">if (a)&#123;  </span><br><span class="line">  console.log(456);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以這個 if 內的東西一定會執行。</p><h2 id="心得"><a href="#心得" class="headerlink" title="[心得]"></a>[心得]</h2><p>這個小節的內容個各別散落在原本世界線的不同文章上，透過這樣的重新整理，又再次的複習了這些概念，其中我最喜歡的是小陷阱的部分，可以藉由這些陷阱，再度的仔細思考是不是哪個環節想錯了。</p><p>我開始喜歡寫紀錄文了，這有點像鄧不利多的儲思盆，可以把記不住的東西給寫下來，然後不占據腦容量，需要的時候在到儲思盆看一下～</p><blockquote><p>雖然暫時沒辦法全部都記住，看久、摸久、寫久總會是我的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上次提到 Primitive Types 與 object 的其中一個差別，接下來我們討論另一個差別，那就是對於運算子「=」，兩者的表現並不一樣。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.51 變數的資料型態</title>
    <link href="http://pvt5r486.github.io/f2e/20190214/2106705850/"/>
    <id>http://pvt5r486.github.io/f2e/20190214/2106705850/</id>
    <published>2019-02-14T06:03:34.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因緣際會之下，我得到了更多學習 JavaScript 的機會，覺得這很適合成為 JavaScript Weird 的一個支線，大概就很像打遊戲一樣，同樣的關卡還有個裏關。因此所謂的支線呢，就是把之前篇章提到的某些概念再拿出來寫一次，但是記錄的觀點不一樣，希望透過這樣的方式，能讓自己理解更多。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*C2AcGMhKqt2SGylx" alt></p><h2 id="變數的資料型態"><a href="#變數的資料型態" class="headerlink" title="變數的資料型態"></a>變數的資料型態</h2><p>變數的資料型態總共有七種：</p><ul><li>可對應<a href="https://pvt5r486.github.io/javascript/20190116/4270157926">[JavaScriptWeird]No.13 純值</a></li></ul><blockquote><p><strong>JavaScript 有六種純值</strong> (Primitive Types，或稱為基本型別、原始型態)</p></blockquote><ul><li>null</li><li>undefined</li><li>string</li><li>number</li><li>boolean</li><li>sysbol ( ES6 )</li></ul><p><strong>其他都是物件</strong></p><ul><li>object (像是 array , function , date … )</li></ul><h2 id="如何判斷型態"><a href="#如何判斷型態" class="headerlink" title="如何判斷型態"></a>如何判斷型態</h2><p>最簡單的方式就是使用「<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="external nofollow noopener noreferrer" target="_blank">typeof</a>」，先把每個型態都印出來瞧瞧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 10);　// number  </span><br><span class="line">console.log(typeof &apos;Hi&apos;); // string  </span><br><span class="line">console.log(typeof undefined); // undefined  </span><br><span class="line">console.log(typeof true); // boolean  </span><br><span class="line">console.log(typeof &#123;&#125;); // object</span><br><span class="line"></span><br><span class="line">console.log(typeof \[\]); // object  </span><br><span class="line">console.log(typeof function()&#123;&#125;); // function  </span><br><span class="line">console.log(typeof null); // object</span><br></pre></td></tr></table></figure><p></p><p>這邊故意用了一行空白隔開，上半部是比較好理解的，因為那些的確就是它們的型態，可是下面的部分呢？</p><p>為什麼陣列的型態會是物件 ?</p><ul><li>這部分也能參考 <a href="https://pvt5r486.github.io/javascript/20190206/113208756">[JavaScriptWeird]No.42 所有東西都是物件或純值</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [];  </span><br><span class="line">console.log(a.__proto__);  </span><br><span class="line">console.log(a.__proto__.__proto__);  </span><br><span class="line">console.log(a.__proto__.__proto__.__proto__); // null</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*sDP2kpRjF5I-woTOfIXtpQ.png" alt></p><p>可以像這樣透過觀察原型的方式得知， array 的最底層也是物件。</p><p>同理也可以觀察函式，會得出函式也是物件。</p><blockquote><p><strong>最特別的是 null ，為什麼 null 的型別會是 object ?</strong></p></blockquote><p>其實這是 JavaScript 最廣為人知的 BUG ，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 上也有相關的記載，聽說是從一開始就存在了，但可能是有牽扯到很多東西，所以沒有人去修正。</p><p>MDN 也幫我們整理好了 <code>typeof</code> 的表格，真的是非常給力。</p><h2 id="如何更精準的判斷型態"><a href="#如何更精準的判斷型態" class="headerlink" title="如何更精準的判斷型態"></a>如何更精準的判斷型態</h2><p>雖然大多數的情況， <code>typeof</code> 已經夠用了，但如果我希望如果它的型態就是 array 而不是回傳 object 的話，還有什麼方式?</p><ul><li>可以使用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" rel="external nofollow noopener noreferrer" target="_blank">Array.isArray()</a> 方法，如環境不支援 MDN 內也有 <a href="https://medium.com/pvt5r486/javascript-weird-day-50-object-create-%E8%88%87-%E7%B4%94%E7%B2%B9%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%B9%BC%E6%89%BF-3d8fc7212566" rel="external nofollow noopener noreferrer" target="_blank">Polyfill</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [];  </span><br><span class="line">console.log(Array.isArray(a)); // true</span><br></pre></td></tr></table></figure><ul><li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" rel="external nofollow noopener noreferrer" target="_blank">Object.prototype.toString</a> 方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [];  </span><br><span class="line">console.log(Object.prototype.toString.call(a)); // [object Array]  </span><br><span class="line">console.log(Object.prototype.toString.call(null)); // [object Null]</span><br></pre></td></tr></table></figure><h2 id="常見的-typeof-用法"><a href="#常見的-typeof-用法" class="headerlink" title="常見的 typeof 用法"></a>常見的 typeof 用法</h2><p>還記得<a href="https://pvt5r486.github.io/javascript/20190120/945735864"><strong>運算子的優先性與相依性</strong></a>嗎？typeof 是運算子，查詢表格後得知是右相依性 (right-to-left)，常見的做法像是「檢查某變數有無作用」：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof a !== &apos;undefined&apos;) &#123;  </span><br><span class="line">  console.log(typeof a);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>透過這樣子寫，當變數 <code>a</code> 不存在的時候什麼都不會發生，存在的時候就會秀出該變數型態。</p><p>但問題是為什麼不能直接用「!==」判斷就好 ?</p><p>為什麼 <code>typeof</code> 後面可以直接用 <code>a</code>?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// var a; 沒有這行就出錯  </span><br><span class="line">if (a !== &apos;undefined&apos;) &#123;  </span><br><span class="line">  console.log(typeof a);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>就如同先前培養的觀念，如果沒有宣告變數 <code>a</code> ，在全域執行環境內也找不到 <code>a</code> ，這時如果嘗試取用 <code>a</code> 就會跳出錯誤。</p><p><strong>然而，為什麼 typeof 就可以呢？</strong><br>讓我們再次研究運算子的優先性與相依性</p><ul><li>「typeof」的優先值 16，為右相依性</li><li>「!==」的優先值 10，為左相依性</li></ul><p>優先值高的會先執行，也就是說實際上是「<code>typeof a</code>」先做了。</p><blockquote><p><code>typeof</code> 運算子會傳回一個字串值，指出未經運算 (unevaluated) 的運算元所代表的型別，之後才進行「!==」的比較。</p></blockquote><h2 id="Primitive-Types-與-object-差別"><a href="#Primitive-Types-與-object-差別" class="headerlink" title="Primitive Types 與 object 差別"></a>Primitive Types 與 object 差別</h2><p>其中的一個差別就是，Primitive Types 是不可改變 (Immutable) 的，這個「不可改變」不是直觀的那個意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 並不是這個意思  </span><br><span class="line">var a = 1;  </span><br><span class="line">a = 2</span><br></pre></td></tr></table></figure><p>這個並不是改變，正確來說這樣叫重新賦值。</p><p><strong>所謂的 Primitive Types 不可改變是這樣的：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;;  </span><br><span class="line">str.toUpperCase();  </span><br><span class="line">console.log(str);　// hello</span><br></pre></td></tr></table></figure><p></p><p>現在 <code>str</code> 是個字串純值，使用了 <code>toUpperCase()</code> 把小寫字母變成大寫字母，但因為純值本身是不可改變的，所以當執行完 <code>toUpperCase()</code> 後， <code>str</code> 本身並沒有改變什麼，所以仍舊是小寫的 hello 。</p><p>而「<code>toUpperCase()</code>」 會做的事情就是取得 <code>str</code> 的字串值後，「回傳」一個大寫的新字串，而不是改變 <code>str</code> 內容。</p><p>當然如果改成這樣寫就變成大寫了，因為被重新賦值了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;;  </span><br><span class="line">str = str.toUpperCase();  </span><br><span class="line">console.log(str); // HELLO</span><br></pre></td></tr></table></figure><p></p><p><strong>那至於可改變 (mutable) 的 object 是怎麼回事？</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1];  </span><br><span class="line">arr.push(2);  </span><br><span class="line">console.log(arr); // [1, 2]</span><br></pre></td></tr></table></figure><p></p><p>陣列 <code>arr</code> 本身的確被改變了，而且不是藉由等號運算子賦值。</p><h2 id="心得"><a href="#心得" class="headerlink" title="[心得]"></a>[心得]</h2><p>正如我前言所說的，覺得這真得很適合做為 JavaScript Weird 的支線，因為講到的觀念其實都蠻進階的，可以看到我時不時穿插了之前做的筆記，但畢竟這算是給初學者的進階 JavaScript ，所以也算是蠻合理的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      因緣際會之下，我得到了更多學習 JavaScript 的機會，覺得這很適合成為 JavaScript Weird 的一個支線，大概就很像打遊戲一樣，同樣的關卡還有個裏關。因此所謂的支線呢，就是把之前篇章提到的某些概念再拿出來寫一次，但是記錄的觀點不一樣，希望透過這樣的方式，能讓自己理解更多。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
      <category term="JS201" scheme="http://pvt5r486.github.io/tags/JS201/"/>
    
      <category term="支線" scheme="http://pvt5r486.github.io/tags/%E6%94%AF%E7%B7%9A/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.50 Object.create() 與 純粹的原型繼承</title>
    <link href="http://pvt5r486.github.io/f2e/20190211/53717031/"/>
    <id>http://pvt5r486.github.io/f2e/20190211/53717031/</id>
    <published>2019-02-11T00:44:32.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們已經知道了如何使用函式建構子建立物件的方法，但除了透過函式建構子之外其實還有別的方法可以建立物件且指定原型。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*6qFfiNXFIzKyivO5" alt></p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="external nofollow noopener noreferrer" target="_blank">Object.create()</a> ，MDN 的說明為指定其原型物件與屬性，創建一個新物件，直接透過範例來了解：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  greet: function() &#123;  </span><br><span class="line">    return &apos;hello &apos; + this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = Object.create(person);  </span><br><span class="line">console.log(john);</span><br></pre></td></tr></table></figure><p></p><p>我們建立物件 <code>person</code> ，並且使用 <code>Object.create()</code> 方法建立新的物件，把 <code>person</code> 當成參數傳入，接著印出 <code>john</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*GL9EqCpEp3Ge7I7YCKCD4g.png" alt></p><p>我們並沒有改變什麼，只是說有其他種方式可以建立物件。</p><p><code>john</code> 現在是一個空物件，且原型是 <code>person</code> 物件，因此可以呼叫 <code>greet</code> 方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(john.greet());  </span><br><span class="line">// hello Default</span><br></pre></td></tr></table></figure><p></p><p>因為 <code>john</code> 現在是空物件，所以它的 <code>firstName</code> 會到原型鏈上尋找，因此我們只要讓 <code>john</code> 有對應的屬性就可以了，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  greet: function() &#123;  </span><br><span class="line">    return &apos;hello &apos; + this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var john = Object.create(person);  </span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(john.greet()); // hello Default  </span><br><span class="line">john.firstName = &apos;John&apos;;  </span><br><span class="line">console.log(john.greet());　// hello John</span><br></pre></td></tr></table></figure><p></p><p>簡單來說我們只是建立一個物件，並且以這個物件為基底，在這物件之上建立了新物件，然後我們就可以在這之上進行覆寫、增加屬性或方法。</p><p>這麼做還有一個好處，就是原型物件非常直觀就可以進行修改，而且以該物件為原型的其他物件都可以取用這些方法，這就是純粹的原型繼承。</p><h2 id="如果與先前的函式建構子對照起來"><a href="#如果與先前的函式建構子對照起來" class="headerlink" title="如果與先前的函式建構子對照起來"></a>如果與先前的函式建構子對照起來</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  greet: function() &#123;  </span><br><span class="line">    return &apos;hello &apos; + this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function person1(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">    this.getFullName = function()&#123;  </span><br><span class="line">      return this.firstName;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = Object.create(person);  </span><br><span class="line">console.log(john);  </span><br><span class="line">john.firstName = &apos;John&apos;;</span><br><span class="line"></span><br><span class="line">var mary = new person1(&apos;mary&apos;, &apos;Doe&apos;);  </span><br><span class="line">console.log(mary);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*_2w1-F04LI06PllY38S1Iw.png" alt></p><p>結構略有不同，個人較偏好使用 <code>Object.create()</code> 建立原型物件。</p><h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><code>Object.create()</code> 這麼神奇好用，是不是可以廣泛應用在任何地方？很遺憾，雖然大部分瀏覽器都支援這麼方法，但如果需要支援到 IE8 的話這是沒有辦法使用的，但也有相對應的措施，那就是找找看有沒有 Polyfill 。</p><p>Polyfill 是將引擎缺少的功能增加到程式中，使之可以正常運作，所以如果我們想要在 IE8 或者更舊的環境下使用 <code>Object.create()</code> 可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Polyfill  </span><br><span class="line">if (typeof Object.create !== &quot;function&quot;) &#123;  </span><br><span class="line">  Object.create = function (proto, propertiesObject) &#123;  </span><br><span class="line">      if (!(proto === null || typeof proto === &quot;object&quot; || typeof proto === &quot;function&quot;)) &#123;  </span><br><span class="line">          throw TypeError(&apos;Argument must be an object, or null&apos;);  </span><br><span class="line">      &#125;  </span><br><span class="line">      var temp = new Object();  </span><br><span class="line">      temp.__proto__ = proto;  </span><br><span class="line">      if(typeof propertiesObject === &quot;object&quot;)  </span><br><span class="line">          Object.defineProperties(temp, propertiesObject);  </span><br><span class="line">      return temp;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  greet: function() &#123;  </span><br><span class="line">    return &apos;hello &apos; + this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function person1(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">    this.getFullName = function()&#123;  </span><br><span class="line">      return this.firstName;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = Object.create(person);  </span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(john.greet());  </span><br><span class="line">john.firstName = &apos;John&apos;;  </span><br><span class="line">console.log(john.greet());</span><br><span class="line"></span><br><span class="line">var mary = new person1(&apos;mary&apos;, &apos;Doe&apos;);  </span><br><span class="line">console.log(mary);</span><br></pre></td></tr></table></figure><p></p><p>MDN 很貼心的將 <code>Object.create()</code> 的 Polyfill 放上去了，所以可以像這樣直接貼上到程式碼內，MDN 其實提共了不少現成的 Polyfill，讓我們方便使用。</p><p>同樣的方式我們可以再新增一個 <code>mary</code> 物件，並且設定原型為 <code>john</code> 然後觀察輸出情形：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  greet: function() &#123;  </span><br><span class="line">    return &apos;hello &apos; + this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var john = Object.create(person);  </span><br><span class="line"> console.log(john);  </span><br><span class="line">// console.log(john.greet());  </span><br><span class="line">john.firstName = &apos;John&apos;;  </span><br><span class="line">john.sayHi = function()&#123;  </span><br><span class="line">  return &apos;Hi &apos; + this.firstName;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(john.greet());  </span><br><span class="line">console.log(john.sayHi());</span><br><span class="line"></span><br><span class="line">var mary = Object.create(john);  </span><br><span class="line">mary.firstName = &apos;mary&apos;;  </span><br><span class="line">console.log(mary);  </span><br><span class="line">console.log(mary.greet());  </span><br><span class="line">console.log(mary.sayHi());</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*fzc8FarCvDE8MIaS4j5XGw.png" alt></p><p>觀察後發現 <code>mary</code> 物件的原型鏈的下一層就是 <code>john</code> ，最底層是 <code>person</code> ，因此也可以使用 <code>greet</code> 、 <code>sayHi</code> 方法。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們已經知道了如何使用函式建構子建立物件的方法，但除了透過函式建構子之外其實還有別的方法可以建立物件且指定原型。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.49 危險小叮嚀：陣列與 for in</title>
    <link href="http://pvt5r486.github.io/f2e/20190210/3561616305/"/>
    <id>http://pvt5r486.github.io/f2e/20190210/3561616305/</id>
    <published>2019-02-09T21:19:08.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>for in</code> 我想並不陌生，因為在 <a href="https://pvt5r486.github.io/javascript/20190206/3636975661">Reflection 與 Extend</a> 時有用它來遍歷物件並且印出來，然而<a href="https://pvt5r486.github.io/javascript/20190206/113208756">前面</a>我們也提到過，陣列也是物件，所以也可以在原型上加入新的屬性或方法，本篇是用來介紹關於兩者如果一起用可能會導致的問題。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*elgxWB7mOMRZWMQu" alt></p><h2 id="直接看例子："><a href="#直接看例子：" class="headerlink" title="直接看例子："></a>直接看例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;John&apos;, &apos;Mary&apos;, &apos;Tom&apos;];  </span><br><span class="line">for(var item in arr)&#123;  </span><br><span class="line">  console.log(item + &apos;: &apos; + arr[item]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*oBdtJL1aASueDVNWwzNLWw.png" alt></p><p>雖然很奇怪但這是合理的結果，因為陣列也是物件。</p><p>變數 <code>item</code> 中的 0、1、2 其實是名稱屬性，所以可以使用中括號取用它們，而 <code>John、Mary、Tom</code> 是值。我們使用 <code>for in</code> 遍歷了整個陣列並且印出。</p><p>接著我們增加屬性到它的原型上。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myNewAdd = &apos;cool!&apos;;  </span><br><span class="line">var arr = [&apos;John&apos;, &apos;Mary&apos;, &apos;Tom&apos;];  </span><br><span class="line">for(var item in arr)&#123;  </span><br><span class="line">  console.log(item + &apos;: &apos; + arr[item]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*fO6RsScyYVa6N0CQ30X7Zw.png" alt></p><p>結果居然多跑出一行我們新增到原型上的屬性，為什麼？</p><p>因為陣列也是物件，而 <code>for in</code> 會找到原型鏈上，把原型上的屬性、方法一起遍歷，所以再一些不需要 <code>for in</code> 的情況中可以使用 <code>for</code> 迴圈即可，像是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; arr.length; i++)&#123;  </span><br><span class="line">  console.log(i + &apos;: &apos; + arr\[i\]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*mvmjml8yvxmcFKSvqhOwcw.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      for in 我想並不陌生，因為在 Reflection 與 Extend 時有用它來遍歷物件並且印出來，然而前面我們也提到過，陣列也是物件，所以也可以在原型上加入新的屬性或方法，本篇是用來介紹關於兩者如果一起用可能會導致的問題。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.48 觀念小叮嚀：內建的函式建構子(二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190210/1744156963/"/>
    <id>http://pvt5r486.github.io/f2e/20190210/1744156963/</id>
    <published>2019-02-09T20:46:01.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接續前篇，另一個危險小叮嚀時間，我們已經討論過內建的函式建構子，它們相當的便利簡潔，但也很危險。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*SW9e-0ZFmIMhkboM" alt></p><h2 id="為什麼危險呢？透過例子來了解："><a href="#為什麼危險呢？透過例子來了解：" class="headerlink" title="為什麼危險呢？透過例子來了解："></a>為什麼危險呢？透過例子來了解：</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*hkWtTiJjvtnk9rVqvE5FqQ.png" alt></p><p>看出問題在哪邊了嗎？</p><h3 id="問題再於"><a href="#問題再於" class="headerlink" title="問題再於"></a>問題再於</h3><ul><li>如果使用內建的函式建構子來設定值，這時候 <code>a</code> 是數值 3 ，而 <code>b</code> 是物件。</li><li>而雙等號運算子知道兩者的型別，試著將兩者型別變成一樣</li></ul><blockquote><p>但實際上兩者是完全不同的東西，三等號運算子回傳的結果才是正確的。</p></blockquote><p><strong>內建的函式建構子所建立的純值並不是真正的純值</strong>，因此如果要建立純值就使用實體語法建立即可，除非我們很確定須要用上函式建構子建立。</p><p>前面提到 <code>new</code> 後面接著的是一般的函式，所以有沒有 <code>new</code> 的差距相當大，例如沒有 <code>new</code> 的情況，我們可以使用這些內建函式來轉換型別，此時的 <code>c</code> 就是一個真正的純值。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*nM1cylTOIxzp64KyXMxwSA.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接續前篇，另一個危險小叮嚀時間，我們已經討論過內建的函式建構子，它們相當的便利簡潔，但也很危險。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.47 觀念小叮嚀：內建的函式建構子(一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190210/1934200484/"/>
    <id>http://pvt5r486.github.io/f2e/20190210/1934200484/</id>
    <published>2019-02-09T19:15:56.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在我們已經知道函式建構子了， JavaScript 有一些內建的函式建構子，可以在這篇討論一下，而這些內建的函式建構子大多也都遵循傳統<strong>首字母大寫</strong>。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*aex-RYIDfRf5-RnA" alt></p><h2 id="內建的函式建構子"><a href="#內建的函式建構子" class="headerlink" title="內建的函式建構子"></a>內建的函式建構子</h2><p>首先打開 chrome 的開發者工具，不需要自行撰寫程式碼，因為有些函式以及函式原型已經存在，所以可以直接測試。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Cumi4UF5xg3XotZBaJU5qA.png" alt></p><p><code>Number()</code> 是 JavaScript 內建的函式建構子，遵循了首字母大寫的傳統，這邊要注意的是 <code>a</code> 並不是一個純數值，而是一個物件裡面包著純值 3 。</p><p>因為 <code>Number()</code> 是一個物件，所以它有原型，順著觀察下去：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*NA_UYQjmkmcJ9DWuGg2eaQ.png" alt></p><p>可以看到有許多的方法，所以 <code>Number</code> 物件都可以取用到這些方法，像是裡面的 <code>toFixed()</code> ，因此可以這麼用：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*aKO7fuwYaBAMFcXsck5CEA.png" alt></p><p>試試另一個內建的函式建構子 <code>String</code></p><p><img src="https://cdn-images-1.medium.com/max/800/1*VJghXaNq1hG7s4ZoaoU4aQ.png" alt></p><p>用同樣的做法讓 「<code>a.</code>」能夠取用到一堆在字串上能用的方法。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*LgAWe9miDTmOEi0KbLx8og.png" alt></p><p>這些方法並不再 <code>a</code> 上，而是在 <code>String</code> 的原型上。舉例來說，像是：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*cK_VaetiojJeVCYhN-EZKg.png" alt></p><p>我使用了 <code>.indexOf(&quot;J&quot;)</code> 尋找字串中是否有這個字母，回傳 0 代表 <code>J</code> 在第 0 個位址。</p><p>要特別注意的是，這裡的 a 並不是字串，這與上一個範例相同，a 是一個物件。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ANxxV38t9Yq-5PC0xonqrA.png" alt></p><p>上面的兩個例子看起來起手都像是在建立純值，但其實我們是在建立一個物件，而這個物件包含了純值以及一些額外功能。</p><p>另外某些例子中 JavaScript 允許這樣子做，它會知道我們要物件而不是純值：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*KYFJvlees1aplum5jJJYXA.png" alt></p><p>「.」前面的 <code>John</code> 是個純值，但 JavaScript 自動把它放入字串物件中，讓我們能使用 <code>length</code> 方法。</p><p>就類似於這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;John&quot;)</span><br></pre></td></tr></table></figure><p></p><p>然後再對它做 <code>length</code> 方法。</p><p>但並不是所有內建的函式建構子都能這麼做，像是：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*1c1gmC4lfivyeYAVy6KmeA.png" alt></p><blockquote><p>在有了原型、原型鏈、函式建構子的觀念後，我們甚至可以在內建的函式建構子上額外擴充一些方法，像是增加一個方法給所有字串：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.isLengthGreaterThan = function(limit) &#123;  </span><br><span class="line">  return this.length &gt; limit;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;John&quot;.isLengthGreaterThan(3));　// true</span><br></pre></td></tr></table></figure><p>純值字串 <code>John</code> 被字串原型函式轉換成字串物件，並且取用了我們新增於字串原型上的 <code>isLengthGreaterThan</code> 方法。</p><p>而且之後所有的字串都可以取用這個方法，這是相當強大的！</p><p>嘗試對 <code>Number</code> 增加一個方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.isPositive = function() &#123;  </span><br><span class="line">  return this &gt; 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*1E6XSzICYN19tcCRWhOT3A.png" alt></p><p>如同上面的範例， <code>JavaScript</code> 雖然會幫我們轉換字串但不會轉換數值，所以仍然要使用函式建構子，然後呼叫我們新增的 <code>isPositive</code> 方法。</p><p>如果要處理這些被函式建構子所建立的東西，觀念不清楚是相當危險的，畢竟它們很像純值但實際上是物件。</p><p>下一篇要來了解為什麼危險以及正確的觀念為何？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      現在我們已經知道函式建構子了， JavaScript 有一些內建的函式建構子，可以在這篇討論一下，而這些內建的函式建構子大多也都遵循傳統，首字母大寫。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.46 危險小叮嚀：「new」與函式</title>
    <link href="http://pvt5r486.github.io/f2e/20190210/2294279041/"/>
    <id>http://pvt5r486.github.io/f2e/20190210/2294279041/</id>
    <published>2019-02-09T18:07:40.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>還記得函式建構子是如何運作的嗎？當執行環境執行時， <code>this</code> 變數指向空物件，如果不回傳任何東西的話，預設回傳新物件。而當我們用函式建構子時，它們仍然是一般的函式，只是在前面加上 <code>new</code> 運算子，然而危險的部分也在這裡。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*O7iptxnlck2GRcAR" alt></p><h2 id="使用先前的範例來說明："><a href="#使用先前的範例來說明：" class="headerlink" title="使用先前的範例來說明："></a>使用先前的範例來說明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">    this.getFullName = function()&#123;  </span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.getFullName = function()&#123;  </span><br><span class="line">  return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = person(&apos;Doe&apos;, &apos;john&apos;);  </span><br><span class="line">var joan = person(&apos;Mar&apos;, &apos;joan&apos;);  </span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);  </span><br><span class="line">person.prototype.getFormalFullName = function()&#123;  </span><br><span class="line">  return this.firstName;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(john.getFormalFullName());</span><br></pre></td></tr></table></figure><p>如果把 <code>new</code> 運算子拿掉會如何呢？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*X22zu06Ysd7x4RmEbML4Mg.png" alt></p><p>當我們忘記放上 <code>new</code> 關鍵字時，後面跟著的是一般的無回傳函式，所以運行後沒有回傳任何東西給變數，因此變數的值為 <code>undefined</code> 。</p><p>當取用 <code>getFormalFullName</code> 方法時，因為此時 <code>john</code> 並非物件，而是 <code>undefined</code> ，所以沒辦法到原型鏈上尋找方法，因此跳出錯誤。</p><h2 id="如何避免忘記放上-new-呢？"><a href="#如何避免忘記放上-new-呢？" class="headerlink" title="如何避免忘記放上 new 呢？"></a>如何避免忘記放上 new 呢？</h2><p>課程中講師有提到似乎有一些約定成俗的習慣，就是:</p><blockquote><p><strong>任何要做為函式建構子的函式，首字母大寫</strong></p></blockquote><p>這樣子就能馬上認出哪個地方少了 <code>new</code> 運算子，或者是使用 <a href="https://atom.io/packages/linter" rel="external nofollow noopener noreferrer" target="_blank">Linters</a> 輔助撰寫程式碼。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      還記得函式建構子是如何運作的嗎？當執行環境執行時，this 變數指向空物件，如果不回傳任何東西的話，預設回傳新物件。而當我們用函式建構子時，它們仍然是一般的函式，只是在前面加上 new 運算子，然而危險的部分也在這裡。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.3 計算機</title>
    <link href="http://pvt5r486.github.io/f2e/20190209/27704665/"/>
    <id>http://pvt5r486.github.io/f2e/20190209/27704665/</id>
    <published>2019-02-09T01:23:02.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="預覽圖"><a href="#預覽圖" class="headerlink" title="預覽圖"></a>預覽圖</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*kgQ-ONeqab6M03ZoHjxSDg.png" alt></p><h2 id="本層-BOSS-弱點"><a href="#本層-BOSS-弱點" class="headerlink" title="本層 BOSS 弱點"></a>本層 BOSS 弱點</h2><ul><li>【特定技術】數字位數過多時，不能因此而破版，計算機功能皆須齊全</li><li>【自我學習】請在此關卡中「自學一個你原本不太會的技巧」，投稿時分享你透過哪些資源學習，並寫範例程式碼講解該技巧，以及你如何應用在此關卡上。</li></ul><h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul><li>Vue.js</li><li>SCSS</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一層樓的網頁切版相對的簡單很多，困難的點在於程式邏輯上</p><ul><li>要怎麼處理計算機的每一個小細節，像是 0.1 + 0.2 會跑出 0.3000000004 的問題，諸如此類。</li><li>JavaScript 中字串與數字間的轉換。</li></ul><p>然而在這一次的地下城中，學到了 eval() 與 正規表達式的用法：</p><ul><li><p>eval() 在本次地下城中，主要用來處理已經轉換成字串的算式部分，舉例來說像是這樣：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;100 - 50&apos;;  </span><br><span class="line">console.log(eval(str)) // 50</span><br></pre></td></tr></table></figure></li><li><p>正規表達式主要用於加入千分號、驗證上，本次只有知道該如何使用正規表達式在程式上，至於規則的撰寫並沒有太過深入，可以像這樣用在需要驗證的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let key = &apos;00&apos;;  </span><br><span class="line">let key1 = &apos;.&apos;;  </span><br><span class="line">let key2 = &apos;1&apos;;  </span><br><span class="line">let reg = /^\\.|00/;  </span><br><span class="line">console.log(reg.test(key)); // true  </span><br><span class="line">console.log(reg.test(key1)); // true  </span><br><span class="line">console.log(reg.test(key2)); // false</span><br></pre></td></tr></table></figure></li></ul><p>像這樣，我寫了一個規則，檢查字串開頭是否包含「00」或「.」，對於正規表達式可以使用 <code>.test()</code> 來驗證，還有更多使用方式可以參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Regular_Expressions" rel="external nofollow noopener noreferrer" target="_blank">MDN</a></p><p>然後還有計算機上方那一排小字，就是記錄著已經輸入哪些算式的地方，有些人的做法是「如果過長就刪節號省略」、有些人的做法是「客制化 Scroll bar 使之可滾動」。</p><p>但我的做法是參考 win7 內的小算盤，電腦內的小算盤再算式過長時，會有一 種被往前推的效果 (<em>請原諒我不會描述</em>) ，一開始我也不知道這是什麼效果、要怎麼寫，但後來我是使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring" rel="external nofollow noopener noreferrer" target="_blank"><strong>substring ()</strong></a> 達成。</p><p>我設定了固定的字元數，如果公式長度超出了字元數，那麼就兩者相減，多出來的字元數就填入 substring () 當成起點。</p><h2 id="不足的部分"><a href="#不足的部分" class="headerlink" title="不足的部分"></a>不足的部分</h2><ul><li>正規表達式真的很反人類，困難指數破表…。</li><li>計算機需要注意的細節很多，還有一些可以使用正規表達式處理好的細節沒有做好。</li></ul><h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><ul><li><a href="https://pvt5r486.github.io/JSD3_Calc/index">線上DEMO</a></li><li><a href="https://github.com/pvt5r486/JSD3_Calc" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      六角 JavaScriptDungeon 計算機
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.45 函式建構子與「.prototype」</title>
    <link href="http://pvt5r486.github.io/f2e/20190207/174313532/"/>
    <id>http://pvt5r486.github.io/f2e/20190207/174313532/</id>
    <published>2019-02-07T04:52:00.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇看到了函式建構子能夠幫新物件設定屬性和方法，接下來要介紹如何使用函式建構子設定原型，是另一個 JavaScript 建立物件的重要部分。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*4qoHuEFIpXZPy8tI" alt></p><h2 id="延續上一篇的程式碼，如下："><a href="#延續上一篇的程式碼，如下：" class="headerlink" title="延續上一篇的程式碼，如下："></a>延續上一篇的程式碼，如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person(&apos;Doe&apos;, &apos;john&apos;);  </span><br><span class="line">var joan = new person(&apos;Mar&apos;, &apos;joan&apos;);</span><br><span class="line"></span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);</span><br></pre></td></tr></table></figure><p>問題是，應該要如何設定原型呢？首先觀察一下 <code>john</code> 、 <code>joan</code> 的 <code>__proto__</code> 指向哪邊。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*KpXOnz648-RW_l9gNKabqg.png" alt></p><p>當使用函式建構子時，函式建構子已經幫我們設定好原型了。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*u1HaL1c2RXOeXOFZd5iVqA.png" alt></p><p>建立函式物件時有個特殊屬性像是名稱屬性、程式屬性，還有每個函式都具有的原型屬性 (prototype property)，除非將函式做為函式建構子使用，否則原型屬性永遠不會用到，使用 <code>new</code> 運算子並且使用函式建構子來建立物件時，原型屬性才有作用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.getFullName = function()&#123;  </span><br><span class="line">  return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = new person(&apos;Doe&apos;, &apos;john&apos;);  </span><br><span class="line">var joan = new person(&apos;Mar&apos;, &apos;joan&apos;);</span><br><span class="line"></span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);</span><br></pre></td></tr></table></figure><p></p><p>「.prototype」指的是<strong>函式的原型屬性</strong>，所謂<strong>函式的原型屬性</strong>其實就是用函式建構子建立的物件其原型鏈指向的東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*mr9YKClssn5mddqskxabWQ.png" alt></p><p>也就是說 <code>john</code> 、 <code>joan</code> 都指向 <code>person.prototype</code> 為原型，它們都可以取用到我增加的 <code>getFullName</code> 方法，甚至可以直接在瀏覽器直接使用。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*DZf_F_5tmWn282d3K8227g.png" alt></p><h2 id="也可以之後又新增更多東西到原型，像是："><a href="#也可以之後又新增更多東西到原型，像是：" class="headerlink" title="也可以之後又新增更多東西到原型，像是："></a>也可以之後又新增更多東西到原型，像是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.getFullName = function()&#123;  </span><br><span class="line">  return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = new person(&apos;Doe&apos;, &apos;john&apos;);  </span><br><span class="line">var joan = new person(&apos;Mar&apos;, &apos;joan&apos;);  </span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);  </span><br><span class="line">person.prototype.getFormalFullName = function()&#123;  </span><br><span class="line">  return this.firstName;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(john.getFormalFullName);</span><br></pre></td></tr></table></figure><p>後面才新增在原型上的方法，仍然可以被先前就建立好的物件取用。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*dK1jDdIecHsZcWWEGDuNNw.png" alt></p><p>這代表之後所有使用 <code>preson</code> 函式建立的物件，都可以取用我們新增在原型上的方法，藉由「<code>.prototype</code>」這個函式的原型屬性。</p><p>如果把 <code>getFullName</code> 方法放到 <code>person</code> 函式內，與把 <code>getFullName</code> 方法放到 <code>person</code> 函式的原型屬性內差別在哪?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">    this.getFullName = function()&#123;  </span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>舉例來說，假如前者有一千個物件，那麼這一千個物件內都會新增 <code>getFullName</code> 方法，表示每個物件都會有自己的 <code>getFullName</code> 方法，這會佔據較多的記憶體空間。</p><p>而後者的話，雖然有一千個物件，但只會有一個 <code>getFullName</code> 方法，因為這個方法被增加到原型上。</p><p>以效能的觀點來看，將重複的屬性和方法放在原型上會比較好。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇看到了函式建構子能夠幫新物件設定屬性和方法，接下來要介紹如何使用函式建構子設定原型，是另一個 JavaScript 建立物件的重要部分。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.44 函數建構子「new」</title>
    <link href="http://pvt5r486.github.io/f2e/20190206/1341619258/"/>
    <id>http://pvt5r486.github.io/f2e/20190206/1341619258/</id>
    <published>2019-02-06T05:47:11.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>至此我們已經了解物件和原型、繼承、原型鏈、物件屬性、方法等等，現在該更深入的討論建立物件。之前建立物件的方式都是使用物件實體語法建立的，然而有另一種方法可以建立物件，這是本篇要討論的內容。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*W4aJ7UjERgYbn0TI" alt></p><h2 id="函數建構子「new」"><a href="#函數建構子「new」" class="headerlink" title="函數建構子「new」"></a>函數建構子「new」</h2><p>一個正常的函式用來建立物件，當在呼叫函式前面放了 <code>new</code> 關鍵字時，在執行階段的創造階段被產生的 <code>this</code> 變數會指向新的空物件，當函式結束執行時，該物件會被函式自動回傳。</p><h3 id="看看例子："><a href="#看看例子：" class="headerlink" title="看看例子："></a>看看例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;  </span><br><span class="line">    this.firstName = &apos;Doe&apos;;  </span><br><span class="line">    this.lastName = &apos;John&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person();</span><br></pre></td></tr></table></figure><p>像這樣建立了一個 <code>person</code> 函式，接著用 <code>new</code> 關鍵字建立物件，並且輸出結果觀察。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*X-_rES97CXMTXg9saZpX3w.png" alt></p><p>居然一個物件就建立好了，我們來看看發生了什麼事。</p><p>在這個例子，我們只是用不同的方式在 JavaScript 中建立物件，為了建立物件，我們需要給這個物件屬性和方法以及設定原型，在前面幾篇文章我們都用錯誤的方式在設定原型，那只是為了好理解原型是如何運作的。</p><h2 id="new-是個運算子，記得先前幾篇提到的運算子優先性嗎"><a href="#new-是個運算子，記得先前幾篇提到的運算子優先性嗎" class="headerlink" title="new 是個運算子，記得先前幾篇提到的運算子優先性嗎?"></a>new 是個運算子，記得先前幾篇提到的運算子優先性嗎?</h2><p>可以在裡面找到 new 這個關鍵字。當使用 <code>new</code> 時一個空物件被建立，就好比直接用物件實體語法這樣寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>接著運算子 <code>new</code> 呼叫函式 <code>person</code> ，當函式被呼叫時執行環境會產生 <code>this</code> ，然而 <code>new</code> 會改變 <code>this</code> 的指向到產生的空物件，於是我們寫的程式屬性被執行後， <code>firstName</code> 、 <code>lastName</code> 屬性被增加到空物件上。</p><p>使用 <code>new</code> 運算子的函式並不會回傳值，因為 JavaScript 會回傳被 <code>new</code> 運算子建立的物件，並且會呼叫這個函式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;  </span><br><span class="line">    this.firstName = &apos;Doe&apos;;  </span><br><span class="line">    this.lastName = &apos;John&apos;;  </span><br><span class="line">    console.log(&apos;我被呼叫了&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person();  </span><br><span class="line">console.log(john);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*66_ickvprC6v1KiVtFAQeA.png" alt></p><p>如果不作任何事情，這個 <code>this</code> 會是什麼?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    this.firstName = &apos;Doe&apos;;  </span><br><span class="line">    this.lastName = &apos;John&apos;;  </span><br><span class="line">    console.log(&apos;我被呼叫了&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person()</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*uz2TtOG-A68mUcHIaqJtFw.png" alt></p><p>此時的 <code>this</code> 會指向 <code>person</code> 空物件，後來我們增加屬性，於是空物件內多了屬性。</p><p>我們說使用 <code>new</code> 運算子的函式並不會回傳值，如果主動回傳值的話會發生什麼事情呢?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    this.firstName = &apos;Doe&apos;;  </span><br><span class="line">    this.lastName = &apos;John&apos;;  </span><br><span class="line">    console.log(&apos;我被呼叫了&apos;);  </span><br><span class="line">    return &#123; greeting: &apos;你好&apos; &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person();  </span><br><span class="line">console.log(john);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Deob-pRYUJuw12p512lpag.png" alt></p><p>於是 <code>new</code> 運算子便會回傳我們寫的 <code>return</code> 內容，但如果不回傳任何東西，JavaScript 會知道要建立一個新物件。</p><h2 id="使用-new-運算子也能一次建立多個同樣的屬性、方法的物件"><a href="#使用-new-運算子也能一次建立多個同樣的屬性、方法的物件" class="headerlink" title="使用 new 運算子也能一次建立多個同樣的屬性、方法的物件"></a>使用 new 運算子也能一次建立多個同樣的屬性、方法的物件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    this.firstName = &apos;Doe&apos;;  </span><br><span class="line">    this.lastName = &apos;John&apos;;  </span><br><span class="line">    console.log(&apos;我被呼叫了&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person();  </span><br><span class="line">var joan = new person();  </span><br><span class="line">var jim = new person();</span><br><span class="line"></span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);  </span><br><span class="line">console.log(jim);</span><br><span class="line"></span><br><span class="line">![](https://cdn-images-1.medium.com/max/800/1*YcF93DU_6M0uWco5YHRCFQ.png)</span><br></pre></td></tr></table></figure><p>像這樣，即可建立多個相同屬性方法的物件，但可以再做一些調整<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function person(firstName, lastName)&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    this.firstName = firstName;  </span><br><span class="line">    this.lastName = lastName;  </span><br><span class="line">    console.log(&apos;我被呼叫了&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">var john = new person(&apos;Doe&apos;, &apos;john&apos;);  </span><br><span class="line">var joan = new person(&apos;Mar&apos;, &apos;joan&apos;);  </span><br><span class="line">var jim = new person(&apos;TTT&apos;, &apos;jim&apos;);</span><br><span class="line"></span><br><span class="line">console.log(john);  </span><br><span class="line">console.log(joan);  </span><br><span class="line">console.log(jim);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*PPN5dUiyAqxdE5mhmzMEag.png" alt></p><p><code>new</code> 後面接的是函式所以可以傳入參數，因此可以設定不同的 <code>firstName</code> 、 <code>lastName</code> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      至此我們已經了解物件和原型、繼承、原型鏈、物件屬性、方法等等，現在該更深入的討論建立物件。之前建立物件的方式都是使用物件實體語法建立的，然而有另一種方法可以建立物件，這是本篇要討論的內容。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.43 Reflection 與 Extend</title>
    <link href="http://pvt5r486.github.io/f2e/20190206/3636975661/"/>
    <id>http://pvt5r486.github.io/f2e/20190206/3636975661/</id>
    <published>2019-02-06T00:39:07.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這門課程推出的時候 ES6 還未問世，現在可以看到許多的框架都有 Extend 的概念，甚至 ES6 也有 Extends ，而本小節課程作者要用 <a href="https://underscorejs.org/" rel="external nofollow noopener noreferrer" target="_blank">underscore.js</a> ，利用一個叫做 Reflection 的概念達成 Extend。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*ezqdTXY-5BW8G-sx" alt></p><h2 id="Reflection-與-Extend"><a href="#Reflection-與-Extend" class="headerlink" title="Reflection 與 Extend"></a>Reflection 與 Extend</h2><p>Reflection 意思就是一個物件可以列出自身的屬性，並且改變當中的屬性、方法。而 JavaScript 物件有能力可以看自己的屬性和方法，而我們可以透過這樣達成一個很有用的模式，稱為 Extend (擴展、繼承) 。</p><p>讓我們先準備好一些程式碼，並引入 underscore.js<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 僅方便理解原型使用，需要使用原型時不可以使用這種方式!!  </span><br><span class="line">john.__proto__ = person;</span><br><span class="line"></span><br><span class="line">我們建立了一些物件，並且把 john 的原型設為 person ，這是先前文章內的一個範例，我們將從這個例子做延伸。</span><br><span class="line"></span><br><span class="line">for(var prop in john)&#123;  </span><br><span class="line">    console.log(prop + &apos;: &apos; + john[prop]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先使用 for in ( <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/for...in" rel="external nofollow noopener noreferrer" target="_blank">MDN 介紹</a>) 迴圈，遍歷 john 物件內所有成員並且印出，讓我們看看現在 john 物件內有什麼東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Nsgf_PaRAAJpZ2qot1gNww.png" alt></p><h3 id="為什麼-john-物件內會有在原型上的-getFullName-方法"><a href="#為什麼-john-物件內會有在原型上的-getFullName-方法" class="headerlink" title="為什麼 john 物件內會有在原型上的 getFullName 方法 ?"></a>為什麼 john 物件內會有在原型上的 getFullName 方法 ?</h3><p>因為 <code>for in</code> 迴圈也會到原型上取用屬性和方法，因此不侷限於物件本身。</p><p>也可以透過 if 結合 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="external nofollow noopener noreferrer" target="_blank">hasOwnProperty</a> 進一步篩選結果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var prop in john)&#123;  </span><br><span class="line">  if (john.hasOwnProperty(prop))&#123;  </span><br><span class="line">    console.log(prop + &apos;: &apos; + john[prop]);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這樣就可以單純取出在 <code>john</code> 物件上的屬性或是方法，如果不在自身物件上，就是在原型上、或者根本不在原型鏈上的任何地方。</p><p>這樣的概念可以讓我們做更多的事 - 補足原型繼承，接下來課程作者就使用 <a href="https://underscorejs.org/" rel="external nofollow noopener noreferrer" target="_blank">underscore</a> 內的 <code>extend</code> 函式作為範例介紹， <code>extend</code> 可以將其他物件的屬性、方法新增給目標物件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 僅方便理解原型使用，需要使用原型時不可以使用這種方式!!  </span><br><span class="line">john.__proto__ = person;</span><br><span class="line"></span><br><span class="line">for(var prop in john)&#123;  </span><br><span class="line">  if (john.hasOwnProperty(prop))&#123;  </span><br><span class="line">    console.log(prop + &apos;: &apos; + john[prop]);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">// 新增以下物件  </span><br><span class="line">var jane = &#123;  </span><br><span class="line">  address: &apos;111 Main St.&apos;,  </span><br><span class="line">  getFormalFullName: function() &#123;  </span><br><span class="line">    return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jim = &#123;  </span><br><span class="line">  getFirstName: function() &#123;  </span><br><span class="line">    return this.firstName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這邊新增的 <code>jane</code> 、 <code>jim</code> 物件，並沒有將它們放入原型鏈，但 <code>john</code> 又想要能有它們的屬性或方法，於是可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.extend(john, jane, jim);  </span><br><span class="line">console.log(john);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*dfDTkP2d24XiP-1sKFhCJg.png" alt></p><p>如此一來 <code>john</code> 就有了 <code>jane</code> 、 <code>jim</code> 內的方法，而且原型 <code>person</code> 也還在。打開 underscore.js 觀察 <code>extend</code> 函式是如何處理這一塊的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*WB927kKdXr-EWqAHnUTRnA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*Tlg1ix8sBU5mYcaapv2A9g.png" alt></p><p>可以看到 <code>createAssigner</code> 是利用閉包的特性撰寫而成，而使用 <code>extend</code> 後，物件 <code>john</code> 被新增了另外兩個物件 <code>jane</code> 、 <code>jim</code> 的屬性與方法。</p><p>透過 <code>extend</code> 函式現在 <code>john</code> 可以使用原本不屬於自身的屬性以及方法了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(john.getFirstName()); // John</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這門課程推出的時候 ES6 還未問世，現在可以看到許多的框架都有 Extend 的概念，甚至 ES6 也有 Extends ，而本小節課程作者要用 underscore.js ，利用一個叫做 reflection 的概念達成 extend。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.42 所有東西都是物件或純值</title>
    <link href="http://pvt5r486.github.io/f2e/20190206/113208756/"/>
    <id>http://pvt5r486.github.io/f2e/20190206/113208756/</id>
    <published>2019-02-05T21:58:11.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇了解物件原型與原型鏈，接著我們透過一些簡單的驗證可以了解到 JavaScript 的所有東西都是物件或純值， JavaScript 的所有東西像是數值、字串、布林、函式、陣列、一般物件這些都有原型，除了 JavaScript 的基本物件 (base object)。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*AE3SMouEbMP5jH0e" alt></p><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>首先建立一些東西方便我們做驗證：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;  </span><br><span class="line">var b = function () &#123;&#125;;  </span><br><span class="line">var c = \[\];</span><br></pre></td></tr></table></figure><p></p><p>分別建立物件、函式、陣列，透過這三個東西來觀察各自的原型，接著使用 chrome 瀏覽器來觀察：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*TmGuTZzhVFXT8QaQbuGDkQ.png" alt></p><ul><li><code>a</code> 的原型是 JavaScript 的基本物件 (base object)，基本物件在原型鏈上是相當底層的，因為所有東西的底層都會是基本物件或純值。 <code>a</code> 的基本物件下掛載了許多的屬性以及方法，還記得前一篇提到的，物件上的屬性以及方法是如何透過原型鏈取得的嗎?這也是為什麼我們沒有寫那些方法卻可以使用，這是因為 JavaScript 已經幫我們寫好在原型上了。</li><li><code>b</code> 的原型是函式，這是所有函式的原型，可以在裡面找到先前提到的 <code>call、bind、apply</code> 方法，這也是為什麼之前說這些方法所有的函式都可以使用的緣故。</li><li><code>c</code> 的原型是個空陣列，也可以看到裡面掛載了許多的方法，像是 <code>filter</code> 、 <code>push</code> 等等，意思就是我們建立的所有陣列都可以使用這裡面的方法，因為這些方法被設定在陣列的原型上。</li></ul><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>透過上面的小測試我們知道各自的原型並不直接是物件，但如果原型的原型呢?</p><p><img src="https://cdn-images-1.medium.com/max/800/1*82o9z6i7F7eJxLQEp35uVg.png" alt></p><ul><li>因為 <code>a</code> 第一層的原型已經是最小單位(基本物件)了，所以回傳 <code>null</code> 。</li><li><code>b</code> 的第一層原型則是函式，第二層原型則是回傳基本物件。</li><li>同樣地， <code>c</code> 也是回傳基本物件。</li></ul><p>這也驗證了開頭的標題，<strong>所有東西的原型都是物件或純值。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇了解物件原型與原型鏈，接著我們透過一些簡單的驗證可以了解到 JavaScript 的所有東西都是物件或純值， JavaScript 的所有東西像是數值、字串、布林、函式、陣列、一般物件這些都有原型，除了 JavaScript 的基本物件 (base object)。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.41 了解原型</title>
    <link href="http://pvt5r486.github.io/f2e/20190205/598580613/"/>
    <id>http://pvt5r486.github.io/f2e/20190205/598580613/</id>
    <published>2019-02-04T20:35:55.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 用了原型繼承，這表示有個叫作原型的概念。<br><img src="https://cdn-images-1.medium.com/max/800/0*76y5PXDGDFV1uUrx" alt></p><h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 (Prototype)"></a>原型 (Prototype)</h2><p>JavaScript 用了原型繼承，這表示有個叫作原型的概念，讓我們用圖片來解說。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*eIq3GXj_JXQ65JbeTi7GVQ.png" alt></p><ul><li>有個物件在記憶體中，給它個名稱 <code>obj</code></li><li>物件具有屬性或方法，也給個名稱 <code>prop1</code></li></ul><p>我們可以使用點運算子取用這屬性，點運算子便會尋找 prop1，找到它的記憶體位置然後回傳。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ASF_GNJexnAWitGVzdQNTg.png" alt></p><p>JavaScript 所有的物件 (包含函式) 都具有原型屬性，</p><ul><li>然而這個屬性會參考到另一個物件，稱為 <code>proto</code></li><li>屬性物件 <code>proto</code> 是 <code>obj</code> 的原型</li><li><code>proto</code> 是會被 <code>obj</code> 參考到且取用屬性和方法的物件</li><li><code>proto</code> 也可以有些屬性，給個名稱 <code>prop2</code></li></ul><p>當需要 <code>prop2</code> 屬性，可以這麼寫「<code>obj.prop2</code>」，點運算子會尋找 <code>prop2</code> 的參考，最後找到 <code>obj</code> ，但是在 <code>obj</code> 上找不到，於是會往原型找，最後在 <code>proto</code> 上找到 <code>prop2</code> 並回傳。</p><p>這麼寫會讓人覺得 <code>prop2</code> 在 <code>obj</code> 上，但其實它在物件原型上。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*-9x158NkAOBT7AQ6MIG8Kg.png" alt></p><p>相同的，原型物件也可以指向另一個原型物件。</p><p>每個物件可以有自己的原型，可能這個原型會有另一個屬性 <code>prop3</code> ，如果我們寫「<code>obj.prop3</code>」那麼點運算子會怎麼尋找 <code>prop3</code>?</p><ul><li>點運算子在 <code>obj</code> 上沒有找到 <code>prop3</code> ， 所以改找原型 <code>proto</code> 物件</li><li><code>proto</code> 上也沒有 <code>prop3</code> ，所以又往另一個 <code>proto</code> 找</li><li>最後在這個 <code>proto</code> 上找到 <code>prop3</code> 並回傳。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*RDfFyGB6Gj0N61k95qHFPw.png" alt></p><p>這樣看起來像所有的 <code>prop</code> 屬性都在我們的主物件 <code>obj</code> 上，但其實是在一個稱為<strong>原型鏈 ( prototype chain )</strong>的東西上。</p><p>雖然之前也有個東西稱為範圍鏈，但其實沒什麼關連。</p><ul><li>範圍鏈是尋找取用的變數</li><li>原型鏈則是與取用屬性或方法有關，透過原型屬性連結，也就是圖片上的 <code>proto</code></li></ul><p>然而這些 <code>proto</code> 是隱藏起來的，不需要這麼寫「<code>obj.proto.proto.prop3</code>」，因此只需要「<code>obj.prop3</code>」， JavaScript 會搜尋原型鏈找出 <code>prop3</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*eXK7IkLmacuiPaI5zqDkuw.png" alt></p><p>如果有另一個物件 <code>obj2</code> ，它也可以指向同樣的原型。</p><p>所以如果需要的話，物件可以共享一樣的原型記憶體位址。</p><p>就是說如果「<code>obj2.prop2</code>」會與「<code>obj.prop2</code>」一樣得到同樣的結果。</p><h3 id="了解原型與原型鏈的基礎觀念後，我們透過簡單的實作來驗證。"><a href="#了解原型與原型鏈的基礎觀念後，我們透過簡單的實作來驗證。" class="headerlink" title="了解原型與原型鏈的基礎觀念後，我們透過簡單的實作來驗證。"></a>了解原型與原型鏈的基礎觀念後，我們透過簡單的實作來驗證。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Default&apos;,  </span><br><span class="line">  lastName: &apos;Default&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    return this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先建立兩個物件，一個是 <code>person</code> 物件另一個 <code>john</code> 物件，其中 <code>john</code> 沒有 <code>getFullName</code> 方法，我們要透過原型鏈找到 <code>getFullName</code> 方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 僅方便理解原型使用，需要使用原型時不可以使用這種方式!!  </span><br><span class="line">john.__proto__ = person;  </span><br><span class="line">console.log(john.getFullName());  </span><br><span class="line">// John Doe</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>這樣子做在實例運用上會有很大的問題，但在這邊只是為了好理解原型。</strong></p></blockquote><p>我們透過 <code>__proto__</code> 將 <code>John</code> 的原型指向 <code>person</code> ，並且嘗試呼叫 <code>getFullName</code> 方法，如同先前所述，在原型鏈上找到了 <code>getFullName</code> 方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(john.firstName); // John</span><br></pre></td></tr></table></figure><p></p><p>而當取得 <code>firstName</code> 時，為什麼不是「 <code>Default</code> 」?<br>因為原型鏈的關係，點運算子會優先在 <code>john</code> 物件內找到 <code>firstName，一旦找到了就不會繼續往下找了。</code></p><p>另外同樣的例子，再度新增一個物件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var jane = &#123;  </span><br><span class="line">  firstName: &apos;Jane&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">jane.__proto__ = person;</span><br></pre></td></tr></table></figure><p></p><p>一樣的讓 <code>jane</code> 的 <code>__proto__</code> 指向 <code>person</code> 物件，指向同個記憶體位址。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(jane.getFullName());  </span><br><span class="line">// Jane Default</span><br></pre></td></tr></table></figure><p></p><p>如同預期，因為 <code>jane</code> 物件內有 <code>firstName</code> ，所以顯示出 <code>Jane</code> ，而找不到 <code>lastName</code> 所以轉往 <code>jane</code> 的原型鏈下找，最後找到了 <code>lastName</code> 的值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      原型 (Prototype)
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.40 觀念小叮嚀：古典和原型繼承</title>
    <link href="http://pvt5r486.github.io/f2e/20190205/739595789/"/>
    <id>http://pvt5r486.github.io/f2e/20190205/739595789/</id>
    <published>2019-02-04T18:56:22.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>老樣子，在進入新的觀念之前，都會先解釋某些特定名詞的意思，避免聽不懂講師再說什麼，本篇之後將進入 JavaScript 相當受歡迎也很困難的概念，我們要討論 JavaScript 的物件導向和原型繼承。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*T7RXkeeQ5Ighmwyl" alt></p><h2 id="繼承-Inheritance"><a href="#繼承-Inheritance" class="headerlink" title="繼承 (Inheritance)"></a>繼承 (Inheritance)</h2><p>繼承表示<strong>「一個物件取用另一個物件的屬性或方法」</strong>，當然這在不同的程式語言間可能是不太一樣的，但對我們來說只要了解基本的概念就好。</p><h2 id="古典繼承-Classical-Inheritance"><a href="#古典繼承-Classical-Inheritance" class="headerlink" title="古典繼承 (Classical Inheritance)"></a>古典繼承 (Classical Inheritance)</h2><p>古典繼承在 C# 以及 Java 內都有相同的概念，這可以分享物件的方法和屬性。</p><p>當然古典繼承也並非完美，舉例來說，當我們已經建立很多大型的物件，這些物件互相繼承彼此的屬性、方法，最終會得到一個很大的集合。</p><p>整體上來看這個大集合變成像是很多樹狀的物件在互動，這種情況下會很難搞清楚彼此之間的關連。</p><h3 id="而古典繼承也有很多不同的關鍵字，像是："><a href="#而古典繼承也有很多不同的關鍵字，像是：" class="headerlink" title="而古典繼承也有很多不同的關鍵字，像是："></a>而古典繼承也有很多不同的關鍵字，像是：</h3><ul><li>friend</li><li>protected</li><li>private</li><li>interface<br>需要個別搞懂不同關鍵字是什麼意思，並且使用它們。</li></ul><h2 id="原型繼承-Prototypal-Inheritance"><a href="#原型繼承-Prototypal-Inheritance" class="headerlink" title="原型繼承 ( Prototypal Inheritance )"></a>原型繼承 ( Prototypal Inheritance )</h2><p>相較於古典繼承而言，原型繼承具有這些特點：</p><ul><li>彈性 (flexible)</li><li>可擴充性 (extensible)</li><li>簡單易懂 (east to understand)</li></ul><blockquote><p>當然原型繼承也不是個完美的東西，和古典繼承一樣都是有好有壞的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      老樣子，在進入新的觀念之前，都會先解釋某些特定名詞的意思，避免聽不懂講師再說什麼，本篇之後將進入 JavaScript 相當受歡迎也很困難的概念，我們要討論 JavaScript 的物件導向和原型繼承。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.39 函式程式設計</title>
    <link href="http://pvt5r486.github.io/f2e/20190204/4039406177/"/>
    <id>http://pvt5r486.github.io/f2e/20190204/4039406177/</id>
    <published>2019-02-03T19:08:14.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>討論完一級函式與 JavaScript 其他特色後，我們已經可以使用這些概念進行 JavaScript 中的<strong>函式程式設計 (Functional Programming)</strong>，這很有趣也非常強大，但一開始不好掌握，需要多多練習。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*DIwuqsj8Z-9W6uSa" alt></p><h2 id="函式程式設計-Functional-Programming"><a href="#函式程式設計-Functional-Programming" class="headerlink" title="函式程式設計 (Functional Programming)"></a>函式程式設計 (Functional Programming)</h2><p>JavaScript 乍聽之下好像跟 Java 有關、或是看起來有點像 C++、C#，但其實 JavaScript 與函式程式語言較相關，像是 Lisp、Scheme、ML，這些提到的語言都有一級函式的概念。</p><h3 id="來點例子"><a href="#來點例子" class="headerlink" title="來點例子"></a>來點例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var originArr = [1, 2, 3];  </span><br><span class="line">console.log(originArr);  </span><br><span class="line">var outputArr = []; // [1,2,3]  </span><br><span class="line">for(var i = 0; i &lt; originArr.length; i++) &#123;  </span><br><span class="line">  outputArr.push(originArr[i]*2);  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(outputArr); // [2,4,6]</span><br></pre></td></tr></table></figure><p>這段程式很簡單，就只是把陣列的內容乘以 2 放到另一個陣列而已，這麼寫其實不算是有錯誤，還可以處理得更好。</p><p>這段程式，可以想成把某陣列的內容透過迴圈遍歷，並傳入某函式處理後，得到新的陣列。</p><p>因此可以整理出可能需要做的事情：</p><ul><li>需要一個可以傳入兩個參數的函式<ul><li>參數 - 某陣列以及「想如何處理」的函式</li></ul></li><li>需要迴圈跑完傳入陣列的所有內容</li><li>函式最後需要回傳新陣列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var originArr = [1, 2, 3];  </span><br><span class="line">function mapForEach(arr, fn) &#123;  </span><br><span class="line">  var newArr = [];  </span><br><span class="line">  for(var i = 0; i &lt; arr.length; i++) &#123;  </span><br><span class="line">    newArr.push(  </span><br><span class="line">      fn(arr[i])  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">  return newArr;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var outputArr = mapForEach(originArr, function(item)&#123;  </span><br><span class="line">  return item * 2;  </span><br><span class="line">&#125;);  </span><br><span class="line">console.log(outputArr);</span><br></pre></td></tr></table></figure></li></ul><p>透過這樣子的撰寫，可以做到同樣的事情，更棒的是可以更彈性的調整傳入的陣列輸出的結果，像是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var outputArr2 = mapForEach(originArr, function(item)&#123;  </span><br><span class="line">  return item &gt; 2;  </span><br><span class="line">&#125;);  </span><br><span class="line">console.log(outputArr2); // [false, false, true]</span><br></pre></td></tr></table></figure><p></p><p>不必重新撰寫整個比大小的程式，只需要微調傳入的函式。</p><h2 id="進階應用-結合-bind"><a href="#進階應用-結合-bind" class="headerlink" title="進階應用 - 結合 bind()"></a>進階應用 - 結合 bind()</h2><p>承接上面的例子，有時候可能需要傳入不只一個參數，假使我們傳入的函式需要用到更多參數，而不是上面的例子只有一個參數時該怎麼辦呢?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 進階 - 利用先前的觀念將需要兩個參數的函式變成一個參數  </span><br><span class="line">var checkPastLimit = function(limiter , item)&#123;  </span><br><span class="line">  // 檢查傳入的 item 是否大於 limiter  </span><br><span class="line">  return item &gt; limiter;  </span><br><span class="line">&#125;  </span><br><span class="line">var outputArr3 = mapForEach(originArr, checkPastLimit.bind(this,2))  </span><br><span class="line">console.log(outputArr3); // [false, false, true]</span><br></pre></td></tr></table></figure><p></p><p>可以使用上一篇提到的 <code>bind()</code> 方法，將第一個參數設定固定預設值，就搞定囉，在這邊因為不會使用到 <code>this</code> 所以不重要。</p><p>另外同樣的做法，也可以這麼寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var checkPastLimitEasyUse = function(limiter) &#123;  </span><br><span class="line">  return function(limiter , item)&#123;  </span><br><span class="line">    return item &gt; limiter;  </span><br><span class="line">  &#125;.bind(this,limiter);  </span><br><span class="line">&#125;  </span><br><span class="line">var outputArr4 = mapForEach(originArr, checkPastLimitEasyUse(3));  </span><br><span class="line">console.log(outputArr4); // [false, false, false]</span><br></pre></td></tr></table></figure><p></p><p>如果不想要每次都使用 bind() 方法，可以再用一個函式把原本的函式包覆並傳原本函式的內容，這樣就可以僅傳入一個參數使用囉。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>要把程式寫成具有函式程式設計概念是需要透過很大量練習的，期許自己能透過大量的練習，早日熟練這一塊。</p><p>現在的我還不能自在的使出這一招，寫出的程式碼大多類似像這篇文章的第一個範例，需要透過事後的整理才會變成第二個範例這樣，這也是我往後進行實作時可以練習的一個重點。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      討論完一級函式與 JavaScript 其他特色後，我們已經可以使用這些概念進行 JavaScript 中的函式程式設計 (Functional Programming)，這很有趣也非常強大，但一開始不好掌握，需要多多練習。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.2 時鐘</title>
    <link href="http://pvt5r486.github.io/f2e/20190203/582305906/"/>
    <id>http://pvt5r486.github.io/f2e/20190203/582305906/</id>
    <published>2019-02-03T00:09:39.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="預覽圖"><a href="#預覽圖" class="headerlink" title="預覽圖"></a>預覽圖</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*cD42uLi4nbzyZDaz4qejxQ.png" alt></p><h2 id="本層-BOSS-弱點"><a href="#本層-BOSS-弱點" class="headerlink" title="本層 BOSS 弱點"></a>本層 BOSS 弱點</h2><ul><li>【特定技術】需使用 JS 原生語法的 <code>getDate()</code> 撈取時間，不可用套件</li><li>【特定技術】需使用 JS 原生語法的 <code>setTimeout()</code> 或 <code>setInterval()</code>，持續讓秒針、分針、時針能夠以台北時區移動</li><li>【特定技術】介面請全部用 CSS2、CSS3 手寫繪製，什麼…？你說太強人所難？？那..用圖片也不是不行辣， 點選一下元素，右側控制列會有個藍色按鈕，點選 [下載] 即可。</li></ul><h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul><li>原生 JavaScript</li><li>SCSS</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雖然沒辦法像其他大神一樣手刻 CSS 或者使用 Canvas 繪出時鐘，不過還是最低限度的有達成本次要求，本次主要學習了 transform-origin 的用法，還 setInterval() 。</p><p>主要的概念就是計算每一小格 / 每一格的角度 ， 取得當前時間後計算目前各指針的位置，並且使用 setInterval 設置每秒更新一次，為了擬真所以有額外處理讓時針偏移。</p><h2 id="不足的部分"><a href="#不足的部分" class="headerlink" title="不足的部分"></a>不足的部分</h2><ul><li>沒有達成第三點，純用 CSS 刻出來太難了，本次地下城目的是練習 JS ，所以考量之下認為還是先用 SVG 圖片學習就好。</li><li>指針移動時沒有很精確的對齊每一格。</li></ul><h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><ul><li><a href="https://pvt5r486.github.io/JSD2_Clock/index.html">線上DEMO</a></li><li><a href="https://github.com/pvt5r486/JSD2_Clock" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      六角 JavaScriptDungeon 時鐘
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.1 九九乘法表</title>
    <link href="http://pvt5r486.github.io/f2e/20190203/2098586066/"/>
    <id>http://pvt5r486.github.io/f2e/20190203/2098586066/</id>
    <published>2019-02-02T23:52:10.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="預覽圖"><a href="#預覽圖" class="headerlink" title="預覽圖"></a>預覽圖</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*dhmsoKjoTN6s-GBPMALnaQ.png" alt="九九乘法表"></p><h2 id="本層-BOSS-弱點"><a href="#本層-BOSS-弱點" class="headerlink" title="本層 BOSS 弱點"></a>本層 BOSS 弱點</h2><ul><li>【特定技術】需使用 <code>JS for 迴圈技巧</code>，裡頭數字不能直接寫在 HTML 上，需使用 JS 印出。</li><li>需使用 HTML、CSS、JS 技術</li><li>介面需與設計稿一致</li></ul><h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul><li>Vue.js</li><li>Vue Cli 3.0</li><li>SCSS</li><li>Eslint Airbnb 風格</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>因為最近都在看 JavaScript 的底層，也有好一陣子沒碰 Vue 了，怕太久沒碰生疏了，所以這次難得有這個機會，想說不然來總複習好了。</p><p>所以就使用 Vue Cli 3.0 從頭到尾跑一次，還使用了 Eslint 來折磨(?)自己，並把每一個方塊拆成元件使用，再傳入 props ，算是有好好地複習元件的概念。</p><h2 id="不足的部分"><a href="#不足的部分" class="headerlink" title="不足的部分"></a>不足的部分</h2><ul><li>對於精確還原設計稿的每一 px 還是有點苦手，看來 CSS 還要加油。</li><li>參考了別人的 code 後，發現有一些小地方可以用偽元素處理掉，可以再多運用。</li></ul><h2 id="雷點"><a href="#雷點" class="headerlink" title="雷點"></a>雷點</h2><ul><li>Eslint 的 Airbnb 風格很嚴謹，for 迴圈不可以寫 i++ 要寫成 i += 1 。</li><li>如果使用 v-html 輸出 HTML 的話，script 上的 scope 要記得拿掉，不然會無法吃到 CSS 。</li></ul><h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><ul><li><a href="https://github.com/pvt5r486/JSD1_Multiplication" rel="external nofollow noopener noreferrer" target="_blank">程式碼</a></li><li><a href="https://pvt5r486.github.io/JSD1_Multiplication/dist/index#/index">線上DEMO</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      六角 JavaScriptDungeon 九九乘法表
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptDungeon]LV.0 挑戰 JavaScript 地下城</title>
    <link href="http://pvt5r486.github.io/f2e/20190203/1891223199/"/>
    <id>http://pvt5r486.github.io/f2e/20190203/1891223199/</id>
    <published>2019-02-02T23:28:04.000Z</published>
    <updated>2020-02-16T05:52:53.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>雖然我的克服 JavaScript 奇怪部份的記錄還沒寫完，但是又迫不及待的把自己推入另一個火坑 - 六角的 JavaScript 地下城。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Oz9WM34bxpJSyORY" alt></p><p>六角這次舉辦的這個地下城超棒的，不僅有提供設計稿，還有一些額外添加的規則限制，更重要的是可以看到大神們如何針對題目解題，整個就是給新手練習的最佳去處啊！</p><p>當初建立這個部落格的目的也很單純，因為我的技術目前可能並沒有好到可以跟別人分享，所以就只是很簡單的紀錄一些解題過程以及心得而已。</p><p>那麼為了不給自己無謂的寫作壓力（？），這一系列會寫的比較隨興哩。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      雖然我的克服 JavaScript 奇怪部份的記錄還沒寫完，但是又迫不及待的把自己推入另一個火坑 - 六角的 JavaScript 地下城。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptDungeon" scheme="http://pvt5r486.github.io/tags/JavaScriptDungeon/"/>
    
      <category term="自我挑戰" scheme="http://pvt5r486.github.io/tags/%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.38 call()、apply()、bind()</title>
    <link href="http://pvt5r486.github.io/f2e/20190130/538224560/"/>
    <id>http://pvt5r486.github.io/f2e/20190130/538224560/</id>
    <published>2019-01-29T23:58:19.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章我們要討論三個函式 (call、apply、bind)，這是用來控制特殊關鍵字 this 指向的函式。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*R-ThPXtJad2W5-Xe" alt></p><h2 id="call-、apply-、bind"><a href="#call-、apply-、bind" class="headerlink" title="call()、apply()、bind()"></a>call()、apply()、bind()</h2><p>在前面的篇章提到，在執行環境中有變數環境、外部參考，還有 JavaScript 幫我們設定好的 <code>this</code> 變數。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*3TYq4Bgs6k0sbPXK6WTwAA.png" alt></p><p>我們已經看過 <code>this</code> 預設指向全域物件、也可以指向包含函式的物件，然而之前我們提到控制 <code>this</code> 的方式，是使用一個變數來儲存 <code>this</code> 指向的位址。</p><p>而這一篇提到的三個函式將幫助我們更有效率的控制 <code>this</code> 。</p><p>函式是特殊形態的物件，它具有</p><ul><li>名稱屬性 - 可匿名的名稱屬性</li><li>程式屬性 - 可包含程式碼，而程式屬性是可以被呼叫的，所以可以被執行。</li></ul><blockquote><p>函式就是物件，所以函式可以有屬性和方法，而且<strong>所有函式都有 call()、apply()、bind() 方法</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*WEHyO0BeD-6lY7AmmSVaPw.png" alt></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>我們先建立一個初始的範例，如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">&#125;  </span><br><span class="line">logName();</span><br></pre></td></tr></table></figure><p></p><ul><li>我們建立了 <code>person</code> 物件，並且在裡面建立了 <code>getFullName</code> 方法。</li><li>方法內的 <code>this</code> 指向 <code>person</code> 物件，並回傳 <code>fullName</code> 。</li><li>宣告了 <code>logName</code> 並指向一個匿名函式，但函式內的 <code>this</code> 此時是指向全域物件 <code>windows</code> ，因此執行 <code>logName</code> 函式後得到 <code>undefined</code> 。</li></ul><p>這時就是 <code>bind()</code> 出場的時候了，將程式碼改成以下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logPersonName = logName.bind(person);  </span><br><span class="line">logPersonName();</span><br></pre></td></tr></table></figure><p></p><p>我宣告了 <code>logPersonName</code> 並且取用 <code>logName</code> 的 <code>bind</code> 方法，然後傳入想要 <code>this</code> 變數指向的物件，接著 <code>bind</code> 方法會回傳一個新的函式，它會複製 <code>logName</code> 函式，並且設定為一個新的函式物件。</p><p>所以當呼叫 <code>logPersonName</code> 函式時，因為 <code>this</code> 已經指向 <code>person</code> 物件，所以輸出就如同預期。</p><p>甚至也可以寫得更簡潔，像是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">&#125;.bind(person);</span><br><span class="line"></span><br><span class="line">logName();</span><br></pre></td></tr></table></figure><p></p><p><code>bind</code> 方法會產生 <code>logName</code> 函式的拷貝，並且將 <code>this</code> 指向為我們指定的物件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">  console.log(&apos;Argument: &apos; + lang1 + &apos; &apos; +lang2);  </span><br><span class="line">  console.log(&apos;---------------&apos;);  </span><br><span class="line">&#125;.bind(person);</span><br><span class="line"></span><br><span class="line">logName(&apos;es&apos;,&apos;en&apos;);</span><br></pre></td></tr></table></figure><p></p><p><code>bind</code> 方法會將函式完整的拷貝下來。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*2IM9HGqigrFQRe79519vPw.png" alt></p><p><strong>這就是 bind 的作用，創造拷貝函式，然後將 this 指向到某個物件。</strong></p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>接續上面的範例<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">  console.log(&apos;Argument: &apos; + lang1 + &apos; &apos; +lang2);  </span><br><span class="line">  console.log(&apos;---------------&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logPersonName = logName.bind(person);  </span><br><span class="line">logPersonName(&apos;es&apos;,&apos;en&apos;);  </span><br><span class="line">logName.call(person,&apos;en&apos;,&apos;es&apos;);</span><br></pre></td></tr></table></figure><p></p><p><code>call</code> 方法可以讓我們決定 <code>this</code> 要指向哪個物件、也可以傳入參數，而第一個參數就是決定 <code>this</code> 要指向的物件。基本上就跟 () 用法一樣，但 <code>call</code> 方法允許控制 <code>this</code> 的值。</p><p>與 <code>bind</code> 方法不同的地方是，<strong>call 方法並不是創造函式的拷貝並等待呼叫，而是直接執行並且改變 this 的指向</strong>。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><strong>apply()</strong></h3><p>接續上面的範例<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logName = function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">  console.log(&apos;Argument: &apos; + lang1 + &apos; &apos; +lang2);  </span><br><span class="line">  console.log(&apos;---------------&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logPersonName = logName.bind(person);  </span><br><span class="line">logPersonName(&apos;es&apos;,&apos;en&apos;);  </span><br><span class="line">logName.call(person,&apos;en&apos;,&apos;es&apos;);  </span><br><span class="line">logName.apply(person, [&apos;es&apos;,&apos;en&apos;]);</span><br></pre></td></tr></table></figure><p></p><p><code>apply</code> 方法與 <code>call</code> 方法雷同，只是控制 <code>this</code> 之後的傳入參數，部分略有不同。</p><blockquote><p><code>call</code> 方法允許傳入各種型別的值，但是 <code>apply</code> 方法只接受陣列作為參數。</p></blockquote><p>所以這兩個方法可以根據函式的情況來使用。</p><h2 id="不使用括號來達成立即執行函式"><a href="#不使用括號來達成立即執行函式" class="headerlink" title="不使用括號來達成立即執行函式"></a>不使用括號來達成立即執行函式</h2><p>看過了 <code>apply</code> 方法與 <code>call</code> 方法，我們可以這麼寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">  console.log(&apos;Argument: &apos; + lang1 + &apos; &apos; +lang2);  </span><br><span class="line">  console.log(&apos;---------------&apos;);  </span><br><span class="line">&#125;).call(person,&apos;es&apos;,&apos;en&apos;);</span><br><span class="line"></span><br><span class="line">(function(lang1, lang2)&#123;  </span><br><span class="line">  console.log(&apos;Logged: &apos; + this.getFullName());  </span><br><span class="line">  console.log(&apos;Argument: &apos; + lang1 + &apos; &apos; +lang2);  </span><br><span class="line">  console.log(&apos;---------------&apos;);  </span><br><span class="line">&#125;).apply(person, \[&apos;es&apos;,&apos;en&apos;\]);</span><br></pre></td></tr></table></figure><p></p><p>所有的函式都可以使用 <code>apply、call、bind</code> 方法。</p><h2 id="實際上的使用"><a href="#實際上的使用" class="headerlink" title="實際上的使用"></a>實際上的使用</h2><p>這些方法可以如何地在實際開發上使用呢?</p><h3 id="函式借用-function-borrow"><a href="#函式借用-function-borrow" class="headerlink" title="函式借用 (function borrow)"></a>函式借用 (function borrow)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;John&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">  getFullName: function()&#123;  </span><br><span class="line">    var fullName = this.firstName + &apos; &apos; + this.lastName;  </span><br><span class="line">    return fullName;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">// function borrow  </span><br><span class="line">var person2 = &#123;  </span><br><span class="line">  firstName: &apos;Jane&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;,  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(person.getFullName.call(person2));</span><br></pre></td></tr></table></figure><p>我們創造了兩個物件，一個 <code>person</code> 物件、一個 <code>person2</code> 物件，但是在 <code>person2</code> 物件內沒有 <code>getFullName</code> 方法。</p><p>可以透過 <code>call</code> 、 <code>apply</code> 方法達成<strong>函式借用，即使</strong> <code>person2</code> 物件內沒有 <code>getFullName</code> 方法，透過改變 <code>this</code> 的指向，也可以輸出 <code>person2</code> 的物件內容。</p><h3 id="函式柯里化-function-curring"><a href="#函式柯里化-function-curring" class="headerlink" title="函式柯里化 (function curring)"></a>函式柯里化 (function curring)</h3><p>這個部分跟 <code>bind</code> 方法的特性有關，如果我們傳入參數給 <code>bind，會有不太一樣的事情發生，讓我們來觀察。</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function multply(a, b)&#123;  </span><br><span class="line">  return a*b;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mulipleByTwo = multply.bind(this, 2);  </span><br><span class="line">console.log(mulipleByTwo(4));</span><br></pre></td></tr></table></figure><p></p><p>我寫了一個會回傳 <code>a * b</code> 的 <code>multply</code> 函式，並且使用 <code>bind</code> 方法拷貝一份新的函式給 <code>mulipleByTwo</code> ，在此 <code>this</code> 的指向不重要，重要的是傳入的參數。</p><blockquote><p><code>bind</code> 方法會將傳入的參數設定為一個定值。</p></blockquote><p>以例子來說 <code>multply.bind(this, 2)</code> 就好比這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function multply(a, b)&#123;  </span><br><span class="line">  return a*b;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mulipleByTwo(a, b)&#123;  </span><br><span class="line">  var a = 2;  </span><br><span class="line">  return a*b;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mulipleByTwo = multply.bind(this, 2);  </span><br><span class="line">console.log(mulipleByTwo(4));</span><br></pre></td></tr></table></figure><p></p><p>而在 <code>bind</code> 內設定了傳入的參數後，我們呼叫的函式所帶入的參數就會變成另一個，以本例來說就是 <code>b</code> 。</p><blockquote><p>因此輸出就是 2 * 4 = 8</p></blockquote><p>如果 bind 填入了所有參數呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function multply(a, b)&#123;  </span><br><span class="line">  return a\*b;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mulipleByTwo(a, b)&#123;  </span><br><span class="line">  var a = 2;  </span><br><span class="line">  return a\*b;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mulipleByTwo = multply.bind(this, 2);  </span><br><span class="line">console.log(mulipleByTwo(4)); // 8</span><br><span class="line"></span><br><span class="line">var mulipleByThree = multply.bind(this, 3, 4);  </span><br><span class="line">console.log(mulipleByThree(1,7)); // 12</span><br></pre></td></tr></table></figure><p></p><p>像這樣，使用 <code>bind</code> 方法拷貝一份新的函式給 <code>mulipleByThree</code> ，並且填入 <code>a</code> 跟 <code>b</code> 參數。</p><p>當我們呼叫 <code>mulipleByThree</code> 帶入參數時，受到 <code>bind</code> 影響，所以無論帶入什麼，輸出的結果都是 12 。</p><p>於是 <strong>函式柯里化 (function curring)</strong> 的意思就是建立一個函式的拷貝，並設定不可變的預設參數。</p><p>函式柯里化主要用於數學的運算，可以寫個基本的函式，然後根據這個函式放入預設參數，用以減少需要填入的參數，這是一種 bind 的用法。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這篇文章我們要討論三個函式(call、apply、bind)，這是用來控制特殊關鍵字 this 指向的函式。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.37 閉包與回呼</title>
    <link href="http://pvt5r486.github.io/f2e/20190130/3187793921/"/>
    <id>http://pvt5r486.github.io/f2e/20190130/3187793921/</id>
    <published>2019-01-29T21:27:09.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理完閉包與執行環境與一級函式後，我們確實地掌握到了這幾個名詞的基礎概念。但實際上如果曾經開發過 JavaScript ，在還不懂這些名詞的時候，或許已經無意間使用過這些技巧了，只是沒有意識到而已。像是如果使用過 setTimeout 或是 jQuery 事件，可能就使用過閉包。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*or2RLXvvYOlZjDwx" alt></p><h2 id="閉包與回呼-Closures-And-Callbacks"><a href="#閉包與回呼-Closures-And-Callbacks" class="headerlink" title="閉包與回呼 (Closures And Callbacks)"></a>閉包與回呼 (Closures And Callbacks)</h2><p>像是 setTimeout 的小範例，使用了閉包與一級函式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sayHiLater()&#123;  </span><br><span class="line">  var greet = &apos;Hello&apos;;  </span><br><span class="line">  setTimeout(function()&#123;  </span><br><span class="line">    console.log(greet);  </span><br><span class="line">  &#125;,3000)  </span><br><span class="line">&#125;  </span><br><span class="line">sayHiLater();</span><br></pre></td></tr></table></figure><p></p><p><code>setTimeout</code> 接受兩個參數，一個是函式物件，一個為延遲執行時間。於是我們把一個匿名函式傳入，這是使用了 JavaScript 的<strong>一級函式</strong>觀念。</p><p>我們之前也討論過<strong>非同步過程、執行堆、 事件佇列</strong>的觀念，被包覆在 <code>setTimeout</code> 內的函式會先被放進事件佇列，等執行堆空了之後，才開始跑事件佇列裡的內容。</p><p>當開始運行 <code>setTimeout</code> 時，等到設定的時間過後便開始執行匿名函式，但 <code>greet</code> 不在函式裡，所以根據範圍鍊到外部環境尋找。</p><p>而雖然 <code>sayHiLater</code> 函式的執行環境已經不再執行堆內了，但是因為閉包，所以仍然可以取用 <code>greet</code> 變數。</p><p><strong>像是 jQuery 的事件也使用到閉包與一級函式</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// $(&apos;button&apos;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">// &#125;);  </span><br><span class="line">// 因為沒有引用 jQuery 所以上面的程式無效，僅用來解說。</span><br></pre></td></tr></table></figure><p></p><p>這段程式碼將一個匿名函式當成參數傳入 jQuery 中的 click 函式，使其在進行 click 動作時會觸發這個匿名函式。</p><p>jQuery 就是這樣使用函式表示式和一級函式概念的。</p><h2 id="回呼-callback"><a href="#回呼-callback" class="headerlink" title="回呼 (callback)"></a>回呼 (callback)</h2><p>當某個函式執行完畢，要給該函式執行的函式，稱為回呼。</p><p>也就是說，我呼叫函式 <code>a</code> ，然後給它函式 <code>b</code> ，當函式 <code>a</code> 執行完畢時，呼叫函式 <code>b</code> ，也就是說它回呼了 <code>b</code> 函式，這就是回呼函式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function tellMeWhenDone(callback)&#123;  </span><br><span class="line">  var a = 1; // some work  </span><br><span class="line">  var b = 1; // some work  </span><br><span class="line">  callback();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(function()&#123;  </span><br><span class="line">  console.log(&apos;做完了&apos;)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(function()&#123;  </span><br><span class="line">  console.log(&apos;全都做完了&apos;)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>以這個例子來說，我們建立了一個 <code>tellMeWhenDone</code> 的函式陳述句，並且可以帶入一個 <code>callback</code> 的參數。</p><p>接著呼叫 <code>tellMeWhenDone</code> 函式，並傳入一個匿名函式給它，再 <code>tellMeWhenDone</code> 函式執行到 <code>callback()</code> 時，會呼叫我們傳給它的匿名函式，因此輸出就如同我們預計的那樣。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      整理完閉包與執行環境與一級函式後，我們確實地掌握到了這幾個名詞的基礎概念。但實際上如果曾經開發過 JavaScript，在還不懂這些名詞的時候，或許已經無意間使用過這些技巧了，只是沒有意識到而已。像是如果使用過 setTimeout 或是 jQuery 事件，可能就使用過閉包。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.36 框架小叮嚀： Function Factories</title>
    <link href="http://pvt5r486.github.io/f2e/20190130/3162528564/"/>
    <id>http://pvt5r486.github.io/f2e/20190130/3162528564/</id>
    <published>2019-01-29T18:34:53.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面提到了閉包，也講解了一些典型的範例，而閉包還有很多有用的地方。在這篇文章中，我們會談到如何利用閉包來建立函式工廠 (Function Factories)，讓程式的撰寫上能更靈活，減少累贅的程式碼，這個技巧常常可在一些知名框架內看到。<br><img src="https://cdn-images-1.medium.com/max/800/0*-MFoWxHzzqJm25I_" alt></p><h2 id="Function-Factories"><a href="#Function-Factories" class="headerlink" title="Function Factories"></a>Function Factories</h2><p>我們在重載函式那一篇知道，可以有一些做法讓函式可以在不同情況下被不同的預設參數呼叫。因為我們已經了解閉包，所以我們將要使用閉包的概念讓這個範例更完善。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function makeGreetFactory(languaue)&#123;  </span><br><span class="line">  return function(firstName, lastName)&#123;  </span><br><span class="line">    if(languaue === &apos;en&apos;)&#123;  </span><br><span class="line">      console.log(&apos;Hello &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if(languaue === &apos;es&apos;)&#123;  </span><br><span class="line">      console.log(&apos;Hola  &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var greetEnglish = makeGreetFactory(&apos;en&apos;);  </span><br><span class="line">var greetSpanish = makeGreetFactory(&apos;es&apos;);  </span><br><span class="line">greetEnglish(&apos;Tony&apos;, &apos;Doe&apos;);  </span><br><span class="line">greetSpanish(&apos;Tony&apos;, &apos;Doe&apos;);</span><br></pre></td></tr></table></figure><p></p><ul><li>建立一個會回傳函式的 <code>makeGreetFactory</code> 函式，並可以帶入 <code>languaue</code> 參數。</li><li>被回傳的匿名函式可以帶入 <code>firstName</code> 、 <code>lastName</code> 並且依據 <code>languaue</code> 有不同的打招呼方式。</li></ul><h2 id="注意到不同的地方了嗎？"><a href="#注意到不同的地方了嗎？" class="headerlink" title="注意到不同的地方了嗎？"></a>注意到不同的地方了嗎？</h2><p>原本我們是將 <code>languaue</code> 傳入到匿名函式內，這次改成傳到外部函式，利用<strong>閉包</strong>的概念去完成。</p><ul><li><p>接著宣告 <code>greetEnglish</code> 變數，指向 <code>makeGreetFactory</code> 函式並帶入 <code>languaue</code> 的參數值 「en」。</p><ul><li>當 JavaScript 運行到這一行時，每當 <code>makeGreetFactory</code> 被呼叫就會建立一個執行環境，以這個執行環境來說， <code>languaue</code> 為 「en」。</li></ul></li><li><p>同理，宣告 greetSpanish 變數，呼叫 makeGreetFactory ，此時又建立一個執行環境，以這個執行環境來說， <code>languaue</code> 為 「es」。</p><ul><li>因此，當我呼叫 <code>greetEnglish()</code> 時，因為閉包的關係，即使 <code>makeGreetFactory</code> 函式不再執行堆裡，變數 <code>languaue</code> 仍可被取用。</li></ul></li></ul><blockquote><p>而 <code>greetEnglish()</code> 對應的閉包範圍 <code>languaue</code> 值為「en」<br>同理 <code>greetSpanish()</code> 對應的閉包範圍 <code>languaue</code> 值為「es」</p></blockquote><h2 id="白話說-Function-Factories"><a href="#白話說-Function-Factories" class="headerlink" title="白話說 Function Factories"></a>白話說 Function Factories</h2><p>以這個例子來說， <code>makeGreetFactory</code> 函式就像一個箱子工廠，而傳入的 <code>languaue</code> 可以理解成不同種類的箱子。</p><p>然後我跟這個工廠說，我要一個種類為「en」的箱子，於是我得到了一個在外部寫有「en」字樣的箱子，並且裡面裝有一個會<strong>參考到這個箱子外部寫了什麼種類的函式</strong>。</p><h2 id="使用圖例幫助了解閉包範圍"><a href="#使用圖例幫助了解閉包範圍" class="headerlink" title="使用圖例幫助了解閉包範圍"></a>使用圖例幫助了解閉包範圍</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*4dAf1oEzbXjuoNxPSzKZEA.png" alt></p><blockquote><p>最後要強調的是，每當呼叫函式，函式會得到專屬於它的執行環境，然而在這個執行環境內被創造的函式會指向這個執行環境(<strong>注意創造不等於呼叫</strong>)。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前面提到了閉包，也講解了一些典型的範例，而閉包還有很多有用的地方。在這篇文章中，我們會談到如何利用閉包來建立函式工廠 (Function Factories)，讓程式的撰寫上能更靈活，減少累贅的程式碼，這個技巧常常可在一些知名框架內看到。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.35 瞭解閉包(二)</title>
    <link href="http://pvt5r486.github.io/f2e/20190129/3483178315/"/>
    <id>http://pvt5r486.github.io/f2e/20190129/3483178315/</id>
    <published>2019-01-28T22:27:08.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接續上篇內容，這篇將用幾個經典範例用來更深入了解閉包。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*PyHQZd_vrNMJj2LX" alt></p><h2 id="典型的例子："><a href="#典型的例子：" class="headerlink" title="典型的例子："></a>典型的例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function buildFunctions() &#123;  </span><br><span class="line">  var arr = [];  </span><br><span class="line">  for(var i = 0 ; i &lt; 3 ; i++)&#123;  </span><br><span class="line">    arr.push(  </span><br><span class="line">      function()&#123;  </span><br><span class="line">        console.log(i);  </span><br><span class="line">      &#125;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">  return arr;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunctions();  </span><br><span class="line">fs[0](); // 3  </span><br><span class="line">fs[1](); // 3  </span><br><span class="line">fs[2](); // 3</span><br></pre></td></tr></table></figure><p>做為人類，我們預期三個結果應該會是 0 、 1 、 2，但實際上卻是回傳 3 。</p><p>結合我們之前的觀念，當程式碼執行到 <code>arr.push</code> 時，匿名函式被創造，但是必須要注意的是在此時它<strong>並沒有被執行</strong>，只是把匿名函式放入陣列，接著回傳 <code>arr</code> 。</p><p>我們宣告變數 <code>fs</code> 指向 <code>buildFunctions</code> 函式，並且進行呼叫， for 迴圈執行完畢後 <code>i</code> 的值就是 3 被保存在 <code>buildFunctions</code> 函式的執行環境內。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*YlCsQZEawNKTM6jZqToo3Q.png" alt></p><p>而我們呼叫了匿名函式，由於函式內部沒有 <code>i</code> 變數，因此會轉而向外部尋找，此時雖然外部 <code>buildFunctions</code> 函式的執行環境不存在，但是因為<strong>閉包</strong>，所以仍然可以取得 <code>i</code> 的值，所以輸出才是 3 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*aDZ_PnYlGw--f4sYjuHxxQ.png" alt></p><p>而其餘的呼叫也因為需要的變數都是 <code>i</code> ，所以指向相同的外部環境尋找變數，因此結果都是一樣的。</p><h3 id="如何修正成為我們預期的結果？"><a href="#如何修正成為我們預期的結果？" class="headerlink" title="如何修正成為我們預期的結果？"></a>如何修正成為我們預期的結果？</h3><p>如同我們在 IIFE 章節得出的結果，可以使用 ES6 新增的 let 來修改程式碼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function buildFunctions() &#123;  </span><br><span class="line">  var arr = [];  </span><br><span class="line">  for(let i = 0 ; i &lt; 3 ; i++)&#123;  </span><br><span class="line">    arr.push(  </span><br><span class="line">      function()&#123;  </span><br><span class="line">        console.log(i);  </span><br><span class="line">      &#125;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">  return arr;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunctions();  </span><br><span class="line">fs[0](); // 0  </span><br><span class="line">fs[1](); // 1  </span><br><span class="line">fs[2](); // 2</span><br></pre></td></tr></table></figure><p></p><p>let 的範圍只有 for 迴圈的 {} 內，而每次進行迴圈時都會在執行環境內不同的記憶體位址建立 <code>i</code> ，所以當這個匿名函式被呼叫，每次都會指向不同的記憶體位址。</p><h3 id="ES5-的作法-IIFE"><a href="#ES5-的作法-IIFE" class="headerlink" title="ES5 的作法 IIFE"></a>ES5 的作法 IIFE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function buildFunctions() &#123;  </span><br><span class="line">  var arr = [];  </span><br><span class="line">  for(var i = 0 ; i &lt; 3 ; i++)&#123;  </span><br><span class="line">    arr.push(  </span><br><span class="line">      (function(i)&#123;  </span><br><span class="line">        return function()&#123;  </span><br><span class="line">          console.log(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;)(i)  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">  return arr;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = buildFunctions();  </span><br><span class="line">fs[0](); // 0  </span><br><span class="line">fs[1](); // 1  </span><br><span class="line">fs[2](); // 2</span><br></pre></td></tr></table></figure><p>原理很簡單，先前例子 <code>i</code> 的值會相同，是因為尋找到相同外部環境的同樣變數值。</p><p>那麼只要<strong>個別創造不同的執行環境</strong>保存變數 <code>i</code> 就解決問題了。 IIFE 可以有效地解決這個問題，因為只要函式被呼叫了，就會建立一個執行環境。</p><p>像這樣，每次進行迴圈時，都有一個 IIFE 被執行，建立了執行環境，保存當下 <code>i</code> 的值，然而當內部的匿名函式被呼叫時，不再需要跑到最外層去存找 <code>i</code> ，而是在 IIFE 那一層就可以找到相應的 <code>i</code> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      接續上篇內容，這篇將用幾個經典範例用來更深入了解閉包。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.34 瞭解閉包(一)</title>
    <link href="http://pvt5r486.github.io/f2e/20190128/3075346033/"/>
    <id>http://pvt5r486.github.io/f2e/20190128/3075346033/</id>
    <published>2019-01-28T00:03:31.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這個系列會拆分成一跟二，主要介紹 JavaScript 內其中一個蠻惡名昭彰的觀念，這是一個相當抽象且不好懂的觀念，不過如果前面基礎有踏穩，其實就是之前的執行環境、範圍鏈、一級函式、執行堆等等的延伸應用在加入一點新觀念而已，課程到這邊也已經過50%了，勉勵自己繼續加油！</p><p><img src="https://cdn-images-1.medium.com/max/800/0*rgWxCX5W5TILSe6S" alt></p><h2 id="閉包-Closuere"><a href="#閉包-Closuere" class="headerlink" title="閉包 (Closuere)"></a>閉包 (Closuere)</h2><p>閉包的解釋網路上有蠻多的，但我特別喜歡卡斯伯的說法，比較適合我的金魚腦，哈！</p><ul><li>關於閉包的解釋 - <a href="https://wcc723.github.io/javascript/2017/12/13/javascript-closure/" rel="external nofollow noopener noreferrer" target="_blank"><strong>卡斯伯 鐵人賽：另一種方式介紹 JavaScript 閉包</strong></a></li><li>運作原理：呼叫函式內的函式。</li><li>可以幹嘛： 內層函式作用域的變數只會存在內層，且內層函式的變數可以不被釋放，重複利用。</li></ul><h3 id="透過範例了解閉包過程"><a href="#透過範例了解閉包過程" class="headerlink" title="透過範例了解閉包過程"></a>透過範例了解閉包過程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet(whatToSay)&#123;  </span><br><span class="line">  return function(name)&#123;  </span><br><span class="line">    console.log(whatToSay + &apos; &apos; + name);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">greet(&apos;Hi&apos;)(&apos;Tony&apos;); // Hi Tony</span><br></pre></td></tr></table></figure><p>這個寫法很有趣，我們呼叫 <code>greet</code> 函式，然後回傳匿名函式，因此也可以直接在後面又接一個 () ，立即呼叫內部函式。</p><p>然而內部函式雖然沒有 <code>whatToSay</code> 變數，但因為範圍鏈，會轉而尋找外部環境內的 <code>whatToSay</code> 變數。</p><p>這樣看來，都還在認知的合理範圍，但其實有點<strong>不尋常</strong>，我們修改一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function greet(whatToSay)&#123;  </span><br><span class="line">  return function(name)&#123;  </span><br><span class="line">    console.log(whatToSay + &apos; &apos; + name);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sayHi = greet(&apos;Hi&apos;);  </span><br><span class="line">sayHi(&apos;Tony&apos;); // Hi Tony</span><br></pre></td></tr></table></figure><p></p><p>用變數 <code>sayHi</code> 指向 <code>greet</code> 函式的位址，並且呼叫內部函式。</p><h3 id="但，為什麼-sayHi-函式仍然知道-whatToSay-是什麼？"><a href="#但，為什麼-sayHi-函式仍然知道-whatToSay-是什麼？" class="headerlink" title="但，為什麼 sayHi 函式仍然知道 whatToSay 是什麼？"></a>但，為什麼 <code>sayHi</code> 函式仍然知道 <code>whatToSay</code> 是什麼？</h3><p>問題點在於</p><ul><li>當 <code>greet</code> 函式 被呼叫，執行回傳匿名函式後，函式結束並離開執行堆。</li><li>為什麼被創造在 <code>greet</code> 函式內的變數 <code>whatToSay</code> ，在離開執行堆後，仍然可以被內層匿名函式取用?</li></ul><p>這是有可能的，這就是閉包的概念，讓我們用圖片了解：</p><ol><li><p>當程式開始時，全域執行環境被創造。<br><img src="https://cdn-images-1.medium.com/max/800/1*VZ1ZY6lN5XLNgisfyP-7_g.png" alt="課程截圖"><br>課程截圖</p></li><li><p>到 <code>sayHi = greet(&#39;Hi&#39;)</code> 這行時， <code>greet</code> 函式被呼叫，並且 <code>whatToSay</code> 變數被傳入到 <code>greet</code> 函式的變數環境。<br><img src="https://cdn-images-1.medium.com/max/800/1*2m2imr0JzkYLhxA5P4S1CA.png" alt></p></li><li><p><code>greet</code> 函式執行完畢，回傳一個匿名函式， <code>greet</code> 函式的執行環境離開執行堆。<br><img src="https://cdn-images-1.medium.com/max/800/1*kbOvjSzTmJq0BwgpI3Qg8w.png" alt></p></li></ol><p>每個執行環境都有專屬的記憶體空間，變數與函式都被創造在內。而當執行環境沒了之後，記憶體空間會如何?</p><p>在<strong>一般情況下</strong>，JavaScript 會清除掉記憶體空間，這動作稱為垃圾回收 (Garbage Collection)。</p><blockquote><p>但當閉包的執行環境結束後，記憶體空間仍然存在。</p></blockquote><ol start="4"><li><p>現在我們回到全域執行環境，接著呼叫 <code>sayHi</code> 指向的函式，然後又創造一個新的執行環境。<br><img src="https://cdn-images-1.medium.com/max/800/1*B01BvJIiLzCGr94aXXBkLQ.png" alt></p></li><li><p>我們傳入了變數 <code>name</code> 的值，所以這會被保存在記憶體裡，但當執行到 <code>console.log</code> 這行時，JavaScript 發現這裡找不到 <code>whatToSay</code> ，因此根據範圍鍊，跑到了外部環境去尋找。</p><blockquote><p>即使外層的執行環境已經離開執行堆， <code>sayHi</code> 的執行環境仍然可以參考到在外部環境記憶體空間的 <code>whatToSay</code> 變數。</p></blockquote></li></ol><p><img src="https://cdn-images-1.medium.com/max/800/1*JHY5fluzaOpB-0jL87UtkQ.png" alt></p><blockquote><p>執行環境可以把自身環境內會用到的外部變數整個包住。<br>意思是那些在執行過程中應該要被參考到的變數會整個被執行環境包住，即使執行環境已經不存在了。</p></blockquote><blockquote><p>然而這個包住所有可以取用變數的現象稱為閉包。<br><img src="https://cdn-images-1.medium.com/max/800/1*7ZWQ_3jJVMVsWyjIt97Ocw.png" alt></p></blockquote><p>閉包是 JavaScript 本身的特色，無關於什麼時候呼叫函式，不需要擔心這個函式的外部環境是否還在執行，JavaScript 會確保無論正在執行哪個函式，都能取用到應該要取用的變數。這還是按照範圍鏈的規則在走，並沒有改變。我們下一篇將記錄一些經典的例子。</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="https://wcc723.github.io/javascript/2017/12/13/javascript-closure/" rel="external nofollow noopener noreferrer" target="_blank">鐵人賽：另一種方式介紹 JavaScript 閉包</a></li><li><a href="https://pjchender.blogspot.com/2017/05/javascript-closure.html" rel="external nofollow noopener noreferrer" target="_blank">深入淺出瞭解 JavaScript 閉包（closure）</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這個系列會拆分成一跟二，主要介紹 JavaScript 內其中一個蠻惡名昭彰的觀念，這是一個相當抽象且不好懂的觀念，不過如果前面基礎有踏穩，其實就是之前的執行環境、範圍鏈、一級函式、執行堆等等的延伸應用在加入一點新觀念而已，課程到這邊也已經過 50% 了，勉勵自己繼續加油！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.33 立即呼叫的函式表示式 IIFE</title>
    <link href="http://pvt5r486.github.io/f2e/20190128/3130923936/"/>
    <id>http://pvt5r486.github.io/f2e/20190128/3130923936/</id>
    <published>2019-01-28T00:03:31.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要介紹的是在 JavaScript 常常會看到的問題，什麼是 IIFE ?</p><p><img src="https://cdn-images-1.medium.com/max/800/0*AztObYH_EcHOedZ6" alt></p><h2 id="立即呼叫的函式表示式-Immediately-Invoked-Function-Expression-簡稱-IIFE"><a href="#立即呼叫的函式表示式-Immediately-Invoked-Function-Expression-簡稱-IIFE" class="headerlink" title="立即呼叫的函式表示式 ( Immediately Invoked Function Expression 簡稱 IIFE )"></a>立即呼叫的函式表示式 ( Immediately Invoked Function Expression 簡稱 IIFE )</h2><p>在前面的篇章，我們已經了解函式陳述句與函式表示式的差異。</p><h3 id="標準的函式陳述句"><a href="#標準的函式陳述句" class="headerlink" title="標準的函式陳述句"></a>標準的函式陳述句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function greet(name)&#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;John&apos;); // Hello John</span><br></pre></td></tr></table></figure><p>這是標準函式陳述句，當 JavaScript 看到這個會將它放入記憶體中，等待被呼叫才開始執行內容。</p><h3 id="標準的函式表示式"><a href="#標準的函式表示式" class="headerlink" title="標準的函式表示式"></a>標準的函式表示式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">greetFunc(&apos;John&apos;); // Hello John</span><br></pre></td></tr></table></figure><p>這是標準函式表示式，一開始 JavaScript 並不會將函式的部分放入記憶體，而是在執行該行程式碼時，<strong>立即地創造這個函式物件</strong>，然後可以使用指向該函式位址的變數呼叫它。</p><h3 id="同上，如果想立刻創造、同時也呼叫呢"><a href="#同上，如果想立刻創造、同時也呼叫呢" class="headerlink" title="同上，如果想立刻創造、同時也呼叫呢?"></a>同上，如果想立刻創造、同時也呼叫呢?</h3><p>想想我們是如何呼叫一個函式的 ?</p><blockquote><p>是使用「()」，我們已經達成立即創造函式物件了，如果在同一行補上()的話會怎麼樣？</p></blockquote><p>於是可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;();　// Hello undefined</span><br></pre></td></tr></table></figure><p></p><p>的確被執行了，可以讓執行結果更好一些，仿照先前函式帶入參數的方式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;(&apos;John&apos;);　// Hello John</span><br></pre></td></tr></table></figure><p></p><p>這就是<strong>立即呼叫的函式表示式 ( IIFE )，</strong>透過推導可以得知原理並不困難，就是函式表示式在創造後立刻呼叫它。</p><h3 id="現在把程式碼修改並觀察其他部分"><a href="#現在把程式碼修改並觀察其他部分" class="headerlink" title="現在把程式碼修改並觀察其他部分"></a>現在把程式碼修改並觀察其他部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(greetFunc); //函式的程式碼內容  </span><br><span class="line">console.log(greetFunc(&apos;John&apos;)); // Hello John</span><br></pre></td></tr></table></figure><p>如果改成這樣子寫，我們會得到 <code>greetFunc</code> 內函式的程式碼內容，加上 () 則呼叫該函式，一切都如我們預期。</p><p><strong>但如果加入了立即呼叫呢？</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;(&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">console.log(greetFunc); // Hello John</span><br></pre></td></tr></table></figure><p></p><p>函式物件被函式表示式創造，然後被立即呼叫，接著值被回傳給 <code>greetFunc</code> ，所以輸出是 Hello John 。</p><p>但要注意的是，此時 <code>greetFunc</code> 是個字串，不是函式了，因為函式物件創造後又立刻被執行回傳字串給 <code>greetFunc</code> 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;(&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">console.log(greetFunc());  </span><br><span class="line">console.log(typeof(greetFunc)); //string</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Yq72ZYClNCw05U7n1WFJxA.png" alt></p><h3 id="為什麼剛剛那個範例可以多次被呼叫，而不會變成字串呢？"><a href="#為什麼剛剛那個範例可以多次被呼叫，而不會變成字串呢？" class="headerlink" title="為什麼剛剛那個範例可以多次被呼叫，而不會變成字串呢？"></a>為什麼剛剛那個範例可以多次被呼叫，而不會變成字串呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;  </span><br><span class="line">  return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(greetFunc(&apos;John&apos;));  </span><br><span class="line">console.log(greetFunc(&apos;John&apos;));</span><br></pre></td></tr></table></figure><p>在這個例子因為，先前提到，一開始 JavaScript 並不會將函式的部分放入記憶體，而是在執行到該行程式碼時，立即地創造這個函式物件。</p><p>所以當執行到這一行時，</p><p>var greetFunc = function(name) {</p><p>因為只是創造匿名函式物件並沒有執行，所以此時的 greetFunc 變數的值指向匿名函式的記憶體位址。</p><h3 id="JavaScript-中的表示式"><a href="#JavaScript-中的表示式" class="headerlink" title="JavaScript 中的表示式"></a>JavaScript 中的表示式</h3><p>在 JavaScript 中，表示式可以這麼寫，雖然沒作用，不過是正確的表示式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3;  </span><br><span class="line">1 + 2 + 3;  </span><br><span class="line">&apos;我是字串&apos;;  </span><br><span class="line">&#123;  </span><br><span class="line">  name: &apos;Tony&apos;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以觀察到像是數字、字串、物件都能像這樣直接使用表示式，那<strong>函式</strong>呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(name) &#123;  </span><br><span class="line">     return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*ncwmGDRFV5Q3LYHg4h_heQ.png" alt></p><p>問題在於語法解析器先看到 function 這個字，語法解析器認為我們應該是要使用陳述句，然而這個陳述句卻缺少了名稱。陳述句不可以是匿名的，所以語法解析器認為這有問題。</p><p>但實際上，我們想做的是<strong>不藉由其他變數，單獨的讓這個函式表示式在這</strong>。</p><p>那是不是只要讓語法解析器不要第一個看到 function 就可以了?<br>於是我們這麼做，最簡單的就是把這些都包進 () 裡：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(name) &#123;  </span><br><span class="line">     return &apos;Hello &apos; + name;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>現在就不會報錯了，現在語法解析器知道這個包在括號內的函式不是陳述句了，而是表示式。</p><h3 id="調整程式碼並觀察"><a href="#調整程式碼並觀察" class="headerlink" title="調整程式碼並觀察"></a>調整程式碼並觀察</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;)(&apos;John&apos;); //Hello John</span><br><span class="line"></span><br><span class="line">現在我們加入一點前面提到的觀念，直接呼叫它，這也是一個 IIFE。  </span><br><span class="line">另外這也是 IIFE 最常見的一種樣子。</span><br><span class="line"></span><br><span class="line">(function(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;(&apos;John&apos;)); //Hello John</span><br></pre></td></tr></table></figure><p>順帶一提，結尾的()也可以寫在這邊，這兩者都是對的，只要保持一致就可以了。</p><h2 id="IIFE-可以做什麼"><a href="#IIFE-可以做什麼" class="headerlink" title="IIFE 可以做什麼"></a>IIFE 可以做什麼</h2><p>我們知道 JavaScript 有全域執行環境、函式執行環境，直到 ES6 才出現塊級作用域(例如 let )，在 ES6 出來前，為了避免設定太多的全域變數，開發者往往會將變數設定在函式中，使其成為區域變數，尤其是設定在 IIFE 中，確保不會汙染到全域環境的變數。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &apos;Emma&apos;;  </span><br><span class="line">(function(name) &#123;  </span><br><span class="line">  var firstName = &apos;Doe&apos;;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name + &apos; &apos; + firstName);  </span><br><span class="line">&#125;)(&apos;John&apos;); // Hello John Doe</span><br><span class="line"></span><br><span class="line">console.log(firstName); // Emma</span><br></pre></td></tr></table></figure><p></p><p>即使使用同樣的變數 <code>firstName</code> ，但 <code>Doe</code> 只存在於 IIFE 內，不會影響到外部環境的變數值 <code>Emma</code> 。</p><p>那如果反過來呢? IIFE 內想取用同樣名稱的變數值<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &apos;Emma&apos;;  </span><br><span class="line">(function(global) &#123;  </span><br><span class="line">  var firstName = &apos;Doe&apos;;  </span><br><span class="line">  console.log(&apos;Hello &apos; + firstName); // Hello Doe  </span><br><span class="line">  console.log(&apos;Hello &apos; + global.firstName); // Hello Emma  </span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p></p><p>也只需要把全域物件 <code>window</code> 傳入即可。</p><h3 id="經典例子"><a href="#經典例子" class="headerlink" title="經典例子"></a>經典例子</h3><p>這是一個蠻常看到的經典例子，主要是一些觀念的綜合題。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;  </span><br><span class="line">  console.log(i);  </span><br><span class="line">  setTimeout(function () &#123;  </span><br><span class="line">    console.log(&apos;執行第&apos; + i + &apos;次&apos;);  </span><br><span class="line">  &#125;,10);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*lvOcZiDgnGi9HHnpM2BgKQ.png" alt></p><p>情況是這樣的，該如何修改才能正確地使執行第 <code>i</code> 次正確的輸出所有的 <code>i</code> 呢?</p><p>觀念是這樣的，因為寫在 for 迴圈內的 <code>i</code> 變數是使用 <code>var</code> 宣告的，而又沒有使用函式包覆，因此這個 <code>i</code> 是屬於全域執行環境下的全域變數。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.i); // 10</span><br></pre></td></tr></table></figure><p></p><p>然而寫在 <code>setTimeout</code> 內的匿名函式，因為沒有 <code>i</code> 變數，所以會轉而向外部環境尋找。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><ul><li><code>setTimeout</code> 的作用就是把函式設定執行時間後，丟到事件佇列擱著。</li><li>for 迴圈是這樣處理 <code>setTimeout</code> 的：按照設定的方式，一次跑完，至於 <code>setTimeout</code> 的內容是什麼不管，以本例來說就是幾乎同時設定了 10 次 <code>setTimeout。</code></li></ul><p>所以才會在輸出幾乎同時看到「執行第10次」</p><h3 id="解法一：使用-let"><a href="#解法一：使用-let" class="headerlink" title="解法一：使用 let"></a>解法一：使用 let</h3><p>可以使用 ES6 新增的 let 輕鬆處理掉這個問題。因為 let 屬於區塊範圍 (Block Scope) ，變數僅存活於 {} 中，所以每次執行迴圈時取得的 i 在記憶體位址上都不同的，因此在 <code>setTimeout</code> 內的匿名函式參考到的 <code>i</code> 也都是不同的記憶體位址。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 10 ; i++)&#123;  </span><br><span class="line">  setTimeout(function () &#123;  </span><br><span class="line">    console.log(&apos;執行第&apos; + i + &apos;次&apos;);  </span><br><span class="line">  &#125;,10);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*u4sGpqmlx12K8T8mtwzS1g.png" alt></p><h3 id="解法二：使用-IIFE"><a href="#解法二：使用-IIFE" class="headerlink" title="解法二：使用 IIFE"></a>解法二：使用 IIFE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;  </span><br><span class="line">  (function(i) &#123;  </span><br><span class="line">    setTimeout(function () &#123;  </span><br><span class="line">      console.log(&apos;執行第&apos; + i + &apos;次&apos;);  </span><br><span class="line">    &#125;,10);  </span><br><span class="line">  &#125;)(i)  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(window.i); // 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*v8Nj3ibrNptjfq3mmkHl3Q.png" alt></p><p>透過 IIFE 建立個別的執行環境，讓傳入的 <code>i</code> 值每個都可以被保存，讓 <code>setTimeout</code> 內的匿名函式向外尋找變數 <code>i</code> 時會先找到 IIFE 內的，因此就不會被外部環境的 <code>i</code> 影響了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇要介紹的是在 JavaScript 常常會看到的問題，什麼是 IIFE ?
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.32 框架小叮嚀：空格</title>
    <link href="http://pvt5r486.github.io/f2e/20190127/671139250/"/>
    <id>http://pvt5r486.github.io/f2e/20190127/671139250/</id>
    <published>2019-01-26T19:18:58.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們這篇來記錄一下 JavaScript 的空格， JavaScript 對於空格的規範其實算是相當寬鬆的，所以可以很自由的運用在排版上。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*2LWE386IiZF19jML" alt></p><h2 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格 (White Space)"></a>空格 (White Space)</h2><p>空格，創造一個看不見的字元空間在我們寫的程式碼中，像是「Enter」、「Tab」、「空白鍵」，這可以讓程式碼的可讀性更高，而且這些東西也不會被執行，我們可以利用這些空格對程式碼做一些排版，像是可以這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var   </span><br><span class="line">  // 註解註解  </span><br><span class="line">  firstName,   </span><br><span class="line">  // 註解註解  </span><br><span class="line">  lastName,   </span><br><span class="line">  // 註解註解  </span><br><span class="line">  languaue;</span><br><span class="line"></span><br><span class="line">var person = &#123;  </span><br><span class="line">  // 註解註解  </span><br><span class="line">  firstName: &apos;Tony&apos;,  </span><br><span class="line">  lastName: &apos;Doe&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">console.log(person); // &#123;firstName: &quot;Tony&quot;, lastName: &quot;Doe&quot;&#125;</span><br></pre></td></tr></table></figure><p></p><p>當然這樣不會是最好的排版，不過只是為了說明 JavaScript 對於空格的自由度很高而已。</p><p>當語法解析器看到「//」就會忽略剩下的東西，直到下一行。然而剛才也提到空格不會被執行，所以程式輸出的最終結果就如同我們預期。</p><p>不過要注意一下「Enter」就是了，因為 No.1 的時候我們說過語法解析器可能會因為「CR」而自動幫補上分號，所以還是要小心的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們這篇來記錄一下 JavaScript 的空格， JavaScript 對於空格的規範其實算是相當寬鬆的，所以可以很自由的運用在排版上。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.31 框架小叮嚀：重載函式</title>
    <link href="http://pvt5r486.github.io/f2e/20190127/2785340838/"/>
    <id>http://pvt5r486.github.io/f2e/20190127/2785340838/</id>
    <published>2019-01-26T17:56:17.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要提的是「重載函式」，請注意這是一個 JavaScript 沒有的功能，但是JavaScript 可以利用一級函式的特性來取代。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*NKJHvao5EYka9cbL" alt></p><h2 id="重載函式-Function-Overloading"><a href="#重載函式-Function-Overloading" class="headerlink" title="重載函式 ( Function Overloading )"></a>重載函式 ( Function Overloading )</h2><p>直接使用範例說明：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這是一個函式，在其他程式語言中，都有重載函式的概念，這代表可以讓同一個函式能夠有不同數量的參數，但在 JavaScript 不能這麼做，因為JavaScript 的函式就是物件，不過我們也可以利用 JavaScript 的一級函式概念來處理這些問題。</p><p>像是以本例來說，假如我們「不想要每次都傳入 <code>languaue</code>」<br>我們已經看過可以使用 ES6 的<strong>預設參數</strong>或者使用 || 運算子，然後用邏輯運算來決定什麼情況用什麼語言。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue = &apos;en&apos;)&#123;  </span><br><span class="line">  if (languaue === &apos;en&apos;)&#123;  </span><br><span class="line">    console.log(&apos;Hello &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (languaue === &apos;es&apos;)&#123;  </span><br><span class="line">    console.log(&apos;Hola &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;en&apos;); // Hello John Doe  </span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;es&apos;); //Hola John Doe  </span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;); // Hello John Doe</span><br></pre></td></tr></table></figure><p></p><p>當然也還有其它的方式，像是<strong>再包一層函式處理</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  if (languaue === &apos;en&apos;)&#123;  </span><br><span class="line">    console.log(&apos;Hello &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">  &#125;  </span><br><span class="line">  if (languaue === &apos;es&apos;)&#123;  </span><br><span class="line">    console.log(&apos;Hola &apos; + firstName + &apos; &apos; + lastName);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greetEnglish(firstName, lastName)&#123;  </span><br><span class="line">  greet(firstName, lastName, &apos;en&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greetSpanish(firstName, lastName)&#123;  </span><br><span class="line">  greet(firstName, lastName, &apos;es&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetEnglish(&apos;John&apos;, &apos;Doe&apos;);  </span><br><span class="line">greetSpanish(&apos;John&apos;, &apos;Doe&apos;);</span><br></pre></td></tr></table></figure><p></p><p>也就是說，雖然 JavaScript 沒有重載函式的概念，但是可以透過其它的方式來處理這一塊，所以不用太擔心。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇要提的是「重載函式」，請注意這是一個 JavaScript 沒有的功能，但是JavaScript 可以利用一級函式的特性來取代。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.30 arguments 與其餘參數</title>
    <link href="http://pvt5r486.github.io/f2e/20190126/3952999924/"/>
    <id>http://pvt5r486.github.io/f2e/20190126/3952999924/</id>
    <published>2019-01-26T04:23:58.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><p>當我們呼叫執行函式時，其實 JavaScript 不只建立了特殊的關鍵字 <code>this</code> ，還建立了特殊關鍵字 <code>arguments</code> ，以及 ES6 後新增的其餘參數。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*PS0Vm2jbtQjbBWjV" alt></p><h2 id="參數-arguments"><a href="#參數-arguments" class="headerlink" title="參數 (arguments)"></a>參數 (arguments)</h2><p>如同開頭所說的，當新的執行環境被創造，然後 JavaScript 會幫我們設定一些東西，像是用變數環境包住變數給範圍鏈的外部程式參考、以及特殊關鍵字 <code>this</code> 、 <code>arguments</code> 。</p><blockquote><p><strong>arguments 包含了所有傳入函式的參數</strong>。</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*KWt-g-Twg9hZI27hOSs7RA.png" alt="課程截圖"><br>課程截圖</p><h3 id="從範例了解-arguments-是什麼："><a href="#從範例了解-arguments-是什麼：" class="headerlink" title="從範例了解 arguments 是什麼："></a>從範例了解 arguments 是什麼：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  console.log(firstName);  </span><br><span class="line">  console.log(lastName);  </span><br><span class="line">  console.log(languaue);  </span><br><span class="line">&#125;  </span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>JavaScript 與其他程式語言一個很不同的地方是，假使我們寫了一個需要帶參數的函式，呼叫函式時如果不帶任何參數也可以執行。在其他語言這樣會發生錯誤，但 JavaScript 不會，這是因為 JavaScript 具有<strong>提升</strong>的效果。</p><p>然而在 ES6 中，我們甚至可以使用預設參數的技巧，讓函式的參數有預設值，這些之前就示範過了，因此不再贅述。</p><h3 id="慢慢將參數傳入函式觀察變化"><a href="#慢慢將參數傳入函式觀察變化" class="headerlink" title="慢慢將參數傳入函式觀察變化"></a>慢慢將參數傳入函式觀察變化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  console.log(firstName);  </span><br><span class="line">  console.log(lastName);  </span><br><span class="line">  console.log(languaue);  </span><br><span class="line">&#125;  </span><br><span class="line">greet();  </span><br><span class="line">greet(&apos;John&apos;);</span><br></pre></td></tr></table></figure><p>像這樣，僅傳入對應 <code>firstName</code> 變數的參數值，</p><p><img src="https://cdn-images-1.medium.com/max/800/1*J4eTJiPDWtjbdWTloUCj3w.png" alt></p><p>繼續傳入其他參數，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  console.log(firstName);  </span><br><span class="line">  console.log(lastName);  </span><br><span class="line">  console.log(languaue);  </span><br><span class="line">&#125;  </span><br><span class="line">greet();  </span><br><span class="line">greet(&apos;John&apos;);  </span><br><span class="line">greet(&apos;John&apos;, &apos;Doe&apos;);  </span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;es&apos;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*yf5-FdzcPubYcaDlRhakiA.png" alt></p><p>透過這樣的實驗，表示我們可以省略傳入參數也不會發生錯誤 (Error)，或者是可以只傳入一部分的參數。</p><h2 id="arguments-是類陣列"><a href="#arguments-是類陣列" class="headerlink" title="arguments 是類陣列"></a>arguments 是類陣列</h2><p>什麼是類陣列 (array-like)，簡單來說，這是個長的像陣列的東西，但是它不支援部分陣列的方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  console.log(firstName);  </span><br><span class="line">  console.log(lastName);  </span><br><span class="line">  console.log(languaue);  </span><br><span class="line">  console.log(arguments);  </span><br><span class="line">  console.log(&apos;-----------&apos;);  </span><br><span class="line">  var arr = \[1,2,3\];  </span><br><span class="line">  console.log(arr);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;es&apos;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*PBkWo09MSul9AeXdU8Okfw.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*6du4a_i7hpOb78ackSjN5g.png" alt></p><p>我並沒有宣告 <code>arguments</code> ，但我卻可以使用，這是因為當函式執行時， <code>arguments</code> 就與 <code>this</code> 一同被創造了。</p><p>然而如同上面所述，類陣列因為不是真正的陣列，所以相較真正的陣列而言少了很多能用的方法，可觀察 <code>__proto__</code> 底下的得知。</p><p>也可以觀察到 <code>arguments</code> 包含了所有傳入的參數值，因此可以像取用一般陣列的值一樣地使用 <code>arguments</code> 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue)&#123;  </span><br><span class="line">  if (arguments.length === 0)&#123;  </span><br><span class="line">    console.log(&apos;沒有傳入參數&apos;);  </span><br><span class="line">    return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(firstName);  </span><br><span class="line">  console.log(lastName);  </span><br><span class="line">  console.log(languaue);  </span><br><span class="line">  console.log(arguments);  </span><br><span class="line">  console.log(arguments[2]);  </span><br><span class="line">  console.log(&apos;-----------&apos;);  </span><br><span class="line">  var arr = [1,2,3];  </span><br><span class="line">  console.log(arr);  </span><br><span class="line">&#125;  </span><br><span class="line">greet();  </span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;es&apos;);</span><br></pre></td></tr></table></figure><p></p><p>像是我們可以利用 <code>arguments</code> 來判斷函式有沒有傳入參數，或者取出特定索引的值等等運用。</p><p>隨著 JavaScript 的發展，在 ES6 中，我們可以使用其餘參數來取代 <code>arguments</code> ，但不代表 <code>arguments</code> 不存在了，它仍然可以使用，只是有更好的選擇。</p><h2 id="其餘參數-Rest-parameters"><a href="#其餘參數-Rest-parameters" class="headerlink" title="其餘參數 (Rest parameters)"></a>其餘參數 (Rest parameters)</h2><p>詳細可以參考<a href="http://eddychang.me/blog/16-javascript/45-spread-operator-rest-parameters.html" rel="external nofollow noopener noreferrer" target="_blank">這篇</a>課外讀物</p><blockquote><p>簡單來說如果我們有傳入函式的參數，可以使用「…」來省略，但要特別注意的是，只能在沒有其他參數下，或者「…」必須是最後一個參數才可以使用。</p></blockquote><p>其餘參數比起 <code>arguments</code> 好用的地方在於，其餘參數是一個真正的陣列，支援所有可以用於陣列上的方法， <code>arguments</code> 是類陣列，處理上較為麻煩。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function greet(firstName, lastName, languaue, ...other)&#123;  </span><br><span class="line">  if (arguments.length === 0)&#123;  </span><br><span class="line">    console.log(&apos;沒有傳入參數&apos;);  </span><br><span class="line">    return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(arguments);  </span><br><span class="line">  console.log(other);  </span><br><span class="line">  console.log(&apos;-----------&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">greet();  </span><br><span class="line">greet(&apos;John&apos;,&apos;Doe&apos;,&apos;es&apos;,&apos;orther1&apos;,&apos;orther2&apos;,&apos;orther3&apos;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*TtWBZ3QJhlnFxbpKjazqPA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*uGHneEt4VFG4lc-tJelg-w.png" alt></p><p>而比較典型的例子像是這個:</p><h3 id="計算加總-—-其餘參數"><a href="#計算加總-—-其餘參數" class="headerlink" title="計算加總 — 其餘參數"></a>計算加總 — 其餘參數</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(...input) &#123;  </span><br><span class="line">  var result = 0;  </span><br><span class="line">  input.forEach(function(input) &#123;  </span><br><span class="line">    result += input;  </span><br><span class="line">  &#125;);  </span><br><span class="line">  return result;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(sum(1)); // 1  </span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); // 15</span><br></pre></td></tr></table></figure><p>由於其餘參數會回傳一個真正的陣列，所以可以使用陣列方法來計算，程式碼相對的易讀明瞭。</p><h3 id="計算加總-—-arguments"><a href="#計算加總-—-arguments" class="headerlink" title="計算加總 — arguments"></a>計算加總 — arguments</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;  </span><br><span class="line">  var result = 0;  </span><br><span class="line">  for (var i = 0;i&lt;arguments.length;i++)&#123;  </span><br><span class="line">    result += arguments[i]  </span><br><span class="line">  &#125;  </span><br><span class="line">  return result;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(sum(1)); // 1  </span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); // 15</span><br></pre></td></tr></table></figure><p>雖然 <code>arguments</code> 也能做到一樣的事情，但是因為不是真正的陣列，沒辦法使用 ES6 新增的一些好用的陣列方法，所以只能使用 for 迴圈一個個加總，或者使用其他方式將類陣列轉換成真正的陣列。</p><p>也因為 <code>arguments</code> 不能自訂一個名稱，所以也很難讓人明白到底這段程式是在做些什麼。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      當我們呼叫執行函式時，其實 JavaScript 不只建立了特殊的關鍵字 this ，還建立了特殊關鍵字 arguments ，以及 ES6 後新增的其餘參數。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.29 觀念小叮嚀：陣列－任何東西的集合</title>
    <link href="http://pvt5r486.github.io/f2e/20190125/3910130714/"/>
    <id>http://pvt5r486.github.io/f2e/20190125/3910130714/</id>
    <published>2019-01-25T00:42:53.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們提過 JavaScript 是動態型別的程式語言，前面也介紹過動態型別的優點以及缺點，動態型別是相當強大的特性，像是用在 JavaScript 的陣列上。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*LnUy3Yz5oobpXr65" alt></p><h2 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列 (Array)"></a>陣列 (Array)</h2><p>JavaScript 的陣列相較於其他程式語言的陣列來說彈性了不少。受惠於動態型別的緣故，JavaScript 的陣列可以是任何東西的集合，這可以讓我們寫出一些沒接觸過 JavaScript 的人可能感到困惑的程式。</p><p>此外，陣列的索引是從0開始的、陣列也有陣列實體語法，這跟物件實體語法很相似，不多說我們直接看範例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 陣列實體語法  </span><br><span class="line">var arr = [1,2,3];  </span><br><span class="line">// 也可以這樣寫  </span><br><span class="line">// var arr1 = new Array();  </span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure><p></p><p>使用陣列實體語法建立陣列，並且在陣列內放入值並使用逗號分隔，陣列是從０開始算的，代表我可以使用 <code>console.log</code> 抓出指定的陣列值。</p><p>在大部分的程式語言，陣列通常只能放相同型別的東西，像是一個數字陣列、一個字串陣列、一個物件陣列等等，但是 JavaScript 可以是任何東西：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [  </span><br><span class="line">  1,  </span><br><span class="line">  false,  </span><br><span class="line">  &#123;  </span><br><span class="line">    name: &apos;Tony&apos;,  </span><br><span class="line">    address: &apos;111 Main St.&apos;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  function(name)&#123;  </span><br><span class="line">    var greeting = &apos;Hello&apos;;  </span><br><span class="line">    console.log(greeting + name);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  &apos;hello&apos;  </span><br><span class="line">];  </span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p></p><p>像這樣，我在 <code>arr</code> 陣列中各放了數值、布林、物件、函式 (也是物件的一種)、字串，並且輸出觀察結果。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*vSjjelSQyNPCYOse5gxdLA.png" alt></p><p>看起來很怪異，不過在 JavaScript 中是完全合理的。</p><p>另外還可以有這樣的組合用法：</p><p>我預期呼叫陣列內的函式，並且帶入陣列內物件的 <code>name</code> 屬性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [  </span><br><span class="line">  1,  </span><br><span class="line">  false,  </span><br><span class="line">  &#123;  </span><br><span class="line">    name: &apos;Tony&apos;,  </span><br><span class="line">    address: &apos;111 Main St.&apos;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  function(name)&#123;  </span><br><span class="line">    var greeting = &apos;Hello &apos;;  </span><br><span class="line">    console.log(greeting + name);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  &apos;hello&apos;  </span><br><span class="line">];  </span><br><span class="line">arr[3](arr[2].name);</span><br></pre></td></tr></table></figure><p></p><p>陣列索引是從 0 開始計算的，因此我們要先指定到函式的索引，而呼叫的方法一樣是加上 () 即可，參數的部分則是指定到陣列內物件的索引，並且使用點運算子取出屬性的值。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*McgM8RfidHeaDFpm5R9AXA.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們提過 JavaScript 是動態型別的程式語言，前面也介紹過動態型別的優點以及缺點，動態型別是相當強大的特性，像是用在 JavaScript 的陣列上。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.28 物件、函式 與 this</title>
    <link href="http://pvt5r486.github.io/f2e/20190125/672190371/"/>
    <id>http://pvt5r486.github.io/f2e/20190125/672190371/</id>
    <published>2019-01-24T22:43:37.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們了解了函式是物件的一種，有屬性及許多其它的東西。記得課程剛開始時，提過的執行環境嗎？這堂課是物件、函式，以及 this 的探討。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*w7UkkxspX9gLLZWV" alt></p><h2 id="當函式被呼叫"><a href="#當函式被呼叫" class="headerlink" title="當函式被呼叫"></a>當函式被呼叫</h2><p>複習一下，當函式被呼叫時，會創造新的執行環境。當執行環境被創造，放進執行堆，這過程決定了程式怎樣執行。</p><p>每個執行環境都有自己的變數環境，也就是被創造在函式內的變數所在，並且可以參考到外部環境，能夠隨著範圍鏈一路往下找，直到全域執行環境。</p><p>而我們也知道，當函式被執行、執行環境被創造時 JavaScript 也會產生一個我們沒宣告過的特殊變數 <code>this</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*KFKKeZ9NVHRnrWG3VvWlpg.png" alt></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 會指向不同的物件，而這是根據<strong>函式是如何被呼叫的</strong>，這很重要，讓我們直接從簡單的範例了解吧。</p><h3 id="直接觀察-this"><a href="#直接觀察-this" class="headerlink" title="直接觀察 this"></a>直接觀察 this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br></pre></td></tr></table></figure><p>如果直接取用 <code>this</code> ，這個 <code>this</code> 會指向全域物件 <code>window。</code></p><p><img src="https://cdn-images-1.medium.com/max/800/1*rRPdSDX1klE3ho-nyz6xug.png" alt></p><h3 id="建立函式陳述句呼叫觀察-this-："><a href="#建立函式陳述句呼叫觀察-this-：" class="headerlink" title="建立函式陳述句呼叫觀察 this ："></a>建立函式陳述句呼叫觀察 this ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a ()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>直接呼叫 <code>a</code> 函式，於是函式 <code>a</code> 內的執行環境被創造、 <code>this</code> 也被創造，在這個情況下， <code>this</code> 會指向全域物件 <code>window。</code></p><p><img src="https://cdn-images-1.medium.com/max/800/1*rRPdSDX1klE3ho-nyz6xug.png" alt></p><h3 id="建立函式表示式呼叫觀察-this-："><a href="#建立函式表示式呼叫觀察-this-：" class="headerlink" title="建立函式表示式呼叫觀察 this ："></a>建立函式表示式呼叫觀察 this ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var b = function()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;  </span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>結果也是一樣的，因為我們仍然是直接呼叫變數 <code>b</code> 的函式。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*rRPdSDX1klE3ho-nyz6xug.png" alt></p><p>從上面兩個小測試可以觀察到，無論我們使用表示式、陳述句在何處創造函式，並不會影響 <code>this</code> 指向全域物件，因為會影響到 <code>this</code> 的是<strong>函式如何被呼叫</strong>。</p><h3 id="小測試"><a href="#小測試" class="headerlink" title="小測試"></a>小測試</h3><p>而每一個執行環境都有自己的 <code>this</code> ， 在上述兩個小測試中的 <code>this</code> 都指向同一個記憶體位址，也就是同個全域物件，所以我們可以再透過這個延伸例子觀察：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a ()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">  this.newVariable = &apos;hello&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">var b = function()&#123;  </span><br><span class="line">  console.log(this);  </span><br><span class="line">&#125;  </span><br><span class="line">a();  </span><br><span class="line">console.log(newVariable);  </span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p></p><p>在 <code>a</code> 函式的 <code>this</code> 被創造之後，我們在這個 <code>this</code> 上利用點運算子新增一個屬性，將這個屬性連接到全域物件，所以在呼叫 <code>a</code> 函式之後，我們可以透過 <code>console.log</code> 觀察到 <code>newVariable</code> 的值。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*8n0k24DdhKZA-8RmT3u3-A.png" alt></p><p>可能我們會感到奇怪，為什麼取用 <code>newVariable</code> 變數的時候不需要使用點運算子，因為這時候的 <code>this</code> 指向全域物件，而任何連接到全域物件的變數都可以直接使用。這就相當於在全域執行環境時使用 <code>var</code> 宣告變數一樣，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function a ()&#123;  </span><br><span class="line">  this.newVariable = &apos;hello&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">a();  </span><br><span class="line">var c = &apos;123&apos;;  </span><br><span class="line">console.log(window);</span><br></pre></td></tr></table></figure><p></p><p>我們在全域執行環境中宣告了變數 <code>c</code> ，並且跟上面的例子一樣直接呼叫函式 <code>a</code> ，並在函式 <code>a</code> 的程式內新增全域物件的屬性，接著觀察 <code>window</code> 的輸出。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*WRhRmKc8z-QceL3TABskYw.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*LTMLnqjAtgfQKDvzyRjSEA.png" alt></p><p>可以發現如果 <code>this</code> 指向全域物件時，使用點運算子增加屬性到全域物件上，這時的效果會同於直接在全域執行環境上使用 <code>var</code> 宣告變數。</p><h2 id="物件實體內的方法"><a href="#物件實體內的方法" class="headerlink" title="物件實體內的方法"></a>物件實體內的方法</h2><p>透過上面的範例，我們已經了解函式表示式、陳述句，因此這次我們在一個物件內建立一個函式。記得我們先前提的，物件是許多名稱 / 值配對而成的組合，當值是純值時稱為「<strong>屬性</strong>」；當值為函式時稱為「<strong>方法</strong>」。像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  name: &apos;這是 c 物件&apos;,  </span><br><span class="line">  log: function()&#123;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p></p><p>現在情況就有點不一樣了，並不是直接呼叫函式，而是呼叫被創造在物件時體內的函式，因此要取用物件內的成員，必須使用點運算子，並且加上()呼叫該函式，也就是 <code>c</code> 物件的 <code>log</code> 方法。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*7D5ruT_XdesWf1pn_boROg.png" alt></p><p>因為呼叫的方式改變了，在這個範例中 <code>this</code> 會指向有 <code>log</code> 方法的 <code>c</code> 物件，因此我們可以利用這個特性，在方法內修改 <code>c</code> 物件的 <code>name</code> 屬性，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  name: &apos;這是 c 物件&apos;,  </span><br><span class="line">  log: function()&#123;  </span><br><span class="line">    this.name = &apos;更新 c 物件&apos;;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p></p><p>可以看到 <code>name</code> 屬性被修改了!</p><p><img src="https://cdn-images-1.medium.com/max/800/1*jeiGK4NQ2iFJmUSSTmGKdQ.png" alt></p><h2 id="延伸範例"><a href="#延伸範例" class="headerlink" title="延伸範例"></a>延伸範例</h2><p>讓我們將範例混合起來觀察， <code>this</code> 是否仍然如我們所想的那樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  name: &apos;這是 c 物件&apos;,  </span><br><span class="line">  log: function()&#123;  </span><br><span class="line">    this.name = &apos;更新 c 物件&apos;;  </span><br><span class="line">    console.log(this);  </span><br><span class="line">    var setName = function(newName)&#123;  </span><br><span class="line">      this.name = newName;  </span><br><span class="line">    &#125;  </span><br><span class="line">    setName(&apos;再次更新 c 物件&apos;);  </span><br><span class="line">    console.log(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Ke8AfKG99p5KC2rso-q7GA.png" alt></p><p>結果令人驚訝嗎？其實並不，這是可以解釋的。</p><p>在 <code>log</code> 方法內，我們雖然又新增了一個 <code>setName</code> 的函式，並且是直接的呼叫它，但是會影響 <code>this</code> 的是函式呼叫的方式，並非實際上程式碼的實體位置，因此雖然方法內的 <code>this</code> 是指向 <code>c</code> 物件本身，但在 <code>setName</code> 函式內的 <code>this</code> 仍然是指向全域物件 <code>window</code> 。</p><p>所以我們可以在全域物件 <code>window</code> 中找到剛剛新增的屬性</p><p><img src="https://cdn-images-1.medium.com/max/800/1*cYnAMw5XqkMcp5Y2tjmqQQ.png" alt></p><h3 id="那麼，該如何修改才能符合預期呢"><a href="#那麼，該如何修改才能符合預期呢" class="headerlink" title="那麼，該如何修改才能符合預期呢?"></a>那麼，該如何修改才能符合預期呢?</h3><p>其實很容易，我們說過物件是傳參考的，我們只需要創造一個變數，並把想保存的 <code>this</code> 利用等號運算子設定給該變數就可以了，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  name: &apos;這是 c 物件&apos;,  </span><br><span class="line">  log: function()&#123;  </span><br><span class="line">    var self = this;  </span><br><span class="line">    self.name = &apos;更新 c 物件&apos;;  </span><br><span class="line">    console.log(self);  </span><br><span class="line">    var setName = function(newName)&#123;  </span><br><span class="line">      self.name = newName;  </span><br><span class="line">    &#125;  </span><br><span class="line">    setName(&apos;再次更新 c 物件&apos;);  </span><br><span class="line">    console.log(self);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*wQo9_T8JBFfAA8J8_QnYzA.png" alt></p><p>這樣就不需要考慮每個時候的 <code>this</code> 究竟是指向誰，只需要知道要保存下來的 <code>this</code> 是指向誰就可以了。</p><p>在這個例子中，我希望保存 <code>this</code> 指向 <code>c</code> 物件的記憶體位址，因此用了變數 <code>self</code> 配合等號運算子，令其與 <code>this</code> 指向同樣的 <code>c</code> 物件的記憶體位址。這樣即使之後 <code>this</code> 變動，也已經 <code>self</code> 無關，我們仍然可以使用這個變數修改 <code>c</code> 物件。</p><h2 id="額外補充"><a href="#額外補充" class="headerlink" title="額外補充"></a>額外補充</h2><p>關於 this 部分還有很多例子可以細細觀察，這部分可以參考 <a href="https://wcc723.github.io/javascript/2017/12/12/javascript-this/" rel="external nofollow noopener noreferrer" target="_blank">卡斯伯的鐵人賽文章 - JavaScript 的 this 到底是誰？</a></p><p>當然 <code>console.log(this)</code> 隨時查一下 <code>this</code> 指向哪裡也是可以的，配合著這些觀念，會讓我們寫 code 更順利哦~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們了解了函式是物件的一種，有屬性及許多其它的東西。記得課程剛開始時，提過的執行環境嗎？這堂課是物件、函式，以及 this 的探討。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.27 觀念小叮嚀：傳值和傳參考</title>
    <link href="http://pvt5r486.github.io/f2e/20190124/2673002552/"/>
    <id>http://pvt5r486.github.io/f2e/20190124/2673002552/</id>
    <published>2019-01-23T23:50:08.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要記錄 JavaScript 相當重要的觀念「傳值與傳參考」，了解這個觀念是相當重要的，兩者都是討論關於變數的東西，讓我們開始吧。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*yPAjtuVSAfmnNdCN" alt></p><h2 id="傳值-By-Value"><a href="#傳值-By-Value" class="headerlink" title="傳值 (By Value)"></a>傳值 (By Value)</h2><p>還記得純值 (Primitives value) 是什麼東西嗎?</p><h3 id="純值可以是："><a href="#純值可以是：" class="headerlink" title="純值可以是："></a>純值可以是：</h3><ul><li>String</li><li>Number</li><li>Boolean</li><li>null</li><li>undefined</li><li>Symbol</li></ul><p>我們把其中一種純值設定到變數 <code>a</code> 中，所以現在這個變數 <code>a</code> 知道了這個純值的記憶體位址。</p><p>接著我們創造一個新的變數 <code>b</code> ，並且令 <code>b = a</code> ，變數 <code>b</code> 會指向一個新的記憶體位址，並拷貝那個純值，放到新的記憶體位址。</p><blockquote><p>這種方式稱為<strong>傳值 ( By Value )</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*gbb9Z_K0bgYiEroNU_7F1A.png" alt></p><h2 id="傳參考-By-Reference"><a href="#傳參考-By-Reference" class="headerlink" title="傳參考 ( By Reference)"></a>傳參考 ( By Reference)</h2><blockquote><p>在 JavaScript 中，所有的物件 (包含函式物件)，全部都是傳參考的。</p></blockquote><p>當設定一個變數 <code>a</code> 並且賦予值為物件類型，變數 <code>a</code> 仍然會得到物件的記憶體位址。</p><p>但當令 <code>b = a</code> ，變數 <code>b</code> 此時不會得到一個新的記憶體位址，而是會指向變數 <code>a</code> 的記憶體位址，並不會創造新的拷貝物件。就好像別名一般，此時的 <code>a</code> 與 <code>b</code> 這兩個名稱都指向同一記憶體位址。簡單來說，此時的 <code>a</code> 與 <code>b</code> 的值是同樣的，因為它們指向相同的記憶體位址。</p><h2 id="傳值的例子"><a href="#傳值的例子" class="headerlink" title="傳值的例子"></a>傳值的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// by value  </span><br><span class="line">var a = 3;  </span><br><span class="line">var b;  </span><br><span class="line">b = a;  </span><br><span class="line">console.log(a, b); // 3  3</span><br></pre></td></tr></table></figure><p>透過上面的敘述，可以了解，為什麼 <code>a</code> 與 <code>b</code> 都是 3 了。</p><p>因為 3 是數值型別，所以當 <code>b</code> 被設定為 <code>a</code> 時，等號運算子看到 3 是純值，所以創造一個新的記憶體位址給 <code>b</code> ，接著拷貝 <code>a</code> 的值填入 <code>b</code> 的位址。</p><p>所以 <code>a</code> 是 3 、 <code>b</code> 也是 3 ，但它們是對方的拷貝，在兩個不同的記憶體位址。</p><blockquote><p>也就是說當 <code>a</code> 被更動時， <code>b</code> 不會受到影響。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// by value  </span><br><span class="line">var a = 3;  </span><br><span class="line">var b;  </span><br><span class="line">b = a;  </span><br><span class="line">console.log(a, b); // 3 3  </span><br><span class="line">a = 2;  </span><br><span class="line">console.log(a, b); // 2 3</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="傳參考的例子"><a href="#傳參考的例子" class="headerlink" title="傳參考的例子"></a>傳參考的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  greeting: &apos;Hi&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">var d = c;  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*qDit78K12_uJvbZgLN091Q.png" alt></p><p>我們給變數 <code>c</code> 設定了一個物件，同樣的， <code>c</code> 知道了物件的記憶體位址。當執行到 <code>d = c</code> 時，等號運算子看到物件不會創造新的記憶體位址給 <code>d</code> ，而是把 <code>d</code> 指向和 <code>c</code> 相同的記憶體位址。</p><p>所以結果是相同的 ，但它們<strong>不是</strong>對方的拷貝， <code>c</code> 和 <code>d</code> 只是指向相同的記憶體位址。</p><blockquote><p>也就是說當 <code>c</code> 被更動時， <code>d</code> 也會受到影響。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// by reference (all objects (including functions))  </span><br><span class="line">var c = &#123;  </span><br><span class="line">  greeting: &apos;Hi&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">var d = c;  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);  </span><br><span class="line">c.greeting = &apos;Hello&apos;;  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><p></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*PIN4SXp7XioLvLqgGAiPTA.png" alt></p><h2 id="當物件用於函式的參數上時"><a href="#當物件用於函式的參數上時" class="headerlink" title="當物件用於函式的參數上時"></a>當物件用於函式的參數上時</h2><p>當物件用於函式的參數上時，物件也是透過傳參考的方式被傳入，觀察一個例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  greeting: &apos;Hi&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">var d = c;  </span><br><span class="line">c.greeting = &apos;Hello&apos;;</span><br><span class="line"></span><br><span class="line">function changeGreeting(obj)&#123;  </span><br><span class="line">  obj.greeting = &apos;Hola&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">changeGreeting(d);  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><p></p><p>我們傳入變數 <code>d</code> 到函式中，此時 <code>obj</code> 會指向 <code>d</code> 的記憶體位址，但接續前面的例子， <code>d</code> 已經指向 <code>c</code> 的記憶體位置，而 <code>c</code> 被設定了一個物件。</p><p>所以當使用 <code>obj.greeting</code> 改變了值，表示會更新這個物件所指向的記憶體位址內的值，因此輸出 <code>c</code> 與 <code>d</code> 的值，可以發現都被改變了。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*VoApy3qBlwocvqBoUNOuew.png" alt></p><h3 id="例外情況一"><a href="#例外情況一" class="headerlink" title="例外情況一"></a>例外情況一</h3><p>有件事情要特別注意，<strong>使用等號運算子賦予新值(記憶體還不存在的值)時，會設定一個新的記憶體位址，</strong>接續上面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  greeting: &apos;Hi&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">var d = c;  </span><br><span class="line">c.greeting = &apos;Hello&apos;;</span><br><span class="line"></span><br><span class="line">function changeGreeting(obj)&#123;  </span><br><span class="line">  obj.greeting = &apos;Hola&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line">changeGreeting(d);  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);</span><br><span class="line"></span><br><span class="line">c = &#123;  </span><br><span class="line">  greeting: &apos;Howdy&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(c);  </span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><p></p><p>我使用等號運算子設定變數 <code>c</code> 為一個新的值，然後等號運算子會設定一個新的記憶體空間給 <code>c</code> ，並且放進那個值。自此， <code>d</code> 和 <code>c</code> 就不再指向同一個記憶體位址。</p><blockquote><p>所以這是一個特殊的例子，這並不是傳參考。</p></blockquote><p>等號運算子看到 <code>{ greeting: &#39;Howdy&#39; }</code> 還不存在於記憶體，這是一個創造物件的物件實體語法，所以並不是一個已經存在的物件。因此等號運算子必須建立另一個新的記憶體空間給物件，然後指向 <code>c</code> 。</p><p><strong>與例子上半部 <code>d = c</code> 不同的地方是 <code>c</code> 已經存在了</strong></p><p>因此等號運算子知道 <code>c</code> 已經在記憶體中，不需要另外創造記憶體空間，而且 <code>c</code> 是個物件，只要把 <code>d</code> 指向同一個位址就好。</p><h3 id="例外情況二"><a href="#例外情況二" class="headerlink" title="例外情況二"></a>例外情況二</h3><p>我們延伸例外情況一，使之變得更為複雜：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var c = &#123;  </span><br><span class="line">  greeting: &apos;Hi&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">function changeGreeting(obj)&#123;  </span><br><span class="line">  obj = &#123;  </span><br><span class="line">    greeting: &apos;Hola&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">changeGreeting(c);  </span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure><p></p><p>這個答案是我們想的那樣嗎？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Qo7tbKQbvTEt9pis0auOHg.png" alt></p><p>答案不是<code>{ greeting: &quot;Hola&quot; }</code> ，為什麼?</p><p>我們使用物件實體語法創造一個物件並且令變數 <code>c</code> 指向自身記憶體位址。</p><p>接著我們知道當物件用於函式的參數上時是傳參考的。因此此時的 <code>obj</code> 與 <code>c</code> 指向同一個物件的記憶體位址。</p><p>但是，當程式碼執行到<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;  </span><br><span class="line">    greeting: &apos;Hola&apos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同<strong>例外情況一</strong>看到的，等號運算子看到 <code>{ greeting: &#39;Hola&#39; }</code> 還不存在於記憶體，這是一個創造物件的物件實體語法，所以並不是一個已經存在的物件。因此等號運算子必須建立另一個新的記憶體空間給物件，然後指向 <code>obj</code> 。</p><p>因此這個時候 <code>obj</code> 已經與 <code>c</code> 指向不同的記憶體位址了，自然 <code>c</code> 指向的物件並不會被改變。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>在寫這篇的時候，發現到有些文章好像對於傳值、傳參考的細節描述都有一些些不同的地方，像是這篇文章 - <a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" rel="external nofollow noopener noreferrer" target="_blank"><strong>深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</strong></a>寫得很仔細，而且其實技術的名詞定義紛爭也是不少，像是<a href="https://www.ithome.com.tw/voice/94877" rel="external nofollow noopener noreferrer" target="_blank"><strong>這篇</strong></a>。</p><p>最後擷取一段胡立大大文章的句子作為例外情況的總結：</p><blockquote><p>JavaScript 傳 object 進函式的時候，可以更改原本 object 的值，但重新賦值並不會影響到外部的 object</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇要記錄 JavaScript 相當重要的觀念「傳值與傳參考」，了解這個觀念是相當重要的，兩者都是討論關於變數的東西，讓我們開始吧。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.26 函式表示式與函式陳述句</title>
    <link href="http://pvt5r486.github.io/f2e/20190123/1596425308/"/>
    <id>http://pvt5r486.github.io/f2e/20190123/1596425308/</id>
    <published>2019-01-22T23:45:33.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在我們知道，在 JavaScript 內函數就是物件，接著要運用這個觀念，來做一些實際運用！但在開始之前，需要先了解函式陳述句 (Function Statements)、什麼是函式表示式 (Function Expressions) 之間的用法差異。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Pbij-zRsIOmv-uy9" alt></p><h2 id="表示式-Expressions"><a href="#表示式-Expressions" class="headerlink" title="表示式 (Expressions)"></a>表示式 (Expressions)</h2><blockquote><p><strong>表示式為程式碼的單位，會回傳一個值</strong> (A unit of code that results in a value)</p></blockquote><p>白話來說，<strong>函式表示式或者任何形式的表示式最終會創造一個值，然而這個值不一定要儲存在某個變數，且這個值可以是任何東西。</strong></p><p>舉個例子，我們在 .js 檔內宣告變數 <code>a</code> 並且打開開發者工具，輸入以下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*9yf8D6uYz6WKtpz-6Kg8TQ.png" alt></p><p>這是一個簡單的表示式，我們把 3 透過等號運算子賦予給變數 <code>a</code> ，並且執行它，得到回傳的結果。</p><p>我們說過，值不一定要儲存在某個變數，因此這樣也是表示式：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*mbyQJDcRrSvjSKs_CgVeAg.png" alt></p><p>這個表示式回傳了 3 ，我們並沒有使用等號運算子將這個值放入變數。</p><p>然而，表示式也可以是這個形式</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Ev6CyMNoOTFQq1W64c3DWw.png" alt></p><h2 id="陳述句-Statements"><a href="#陳述句-Statements" class="headerlink" title="陳述句 (Statements)"></a>陳述句 (Statements)</h2><blockquote><p>當我們提到陳述句，陳述句代表「會做某件事」。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">if (a === 3)&#123;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>當 <code>if (a === 3)</code> 就做某件事情。</p><p>在 if 陳述句的括號內，必須放進表示式產生一個值，這樣這個陳述句才能運作。</p><p>另外陳述句本身不會回傳任何值。</p><p>像是我不能這麼做，這是無效的，因為沒有任何值會被回傳給變數 b 。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 錯誤示範  </span><br><span class="line">var b = if (a === 3)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>簡單來說，陳述句會做其他事；表示式則回傳值</p></blockquote><h2 id="函式表示式與函式陳述句的差異"><a href="#函式表示式與函式陳述句的差異" class="headerlink" title="函式表示式與函式陳述句的差異"></a>函式表示式與函式陳述句的差異</h2><p>接著我們來看看這兩者之間的差異，直接看例子。</p><h3 id="函式陳述句"><a href="#函式陳述句" class="headerlink" title="函式陳述句"></a>函式陳述句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就是一個簡單的函式陳述句，當創造執行環境時， <code>greet</code> 函式被放進記憶體中，但因為 <code>greet</code> 是函式陳述句，所以不會回傳任何值，直到函式被呼叫執行。</p><p>雖然函式陳述句不會回傳任何值，但它會有提升 (hoisting) 現象，所以可以在任何地方取用它，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet();  </span><br><span class="line">function greet() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="函式表示式"><a href="#函式表示式" class="headerlink" title="函式表示式"></a>函式表示式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anonymousGreet = function greet() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宣告一個 <code>anonymousGreet</code> 變數並且使用等號運算子，然後在右側使用函式陳述句。</p><p>記得我們說的「函式就是物件」，所以可以當作「我們建立了一個物件，並設定它等於這個變數」，也就是這個變數在記憶體中指向的位址。</p><p>另外，我們已經有一個已經知道函式物件位址的變數 <code>anonymousGreet</code> ，所以等號右邊的陳述句可以改寫成這樣，稱為匿名函式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anonymousGreet = function() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*y5fKSHJ-mq6-CBb8tO1TaA.png" alt></p><h3 id="如何觸發函式表示式呢"><a href="#如何觸發函式表示式呢" class="headerlink" title="如何觸發函式表示式呢"></a>如何觸發函式表示式呢</h3><p>我們需要指向該物件，並且告訴它執行程式，像是這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymousGreet();</span><br></pre></td></tr></table></figure><p></p><p>因為變數已經知道了函式物件的記憶體位址，只需要加上()來呼叫函式就可以執行了。</p><p>另外還有一個值得注意的問題，函式表示式的提升 (hoisting) 現象，如果我們將程式改成這個樣子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anonymousGreets();  </span><br><span class="line">var anonymousGreets = function() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>結果會變成這樣，為什麼呢？</p><p><img src="https://cdn-images-1.medium.com/max/800/1*_VsRhHZ3soEoLcGHJHPNHw.png" alt></p><p>還記得當執行環境被創造，創造執行階段會把函式陳述句以及變數都放入記憶體，變數被賦予初始值 <code>undefined</code> ，然後逐行執行程式碼。</p><p>於是程式的第一行是「<code>anonymousGreets();</code>」，但此時仍未賦予變數值，變數的值仍然是 <code>undefined</code> 。自然的，錯誤便會告訴我們 <code>undefined</code> 不是函式，它沒辦法被使用 () 呼叫執行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anonymousGreets = function() &#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>直到上述這行程式碼，<code>anonymousGreets</code> 變數的值才被賦予函式物件。</p><blockquote><p>代表函式表示式不受到提升 (hoisting) 影響。</p></blockquote><h3 id="傳入函式表示式做為參數"><a href="#傳入函式表示式做為參數" class="headerlink" title="傳入函式表示式做為參數"></a>傳入函式表示式做為參數</h3><p>記得我們說的函式是物件，函式表示式可以馬上創造函式物件，因此我們可延伸出以下寫法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(a)&#123;  </span><br><span class="line">  console.log(a);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(function()&#123;  </span><br><span class="line">  console.log(&apos;hi&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>我們立即創造了一個函式物件，在裡面寫了一些程式碼。然後把這個函式物件當成參數傳入 <code>log</code> 函式內。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*w6YIqEg9-9-5iyubICxhsA.png" alt></p><p>不過這樣只是印出函式物件的內容而已，但透過這樣的觀察得知「<strong>一級函式可以很快地被創造、使用，且變數也可以設值成為一級函式</strong>」</p><p>我們結合上述這些並做些修改：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(a)&#123;  </span><br><span class="line">  a();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var anonymousGreets = function()&#123;  </span><br><span class="line">  console.log(&apos;hi&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">log(anonymousGreets);　// hi</span><br></pre></td></tr></table></figure><p></p><p>因為我們傳入 <code>log</code> 函式的參數為函式物件，所以變數 <code>a</code> 參照到了這個函式物件。同樣地，要呼叫執行函式僅需要加上 () 即可。</p><p>本例來看，我使用函式表示式，接著把這個函式傳入當作另一個函式的參數，這樣另一個函式就可以使用這個函式表示式，這就是我們提到的一級函式的觀念「可以將函式傳入別處」。</p><p>可以把函式給另一個函式，就像使用變數一樣，這樣的做法也稱為<strong>函式程式語言 ( functional programming )</strong>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      現在我們知道，在 JavaScript 內函數就是物件，接著要運用這個觀念，來做一些實際運用！但在開始之前，需要先了解函式陳述句 (Function Statements)、什麼是函式表示式 (Function Expressions) 之間的用法差異。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.25 函式就是物件</title>
    <link href="http://pvt5r486.github.io/f2e/20190123/2616887914/"/>
    <id>http://pvt5r486.github.io/f2e/20190123/2616887914/</id>
    <published>2019-01-22T19:41:54.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在這節課中，作者說明了一個很重要的觀念，也就是在 JavaScript 中，函式也是物件的一種 (functions are object) 而且也會提到什麼是一級函式(first class functions)</p><p><img src="https://cdn-images-1.medium.com/max/800/0*HvEdGt8d683Ygd1M" alt></p><h2 id="一級函式-First-Class-Functions"><a href="#一級函式-First-Class-Functions" class="headerlink" title="一級函式 (First Class Functions)"></a>一級函式 (First Class Functions)</h2><p>一級函式從字面上看來或許很複雜，但其實不會。一級函式指的是，可以對別的型別，像是物件、字串、數值、布林做的事情，全部都可以對函式做。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><ul><li>可以指派一個變數的值為函式</li><li>可以將函式當作參數傳入另一個函式</li><li>可以在一個函式中回傳另一個函式</li><li>函式就是物件，所以也可以擁有屬性 (property)</li></ul><p>一級函式可以讓我們用完全不同的方法解決問題，所以當我們說「函式就是物件」，那麼函式物件是什麼東西呢？</p><h2 id="函式物件-Functions-Object"><a href="#函式物件-Functions-Object" class="headerlink" title="函式物件 ( Functions Object )"></a>函式物件 ( Functions Object )</h2><p>就像 JavaScript 內的其他物件般被存放在記憶體，這是個特殊形態的物件，<strong>函式物件具有所有物件的特色</strong>，此外還有一些其他屬性：</p><ul><li>可以連結到純值 (Primitive)</li><li>可以連結到物件 (Object)</li><li>可以連結其他函式 (Function)</li><li>特殊屬性 - 「名稱」，JavaScript 的函式物件可以是匿名的</li><li>特殊屬性 - 「 程式屬性」，意思就是被包覆在函式內的程式碼，簡單來說，我們寫的程式會成為函式物件的特殊屬性。</li></ul><p>程式屬性特別的是，這是可以被呼叫 (invocable) 的，代表可以執行這個函式的程式。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*XgeV_vdbYJvYbeSgc8F9xQ.png" alt></p><h2 id="實際例子"><a href="#實際例子" class="headerlink" title="實際例子"></a>實際例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;  </span><br><span class="line">  console.log(&apos;Hi&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHi.languaue = &apos;english&apos;;  </span><br><span class="line">console.log(sayHi);</span><br></pre></td></tr></table></figure><p>像這樣，我新增了一個函式的屬性，就像前面介紹物件的文章一樣，運用點運算子為物件添加屬性，接著將輸出看結果。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*IYYDILBjUXvMdpKcQPNMyg.png" alt></p><p>如果直接這樣寫，會得到函式的文字內容，在這個範例中這樣子沒什麼用。所以必須使用點運算子取得函式物件的屬性，就像之前在一般物件做的那樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(sayHi.languaue);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*IlgWJWGJ4r9X5QAKTMsOLQ.png" alt></p><p>所以當我建立了這個函式，實際上它看起來像這樣：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*_oWjzP1hBWy61jiv0hFpzw.png" alt></p><h3 id="以本例來說"><a href="#以本例來說" class="headerlink" title="以本例來說"></a>以本例來說</h3><ul><li>我建立了名稱為 <code>sayHi</code> 的函式物件</li><li><code>sayHi</code> 的函式物件具有程式屬性，因為我寫了程式碼在裡面</li><li>我可以在 <code>sayHi</code> 後面加上括號 () ，呼叫 <code>sayHi</code> 函式並執行</li></ul><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>這樣的例子說明了，函式只是一種特殊的物件，它除了具有一般物件有的特性外，還有自身的特殊屬性。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      在這節課中，作者說明了一個很重要的觀念，也就是在 JavaScript 中，函式也是物件的一種 (functions are object) 而且也會提到什麼是一級函式 (first class functions)
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.24 JSON 與物件實體</title>
    <link href="http://pvt5r486.github.io/f2e/20190122/2637324639/"/>
    <id>http://pvt5r486.github.io/f2e/20190122/2637324639/</id>
    <published>2019-01-22T00:00:35.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們需要花點時間討論物件實體，解釋常見錯誤，以及一些大家使用 JSON 會遇到的誤解。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*E4xdJ1lk0TB5D9qm" alt></p><h2 id="JSON-JavaScript-Object-Notation"><a href="#JSON-JavaScript-Object-Notation" class="headerlink" title="JSON (JavaScript Object Notation)"></a>JSON (JavaScript Object Notation)</h2><p>它是被 JavaScript 的物件實體語法啟發的，因為這樣所以看起來很像物件實體語法 (Object Litetal Syntax)，也被稱為 JavaScript Object Notation。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var objectLitetal = &#123;  </span><br><span class="line">  firstName: &apos;Willy&apos;,  </span><br><span class="line">  isProgrammer: true  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(objectLitetal);</span><br></pre></td></tr></table></figure><p></p><p>這個例子在 JavaScript 是有效的，我們可以得到 objectLitetal 物件的結果，這很容易，因為我們之前講過了。</p><h3 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  &quot;firstName&quot;: &quot;Willy&quot;,  </span><br><span class="line">  &quot;isProgrammer&quot;: true  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中現在我們大多用 JSON 格式傳送資料，上述的例子只是個資料字，看起來很像物件實體語法，不過還是有一些小差異，例如：</p><ul><li>屬性需要被包在引號裡面</li></ul><p>這麼寫仍然是個有效的物件實體語法，我們可以做個測試<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var objectLitetal = &#123;  </span><br><span class="line">  &quot;firstName&quot;: &quot;Willy&quot;,  </span><br><span class="line">  &quot;isProgrammer&quot;: true  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(objectLitetal);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*7mjg4gJaKUSjNDYXQuFvtQ.png" alt></p><p>於是我們得知：</p><ul><li>在物件實體語法中，屬性可以被包在引號內</li><li>在 JSON 中 屬性「一定」要被包在引號內</li></ul><p>技術上來說，JSON 是物件實體語法的子集合，意思就是只要在 JSON 中視有效的，那麼在物件實體語法中就是有效的。但反過來就不一樣了，不是所有的物件實體語法在 JSON 格式中都是有效的。</p><h3 id="JavaScript-轉換-JSON"><a href="#JavaScript-轉換-JSON" class="headerlink" title="JavaScript 轉換 JSON"></a>JavaScript 轉換 JSON</h3><p>JSON 的規則比較嚴格且 JSON 並不是 JavaScript 的一部分。但是 JSON 很受歡迎，因為它可以很簡單的被 JavaScript 解析。</p><p>JavaScript 有一些內建的函式可以轉換這兩者，意思就是可以讓任何物件變成 JSON 字串，也可以讓任何 JSON 字串變成物件。</p><h3 id="物件變成-JSON-字串"><a href="#物件變成-JSON-字串" class="headerlink" title="物件變成 JSON 字串"></a>物件變成 JSON 字串</h3><p>承接上面的例子，我們可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var objectLitetal = &#123;  </span><br><span class="line">  &quot;firstName&quot;: &quot;Willy&quot;,  </span><br><span class="line">  &quot;isProgrammer&quot;: true  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(JSON.stringify(objectLitetal));</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*EIGaf8BW2MS79yHXW-sUTA.png" alt></p><p>這是 JavaScript 內建的功能「<code>.stringify</code>」，這會把物件轉換為 JSON 字串。</p><h3 id="JSON-字串變成物件"><a href="#JSON-字串變成物件" class="headerlink" title="JSON 字串變成物件"></a>JSON 字串變成物件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var jsonValue = JSON.parse(&apos;&#123; &quot;firstName&quot;: &quot;Willy&quot;, &quot;isProgrammer&quot;: true &#125;&apos;);  </span><br><span class="line">console.log(jsonValue);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*HwOqwXf9X7jEBkJNl0CFhQ.png" alt></p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>本篇會記錄這些只是因為常常搞不清楚物件實體語法和 JSON 字串的差別，這是兩個不同的東西，但 JavaScript 提共了轉換這兩者的功能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們需要花點時間討論物件實體，解釋常見錯誤，以及一些大家使用 JSON 會遇到的誤解。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.23 框架小叮嚀：偽裝命名空間</title>
    <link href="http://pvt5r486.github.io/f2e/20190122/4016229238/"/>
    <id>http://pvt5r486.github.io/f2e/20190122/4016229238/</id>
    <published>2019-01-21T23:06:30.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>來談談另一個框架小叮嚀，更進一步的討論應用所學到框架中，我們可以在知名的框架中常看見這些東西，在前面討的那些主題，像是點運算子、物件實體語法後，本篇要紀錄的是「<strong>偽裝命名空間</strong>」。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*7k8H0iQ4815BKGx9" alt></p><h2 id="命名空間-NAMESPACES"><a href="#命名空間-NAMESPACES" class="headerlink" title="命名空間 (NAMESPACES)"></a>命名空間 (NAMESPACES)</h2><p>在現代的程式語言，命名空間指的是變數和函式的容器，命名空間只是一個包裝物、一個容器，通常這是用來維持變數和函式名稱分開。</p><blockquote><p>但是這裡有個問題，<strong>JavaScript 並沒有命名空間</strong></p></blockquote><h2 id="偽裝命名空間-FAKING-NAMESPACES"><a href="#偽裝命名空間-FAKING-NAMESPACES" class="headerlink" title="偽裝命名空間 ( FAKING NAMESPACES )"></a>偽裝命名空間 ( FAKING NAMESPACES )</h2><p>雖然 JavaScript 沒有命名空間，但是因為物件的本質，我們不需要命名空間這個功能，我們可以透過物件來「假裝」：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var greet = &apos;Hello!&apos;;  </span><br><span class="line">var greet = &apos;Hola!&apos;;  </span><br><span class="line">console.log(greet);　// Hola!</span><br></pre></td></tr></table></figure><p></p><p>非常明顯我們會得到西班牙文的 Hola。</p><p>但我們可以想像這兩個變數其實是被創造在兩支不同的 JavaScript 檔案中，並且在 HTML 中引入，一個是英文的打招呼另一個是西班牙文的打招呼。</p><p>但是現在它們互相覆蓋了，偽裝命名空間可以幫助解決這個問題，因為命名空間可以有個容器裝著英文的問候語而另個容器裝著西班牙的問候語。</p><p>所以我們可以這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var english = &#123;  </span><br><span class="line">  greet: &apos;Hello&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">var spanish = &#123;  </span><br><span class="line">  greet: &apos;Hola&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(english);</span><br></pre></td></tr></table></figure><p></p><p>可以看到雖然 <code>english</code> 物件和 <code>spanish</code> 物件內都有 <code>greet</code> 變數，但它們不會互相衝突、不會互相覆寫，於是我們可以印出來觀察看看。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*lQCqcNH-91txTdIbVunT4w.png" alt></p><p>然後這個 <code>english</code> 變數基本上就成為一個容器，用來確保裝在容器內的東西不會和其他 JavaScript 檔案中因為相同的全域命名空間衝突。</p><p>除了這樣用之外，還有更進階的用法。</p><h3 id="容器物件分級"><a href="#容器物件分級" class="headerlink" title="容器物件分級"></a>容器物件分級</h3><p>接續剛才的例子，像是我想要在 <code>english</code> 內有個打招呼的命名空間在裡面，在裏面有不同的問候語。</p><h3 id="錯誤的示範"><a href="#錯誤的示範" class="headerlink" title="錯誤的示範"></a>錯誤的示範</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var english = &#123;  </span><br><span class="line">  greet: &apos;Hello&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">var spanish = &#123;  </span><br><span class="line">  greet: &apos;Hola&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">english.greetings.greet = &apos;hello&apos;;  </span><br><span class="line">console.log(english);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*AiTrJUAUCiv5JRVyE7vf7g.png" alt></p><p>得到了錯誤，記得運算子的相依性嗎?在此例由於都是點運算子，且相依性為左相依性。</p><p>於 <code>english</code> 內尋找 <code>greetings</code> 屬性時找不到，所以回傳 <code>undefined</code>，而 <code>undefined</code> 根本不是物件，所以不會在裡面找到 greet 。</p><h3 id="正確的示範"><a href="#正確的示範" class="headerlink" title="正確的示範"></a>正確的示範</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">english.greetings = &#123;&#125;;  </span><br><span class="line">english.greetings.greet = &apos;hello&apos;;  </span><br><span class="line">console.log(english);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*vDU15awt6eBSNUlTKCaBeQ.png" alt></p><p>或者我們也可以使用物件實體語法來做，這會簡單很多：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var english = &#123;  </span><br><span class="line">  greetings: &#123;  </span><br><span class="line">    basic : &apos;Hello&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">console.log(english);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*MlXPve6riEmw68b9QuuJRw.png" alt></p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>我們可以用以上任何一種方式來做偽裝命名空間，透過這樣的方式，可以把變數、函式、方法或其他物件放進容器物件裡，這就是 JavaScript 偽裝命名空間。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      來談談另一個框架小叮嚀，更進一步的討論應用所學到框架中，我們可以在知名的框架中常看見這些東西，在前面討的那些主題，像是點運算子、物件實體語法後，本偏要紀錄的是「偽裝命名空間」。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.22 物件與物件實體</title>
    <link href="http://pvt5r486.github.io/f2e/20190122/4087565538/"/>
    <id>http://pvt5r486.github.io/f2e/20190122/4087565538/</id>
    <published>2019-01-21T22:03:36.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們介紹了如何使用「.」運算子取出物件屬性的值，記得一開始的那行程式碼嗎?課程上提到有「更好的方式」建立物件，本篇就是要來介紹那個「更好的方式」。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*X8PCCcqYClvUAw0_" alt></p><h2 id="物件實體語法-Object-Literals"><a href="#物件實體語法-Object-Literals" class="headerlink" title="物件實體語法 (Object Literals)"></a>物件實體語法 (Object Literals)</h2><p>上一篇有一句程式碼是這樣的，這是宣告 new object 來建立物件，但這不是最好的方式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br></pre></td></tr></table></figure><p></p><p>在 JavaScript 中，對於相同的一件事情可以有多種不同的做法來達成，像是我們想要建立一個物件，可以使用 <code>new object</code> 來建立，但針對建立物件這件事情而言，這個作法不是最好的，之後課程會提到 <code>new object</code> 真正的意涵。</p><p>建立物件有個捷徑，它叫做<strong>物件實體語法</strong>，以大括號決定範圍，這就像我們使用 <code>new object</code> 來建立物件一樣。</p><p>特別注意的是 {} 並不是運算子，這是當 JavaScript 在解析語法時，看到大括號而不是作為 if 條件式或迴圈時，就會認定是要創造一個物件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;  </span><br><span class="line">var person2 = new Object();  </span><br><span class="line">console.log(person); // &#123;&#125;  </span><br><span class="line">console.log(person2); // &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>還記得我們在上一篇要新增物件屬性時，必須這樣子寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// person.firstName = &apos;Tony&apos;;</span><br></pre></td></tr></table></figure><p></p><p>但如果使用物件實體語法，我們可以在大括號裡同時建立屬性與方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; firstName: &apos;Tony&apos;, lastName: &apos;Alicea&apos; &#125;;</span><br></pre></td></tr></table></figure><p></p><p>整理一下排版，會得到這樣的結果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Tony&apos;,  </span><br><span class="line">  lastName: &apos;Alicea&apos;  </span><br><span class="line">&#125;;  </span><br><span class="line">console.log(person);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*jQTT5qMpJ4C1bkX_Rqub_Q.png" alt></p><p>是不是覺得似曾相識呢～沒錯，這個方式就如同使用 <code>new object</code> 來建立物件，會得到一樣的結果，但是透過物件實體語法建立的物件會比較清楚易懂。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;  </span><br><span class="line">  firstName: &apos;Tony&apos;,  </span><br><span class="line">  lastName: &apos;Alicea&apos;,  </span><br><span class="line">  address: &#123;  </span><br><span class="line">    street: &apos;111 Main St.&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*lr9_-C_J2sHDeQM0zVnbFA.png" alt></p><blockquote><p>當我們了解物件實體語法是什麼東西後，便可以相當迅速地建立物件，也可以從中衍生出一些用法。</p></blockquote><p>舉個例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Tony = &#123;  </span><br><span class="line">  firstName: &apos;Tony&apos;,  </span><br><span class="line">  lastName: &apos;Alicea&apos;,  </span><br><span class="line">  address: &#123;  </span><br><span class="line">    street: &apos;111 Main St.&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function sayHi(person)&#123;  </span><br><span class="line">  console.log(&apos;Hi &apos; + person.firstName);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi(Tony);　// Hi Tony</span><br></pre></td></tr></table></figure><p></p><p>這個結果如我們預料，我們呼叫 <code>sayHi</code> 函式並將物件當成參數傳入，最後印出結果，但是我們可以同時呼叫函式和建立物件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi(&#123; firstName: &apos;Mary&apos;, lastName: &apos;Alicea&apos; &#125;);</span><br></pre></td></tr></table></figure><p></p><p>或者也可以做換行整理<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi(&#123;   </span><br><span class="line">  firstName: &apos;Mary&apos;,  </span><br><span class="line">  lastName: &apos;Alicea&apos;   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Rsgaicgyi3yaMzHl3IFWUw.png" alt></p><p>JavaScript 可以使用物件實體語法在任何地方建立物件，也可以把這個當作一般變數使用。</p><h3 id="物件實體語法也可以和「-」運算子混合使用"><a href="#物件實體語法也可以和「-」運算子混合使用" class="headerlink" title="物件實體語法也可以和「.」運算子混合使用"></a>物件實體語法也可以和「.」運算子混合使用</h3><p>接續上面的範例，我們可以這樣做<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tony.address2 = &#123;  </span><br><span class="line">  street: &apos;333 Second St.&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(Tony);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*qWB9L7DBAjNy7x_Hc677NA.png" alt></p><h3 id="為什麼可以這麼做"><a href="#為什麼可以這麼做" class="headerlink" title="為什麼可以這麼做?"></a>為什麼可以這麼做?</h3><p>因為我們寫的程式碼並不會真的直接被輸出，而是會透過 JavaScript 變成電腦能懂的東西，不論物件實體語法或是使用「.」運算子建立物件都是一樣的，對於 JavaScript 底層來說，這件事情就是「建立物件、物件屬性和方法到記憶體中並且建立參考」，所以我們用的語法對它們而言沒差，因為都是做同樣的事情，重要的是我們要用什麼語法。</p><p>這就是<strong>物件實體語法，</strong>用大括號定義範圍、用冒號區隔屬性名稱和值<strong>。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇我們介紹了如何使用「.」運算子取出物件屬性的值，記得一開始的那行程式碼嗎?課程上提到有「更好的方式」建立物件，本篇就是要來介紹那個「更好的方式」。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.21 物件與點</title>
    <link href="http://pvt5r486.github.io/f2e/20190122/2878791352/"/>
    <id>http://pvt5r486.github.io/f2e/20190122/2878791352/</id>
    <published>2019-01-21T19:41:02.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>終於進展到一個新的階段：物件與函式，在 JavaScript 中，物件與函式兩者是非常相關的，它們在很多情況下幾乎是一樣的，讓我們從本篇之後來談談物件與函式，但在這之前得先了解本篇標題「物件與點」</p><h2 id="物件與點-OBJECTS-AND-THE-DOT"><a href="#物件與點-OBJECTS-AND-THE-DOT" class="headerlink" title="物件與點 (OBJECTS AND THE DOT)"></a>物件與點 (OBJECTS AND THE DOT)</h2><p>之前說過物件是一群「名稱 / 值」的組合，然而這些值也可以是另一個「名稱 / 值」的組合。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*b53YOzDajxjFbCRzo4-k3w.png" alt></p><h3 id="物件是如何存在電腦記憶體中呢？"><a href="#物件是如何存在電腦記憶體中呢？" class="headerlink" title="物件是如何存在電腦記憶體中呢？"></a>物件是如何存在電腦記憶體中呢？</h3><p>一個物件是一群「名稱 / 值」的組合，但這個「值」可以是什麼?</p><p>物件可以有屬性和方法，屬性可以是「純值」，也可以是另一個「物件」；另外物件內也可以有函式。當函式在物件內時，我們稱之為「<strong>方法 (method)</strong>」</p><p><img src="https://cdn-images-1.medium.com/max/800/1*we3BncVFeIDzD5GGqq8YlA.png" alt></p><p>在記憶體中，核心物件會有一個記憶體的位址，透過這個記憶體的位址，能夠參考到其他位於記憶體中的屬性、方法的位址並找到這些屬性、方法的所在。</p><h2 id="JavaScript-如何取得物件的屬性和方法"><a href="#JavaScript-如何取得物件的屬性和方法" class="headerlink" title="JavaScript 如何取得物件的屬性和方法"></a>JavaScript 如何取得物件的屬性和方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 課程提到有更多更好的方法建立物件  </span><br><span class="line">// 在此用這個方法只是因為好明白  </span><br><span class="line">var person = new Object();  </span><br><span class="line">person[&apos;firstName&apos;] = &apos;Tony&apos;;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中取得物件的屬性和方法有兩種方式，這是其中一種利用中括號「[]」，一個稱為「計算取用成員」的運算子。</p><p>在中括號內放進值的名稱，這是要存在記憶體中的東西。這時它還不存在，所以我們要令它等於 <code>Tony</code>。</p><p>這樣就會正式在記憶體中創造，並且有個名稱叫做 <code>firstname</code> 的東西。然後 <code>person</code> 物件就能夠參考到 <code>firstname</code> 在記憶體內的位址，並且知道 <code>firstname</code> 的值是一個字串，這就是物件的「屬性」。</p><p>這個方式好用的一點是，可以利用變數修改物件的屬性名稱，像是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();  </span><br><span class="line">person[&apos;firstName&apos;] = &apos;Tony&apos;;  </span><br><span class="line">person[&apos;lastName&apos;] = &apos;Alicea&apos;;  </span><br><span class="line">var firstNameProperty = &apos;firstName&apos;;  </span><br><span class="line">console.log(person[firstNameProperty]);  </span><br><span class="line">// Tony</span><br></pre></td></tr></table></figure><p></p><p>但除非有需求，不然還是使用「.」運算子會比較方便。</p><p>另外我們也可以印出物件看看目前長怎樣：<br><img src="https://cdn-images-1.medium.com/max/800/1*5I5u9KxPZArSjfd-wsEZpQ.png" alt></p><h3 id="利用點「-」運算子的方式"><a href="#利用點「-」運算子的方式" class="headerlink" title="利用點「.」運算子的方式"></a>利用點「.」運算子的方式</h3><p>這個方式用起來會比較清楚且常見，使用方法也很簡單：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person.firstName);  </span><br><span class="line">// Tony</span><br></pre></td></tr></table></figure><p></p><p>創立物件的新屬性名稱也可以運用「.」運算子完成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.dog = &apos;John&apos;;  </span><br><span class="line">console.log(person.dog);</span><br></pre></td></tr></table></figure><p></p><p>簡單來說這個點就和中括號一樣，是「成員取用」運算子，這個成員指的是物件的成員。所以這些運算子會幫我們找到物件的成員，像是方法和屬性。</p><h3 id="物件內的物件"><a href="#物件內的物件" class="headerlink" title="物件內的物件"></a>物件內的物件</h3><p>前面提到物件內也可以有另一個物件，我們用「.」運算子來做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//完整程式碼  </span><br><span class="line">var person = new Object();  </span><br><span class="line">person[&apos;firstName&apos;] = &apos;Tony&apos;;  </span><br><span class="line">person[&apos;lastName&apos;] = &apos;Alicea&apos;;  </span><br><span class="line">var firstNameProperty = &apos;firstName&apos;;  </span><br><span class="line">console.log(person);  </span><br><span class="line">console.log(person[firstNameProperty]);  </span><br><span class="line">console.log(person.firstName);  </span><br><span class="line">person.dog = &apos;John&apos;  </span><br><span class="line">console.log(person.dog);  </span><br><span class="line">person.address = new Object();  </span><br><span class="line">person.address.street = &apos;111 Main St.&apos;;  </span><br><span class="line">console.log(person);  </span><br><span class="line">console.log(person.address.street);  </span><br><span class="line">// 也可以這樣寫 console.log(person[&apos;address&apos;][&apos;street&apos;]);</span><br></pre></td></tr></table></figure><p></p><p>我們可以再次印出 <code>person</code> 物件觀察，便可發現新增的物件被包覆在 <code>person</code> 物件內了。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*icdHCkzWebOdJ1C2TXsSnQ.png" alt></p><p>另外程式碼中的「<code>person.address.street= ‘111 Main St.’;</code>」因為用到了兩次運算子，所以我們查一下運算子的優先性與相依性得知，「.」運算子為左相依性，因此會從左邊開始運算到右邊。</p><p>白話來說就是會先到 <code>person</code> 物件內找到屬性物件 <code>address</code> ， 然後再從 <code>address</code> 內找到 <code>street</code> 屬性並且設定字串值。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>物件在記憶體中是「名稱 / 值」的組合，可以包含另一個物件，也可以包含純值像是字串、布林、數值，也可以包含函式( 在此稱為「方法」)，但本篇還不會討論到「方法」，因為還有一些概念要先了解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      終於進展到一個新的階段：物件與函式，在 JavaScript 中，物件與函式兩者是非常相關的，它們在很多情況下幾乎是一樣的，讓我們從本篇之後來談談物件與函式，但在這之前得先了解本篇標題「物件與點」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.20 框架小叮嚀：預設值</title>
    <link href="http://pvt5r486.github.io/f2e/20190121/2107328648/"/>
    <id>http://pvt5r486.github.io/f2e/20190121/2107328648/</id>
    <published>2019-01-21T00:51:51.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章主要紀錄關於我們學過的東西如何應用在受歡迎的框架中，後續的課程中會不斷地做這件事。雖然框架和資源庫有不同的意義，但我們在這裡會當成是同一個東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*uzo434P3NvZWpxLC" alt></p><h2 id="預設值-Default-Values"><a href="#預設值-Default-Values" class="headerlink" title="預設值 (Default Values)"></a>預設值 (Default Values)</h2><p>我們可以結合一些之前學到的東西像是預設值、執行環境、全域環境等等，了解一些常出現在知名框架中的程式碼。</p><p>首先，來進行一些準備工作：</p><ul><li>在 index.html 中引入 lib1, lib2 這兩支 js 檔案</li><li>分別在 lib1, lib2 設定一組同樣的變數</li></ul><p>如果都做好了，會像這樣</p><p><img src="https://cdn-images-1.medium.com/max/800/1*3PBq4aAiacPAC4oTQtZXiA.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*HERRtwbHyMFj-hQAaXKkyQ.png" alt><br><img src="https://cdn-images-1.medium.com/max/800/1*guETIOjImba1BVLAfI9LKQ.png" alt></p><p>然後我們再 all.js 內執行「<code>console.log(libraryName);</code>」<br>結果會相當令人驚訝，因為結果是「Lib 2」</p><p>這是因為在在 HTML 內引入 .jS 檔時，並不會幫這三隻檔案建立獨立的執行環境，執行環境仍然只有一個，這麼做只是把程式碼分開，更直接地說，它們其實長得像這個樣子 (按照 HTML 內的引入順序)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var libraryName = &apos;Lib 1&apos;;  </span><br><span class="line">var libraryName = &apos;Lib 2&apos;;  </span><br><span class="line">console.log(libraryName);</span><br></pre></td></tr></table></figure><p></p><p>配合我們之前學到的觀念， <code>libraryName</code> 自然是會輸出 Lib 2 。</p><blockquote><p>現在我們知道了這三隻檔案最終會合併成一個檔案，那麼如何使這三隻檔案不互相衝突是相當重要的。</p></blockquote><p>如果我們不希望全域變數 <code>libraryName</code> 的值被後來的值影響，可以這麼寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// lib2.js 內  </span><br><span class="line">window.libraryName = window.libraryName || &apos;Lib 2&apos;;</span><br></pre></td></tr></table></figure><p></p><p>如果 <code>window.libraryName</code> 有值，那麼就不做其他事情，反之如果沒有值，就賦予 Lib 2 字串。</p><p>這樣子的做法就是在檢查全域命名空間 (Global Namespace) 或全域物件，看是否已經有東西用了那個名稱了，透過這個方法就不會造成衝突或是覆蓋。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這篇文章主要紀錄關於我們學過的東西如何應用在受歡迎的框架中，後續的課程中會不斷地做這件事。雖然框架和資源庫有不同的意義，但我們在這裡會當成是同一個東西。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.19 預設值</title>
    <link href="http://pvt5r486.github.io/f2e/20190121/3570584245/"/>
    <id>http://pvt5r486.github.io/f2e/20190121/3570584245/</id>
    <published>2019-01-20T23:32:47.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回顧一下運算子的強制型轉，我們可以從另一個角度來利用這些特性。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*I249DBQeLpCDtGDF" alt></p><h2 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h2><p>用例子來觀察：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure><p></p><p>透過之前的觀念，我們可以預期如果呼叫函式時，帶 / 不帶參數會出現什麼結果。</p><p>但是雖然程式沒有出錯，但是不帶參數時卻跑出 <code>undefined</code> 還是很奇怪的，如果想要避免這樣的情形該怎麼做呢？</p><p>以本例來說，可以給 <code>name</code> 一個預設值</p><p><strong>以目前來說有兩個做法，先講之前的做法：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name) &#123;  </span><br><span class="line">  name = name || &apos;&lt;我希望的預設值&gt;&apos;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure><p></p><p>這就是一個運算子的強制型轉的應用，我們現在的印象停留在「運算子只是會回傳值的函式」，所以這個「<code>||</code>」會回傳什麼，我們觀察看看!</p><p><img src="https://cdn-images-1.medium.com/max/800/1*QYjg026CLWtVPrMPwYyDyg.png" alt></p><p>「<code>||</code>」不單只是回傳 <code>true</code> 或 <code>false</code> ，在「<code>undefined || &#39;hello&#39;</code>」中回傳字串 hello，<strong>這是因為「||」會回傳可以被強制型轉為「true」的值</strong>，讓我們繼續觀察：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*GhF2-j3XSszUV-YA_S8ZBQ.png" alt></p><p>而「<code>||</code>」還有一個特性就是，<strong>當兩個值都可以被強制型轉為「<code>true</code>」的時候，僅會回傳第一個。</strong></p><h3 id="讓我們重新整理一下「-」特性"><a href="#讓我們重新整理一下「-」特性" class="headerlink" title="讓我們重新整理一下「||」特性"></a>讓我們重新整理一下「<code>||</code>」特性</h3><ul><li>「<code>||</code>」會回傳可以被強制型轉為「<code>true</code>」的值</li><li>當兩個值都可以被強制型轉為「<code>true</code>」的時候，僅會回傳第一個值</li></ul><blockquote><p><strong>這就是「||」運算子的特殊行為</strong></p></blockquote><h3 id="讓我們重新把注意力拉回到這個例子"><a href="#讓我們重新把注意力拉回到這個例子" class="headerlink" title="讓我們重新把注意力拉回到這個例子"></a>讓我們重新把注意力拉回到這個例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name) &#123;  </span><br><span class="line">  name = name || &apos;&lt;我希望的預設值&gt;&apos;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHello(&apos;阿軒&apos;);  </span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*pQwemxct8B1jW9KrSOxbtg.png" alt></p><p>以這個例子來說，當我呼叫這個函式不帶入參數時，因為 <code>name</code> 此時是 <code>undefined</code> ，進行「||」運算後回傳預設字串。</p><p>但當我帶入參數呼叫函式時， <code>name</code> 此時並非 <code>undefined</code> 所以進行「<code>||</code>」運算後回傳第一個可以被強制型轉為「<code>true</code>」的值。</p><p>最後因為「<code>=</code>」優先性低於「<code>||</code>」，所以「<code>||</code>」回傳值後，「<code>=</code>」才將值回傳給變數 <code>name</code> 。</p><p>透過利用運算子的強制型轉特性，比起使用 if 陳述式設定預設值，我們可以讓程式碼變得更精簡易讀。</p><h3 id="然而特別要注意的是，這邊仍然要注意數值-0，"><a href="#然而特別要注意的是，這邊仍然要注意數值-0，" class="headerlink" title="然而特別要注意的是，這邊仍然要注意數值 0，"></a>然而特別要注意的是，這邊仍然要注意數值 0，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name) &#123;  </span><br><span class="line">  name = name || &apos;&lt;我希望的預設值&gt;&apos;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHello(0);</span><br></pre></td></tr></table></figure><p>如果我們帶入數值 0，得到的結果會有問題，因為數值 0 會被轉換為 <code>false</code> ，此時的「||」會回傳預設字串，然而這是特例就是了～</p><p>在大多數的時候，這樣子寫還是很好用的。</p><h3 id="記得我說有兩個作法嗎？這邊介紹-ES6-新增的作法"><a href="#記得我說有兩個作法嗎？這邊介紹-ES6-新增的作法" class="headerlink" title="記得我說有兩個作法嗎？這邊介紹 ES6 新增的作法"></a>記得我說有兩個作法嗎？這邊介紹 ES6 新增的作法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name = &apos;我希望的預設值&apos;) &#123;  </span><br><span class="line">  console.log(&apos;Hello &apos; + name);  </span><br><span class="line">&#125;  </span><br><span class="line">sayHello();  </span><br><span class="line">sayHello(&apos;宇軒&apos;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*k7-0bh0CpYzV2lpSx2GIDw.png" alt></p><p>用這個作法就不用擔心數值 0 的特例了，是不是很方便呢！</p><ul><li><a href="https://pjchender.blogspot.com/2017/01/es6-default-value.html" rel="external nofollow noopener noreferrer" target="_blank">課外閱讀：關於 ES6 參數預設值的相關文章</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="external nofollow noopener noreferrer" target="_blank">課外閱讀：MDN 上的介紹</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      回顧一下運算子的強制型轉，我們可以從另一個角度來利用這些特性。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.18 存在與布林</title>
    <link href="http://pvt5r486.github.io/f2e/20190121/2901990494/"/>
    <id>http://pvt5r486.github.io/f2e/20190121/2901990494/</id>
    <published>2019-01-20T22:10:48.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們了解 JavaScript 是動態型別以及具有強制型轉的特性，也知道強制型轉的缺點，所以我們也必須了解其優點，關於存在 (Exeistence) 與布林 Boolean)</p><p><img src="https://cdn-images-1.medium.com/max/800/0*F60RwRDoOJEpRRyN" alt></p><h2 id="使用-Boolean-內建函式觀察轉換結果"><a href="#使用-Boolean-內建函式觀察轉換結果" class="headerlink" title="使用 Boolean() 內建函式觀察轉換結果"></a>使用 Boolean() 內建函式觀察轉換結果</h2><p>同於 <code>Number()</code> 可以進行強制轉型為數值型別，<code>Boolean()</code> 則是轉為布林型別。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Boolean(undefined)); // false  </span><br><span class="line">console.log(Boolean(null)); // false  </span><br><span class="line">console.log(Boolean(&apos;&apos;)); // false</span><br></pre></td></tr></table></figure><p></p><p>透過例子我們可以理解， JavaScript 會把 <code>undefined</code>、 <code>null</code>、空字串強制型轉為布林後的值為 <code>false</code>。</p><p>那麼該如何利用這個特性?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">// 取得一些值給 a  </span><br><span class="line">if (a) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果我們把變數 <code>a</code> 放到 if 陳述句內，則 <code>a</code> 會被轉換成布林值。還記得變數在執行環境的創造階段會發生什麼事嗎?變數會被賦予預設值 <code>undefined</code> ，所以在強制型轉後布林值為 <code>false</code>，所以這個例子輸出的結果是什麼都沒有。</p><p>我們回過來看一開始的例子，當 <code>a</code> 的值是 <code>undefined</code> 、 <code>null</code> 、空字串時，這個 if 陳述句會不成立，因為 <code>a</code> 是不存在的、是 <code>false</code> 的。</p><p>如果我們給 <code>a</code> 其他值<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">// 取得一些值給 a  </span><br><span class="line">a = &apos;hi&apos;;  </span><br><span class="line">if (a) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);   </span><br><span class="line">&#125;  </span><br><span class="line">// show something</span><br></pre></td></tr></table></figure><p></p><p>這時會因為 <code>a</code> 不是空字串，所以是存在的，輸出結果就如同我們預期。</p><blockquote><p><strong>換言之，我們可以利用強制型轉來檢查變數有沒有值</strong></p></blockquote><p>然而，有個危險的地方要特別注意：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Boolean(0)); // false</span><br></pre></td></tr></table></figure><p></p><p>數字 0 轉換成布林值也是 <code>false</code> ，我們再將這個狀況帶入剛剛的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">// 取得一些值給 a  </span><br><span class="line">a = 0;  </span><br><span class="line">if (a) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果最後變數的值為數值 0 ，那麼這個 if 陳述句就有問題，並不如我們預期了，因為 0 並不是不存在，但 <code>a</code> 卻被強制轉型為 <code>false</code> ，因此我們需要稍作修改，可以運用「運算子的優先性」。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">// 取得一些值給 a  </span><br><span class="line">a = 0;  </span><br><span class="line">if (a || a === 0) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以透過優先性與相依性表格得知，「===」的優先性高於「||」，所以「===」會優先執行，以這個例子來說會得到 <code>true</code> 的結果。</p><p>整理一下，目前情況是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (false || true) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>讀作「如果 false 或 true 」的話，回傳 <code>true</code>，在這個函式中其中一個值是 <code>true</code> 或都是 <code>true</code> 的話，就會回傳 <code>true</code> 。</p><p>最終成為這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;  </span><br><span class="line">  console.log(&apos;show something&apos;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>印出「show something」</p><p>不過如果我們可以確保變數不是數值 0 的話，只需要寫 if (a) 看看存不存在就可以了。如果我們能夠確實地掌握這些觀念，就不會常常因為 if 陳述式跑出非預期的結果而感到困惑了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們了解 JavaScript 是動態型別以及具有強制型轉的特性，也知道強制型轉的缺點，所以我們也必須了解其優點，關於存在 (Exeistence) 與布林 (Boolean)
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.17 比較運算子</title>
    <link href="http://pvt5r486.github.io/f2e/20190121/1972610701/"/>
    <id>http://pvt5r486.github.io/f2e/20190121/1972610701/</id>
    <published>2019-01-20T21:16:19.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>來談談 JavaScript 的比較運算子，之前我們紀錄的所有東西，單獨來看可能不知道可以被實際運用在哪裡，直到把運算子的「<strong>優先性</strong>」、「<strong>相依性</strong>」、「<strong>強制型轉</strong>」這三種東西兜再一起，這就是本篇文章要記錄的東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*WGNMPNX55xHYv8FU" alt></p><h2 id="優先性、相依性、強制型轉"><a href="#優先性、相依性、強制型轉" class="headerlink" title="優先性、相依性、強制型轉"></a>優先性、相依性、強制型轉</h2><p>當我們把「<strong>優先性</strong>」、「<strong>相依性</strong>」、「<strong>強制型轉</strong>」這三種東西兜再一起時，就會發生一些 JavaScript 看似奇怪，但實際上非常合理的事情，但是不用擔心，因為這些東西我們都學過了。</p><p>直接看例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 &lt; 2 &lt; 3);　// true</span><br></pre></td></tr></table></figure><p></p><p>合理嗎?</p><p>常識判斷「 1 小於 2 小於 3 」，正確！</p><p>那如果是這樣呢?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 &lt; 2 &lt; 1); // true</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*yedGurmiEKmyEqrLs90qvA.jpeg" alt></p><p>看到這，是不是會懷疑是不是有BUG?<br>為什麼「<strong>3 小於 2 小於 1</strong>」是正確的?</p><h2 id="讓我們用科學的方式來解釋它"><a href="#讓我們用科學的方式來解釋它" class="headerlink" title="讓我們用科學的方式來解釋它"></a>讓我們用科學的方式來解釋它</h2><p>記得「<strong>運算子的優先性</strong>」與「<strong>運算子的相依性</strong>」嗎?</p><p>讓我們查一下<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="external nofollow noopener noreferrer" target="_blank">表格</a></p><p>在這個例子中，有兩個「&lt;」代表優先性是一樣的，而「&lt;」的相依性為「<strong>左相依</strong>」，代表最左邊的會先執行。</p><p>於是，實際過程中是這樣的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//實際上會先執行以下判斷  </span><br><span class="line">(3 &lt; 2) // false</span><br></pre></td></tr></table></figure><p></p><p>3 並不小於 2 因此回傳了 <code>false</code> ，接著原先的例子就會變成這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(false &lt; 1); // true</span><br></pre></td></tr></table></figure><p></p><p>接著我們可能會感到更奇怪了，布林 false 如何與數值 1 比較?</p><p>這並不是預期中的型別，但仍然可以進行比較，這是因為 JavaScript 中的「<strong>強制型轉</strong>」。</p><blockquote><p>「強制型轉」把布林 <code>false</code> 轉換成了什麼數值?</p></blockquote><p>可以運用以下方法觀察<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(false); // 0</span><br></pre></td></tr></table></figure><p></p><p>看到了嗎，JavaScript 把 <code>false</code> 強制轉型成為數值 0 ，讓比較繼續進行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &lt; 1); // true</span><br></pre></td></tr></table></figure><p></p><p>因此最後輸出的結果才會是「<code>true</code>」</p><blockquote><p>懶人包：因為函式運算子執行的<strong>順序</strong>以及值的<strong>強制型轉</strong>影響</p></blockquote><p>當然，也可以回頭想想文章一開始提到的例子，雖然結果與我們所想的相同，但實際上底層的運作跟我們想的並不一樣哦～</p><h2 id="「強制型轉」的缺點"><a href="#「強制型轉」的缺點" class="headerlink" title="「強制型轉」的缺點"></a><strong>「強制型轉」的缺點</strong></h2><p>強制型轉雖然很便利，但上面的例子可以看出也有缺點，不是每個強制轉型後的情況都是可以預期的，我們先用剛剛的觀察方法觀察一些強制型轉後的變化。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;3&apos;); // 3  </span><br><span class="line">Number(false); // 0  </span><br><span class="line">Number(undefined); // NaN  </span><br><span class="line">Number(null); // 0</span><br></pre></td></tr></table></figure><p></p><h3 id="NaN-Not-a-Number"><a href="#NaN-Not-a-Number" class="headerlink" title="NaN (Not a Number)"></a>NaN (Not a Number)</h3><p>表示不是數字 ，NaN 代表有個東西想轉換成數值型別，但它不是數值，所以無法轉換。以本例來說 <strong>undefined 不能轉成數值</strong>。</p><p>但是，null 經過強制型轉後得到的答案是 0 ? 有符合我們的預期嗎?</p><p>我們可以透過觀察得知，並不是每次轉型結果都很明顯，這會導致相當多難以預期的 BUG。</p><blockquote><p>強制轉型雖然很便利，但同時也很危險。</p></blockquote><p>既然這樣不使用不就好了? 或者先檢查兩個東西是否相等?</p><p>的確可以這樣做，讓我們看看 <strong>JavaScript 運算子優先性表格。</strong></p><h3 id="使用「-」進行比較"><a href="#使用「-」進行比較" class="headerlink" title="使用「==」進行比較"></a>使用「==」進行比較</h3><p>好的，我們找到了程式語言相當常見的雙等號「==」，代表「<strong>檢查兩個東西是否相等</strong>」，讓我們直接來點例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 == 3); // true  </span><br><span class="line">console.log(&apos;3&apos; == 3); // true  </span><br><span class="line">console.log(false == 0); // true  </span><br><span class="line">console.log(null == 0); // false</span><br></pre></td></tr></table></figure><p></p><p>在我們知道強制轉型的概念後，大部分的例子都可以了解為什麼，但是我們剛剛不是才觀察過 <code>null</code> 可以被強制轉型成數值 0 嗎，怎麼在這邊是 <code>false</code> 呢?</p><p>有很多特殊情況並不如我們所想的那樣，來個延伸例子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(null &lt; 1); // true</span><br></pre></td></tr></table></figure><p></p><p>雖然 <code>null</code> 會轉型為 0 ，但在某種情況下，像是在「<strong>比較</strong>」的時候並不會轉型為 0，困惑嗎?</p><p>沒錯，這造成了很多疑惑和問題。</p><p>然而我們也透過上述其他例子得知，使用「==」進行比較時，會進行強制型轉。也因為強制型轉的關係，會使得結果可能不如我們預期。這其實也被視為這個語言的缺點。</p><blockquote><p><strong>是不是開始覺得混亂了。 我也是，幸好這問題有解！</strong></p></blockquote><h3 id="使用「-」進行嚴格比較"><a href="#使用「-」進行嚴格比較" class="headerlink" title="使用「===」進行嚴格比較"></a>使用「===」進行嚴格比較</h3><p>用三個等號比較兩個東西，就不會進行強制型轉。</p><p>使用三等號驗證剛剛使用雙等號比較的例子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 === 3); // true  </span><br><span class="line">console.log(&apos;3&apos; === 3); // false  </span><br><span class="line">console.log(false === 0); // false  </span><br><span class="line">console.log(null === 0); // false</span><br></pre></td></tr></table></figure><p></p><p>如果兩個值不是同個型別，就會回傳 <code>false</code>。此時的 JavaScript 不會進行強制型轉。</p><blockquote><p><strong>使用三等號來比較值的話，可以避免ㄧ些奇怪的潛在錯誤。在絕大多數 99.9% 的情形，我們都應該使用三個等號來比較相等性，除非你是「故意」要使用雙等號。</strong></p></blockquote><p>然而還有很多關於雙等號、三等號的<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Equality_comparisons_and_sameness" rel="external nofollow noopener noreferrer" target="_blank"><strong>比較</strong></a>，可以到這裡來查看。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      來談談 JavaScript 的比較運算子，之前我們紀錄的所有東西，單獨來看可能不知道可以被實際運用在哪裡，直到把運算子的「優先性」、「相依性」、「強制型轉」這三種東西兜再一起，這就是本篇文章要記錄的東西。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.16 強制型轉</title>
    <link href="http://pvt5r486.github.io/f2e/20190120/2195525748/"/>
    <id>http://pvt5r486.github.io/f2e/20190120/2195525748/</id>
    <published>2019-01-19T21:38:20.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們提到 JavaScript 宣告變數時不需要指定型別，因為 JavaScript 是動態型別語言，這篇文章要記錄的觀念是「<strong>強制型轉 (coercion)</strong>」</p><p><img src="https://cdn-images-1.medium.com/max/800/0*oILDmkCph16nWXlT" alt></p><h2 id="強制型轉-coercion"><a href="#強制型轉-coercion" class="headerlink" title="強制型轉 (coercion)"></a>強制型轉 (coercion)</h2><p>強制型轉的意思就如同字面上解釋，強制轉換一個值的型別。<br>舉例來說：有個數值型別，然後要轉換成字串型別，這在 JavaScript 是很容易發生的，因為動態型別的關係。<br>例一：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 2;  </span><br><span class="line">console.log(a); // 3  </span><br><span class="line">console.log(typeof(a)); // Number</span><br></pre></td></tr></table></figure><p></p><p>例二：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;1&apos; + &apos;2&apos;;  </span><br><span class="line">console.log(a); // 12  </span><br><span class="line">console.log(typeof(a)); // String</span><br></pre></td></tr></table></figure><p></p><p>這兩個例子都用到了先前提到的運算子「+」，這是一個函式，處理後回傳了一個值。像是例一，我們傳入了兩個數字給加號運算子，它便進行加法的運算 ; 例二則是傳入字串 1 以及 字串 2 ，回傳了字串 12，兩個字串被連接了。</p><h3 id="如果傳入一個字串跟一個數字呢"><a href="#如果傳入一個字串跟一個數字呢" class="headerlink" title="如果傳入一個字串跟一個數字呢?"></a>如果傳入一個字串跟一個數字呢?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;1&apos; + 2;  </span><br><span class="line">console.log(a); // 12  </span><br><span class="line">console.log(typeof(a)); // String</span><br></pre></td></tr></table></figure><p>前面提到， JavaScript 是動態型別的程式語言。注意我們並沒有輸入任何程式碼進行轉型，一般而言，字串和數字是無法直接相加的。但我們第一個傳入的參數卻被 JavaScript 強制型轉成字串，而不是得到一個 Error 。</p><p>JavaScript 在處理這一段的時候，有個規則，當「數值」與「字串」做相加時，數值的部分會被強制型轉成為字串，以本例來說輸出結果為字串 12 。</p><p>另外如果是這樣寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;&apos; + 2;  </span><br><span class="line">console.log(a); // 2  </span><br><span class="line">console.log(typeof(a)); // String</span><br></pre></td></tr></table></figure><p></p><p>雖然字串內沒有寫任何東西，出來的結果也是預期的 2 ，但實際上這邊的 2 是字串 2 ，如果繼續與其他數值計算可能發生預期之外的結果，因此了解強制型轉的概念是相當重要的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們提到 JavaScript 宣告變數時不需要指定型別，因為 JavaScript 是動態型別語言，這篇文章要記錄的觀念是「強制型轉 (coercion)」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.15 運算子的相依性與優先性</title>
    <link href="http://pvt5r486.github.io/f2e/20190120/945735864/"/>
    <id>http://pvt5r486.github.io/f2e/20190120/945735864/</id>
    <published>2019-01-19T20:38:20.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們大概了解了什麼是運算子，這節要來討論運算子的相依性與優先性這兩個非常重要的名詞。它們看起來很複雜，但其實並不。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*CVoLwEz7HP-qJqQn" alt></p><h2 id="運算子優先性-Operator-Precedence"><a href="#運算子優先性-Operator-Precedence" class="headerlink" title="運算子優先性 ( Operator Precedence )"></a>運算子優先性 ( Operator Precedence )</h2><p>運算子優先性表示「<strong>哪個運算子優先被運算</strong>」，是 JavaScript 用來判斷當同一行程式碼有不只一個運算子時，決定優先權的方式。具有高優先性的運算子會先計算依序執行到低優先性的運算子。</p><h2 id="運算子相依性-Operator-Associativity"><a href="#運算子相依性-Operator-Associativity" class="headerlink" title="運算子相依性 ( Operator Associativity )"></a>運算子相依性 ( Operator Associativity )</h2><p>運算子相依性表示「<strong>運算子被計算的順序</strong>」，有分成從左到右的「<strong>左相依性</strong>」或是右到左的「<strong>右相依性</strong>」。</p><blockquote><p><strong>這代表當多個運算子有相同優先性時，會按照怎麼樣的順序被計算</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 3 + 4 * 5;  </span><br><span class="line">console.log(a); // 23</span><br></pre></td></tr></table></figure><p></p></blockquote><p>我們來解釋一下為什麼答案會是 23 。</p><p>以數學的四則運算來看，先「乘除」後「加減」有「括號先算」，JavaScript 同樣也有規則，這個例子因為有三個運算子，所以需要呼叫三個函式，但是 JavaScript 並不會同時計算它們。也就是說，這三個函式會按照優先權決定誰先被呼叫。</p><p>MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="external nofollow noopener noreferrer" target="_blank">運算子優先性網頁</a></p><p>透過查詢，我們可以得知以下：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*0l2RXAYBfvyLx6tF-Mrczw.png" alt></p><p>第一欄是運算子的優先性，數字越高代表有越高的優先權。<br>第三欄是運算子的相依性，決定當優先權相同時該如何運算的順序。</p><p>從這表格得知，「*」優先性為 14，「+」優先性為 13 ，因此「*」函式會優先被 JavaScript 呼叫，接著才是「+」。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 3 + 4 * 5;  </span><br><span class="line">console.log(a); // 23</span><br></pre></td></tr></table></figure><p></p><p>計算的順序為 4 * 5 計算後回傳 20 ， 然後 3 + 20 回傳 23 再將值設定給 <code>a</code> 。</p><p>如果完全不按照優先性，計算上會產生相當大的變化，因此優先性很重要。</p><h3 id="來個相依性的例子："><a href="#來個相依性的例子：" class="headerlink" title="來個相依性的例子："></a>來個相依性的例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 2, b = 3, c = 4  </span><br><span class="line">a = b = c;  </span><br><span class="line">console.log(a); //4  </span><br><span class="line">console.log(b); //4  </span><br><span class="line">console.log(c); //4</span><br></pre></td></tr></table></figure><p>優先性我們已經知道了，「=」的優先性為 3，這個例子來說，運算子的優先性都是一樣的，那麼接著看相依性，「=」為「右相依」 (right-to-left)，是用來傳入值的運算子。</p><p>也就是它會先呼叫這邊的「=」運算子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure><p></p><p>這會讓 <code>b</code> 的值等於 <code>c</code> ，而 <code>c</code> 的值為 4 ，因此「=」函式回傳 4 給 <code>b</code> 。<br>同理，接著執行另一個「=」函式運算<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure><p></p><p>受到上一個「=」函式影響此時的 <code>b</code> 為 4 ，因此這次的「=」函式將回傳 4 給 <code>a</code> 。</p><p>還記得文中有提到數學有「括號先算」的例子嗎？</p><blockquote><p><strong>在 JavaScript 中也是有的，可以查到「括號」的優先性是 20 ，它的作用是區分出一個群組，將被包覆住的東西永遠優先被計算。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = (3 + 4) * 5;  </span><br><span class="line">console.log(a); // 35</span><br></pre></td></tr></table></figure><p></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇我們大概了解了什麼是運算子，這節要來討論運算子的相依性與優先性這兩個非常重要的名詞。它們看起來很複雜，但其實並不。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.14 運算子</title>
    <link href="http://pvt5r486.github.io/f2e/20190120/3157345522/"/>
    <id>http://pvt5r486.github.io/f2e/20190120/3157345522/</id>
    <published>2019-01-19T19:07:38.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們已經探討過型別，現在我們深入了解另一個概念「<strong>運算子</strong>」，能幫助我們除錯和了解其它可能會因為動態型別而產生的問題。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*ex12ZAxW38RopzAp" alt></p><h2 id="運算子-Operator"><a href="#運算子-Operator" class="headerlink" title="運算子 (Operator)"></a>運算子 (Operator)</h2><p>運算子是一個特殊的函式 (Function)，不過這和我們自己寫的函式不太一樣。一般而言，運算子都需要兩個參數來回傳一個結果，來個例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 3 + 4;  </span><br><span class="line">console.log(a); // 7</span><br></pre></td></tr></table></figure><p></p><p>這答案很簡單，但 JavaScript 是怎麼處理的呢?</p><p>語法解析器看到「+」號後就會把前後兩個數字加起來，而「+」號就是運算子，「+」是加法運算子，它是一個特殊的函式。就很類似這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function +(a, b) &#123;  </span><br><span class="line">  return //add the two  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果我們要呼叫這個函式，我們可能會寫<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(3, 4);</span><br></pre></td></tr></table></figure><p></p><p>但是這麼做很麻煩，我們必須寫出函式的名稱，而不能直接寫個加號。</p><p>JavaScript 跟很多程式語言一樣，可以使用「<strong>中綴表示法</strong>」表是即可，意思是將函式名稱寫在兩個參數中間，讀起來簡單易懂。</p><p>運算子的本質就是，一個具有兩個參數的函式，而這個函式會回傳一個值。以這個例子來說，就是將這兩個參數相加，然後回傳 7 這個數值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+3 4; //前綴表示法  </span><br><span class="line">3 + 4; //中綴表示法  </span><br><span class="line">3 4+; //後綴表示法</span><br></pre></td></tr></table></figure><p></p><h3 id="比較運算子「-gt-」"><a href="#比較運算子「-gt-」" class="headerlink" title="比較運算子「&gt;」"></a>比較運算子「&gt;」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 4 &gt; 3; // true</span><br></pre></td></tr></table></figure><p>大於是一個函式，「&gt;」符號是ㄧ個運算子，這和上述的例子有點不同，它需要兩個參數，然後回傳布林值。以本例來說，左邊的 4 大於 右邊的 3 ，所以會回傳布林值 true 。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>當我們輸入這些運算子像是「加、減、大於、小於」符號或其他運算子時，它們其實是特殊的函式，這些參數都被傳入這些函式中，處理後回傳一個值。在這些函式中已經寫好了一些預設的程式碼， JavaScript 讓我們利用這些運算子呼叫函式。</p><blockquote><p>現在只要記著，<strong>運算子都是函式</strong>。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們已經探討過型別，現在我們深入了解另一個概念「運算子」，能幫助我們除錯和了解其它可能會因為動態型別而產生的問題。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.13 純值</title>
    <link href="http://pvt5r486.github.io/f2e/20190116/4270157926/"/>
    <id>http://pvt5r486.github.io/f2e/20190116/4270157926/</id>
    <published>2019-01-16T01:20:34.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇提到 JavaScript 是動態型別，會根據我們設定的值自動決定該變數的型別為何， JavaScript 有六種純值(Primitive Types，或稱為基本型別)，讓我們繼續看下去。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*H91ketVDIoGOsIjN" alt></p><h2 id="純值"><a href="#純值" class="headerlink" title="純值"></a>純值</h2><p>純值代表的是一種資料的型別，表示一個值。換句話說這不是一個物件 (名稱 / 值的組合)，而純值也稱為<strong>基本型別</strong>。</p><h3 id="JavaScript-的基本型別-—-undefined"><a href="#JavaScript-的基本型別-—-undefined" class="headerlink" title="JavaScript 的基本型別 — undefined"></a>JavaScript 的基本型別 — undefined</h3><p>在前面的幾篇文章內我們或多或少都有看過它，這是 JavaScript 給所有變數的初始值，這代表這個變數會一直是 undefined 直到給定變數一個值，這也是我們為什麼不應該用 <code>undefined</code> 來設定變數的值，這會很容易讓人混淆「究竟是變數是還未給值或是設定變數為 <code>undefined</code>」</p><h3 id="JavaScript-的基本型別-—-null"><a href="#JavaScript-的基本型別-—-null" class="headerlink" title="JavaScript 的基本型別 — null"></a>JavaScript 的基本型別 — null</h3><p>null 表示不存在，如果我們要用來表示一個變數的值為「不存在或是空值」，使用 null 是比使用 undefined 好的。</p><h3 id="JavaScript-的基本型別-—-Boolean"><a href="#JavaScript-的基本型別-—-Boolean" class="headerlink" title="JavaScript 的基本型別 — Boolean"></a>JavaScript 的基本型別 — Boolean</h3><p>這個有寫過程式的應該都很熟悉，代表這個變數的值是「真」或是「假」的其中一種可能，在 JavaScript 內直接用 true 或 false 表示。</p><h3 id="JavaScript-的基本型別-—-Number"><a href="#JavaScript-的基本型別-—-Number" class="headerlink" title="JavaScript 的基本型別 — Number"></a>JavaScript 的基本型別 — Number</h3><p>在 JavaScript 只有一種數字型態， 所以可以把它想成自動判斷整數或浮點數，不像其他的程式語言，可能有整數型態或者其他特定數值的型態。</p><h3 id="JavaScript-的基本型別-—-String"><a href="#JavaScript-的基本型別-—-String" class="headerlink" title="JavaScript 的基本型別 — String"></a>JavaScript 的基本型別 — String</h3><p>由一連串的字符所組成，在 JavaScript 中用單引號或雙引號包覆住，都可以用來表示字串。</p><h3 id="JavaScript-的基本型別-—-Symbol"><a href="#JavaScript-的基本型別-—-Symbol" class="headerlink" title="JavaScript 的基本型別 — Symbol"></a>JavaScript 的基本型別 — Symbol</h3><p>Symbol 是 ES6 新增的一個基本型別， Symbol 是一種特殊的、不可變、且獨一無二，可以作為對象屬性的標識符使用。</p><blockquote><p>關於 Symbol 的更多敘述，可參考 <a href="https://ithelp.ithome.com.tw/articles/10195993" rel="external nofollow noopener noreferrer" target="_blank"><strong>這裡</strong></a></p></blockquote><p><strong>基本的用法大概是這樣的：</strong></p><ul><li>Symbol 函數可以接受一個字串作為參數</li><li>Symbol 值不能與其他類型的值進行運算</li><li>Symbol 值可轉成完全字串，使用 toString() 方法，若有參數也會一同輸出</li><li>Symbol 值可作為物件中的屬性名，使用中括號[]，<strong>能防止此屬性名(關鍵字)被改寫或覆蓋</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Symbol 字串用法  </span><br><span class="line">let a = Symbol(&apos;name&apos;);  </span><br><span class="line">let b = Symbol(&apos;name&apos;);  </span><br><span class="line">console.log(a === b); //flase</span><br><span class="line"></span><br><span class="line">//可轉成字串  </span><br><span class="line">console.log(a.toString()); //Symbol(name)</span><br><span class="line"></span><br><span class="line">//作為物件的屬性名稱  </span><br><span class="line">let obj = &#123;  </span><br><span class="line">  [a]:&apos;Tony&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(obj); // &#123; Symbol(name): &quot;Tony&quot; &#125;</span><br></pre></td></tr></table></figure><p><strong>進階用法 &amp; 注意事項：</strong></p><p>Symbol 作為屬性名時，該屬性不會出現在 for…in 、 for…of 迴圈迭代中，也不會在 <code>Object.keys()</code> 、 <code>Object.getOwnPropertyNames()</code> 等等之類的方法中被獲取，只有唯一使用 <code>Object.getOwnPropertySymbols()</code> 此方法才能獲取擁有 Symbol 值的屬性名。</p><p>另外 Symbol 不可以使用 “<code>new Symbol()</code>“<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a = Symbol(&apos;name1&apos;);  </span><br><span class="line">let b = Symbol(&apos;name2&apos;);  </span><br><span class="line">const obj = &#123;  </span><br><span class="line">  [a]: &apos;Tony&apos;,  </span><br><span class="line">  [b]: &apos;John&apos;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let key in obj) &#123;  </span><br><span class="line">  console.log(key); // 無輸出  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let propertyNames = Object.getOwnPropertyNames(obj);  </span><br><span class="line">console.log(propertyNames); // []</span><br><span class="line"></span><br><span class="line">let propertySymbols = Object.getOwnPropertySymbols(obj);  </span><br><span class="line">console.log(propertySymbols); // [ Symbol(name1), Symbol(name2) ]</span><br><span class="line"></span><br><span class="line">Symbol.for() &amp; Symbol.keyFor()</span><br></pre></td></tr></table></figure><p></p><ul><li><code>Symbol.for()</code> : 可以重新使用同一個 Symbol 值，若定義時輸入參數一樣，則 Symbol 值會相等。</li><li><code>Symbol.keyFor()</code>：可以取得在使用 <code>Symbol.for()</code> 定義時所輸入的參數值</li></ul><p>可以使用這兩個函式方法重複利用資源<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = Symbol.for(&apos;name&apos;);  </span><br><span class="line">let b = Symbol.for(&apos;name&apos;);  </span><br><span class="line">console.log(a === b); // true  </span><br><span class="line">console.log(Symbol.keyFor(a)); // &apos;name&apos;;  </span><br><span class="line">// 由於 Symbol() 是沒有登記機制的，所以使用 .keyFor() 會無效  </span><br><span class="line">let c = Symbol(&apos;name&apos;);  </span><br><span class="line">console.log(Symbol.keyFor(c)); // undefined</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇提到 JavaScript 是動態型別，會根據我們設定的值自動決定該變數的型別為何， JavaScript 有六種純值(Primitive Types，或稱為基本型別)，讓我們繼續看下去。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.12 型別與 JavaScript</title>
    <link href="http://pvt5r486.github.io/f2e/20190116/1491434029/"/>
    <id>http://pvt5r486.github.io/f2e/20190116/1491434029/</id>
    <published>2019-01-15T22:12:05.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要記錄的是 JavaScript 的一個小觀念「型別」， JavaScript 很特殊，不同於其他程式語言，特別是在變數的資料與型別的部分，JavaScript 處理它們的方式不太一樣。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*Pmd65gwnN80dk0FT" alt></p><h2 id="動態型別-Dynamic-Typing"><a href="#動態型別-Dynamic-Typing" class="headerlink" title="動態型別 (Dynamic Typing)"></a>動態型別 (Dynamic Typing)</h2><p>這是一個描述 JavaScript 處理型別方式的名詞，意思就是不需要告訴 JavaScript 變數是何種型別資料、不必再程式碼內寫出來，JavaScript 會在運行程式時知道。</p><p>也就是說當我們執行程式時，一個變數可以在不同時候有不同型別，因為型別都是程式執行時才知道的，因為 JavaScript 是動態型別的關係，我們不需要關鍵字來宣告變數的型別，像是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isNew = true; //no errors  </span><br><span class="line">isNew = &apos;yes!&apos;;  </span><br><span class="line">isNew = 1;</span><br></pre></td></tr></table></figure><p></p><p>JavaScript 會根據我們設定的值，決定要給這個變數什麼型別。</p><h2 id="靜態型別-Static-Typing"><a href="#靜態型別-Static-Typing" class="headerlink" title="靜態型別 (Static Typing)"></a>靜態型別 (Static Typing)</h2><p>像是其他的程式語言 (C#、Java)，就是使用靜態型別的方式處理，這種方式必須一開始就告訴編輯器，我們的變數是什麼型別，但如果你將其他型別的值放入就會導致錯誤，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isNew = &apos;hello&apos;; //error</span><br></pre></td></tr></table></figure><p></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>初次學習 JavaScript 的時候會覺得這個東西很方便，但是實際上這樣也是很危險的，變成我們必須很明確地知道這個變數目前的型別是什麼，否則最後運算出來可能不會是我們要的結果。這種情況反而會比較喜歡靜態型別，直接把型別決定好，這樣可以避免一些曖昧不明的情況發生，也比較方便除錯。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇要記錄的是 JavaScript 的一個小觀念「型別」， JavaScript 很特殊，不同於其他程式語言，特別是在變數的資料與型別的部分，JavaScript 處理它們的方式不太一樣。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.11 關於非同步回呼</title>
    <link href="http://pvt5r486.github.io/f2e/20190113/1933569774/"/>
    <id>http://pvt5r486.github.io/f2e/20190113/1933569774/</id>
    <published>2019-01-12T21:54:56.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們在 Day 6 的時候有談到 JavaScript 是 單執行緒且同步的，是如何同步執行這些程式碼，那我們也有一些疑問仍然有待釐清，像是「<strong>非同步回呼 ( asynchronus callbacks)</strong>」是什麼意思?</p><p><img src="https://cdn-images-1.medium.com/max/800/0*PacLTUmR4LHHPCko" alt></p><h2 id="非同步回呼-asynchronus-callbacks"><a href="#非同步回呼-asynchronus-callbacks" class="headerlink" title="非同步回呼 (asynchronus callbacks)"></a>非同步回呼 (asynchronus callbacks)</h2><p>非同步表示在「<strong>同個時間點內不只一個</strong>」，可能一段程式在執行時，又開始執行另一段程式碼，然後又執行別的程式碼，這些程式碼在 JavaScript 是同時在執行的。</p><blockquote><p>但我們之前有說過 JavaScript 是「<strong>同步</strong>」的，並不會「<strong>非同步</strong>」的執行，它是怎麼樣處理「<strong>非同步</strong>」事件呢?</p></blockquote><p>首先我們必須知道，瀏覽器內不只有 JavaScript 還有一些其它像是Rendering 、HTTP Request …等等，在 JavaScript 外執行別的程式。JavaScript 可以向 Rendering 溝通來改變網頁的樣子，或者向HTTP Request 請求資料。但這些可能都是非同步執行，表示 JavaScript 的請求在瀏覽器內是「<strong>非同步</strong>」的，裡面只有 JavaScript 本身是「<strong>同步</strong>」的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PdFO-LwLKmVP6BYtoRzS6g.png" alt><br>克服 JS 奇怪部分 截圖</p><blockquote><p>所以當我們「<strong>非同步</strong>」向外請求，或是某人點擊了一個按鈕執行了某個函式時，這些被「非同步」處理的事情，會怎麼樣?</p></blockquote><p>還記得我們之前提的「<strong>執行堆</strong>」嗎?在 JavaScript 內的等待列則稱為「事件佇列 (Event Queue)」這裡面都是事件、事件通知，這些可能要發生的東西。所以當瀏覽器在 JavaScript 外的某處有個需要被通知的事件時，會將之放進佇列裡，這個事件可能需要有個函式來回應它，我們可以監聽這個事件，並且處理它。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*o7CzJMOYxbtzba8opCSEwQ.png" alt></p><p>要特別注意的是，當執行堆是空的 JavaScript 才會注意事件佇列，在執行堆還沒空之前，是不會處理事件佇列的。</p><p>在處理事件佇列時，JavaScript 會看是否有函式被這個 CLICK 事件觸發，處理後知道有一個函式需要執行，因此又創造執行環境給那個函式，並加入執行堆，接著處理完畢後，又繼續到下一個佇列的事件，如此循環。</p><p>也就是說，這不是真正的「<strong>非同步</strong>」，而是瀏覽器「<strong>非同步</strong>」的把東西放到事件佇列，但原本 JavaScript 的程式仍然一行行執行，當執行後、執行堆空了、執行環境清除了，才開始處理事件佇列內的事件，周而復始。</p><p>來點範例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function wait()&#123;  </span><br><span class="line">  var ms = 3000 + new Date().getTime();  </span><br><span class="line">  while (new Date() &lt; ms)&#123;&#125;  </span><br><span class="line">  console.log(&apos;結束函式&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">function clickHandler()&#123;  </span><br><span class="line">  console.log(&apos;點擊事件!&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">document.addEventListener(&apos;click&apos;,clickHandler)  </span><br><span class="line">wait();  </span><br><span class="line">console.log(&apos;執行環境結束&apos;);</span><br></pre></td></tr></table></figure><p></p><p>我們寫了兩個函式，一個用來模擬需要花長時間動作的函式，結束後會印出函式結束的字樣，另一個用來監聽出現在事件佇列的瀏覽器的點擊事件。我們透過這個範例來觀察，如果我重新整理網頁後，當 <code>wait</code> 函式仍執行時，點擊畫面 / 不點擊畫面，這些 <code>console.log</code> 的輸出會是如何，是不是如我們上面所說的一樣。</p><h4 id="當-wait-函式仍執行時，不點擊畫面"><a href="#當-wait-函式仍執行時，不點擊畫面" class="headerlink" title="當 wait 函式仍執行時，不點擊畫面"></a>當 wait 函式仍執行時，不點擊畫面</h4><p><img src="https://cdn-images-1.medium.com/max/800/1*WkHD_1MGOQ9S_2Xn0zi2Vw.png" alt></p><h4 id="當-wait-函式仍執行時，點擊畫面"><a href="#當-wait-函式仍執行時，點擊畫面" class="headerlink" title="當 wait 函式仍執行時，點擊畫面"></a>當 wait 函式仍執行時，點擊畫面</h4><p><img src="https://cdn-images-1.medium.com/max/800/1*rH-fLg_n22KN_JdbJbhALw.png" alt></p><blockquote><p>透過以上觀察，我們可以得知，當執行堆是空的 JavaScript 才會開始處理事件佇列內的事件，這也表示執行長時間的函式，可以干擾事件</p></blockquote><p>這就是 JavaScript 如何用「同步」的方式處理在瀏覽器別處「非同步」的事件，當事件佇列都結束了之後， JavaScript 會繼續看事件佇列的迴圈，這稱為「<strong>持續檢查 (Continuous Check)</strong>」，當事件再度出現在事件佇列，就會執行。</p><p>也就是說非同步回呼在 JavaScript 是可能的，但是非同步的部分，是發生在JavaScript 之外。JavaScript透過事件佇列迴圈，當執行堆沒有東西時，就開始處理事件佇列內的事件，但是是「同步」的處理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們在 Day 6 的時候有談到 JavaScript 是 單執行緒且同步的，是如何同步執行這些程式碼，那我們也有一些疑問仍然有待釐清，像是「非同步回呼 (asynchronus callbacks)」是什麼意思?
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.10 範圍與 let</title>
    <link href="http://pvt5r486.github.io/f2e/20190113/3480376618/"/>
    <id>http://pvt5r486.github.io/f2e/20190113/3480376618/</id>
    <published>2019-01-12T19:08:04.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們在前面幾篇文章中已經討論「執行環境」、「變數環境」、「詞彙環境」，然而這些東西最終定義了「範圍 (Scope)」。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*UxwVjziwFZxbeTET" alt></p><h2 id="範圍-Scope"><a href="#範圍-Scope" class="headerlink" title="範圍 (Scope)"></a>範圍 (Scope)</h2><p>範圍是變數可以被取用的區域，如果我們呼叫了相同的函式兩次，它們會各有一個屬於自己的執行環境，因此如果函式內有個同樣的變數被宣告兩次，該變數在記憶體中的位置是不一樣的。</p><p>上面那段話用例子來解釋的話是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;  </span><br><span class="line">  var myVar = 1;  </span><br><span class="line">  console.log(myVar);  </span><br><span class="line">&#125;  </span><br><span class="line">a();  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><h2 id="「let」"><a href="#「let」" class="headerlink" title="「let」"></a>「let」</h2><p>在 ES6 (ECMAScript 6) 中，有個新的宣告變數的方法 <code>let</code> ，這個可以像 <code>var</code> 一樣使用，但並不是取代 <code>var</code> ， <code>var</code> 還是存在。</p><p>但 <code>let</code> 讓 JavaScript 使用了一種稱為「區塊範圍 (Block Scoping)」的東西，直接看一個片段程式碼：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; b) &#123;  </span><br><span class="line">  let c = true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我們可以宣告一個變數大致就像使用 <code>var</code> 一樣，變數一樣會被創造在執行階段、<strong>被放入記憶體中但不會被設值為 <code>undefined</code> </strong>，較為不同的是，直到執行階段，<strong>這一行程式被執行、真的宣告變數後，才能存取用 <code>let</code> 宣告的值</strong>。</p><p>我們改寫一下上面的例子，如果試著在 <code>let c = true</code> 之前取用 變數 <code>c</code> ：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;  </span><br><span class="line">var b = 5;  </span><br><span class="line">if (a &gt; b) &#123;  </span><br><span class="line">  console.log(c);  </span><br><span class="line">  let c = true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Rdh1wutxR8wTCgrMtcRc9Q.png" alt></p><p>會很直接的跳出 <code>c is not defined</code></p><h2 id="區塊範圍-Block-Scoping"><a href="#區塊範圍-Block-Scoping" class="headerlink" title="區塊範圍 (Block Scoping"></a>區塊範圍 (Block Scoping</h2><p>區塊通常是被定義為在「大括號 {}」中，像是在 <code>if</code> 、 <code>for</code> 裡面，當變數被宣告在區塊內，變數就只能在裡面被取用。舉個區塊範圍及 <code>let</code> 的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;  </span><br><span class="line">  let a = 0;  </span><br><span class="line">  console.log(a)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>像是這個例子，每次進入迴圈執行到 <code>let a = 0</code> 時，變數 <code>a</code> 在記憶體中都是不同的存在，這就是區塊範圍。</p><h2 id="「let」也有「提升-hosting-」嗎"><a href="#「let」也有「提升-hosting-」嗎" class="headerlink" title="「let」也有「提升 (hosting)」嗎?"></a>「let」也有「提升 (hosting)」嗎?</h2><p>以下引述自 胡立 大大寫的文章：<a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/?fbclid=IwAR0ssuf5LHR3LcwdkLUzNPu-VICwegcTZyp_6-lpOsvDJdXmIyzk3C40pYo" rel="external nofollow noopener noreferrer" target="_blank"><strong>我知道你懂 hoisting，可是你了解到多深？</strong></a></p><p>老實說，我本來以為沒有，但實際上 <code>let</code> 也是有「提升 (hosting)」的，再來個例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 10  </span><br><span class="line">function test()&#123;  </span><br><span class="line">  console.log(a)  </span><br><span class="line">  let a  </span><br><span class="line">&#125;  </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p></p><p>如果 <code>let</code> 沒有「提升」的話，這個範例的輸出應該會是「10」，因為 <code>console.log(a)</code> 會因為 <code>test</code> 函式內找不到變數 <code>a</code> 而跑到外部環境尋找。</p><blockquote><p>但是！這範例的輸出是 <code>ReferenceError: a is not defined</code></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*crWjBPeos1vYYghVn-xeZA.png" alt></p><p>意思就是，它的確提升了，只是提升後的行為跟 <code>var</code> 比較不一樣，所以乍看之下你會以為它沒有提升。</p><p>與 <code>var</code> 的差別在於提升之後， <code>var</code> 宣告的變數會被初始化為 <code>undefined</code> ，而 <code>let</code> 的宣告不會被初始化為 <code>undefined</code> ，而且如果你在「賦值之前」就存取它，就會拋出錯誤。</p><p>在「提升之後」以及「賦值之前」這段「期間」，如果你存取它就會拋出錯誤，而這段期間就稱做是「TDZ」，它是一個為了解釋 <code>let</code> 的 「提升」行為所提出的一個名詞。</p><blockquote><p>後續就到<a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/?fbclid=IwAR0ssuf5LHR3LcwdkLUzNPu-VICwegcTZyp_6-lpOsvDJdXmIyzk3C40pYo" rel="external nofollow noopener noreferrer" target="_blank"><strong>原文處</strong></a>當課後補充吧。</p></blockquote><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>其實我在寫這篇文章的時候發現了一個衝突點，這讓我決定先上論壇尋求一下協助再來做修改，衝突點就是「 <code>let</code> 宣告的變數，會不會在創造階段內被放入記憶體中，且初始化為 <code>undefined</code> 」，影片之中的講師是說會，胡立的文章是說不會，不過這兩者時空背景不太一樣，所以要求證一下。</p><p>這是<a href="https://www.udemy.com/javascript-learning/learn/v4/questions/6086710" rel="external nofollow noopener noreferrer" target="_blank">求證結果</a> ，因為是課程問答區可能沒有買的人不能看…。</p><h3 id="簡單提一下結論："><a href="#簡單提一下結論：" class="headerlink" title="簡單提一下結論："></a>簡單提一下結論：</h3><p><code>let</code> / <code>const</code> 宣告的變數，確實也有提升的作用，只是因為 TDZ 所以並不像使用 <code>var</code> 宣告會得到 <code>undefined</code> ，而是會直接拋出 <code>ReferenceError</code> 。</p><p><code>let</code> / <code>const</code> 在創造階段時，也會把變數寫進記憶體，但是在此不會賦予預設值 <code>undefined</code> ，而是在之後的程式執行階段，如果以 <code>let</code> / <code>const</code> 宣告的變數沒有賦予值時，才會給予 <code>undefined</code> ，這時候 <code>let</code> / <code>const</code> 的初始化才算完成，此時 <code>let</code> / <code>const</code> 宣告的變數才能被正常使用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      我們在前面幾篇文章中已經討論「執行環境」、「變數環境」、「詞彙環境」，然而這些東西最終定義了「範圍 (Scope)」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.9 範圍鏈 Scope Chain</title>
    <link href="http://pvt5r486.github.io/f2e/20190112/2733713332/"/>
    <id>http://pvt5r486.github.io/f2e/20190112/2733713332/</id>
    <published>2019-01-11T22:55:43.000Z</published>
    <updated>2020-02-16T05:58:30.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一篇要記錄的觀念是常常會讓人感到困惑，光看名詞就會讓人不知道在講什麼的「範圍鏈 (Scope Chain)」，但實際上如果照著課程走，看到最後會發現，啊原來就只是這樣！所以不要被名詞嚇到了哩。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*UNc8sXY4F3vHwfaB" alt></p><h2 id="範圍鏈-Scope-Chain"><a href="#範圍鏈-Scope-Chain" class="headerlink" title="範圍鏈 Scope Chain"></a>範圍鏈 Scope Chain</h2><p>現在我們已經了解「執行堆」、「執行環境」、「變數環境」，讓我們直接看一個範例，會相當眼熟：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">  console.log(myVar)  </span><br><span class="line">&#125;  </span><br><span class="line">function a()&#123;  </span><br><span class="line">  var myVar = 2;  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><p>No.2 的時候有提到「<strong>外部環境</strong>」，還記得「<strong>執行堆</strong>」的觀念嗎？當我們進入到 <code>b</code> 函式時，會製造一個執行環境，放到執行堆的上面，並把所有已經宣告的變數都放入它的「<strong>變數環境</strong>」，會在 <code>b</code> 函式的變數環境內尋找 <code>myVar</code> 這個變數，但 <code>b</code> 函式內 <code>myVar</code> 沒被宣告，此時會參考到 <code>b</code> 函式「<strong>外部環境</strong>」的 <code>myVar</code> ，因此印出來的結果會是 1 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*wdlNdu65bUo4O5fL7uIIWg.png" alt="克服 JS 奇怪部分 截圖"></p><h3 id="很混亂嗎？不知道怎麼判斷「外部環境」？"><a href="#很混亂嗎？不知道怎麼判斷「外部環境」？" class="headerlink" title="很混亂嗎？不知道怎麼判斷「外部環境」？"></a>很混亂嗎？不知道怎麼判斷「<strong>外部環境</strong>」？</h3><p>還記得一開始提到的「<strong>詞彙環境</strong>」嗎，就是代表「<strong>程式碼被寫出來的實際位置</strong>」，這意味著 JavaScript 引擎會如何處理這些程式在記憶體中的位置、以及與其他程式的連結。</p><p>所以回到例子，函式 <code>b</code> 以詞彙上來說，它在全域環境之上，代表 <code>b</code> 函式不在 <code>a</code> 函式內，它與最後一行的 <code>myVar = 1</code> 同層級。</p><p>事實上<strong>執行環境的實際位置</strong>不重要，函式 <code>b</code> 可以在 函式 <code>a</code> 上，或者互換位置，重要的是「<strong>執行的順序會決定函式如何被呼叫、執行環境如何被創造</strong>」。</p><p>JavaScript 相當注重詞彙環境，當你需要某個執行環境內的某個變數時，如果沒辦法找到此變數，它會到外部環境尋找變數，直到執行堆最下方尋找。這是整個範圍鏈到外部環境的過程。</p><p>所以如果有許多函式互相呼叫，搜尋範圍鏈會不斷的向下移動，直到全域階層。如果這些函式是互相在內部被定義，也會逐層的在那些外部環境參照尋找，直到找到或者沒找到，這一整個過程就稱為「範圍鏈」</p><blockquote><p>「<strong>範圍 (Scope)</strong>」代表能夠取用這個變數的地方；「<strong>鏈 (Chain)</strong>」是外部環境參照的連結；「<strong>詞彙</strong>」這是實際上程式碼被寫出來的物理位置</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*WTMwdQCrGCO0OWzfhC69_Q.jpeg" alt="克服 JS 奇怪部分 截圖"></p><h3 id="如果上面這個例子了解了，我們來點詞彙環境上的改變："><a href="#如果上面這個例子了解了，我們來點詞彙環境上的改變：" class="headerlink" title="如果上面這個例子了解了，我們來點詞彙環境上的改變："></a>如果上面這個例子了解了，我們來點詞彙環境上的改變：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;  </span><br><span class="line">  function b()&#123;  </span><br><span class="line">    console.log(myVar)  </span><br><span class="line">  &#125;  </span><br><span class="line">  var myVar = 2;  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>我們改變了 <code>b</code> 函式的詞彙環境，它在 <code>a</code> 函式內了。</p><h3 id="這代表什麼？"><a href="#這代表什麼？" class="headerlink" title="這代表什麼？"></a><strong>這代表什麼？</strong></h3><p>這代表現在我們不能在全域的地方呼叫 <code>b</code> 函式，因為全域執行環境會尋找 <code>b</code> 函式，但 <code>b</code> 函式根本不再這個變數環境內， <code>b</code> 函式在 <code>a</code> 函式內。</p><p>我們又可以得知一點，當 JavaScript 創造全域執行環境時，它發現 <code>a</code> 函式，但不會看 <code>a</code> 函式內有什麼東西，會直接到 <code>a</code> 函式結束的地方繼續看下去。所以如果直接這樣寫：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b();</span><br></pre></td></tr></table></figure><p></p><p>會得到 <code>b is not defined</code> 的錯誤。</p><h3 id="如果呼叫-a-函式呢？"><a href="#如果呼叫-a-函式呢？" class="headerlink" title="如果呼叫 a 函式呢？"></a>如果呼叫 a 函式呢？</h3><p>讓我們再來推論一次：</p><ul><li>當呼叫 <code>a</code> 函式，函式 <code>a</code> 的執行、變數環境被創造，此時 <code>myVar</code> 的值為 2</li><li>當程式執行到呼叫 <code>b</code> 函式時，函式 <code>b</code> 的執行、變數環境被創造</li><li>當執行函式 <code>b</code> 內的程式碼 <code>console.log(myVar)</code> ，當 JavaScript 往範圍鏈下面找時，它在函式 <code>b</code> 內找不到 <code>myVar</code> ，便轉向外部環境的函式 <code>a</code> 找，因此結果會是 <code>myVar = 2</code></li></ul><h3 id="所以讓我們再變化一次："><a href="#所以讓我們再變化一次：" class="headerlink" title="所以讓我們再變化一次："></a>所以讓我們再變化一次：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;  </span><br><span class="line">  function b()&#123;  </span><br><span class="line">    console.log(myVar)  </span><br><span class="line">  &#125;  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>延續上面的情境，當 JavaScript 往範圍鏈下面找時，它在函式 <code>b</code> 內找不到 <code>myVar</code> ，便轉向外部環境的函式 <code>a</code> 找，這個時候函式 <code>a</code> 也找不到 <code>myVar</code> 了，但是 <code>a</code> 函式的外部環境參照是全域執行環境，因此找到 <code>myVar = 1</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*wu2RodF_7eJRpQ7whzb68w.jpeg" alt></p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>至此，我總算是明白了 JavaScript 在我們沒看到的地方偷偷摸摸的為我們做了什麼事情，如果明白了這些，也對於工作上的除錯有相當大的幫助，因為我們了解了JavaScript 底層做了些什麼，所以當出現一個非預期的值，我們也能快速的除錯。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這一篇要記錄的觀念是常常會讓人感到困惑，光看名詞就會讓人不知道在講什麼的「範圍鏈 (Scope Chain)」，但實際上如果照著課程走，看到最後會發現，啊原來就只是這樣！所以不要被名詞嚇到了哩。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.8 函式、變數環境</title>
    <link href="http://pvt5r486.github.io/f2e/20190112/4045593043/"/>
    <id>http://pvt5r486.github.io/f2e/20190112/4045593043/</id>
    <published>2019-01-11T20:55:50.000Z</published>
    <updated>2020-02-16T05:58:30.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是討論另一個有關 JavaScript 底層運作的名詞，「變數環境」?這看起來並沒有這麼想像中的複雜，看下去就明白了。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*0ZHcodSmZnBIzNn2" alt></p><h2 id="變數環境-Variable-Environment"><a href="#變數環境-Variable-Environment" class="headerlink" title="變數環境 (Variable Environment)"></a>變數環境 (Variable Environment)</h2><p>變數環境只是在描述創造變數的位置以及與記憶體中和其他變數的關係。簡單來說，當提到「變數環境」時，我們只要想著「變數在哪裡」這樣就可以了，來點例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">  var myVar;  </span><br><span class="line">&#125;  </span><br><span class="line">function a()&#123;  </span><br><span class="line">  var myVar = 2;  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><p>套用前面幾篇學到的觀念，我們可以得知，當這些函式被執行時會發生什麼事，讓我們在溫習一次並加入本次的新名詞：</p><ul><li>當 JavaScript 運行時，一開始全域執行環境被創造， <code>myVar</code> 放進記憶體中，對全域執行環境來說，它的變數環境是全域物件 (瀏覽器的 window)，所以當程式運行到 <code>var myVar = 1</code> 時，在記憶體中的變數會得到 1 的值。</li><li>接著執行 <code>a</code> 函式，<strong>一個新的執行環境被創造給 <code>a</code> 函式，也會創造一個新的變數環境</strong>，<strong>每個執行環境都有自己的變數環境</strong>，然後在執行階段時，變數 <code>myVar</code> 的值會變成 2 ，接著 <code>a</code> 函式會再呼叫 <code>b</code> 函式。</li><li><code>b</code> 函式開始執行，一個新的執行環境、變數環境又被創造，當執行到 <code>var myVar</code> 時，因為沒有設定值，所以這裡的值會是 <code>undefined</code> 。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*wilsWp31DcRY48CQ4daE8w.jpeg" alt="克服 JS 奇怪部分 截圖"></p><blockquote><p>這些和一個叫做「scope」的東西有關，我們之後將會介紹它。</p></blockquote><p>以上面的例子來說，每個變數都被定義在自己的執行環境，每當我們呼叫函式，就會得到這函式自己的執行環境，雖然 <code>myVar</code> 變數被宣告三次，但事實上，這三個 <code>myVar</code> 是完全不相干、彼此沒有關聯的，讓我們來證明它：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">  var myVar;  </span><br><span class="line">  console.log(myVar)  </span><br><span class="line">&#125;  </span><br><span class="line">function a()&#123;  </span><br><span class="line">  var myVar = 2;  </span><br><span class="line">  console.log(myVar)  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">console.log(myVar)  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><p>綜合前面的觀念，推斷後，我們可以得知答案會是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><p></p><p>換句話說，在這個例子內，三個 <code>myVar</code> 都待在自己的執行環境內，呼叫 <code>a</code> 函式並不會影響到 <code>var myVar = 1</code> 的值，讓我們再下方多補入一行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(myVar)</span><br></pre></td></tr></table></figure><p></p><p>則得到的結果會是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">undefined  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>完全符合前面幾篇文章討論過的觀念。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>突然有種逐漸明朗的感覺，事實上我自己在寫這些紀錄的時候，都會有種「這我好像在前面幾篇文章就有看過」的感覺，這應該是這門課程的特色，它是循序漸進的，會在同一件事情上「慢慢地」加入一些要素、觀念，最後當我們每個名詞都弄懂之後，自然也就明白為什麼會這樣了。下一篇要記錄有關「Scope」，感覺篇幅應該不小哦～加油吧！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本篇是討論另一個有關 JavaScript 底層運作的名詞，「變數環境」?這看起來並沒有這麼想像中的複雜，看下去就明白了。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.7 函式呼叫與執行堆</title>
    <link href="http://pvt5r486.github.io/f2e/20190111/536730144/"/>
    <id>http://pvt5r486.github.io/f2e/20190111/536730144/</id>
    <published>2019-01-10T23:25:00.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面我們已經知道了全域執行環境是如何被創造、執行的，在本篇我們要記錄的是「函式呼叫 ( Funtion Invocation)」、「執行堆 (Execution Stack)」究竟是什麼東西～這對之後的進階觀念相當重要！</p><p><img src="https://cdn-images-1.medium.com/max/800/0*h4bq1USTF2RvTeNL" alt></p><h2 id="函式呼叫-Funtion-Invocation"><a href="#函式呼叫-Funtion-Invocation" class="headerlink" title="函式呼叫 (Funtion Invocation)"></a>函式呼叫 (Funtion Invocation)</h2><p>表示執行或者呼叫一個函式，在 JavaScript 我們用括號來表示這件事，像是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><p>這麼做我就呼叫了 <code>a</code> 函式，儘管我根本沒宣告 <code>a</code> 函式，但我希望 JavaScript 執行這個。</p><h2 id="執行堆-Execution-Stack"><a href="#執行堆-Execution-Stack" class="headerlink" title="執行堆 (Execution Stack)"></a>執行堆 (Execution Stack)</h2><p>這個就得從 「當我們在 JavaScript 呼叫函式時發生了什麼事」開始說起，一個簡單的範例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">function a()&#123;  </span><br><span class="line">　b();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p></p><blockquote><p>狀況是這樣的：我們有兩個函式， <code>a</code> 函式會呼叫 <code>b</code> 函式。我們呼叫 <code>a</code> 函式，這時候來看會發生什麼事情。</p></blockquote><ul><li>首先，當我們執行了 JavaScript 第一個被創造的是「全域執行環境」，語法解析器會分析程式，然後編譯器會編譯程式，這個過程也會創造變數 <code>this</code> ，創造全域物件 (在瀏覽器會是 window 物件)，然後會將這些變數、函式放進記憶體中。接著程式碼會開始逐行被執行，直到碰到 <code>a()</code>。</li><li>碰到 <code>a()</code> 時，一個新的執行環境被創造，被放進執行堆中，就像積木一樣被堆疊起來，在最上方的就是正在執行的東西。所以每一次在 JavaScript 呼叫函式，就會創造一個<strong>新的執行環境</strong>並放進執行堆中。然而一個新的執行環境會有自己的記憶體空間存放變數與函式，一樣也會歷經創造階段，逐行執行函式中的程式碼。</li><li>接著執行 <code>a</code> 函式內的程式碼呼叫了 <code>b</code> 函式，此時會停止執行程式再次創造另一個新的執行環境，然後執行 <code>b</code> 函式，儘管 <code>b</code> 函式內沒有任何程式碼。</li><li>當 <code>b</code> 函式結束後，它會離開執行堆的最上方，然後是函式 <code>a</code> ，但在此函式 <code>a</code> 內沒有其他的程式碼了，也離開了執行堆，最後回到最下面的全域執行環境。</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*GxLfTeuOZAYEWFI9KZoAOg.jpeg" alt="克服 JS 奇怪部分 截圖"></p><blockquote><p>程式碼中的實際排列順序並不重要，在函式中剩下的程式碼順序也不會影響執行先後，像是把程式碼改成這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;  </span><br><span class="line">  b();  </span><br><span class="line">  var c;  </span><br><span class="line">&#125;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">  var d;  </span><br><span class="line">&#125;  </span><br><span class="line">a();  </span><br><span class="line">var d;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>如前面所提，這些函式、變數在創造階段就已經在記憶體中了，因此當程式碼逐行被編譯時，也很類似上個範例：</p><ul><li><code>a</code> 函式被呼叫，進入執行堆，變成目前執行的程式，因為 <code>var d</code> 在 <code>a</code> 函式的下方且 JavaScript 是同步的，一次執行一行，所以暫時沒被執行。</li><li>逐行執行 <code>a</code> 函式的內容， <code>b</code> 函式被呼叫，進入執行堆，變成目前執行的程式，注意這時 <code>a</code> 函式並沒有離開執行堆。</li><li>接著執行 <code>b</code> 函式的內容，當執行完之後 <code>b</code> 函式就離開執行堆，此時 <code>a</code> 函式又變成執行堆的最上面了，因此會執行還沒執行的那一行 <code>var c</code> 。</li><li>當 <code>a</code> 函式 執行完畢離開執行堆，回到全域執行環境，還記得一開始的 var d 嗎 ? 終於輪到它了！</li></ul><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>透過一個比較簡單與進階的例子，我們了解 JavaScript 函式呼叫的流程，即使是自己呼叫自己，仍然會遵守這個流程。此外，無論在執行堆最上面的東西是什麼，那就是目前正在執行的程式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前面我們已經知道了全域執行環境是如何被創造、執行的，在本篇要記錄的是「函式呼叫 (Funtion Invocation)」、「執行堆 (Execution Stack)」究竟是什麼東西～這對之後的進階觀念相當重要！
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.6 觀念小叮嚀：單執行緒、同步執行</title>
    <link href="http://pvt5r486.github.io/f2e/20190111/4191157007/"/>
    <id>http://pvt5r486.github.io/f2e/20190111/4191157007/</id>
    <published>2019-01-10T22:11:28.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇紀錄 JavaScript 另一個觀念「單執行緒」、「同步執行」</p><p><img src="https://cdn-images-1.medium.com/max/800/0*t7tRLV_3V9w4-lWf" alt></p><h2 id="單執行緒-Single-Threaded"><a href="#單執行緒-Single-Threaded" class="headerlink" title="單執行緒 ( Single Threaded )"></a>單執行緒 ( Single Threaded )</h2><p>每個程式都有一堆指令，單執行緒表示<strong>「一次只執行一個指令」</strong>。</p><h2 id="同步執行-Synchronous-Execution"><a href="#同步執行-Synchronous-Execution" class="headerlink" title="同步執行 ( Synchronous Execution )"></a>同步執行 ( Synchronous Execution )</h2><p>這跟單執行緒很類似，同步執行的意思是，<strong>「一次執行一行程式碼，而且是按照順序的。」</strong></p><blockquote><p><strong>單執行緒 &amp; 同步執行意味著在 JavaScript 中一次只會發生一件事</strong></p></blockquote><p>當然我們可能聽過 JavaScript 中有什麼非同步請求 (asynchronous requests)，還有非常非常多的疑問，不過在此就只要先記住這些就行了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      這篇紀錄 JavaScript 另一個觀念「單執行緒」、「同步執行」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.5 執行環境：程式執行</title>
    <link href="http://pvt5r486.github.io/f2e/20190111/1828752033/"/>
    <id>http://pvt5r486.github.io/f2e/20190111/1828752033/</id>
    <published>2019-01-10T21:39:08.000Z</published>
    <updated>2020-02-16T05:58:30.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>還記得我們說到執行環境有兩個階段，第一個階段是「創造」，這會設定變數與函式到記憶體中。這篇文章主要是介紹第二個階段「程式執行 (Code Execution)」</p><h2 id="程式執行-Code-Execution"><a href="#程式執行-Code-Execution" class="headerlink" title="程式執行 (Code Execution)"></a>程式執行 (Code Execution)</h2><p>在創造階段時，我們已經設定好所有的東西了，而這個階段就是關於「我們寫好的程式碼」將被逐行的編譯、轉換成電腦懂的東西。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Iw6Nxp881KsiCBHMt7y9bQ.jpeg" alt="克服 JS 奇怪部分 截圖"></p><h3 id="回到提升-hoisting-的例子，調整一下："><a href="#回到提升-hoisting-的例子，調整一下：" class="headerlink" title="回到提升 ( hoisting) 的例子，調整一下："></a>回到提升 ( hoisting) 的例子，調整一下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">  console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">b();  </span><br><span class="line">console.log(a);  </span><br><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>這樣子會印出什麼呢 ?</p><p><img src="https://cdn-images-1.medium.com/max/800/1*UBNp3Iw7vku3xY_Z61GHVA.jpeg" alt></p><p>如我們前面學到的觀念，因為現在是程式執行階段，函式 <code>b</code> 被呼叫印出 <code>called b</code> ，接著印出在變數 <code>a</code> 於創造階段設定的 <code>undefined</code> ，執行到 <code>var a = &#39;hello&#39;</code> 時將記憶體中 <code>a</code> 的值設定為 <code>hello</code> 字串，最後執行 <code>console.log(a);</code> 印出變數 <code>a</code> 的值。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>這一篇文章比較短，不過透過這一篇的範例我們可以知道， JavaScript 中程式碼確實是逐行被編譯的。</p><p>至此，執行環境的兩個階段已經講解完了，自己算是對 JavaScript 的前世今生也有一點點眉目了，但 JavaScript 仍然有很多奇怪的地方需要克服，勉勵自己繼續加油。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      還記得我們說到執行環境有兩個階段，第一個階段是「創造」，這會設定變數與函式到記憶體中。這篇文章主要是介紹第二個階段「程式執行 (Code Execution)」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.4 JavaScript 與 undefined</title>
    <link href="http://pvt5r486.github.io/f2e/20190111/3925526750/"/>
    <id>http://pvt5r486.github.io/f2e/20190111/3925526750/</id>
    <published>2019-01-10T19:29:34.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇的最後，我們提到了「undefined」，於是我們這一篇要探討什麼是JavaScript中的「undefined」，在正式進入本篇之前，先用影片的一段話幫助自己回顧一下前一篇的內容。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*M7IitVCilIcfkVuG" alt></p><h2 id="創造階段發生的事情"><a href="#創造階段發生的事情" class="headerlink" title="創造階段發生的事情"></a>創造階段發生的事情</h2><blockquote><p>在執行階段的第一階段「創造階段」時，會產生一個「全域物件」到全域執行環境裡，還會產生一個特殊變數「 this 」，如果有「外部環境」的話也會產生相應連結，另外還有個特殊現象稱為「提升 (hoisting)」，變數和函式會預先被儲存在記憶體內，而變數會被設定一個初始值「undefined」</p></blockquote><h2 id="直接進入例子"><a href="#直接進入例子" class="headerlink" title="直接進入例子"></a>直接進入例子</h2><p>我們這次專注觀察 <code>undefined</code> ，移除掉其他不相干程式碼<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);  </span><br><span class="line">var a = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><p></p><p>記得這畫面嗎？</p><p>對，我們會得到一個 <code>undefined</code></p><p>那如果是這樣呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p></p><p>還是會得到一個 <code>undefined</code></p><p>如果不透過宣告就使用變數 <code>a</code> 呢？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p></p><p>則會產生錯誤(Error)， <code>a is not defined</code></p><h2 id="「not-defined」和「undefined」的差異"><a href="#「not-defined」和「undefined」的差異" class="headerlink" title="「not defined」和「undefined」的差異"></a>「not defined」和「undefined」的差異</h2><p>「undefined」的意思用上述例子來說，我們透過 <code>var</code> 宣告讓 JavaScript 知道有 <code>a</code> 變數的存在，因此會在創造階段就在記憶體內預留空間給變數 <code>a</code> ，並且賦予一個 JavaScript 內建的特殊值 <code>undefined</code> ，用來表示這個變數 <code>a</code> 還沒有被「設定」過值，以下再來個例子證明。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">if (a === undefined)&#123;  </span><br><span class="line">　console.log(&apos;a is undefined&apos;);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">　console.log(&apos;a is defined&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>特別注意程式碼內的 <code>undefined</code> 沒有使用單引號包住， <code>undefined</code> 並不是字串，而是一個特殊的值。</p></blockquote><p>這樣的結果會是</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PJSobe3BO8S359YpKWpXeA.jpeg" alt></p><p>那如果改成這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">if (a === undefined)&#123;  </span><br><span class="line">　console.log(&apos;a is undefined&apos;);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">　console.log(&apos;a is defined&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>則結果會是</p><p><img src="https://cdn-images-1.medium.com/max/800/1*wmgC0OL1-pBJq-2iSp3jFA.jpeg" alt></p><p>因為 <code>a</code> 被「設定」了值，所以不再是 JavaScript 給變數的預設值 <code>undefined</code> 。</p><p>「not defined」的意思，簡單來說就是 JavaScript 根本不認得這是什麼，因為這個變數沒有被宣告過，故創造階段時並沒有在記憶體內預留空間給這個變數，所以才會是「not defined」。</p><h2 id="混亂嗎-整理一下："><a href="#混亂嗎-整理一下：" class="headerlink" title="混亂嗎 ? 整理一下："></a>混亂嗎 ? 整理一下：</h2><p>在例子中，透過 <code>var</code> 宣告讓 JavaScript 於創造階段時，為變數在記憶體內預留空間，並且給予特殊的初始值 <code>undefined</code> ，因此 <code>undefined</code> 並不是「不存在」，這是會佔據記憶體空間的。</p><p>之後當執行到 <code>var a = &#39;hello&#39;;</code> 時，才正式將字串 <code>hello</code> 給變數 <code>a</code> ；反之，如果沒透過 <code>var</code> 宣告， JavaScript 根本不認得這是什麼，所以自然會跑出錯誤(Error)的提示囉。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>這個小節其實相對的好懂，影片的最後講師也提到了設定變數時，盡量不要把初始值也寫成<code>undefined</code> ，像這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = undefined;</span><br></pre></td></tr></table></figure><p></p><p>因為這樣會讓除錯變得困難，會很難分辨這個 <code>undefined</code> 是我們設定的，還是 JavaScript 給予的預設值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      上一篇的最後，我們提到了「undefined」，於是我們這一篇要探討什麼是 JavaScript 中的「undefined」，在正式進入本篇之前，先用影片的一段話幫助自己回顧一下前一篇的內容。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.3 執行環境:創造與提升</title>
    <link href="http://pvt5r486.github.io/f2e/20190110/1483372396/"/>
    <id>http://pvt5r486.github.io/f2e/20190110/1483372396/</id>
    <published>2019-01-10T00:16:06.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>透過前面的篇章我們得知， JavaScript 於執行環境時，會幫我們建立出一個「全域物件」與「this」，那麼除此之外呢？今天就是探討更多有關 JavaScript 在創造「執行環境」時做的「創造」與「提升 (hoisting)」</p><h2 id="來點提升的範例"><a href="#來點提升的範例" class="headerlink" title="來點提升的範例"></a>來點提升的範例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">b();  </span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>這樣寫很明顯答案會是：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*E0zb77YaCBgSBYpWUqPQ9g.jpeg" alt></p><h3 id="如果我們改變一下順序呢"><a href="#如果我們改變一下順序呢" class="headerlink" title="如果我們改變一下順序呢?"></a>如果我們改變一下順序呢?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b();  </span><br><span class="line">console.log(a);  </span><br><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們可能會很直覺地說，這樣會產生錯誤，因為程式碼是逐行執行的，而 b c函式與 a 變數還沒被宣告。</p><blockquote><p><strong>但在 JavaScript 不是這樣的</strong></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*Sy7JeLCMleySppDjUxWaQg.jpeg" alt></p><p><code>b</code> 函式正確地被執行了，但是變數 <code>a</code> 的值變成了 <code>undefined</code>。即使函式是之後才宣告的，但仍然正確執行；變數雖然值被改變了，但仍然可以使用，這到底是為什麼呢？</p><blockquote><p>我們有很多疑問，但在此先移除變數 <code>a</code> 看看會發生什麼事情<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b();  </span><br><span class="line">console.log(a);  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*rMxZqPNWvUJ9NQJyJP_0zg.jpeg" alt></p><p>這次我們就很直接地獲得了一個 Error ， <code>a is not defined</code></p><blockquote><p>這些現象在 JavaScript 稱為 <strong>「提升 ( hoisting )」</strong></p></blockquote><p>「提升」的解釋很容易被誤會，例如「提升」是 JavaScript 的變數與函式被實際的從程式碼內被『提升』到最上方了，像是這樣：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b();  </span><br><span class="line">console.log(a);  </span><br><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>自動地變成這樣<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;hello&apos;;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">b();  </span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p></p><p>無論在哪宣告都沒有差別。</p><blockquote><p><strong>這樣子似乎也沒什麼錯，但實際上不完全正確，因為 a 也沒有被設值為 hello，這麼說比較像是這樣子</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a;  </span><br><span class="line">function b()&#123;  </span><br><span class="line">　console.log(&apos;called b&apos;);  </span><br><span class="line">&#125;  </span><br><span class="line">b();  </span><br><span class="line">console.log(a);  </span><br><span class="line">a = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>但這樣也不對，不然比較正確的說法是什麼呢？</p><h3 id="「提升-hoisting-」比較合理的解釋是這樣的："><a href="#「提升-hoisting-」比較合理的解釋是這樣的：" class="headerlink" title="「提升 ( hoisting )」比較合理的解釋是這樣的："></a>「提升 ( hoisting )」比較合理的解釋是這樣的：</h3><p>我們要回到最開始，到執行環境剛開始的時候。執行環境剛開始的時候被分成兩階段創造，第一階段是「<strong>創造 ( creation )</strong>」 階段，在這個階段中我們透過前面篇章知道有「<strong>全域物件</strong>」、「<strong>this</strong>」、「<strong>外部環境</strong>」再創造階段裡。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*-qgWRozV_VlGlzTCCffacQ.jpeg" alt="克服 JS 奇怪部分 截圖"></p><p>因此當「<strong>語法解析器</strong>」開始轉換程式碼時，它會知道我們已經在哪創造變數、函式，這是在創造階段就被設定變數以及函式在記憶體裡，這個步驟叫做「提升 (hoisting)」</p><blockquote><p>這個步驟並不是真的把我們的程式碼移動到最上方，而是在程式碼被逐行解讀之前， JavaScript 已經為變數、函式在記憶體中建立一個空間了。</p></blockquote><p>正是如此，當程式被逐行執行時，可以找到在記憶體中的變數、函式。</p><h3 id="然而，變數的情況又有點不一樣"><a href="#然而，變數的情況又有點不一樣" class="headerlink" title="然而，變數的情況又有點不一樣"></a>然而，變數的情況又有點不一樣</h3><p>透過上面解釋，我們知道函式已經完整地在記憶體內了，代表函式內的程式碼已經被執行了。然而下一個執行階段<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><p></p><p>JavaScript 為 變數 a 騰出記憶體空間時並不知道 <code>a</code> 是什麼值，會先放上<code>undefined</code>的特殊值，直到該行程式碼真正被執行時才知道。</p><p>假如設定變數但不給值會發生什麼事，像是這樣?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>所有的 JavaScript 的變數一開始都會被設定為 undefined</strong></p></blockquote><h3 id="既然-JavaScript-有「提升」特性，是不是可以不重視順序"><a href="#既然-JavaScript-有「提升」特性，是不是可以不重視順序" class="headerlink" title="既然 JavaScript 有「提升」特性，是不是可以不重視順序 ?"></a>既然 JavaScript 有「提升」特性，是不是可以不重視順序 ?</h3><p>依賴「提升」並不是好的作法，這麼做可能會遇到問題，而且在可讀性上也會大大的降低，所以雖然技術上來講可以說得通，但並不建議這麼做，可以避免一些未知的 BUG 。</p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>透過影片講解，我們了解「提升 (hoisting)」為何物，即使函式是最後才被宣告，我們還是可以先行呼叫，因為我們寫的程式碼並不會直接被執行，而是會透過 JavaScript 的轉換，並於第一個創造階段把變數、函式設定在記憶體內，因此我們可以有限的取用它們，直到實際出現在詞彙環境 (lexcial environment)之前。</p><p><strong>課後補充一：</strong><a href="https://wcc723.github.io/javascript/2017/12/16/javascript-hoisting/" rel="external nofollow noopener noreferrer" target="_blank"><strong>卡斯伯的網誌</strong></a></p><p><img src="https://cdn-images-1.medium.com/max/800/1*jKQ0o2sKajnPrqXr3ZNMfg.jpeg" alt></p><p>觀念跟文章說的是一樣的，只是函式寫法不同，都會被「提升 (hoisting)」影響。文章中的函式寫法是「函式陳述式」，所以在函式前方直接調用也可以運行。另外還有一種是函式寫法是「函式表達式」，會先把函式指定給一個變數，這時候如圖中範例調用，會產生 <code>undefined</code> ，因為「<strong>所有的 JavaScript 的變數一開始都會被設定為 undefined」</strong>，因為是 <code>undefined</code> 自然也無法運行函式的內容了。</p><p><strong>課後補充二：</strong><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/?fbclid=IwAR0ssuf5LHR3LcwdkLUzNPu-VICwegcTZyp_6-lpOsvDJdXmIyzk3C40pYo" rel="external nofollow noopener noreferrer" target="_blank"><strong>胡立大大寫的 techbridge 技術報</strong></a></p><p>內容相當詳盡，其中有一句很濃縮，又很多人不明白的：</p><blockquote><p><em>let 與 const 也有 hoisting 但沒有初始化為 undefined，而且在賦值之前試圖取值會發生錯誤。</em></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      透過前面的篇章我們得知， JavaScript 於執行環境時，會幫我們建立出一個「全域物件」與「this」，那麼除此之外呢？今天就是探討更多有關 JavaScript 在創造「執行環境」時做的「創造」與「提升 ( hoisting )」
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.2 全域執行環境與全域物件</title>
    <link href="http://pvt5r486.github.io/f2e/20190110/3101754491/"/>
    <id>http://pvt5r486.github.io/f2e/20190110/3101754491/</id>
    <published>2019-01-09T21:26:27.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天課程談到了關於「<strong>全域執行環境</strong>」與「<strong>全域物件</strong>」，那麼這兩個東西又是什麼呢?首先我們需要了解到：</p><ul><li>不論何時執行 JavaScript 程式，皆是在<strong>執行環境 (Execution Context)</strong>裡面執行</li><li>當我們第一次執行 JavaScript 時，會看到基礎的<strong>執行環境</strong> 被建立、執行<blockquote><p><strong>執行環境</strong>就像一個別人寫好的程式把正在執行的程式碼包裹在裡面內驗證、執行。</p></blockquote></li></ul><h2 id="全域執行環境"><a href="#全域執行環境" class="headerlink" title="全域執行環境"></a>全域執行環境</h2><p>前面提到的<strong>基礎執行環境，也可以稱為全域執行環境 (Global Execution Context)，「全域」</strong>指可在<strong>區域裡、JavaScript 檔案裡、詞彙環境</strong>裡被取用。</p><p>全域執行環境<strong>創造</strong>了兩件事情：「<strong>全域物件 (Global Execution Object)</strong>」、「<strong>特殊的變數 this</strong>」</p><h2 id="全域物件"><a href="#全域物件" class="headerlink" title="全域物件"></a>全域物件</h2><p>還記得<strong>物件</strong>的解釋嗎，就只是 名稱 / 值 的組合，再帶入<strong>「全域」</strong>的概念</p><p><img src="https://cdn-images-1.medium.com/max/800/1*5WYD0iaABVNByapVZLw_QQ.jpeg" alt="全域執行環境 - 課程部分截圖"></p><h3 id="實際驗證"><a href="#實際驗證" class="headerlink" title="實際驗證"></a>實際驗證</h3><p>接下來我們可以開始寫一點程式碼測試看看，像是這樣：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*yq_u2CjFN7vRp6mZnS4FRw.jpeg" alt></p><ul><li>什麼都不寫，並打開開發人員工具觀察，</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*T51V6XmLashhoE9phWaNaw.jpeg" alt></p><p>這個時候其實已經做了這些事情：</p><ul><li>JavaScript 檔案被載入 &gt; 語法解析啟動 &gt; 沒寫任何程式碼，所以沒有被執行</li></ul><p>但是 JavaScript 確實已經運行，執行環境已經被創造出來了，另外還有「<strong>全域物件</strong>」、「 <strong>this</strong>」，我們可以進行驗證，執行環境內有什麼?</p><ul><li>直接輸入 this 看看</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*v2ZtbYsRTF6BQPIU3gI1_g.jpeg" alt></p><p>我們什麼都沒寫，為什麼會有這個 window 物件</p><blockquote><p>因為 JavaScript 已經將執行環境建立，而執行環境可以決定現在這個 this 的值是什麼</p></blockquote><p>那如果我們直接輸入 window 會怎麼樣? 我們會得到一樣的結果。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*a-Mga66FoaHr-ZNyBhZbWg.jpeg" alt></p><blockquote><p>執行 JavaScript 時永遠會有一個全域物件</p></blockquote><p>在瀏覽器的話就是 window ，如果再伺服器上執行 node.js 那結果會是得到 Global ，會是個不同的全域物件。另外，不同分頁的全域物件 window，雖然名稱一樣，但彼此是沒有關聯的。</p><blockquote><p>每個分頁有自己的執行環境、全域物件。</p></blockquote><p>整理一下目前的思緒，得出如下圖結論</p><p><img src="https://cdn-images-1.medium.com/max/800/1*QhFNrByH-c7gy-qkaGATYw.jpeg" alt></p><h3 id="讓我們把「全域-GLOBAL-」再定義得更清楚一點："><a href="#讓我們把「全域-GLOBAL-」再定義得更清楚一點：" class="headerlink" title="讓我們把「全域 (GLOBAL)」再定義得更清楚一點："></a>讓我們把「全域 (GLOBAL)」再定義得更清楚一點：</h3><p>原文是這麼寫的「Not Inside a Function」，在 JavaScript 中表示不再函式(Function)內，更直白一點「程式碼或者變數不再函式裡就是全域的」，讓我們直接來驗證。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;Hello world&apos;;</span><br><span class="line">function b() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至此，我們有了一個變數、函式，與之前不同的是，現在我們有程式碼了。而且變數 a 不再 b 函式裡，現在的情況是「<strong>全部的程式碼都不再函式裡</strong>」，讓我們觀察看看它們是不是「<strong>全域</strong>」的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*IftUxBp1cea_nOCyNk88sQ.jpeg" alt></p><p>如紅框處，我們建立的變數 <code>a</code> 、函式 <code>b</code> ，如果不是在函式內建立，那麼這些東西就會與全域物件做連結，也就可以產生以下寫法，兩者是一樣的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ywX5RFUmshCTERXKpJr7ww.jpeg" alt></p><p>至此，本篇大致上到這裡結束，再利用圖片加深一下印象</p><p><img src="https://cdn-images-1.medium.com/max/800/1*jj-4lnNIk6ZDMJp6HrCbsA.jpeg" alt></p><p>還有一些事情沒有提到，像是「<strong>外部環境 (Outer Environment)</strong>」，意思就是說，當程式碼在函式內執行，這代表程式碼在函式內；當在程式碼在全域時，代表不是在函式內，此時就沒有「<strong>外部環境</strong> 」，因為這已經是最外層了，此時會是 <code>null</code> ，這樣講好像有聽沒懂，再來個例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;  </span><br><span class="line">  console.log(myVar);  </span><br><span class="line">&#125;  </span><br><span class="line">function a()&#123;  </span><br><span class="line">  var myVar = 2;  </span><br><span class="line">  b();  </span><br><span class="line">&#125;  </span><br><span class="line">var myVar = 1;  </span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>猜猜這樣寫函式 <code>b</code> 會印出什麼？</p><p>答案是 1，為什麼?</p><p>原因很簡單，在 JavaScript 中，如果要呼叫一個在該「<strong>執行環境</strong>」中沒有的變數時，它會往它的「<strong>外部環境</strong> 」去找。</p><p><strong>也就是說：</strong></p><ol><li>我們先宣告了全域變數 (<code>myVar = 1</code>)，因此全域執行環境有了 (<code>myVar = 1</code>)</li><li>接著執行函式 <code>a</code> ，但這裡的 <code>myVar</code> 不是全域變數，而是區域變數 (<code>myVar = 2</code>)</li><li>最後又執行函式 <code>b</code> ，但對函式 b而言並沒有變數 <code>myVar</code> ，此時函式 <code>b</code> 會從「<strong>外部環境</strong> 」尋找變數 <code>myVar</code> ，也就是一開始宣告的全域變數 (<code>myVar = 1</code>)，而不會是函式 a的(<code>myVar = 2</code>)</li></ol><p><img src="https://cdn-images-1.medium.com/max/800/1*KTjYaILWODGhjZTLoCQaJA.png" alt="克服 JS 奇怪部分 截圖"></p><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>感覺自己又對 JavaScript 更了解了一點，不過瞭解這些專有名詞是有點想睡覺…，但是瞭解這些名詞其實有助於後續課程的學習，你必須知道這些名詞是什麼意思，才能理解講師再說什麼。另外外部環境我覺得是個蠻重要的東西，了解這個有助於避免掉一些鬼打牆的情況。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      今天課程談到了關於「全域執行環境」與「全域物件」，那麼這兩個東西又是什麼呢?首先我們需要了解到...
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[JavaScriptWeird]No.1 觀念小叮嚀：語法解析器、執行環境、詞彙環境</title>
    <link href="http://pvt5r486.github.io/f2e/20190109/3227448912/"/>
    <id>http://pvt5r486.github.io/f2e/20190109/3227448912/</id>
    <published>2019-01-09T01:27:27.000Z</published>
    <updated>2020-02-16T05:58:30.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:04:52 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>終於開始這個系列的第一篇，所以先來記錄一些比較基礎的名詞解釋，往後的課程中也會多次的提及這些詞彙，因此透過這篇記錄下來，避免自己金魚腦忘掉。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*LGFxJTk4tFw-_Z64" alt></p><h2 id="語法解析器-Syntax-Parsers"><a href="#語法解析器-Syntax-Parsers" class="headerlink" title="語法解析器 ( Syntax Parsers )"></a>語法解析器 ( Syntax Parsers )</h2><p>語法解析器可能會是一個「<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">直譯器</a>」或是「<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">編譯器</a>」，例如在 JavaScript 中我們寫的程式沒辦法直接告訴電腦該做什麼，那該怎麼辦?</p><blockquote><p>需要透過一個「中間人」(在此指編譯器，也就是別人寫的程式)</p></blockquote><p><strong>概念像是這樣</strong> ↓<br><img src="https://cdn-images-1.medium.com/max/800/1*JHR5FpFaMoA54jrIRGK-xg.jpeg" alt="克服 JS 奇怪部分 截圖"></p><p>透過語法解析器，我們寫的程式碼會逐字地被解讀，如果程式碼正確，那麼語法解析器就會將其轉化為電腦看得懂的硬體指令，最後呈現出我們預想的結果。</p><blockquote><p>像是如果程式碼內寫了 <code>return;</code>，當語法解析器看到「r」時，它預期會再看到一個「e」，語法解析器會逐字地進行。</p></blockquote><p>如果語法解析器看到一些非預期的東西就會出現錯誤，但如果是正確的，就會繼續下去，並在遇到<strong>分號</strong>時結束。</p><p>語法解析器甚至可以在執行前改變我們的程式碼，像是<strong>幫忙補上分號</strong>，這也是為什麼 JavaScript 中，有時候我們忘記寫分號，程式仍然可以執行。</p><blockquote><p>不過幫忙補上分號有時候並不是一件好事，有時這會讓程式難以除錯，所以我們應該避免語法解析器自動補上分號。</p></blockquote><p>因為有時語法解析器做出不如我們預期的行為，像是我們輸入 <code>return</code> 按下「Enter」 鍵，會出現一個「Carriage Return」，這是個看不見的字元，但它確實存在，這時語法解析器會受「Carriage Return」影響，進而把有「Carriage Return」的地方替換成<strong>分號</strong>。也就是說，任何語法解析器預期會有分號的地方都會自動地補上。</p><h3 id="舉例來說："><a href="#舉例來說：" class="headerlink" title="舉例來說："></a>舉例來說：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getPerson()&#123;  </span><br><span class="line">  return  </span><br><span class="line">  &#123;  </span><br><span class="line">    name:&apos;Tony&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(getPerson());　// undefined</span><br></pre></td></tr></table></figure><p>因為 <code>return</code> 後面有「Carriage Return」，如果 JavaScript 在關鍵字 <code>return</code> 後發現「Carriage Return」，就會自動補上分號，所以什麼都沒有回傳。</p><p>要讓這程式正確執行應該這麼做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getPerson()&#123;  </span><br><span class="line">  return &#123;  </span><br><span class="line">    name:&apos;Tony&apos;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(getPerson()); // &#123;name: &quot;Tony&quot;&#125;</span><br></pre></td></tr></table></figure><p></p><p>刪除「Carriage Return」並且補上一個「空白」分隔，讓程式碼好看一點。再補上一個大括號，讓語法解析器知道要開始使用物件實體語法。</p><h2 id="詞彙環境-Lexical-Environment"><a href="#詞彙環境-Lexical-Environment" class="headerlink" title="詞彙環境 (Lexical Environment)"></a>詞彙環境 (Lexical Environment)</h2><p>詞彙環境指的是程式碼在整個程式中的「實際位置」，在 JavaScript 中詞彙環境<strong>非常重要</strong>，但不是每個程式語言都是這樣。</p><p>在 JavaScript 中我們可能寫了一個 函式 function<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;  </span><br><span class="line">  var a = &apos;say hello&apos;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>這個函數內有個變數 <code>a</code> ，這個 <code>a</code> 詞彙上就是「<strong>在函式內</strong>」，但就像上面提到的，我們寫的程式碼需要被轉換成電腦看得懂的東西，也就是在轉換過程中，函式以及變數會被放到一個對應的記憶體位址，以及如何與其他的函式變數、程式互動。</p><blockquote><p>那為什麼 JavaScript 中詞彙環境非常重要呢?</p></blockquote><p>因為這可以幫助編譯器在轉換過程中做出某些決定。</p><h2 id="執行環境-Execution-Context"><a href="#執行環境-Execution-Context" class="headerlink" title="執行環境 (Execution Context)"></a>執行環境 (Execution Context)</h2><blockquote><p>A wrapper to help mange the code that is running.</p></blockquote><p>執行環境就有點像是一個管理者的角色，因為可能會有相當多的「<strong>詞彙環境</strong>」，但哪一個才是現在正執行的呢?</p><p>這就是執行環境所管理的東西。</p><p>執行環境包含了我們寫的程式碼、正在執行的程式碼，但不只包含這些，當目前程式碼正處於被編譯中時，編譯器除了執行我們的程式碼之外也能執行別的事情。</p><h2 id="名稱-值-配對-amp-物件"><a href="#名稱-值-配對-amp-物件" class="headerlink" title="名稱 / 值 配對 &amp; 物件"></a>名稱 / 值 配對 &amp; 物件</h2><p>在 JavaScript 的世界中，物件是相當重要的，我們必須先了解 JavaScript 中物件的意義。</p><p>例如：名稱(name) / 值(value) 配對</p><blockquote><p><strong>一個「名稱 / 值」配對，代表「一個名稱會對應到一個值」</strong></p></blockquote><p>一段正在執行的程式碼，同樣的名稱只會有一個；一個名稱只能被一個值定義，而這個值可以是更多名稱/值的配對。</p><p>這樣說很模糊，舉例一個簡單的「名稱 / 值」配對：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var brother = &apos;Tony&apos;</span><br></pre></td></tr></table></figure><p></p><p>這樣我們就有了<strong>宣告(var)、變數名稱(brother)、值(Tony)</strong>。</p><blockquote><p>那比較複雜的「名稱 / 值」配對呢?會是什麼樣子?</p></blockquote><p>記得剛才提到的<strong>物件</strong>嗎？在 JavaScript 中我們也可以同樣套用這個概念!<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var farm = &#123;  </span><br><span class="line">  farmName: &apos;nice Farm&apos;,  </span><br><span class="line">  owner: &apos;Tony&apos;,  </span><br><span class="line">  animals: &#123;  </span><br><span class="line">    dogs: 3,  </span><br><span class="line">    cats: 1  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>例如 farm 的值是一個「名稱 / 值」 的<strong>組合</strong>，farm 仍然是個名稱，但值是用{}包覆住的「名稱 / 值」<strong>組合</strong>。</p><p>繼續往下一層觀察， <code>farmName</code> 、 <code>owner</code> 也是「名稱 / 值」配對，注意到 <code>animals</code> 了嗎?它的值也是一個「名稱 / 值」 的<strong>組合。</strong></p><blockquote><p>JavaScript 中的物件，就是在說名稱 / 值配對的組合，而這個值本身可能是另一個物件</p></blockquote><h2 id="後記："><a href="#後記：" class="headerlink" title="後記："></a>後記：</h2><p>總算是把心得記錄完了，這篇主要記錄之後課程可能會多次提到的關鍵字，為了避免之後自己忘記這些關鍵字到底再說什麼，所以特別整理起來，這樣子之後回顧會比較容易。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      終於開始這個系列的第一篇，所以先來記錄一些比較基礎的名詞解釋，往後的課程中也會多次的提及這些詞彙，因此透過這篇記錄下來，避免自己金魚腦忘掉。
    
    </summary>
    
      <category term="前端學習" scheme="http://pvt5r486.github.io/categories/f2e/"/>
    
    
      <category term="JavaScriptWeird" scheme="http://pvt5r486.github.io/tags/JavaScriptWeird/"/>
    
      <category term="學習筆記" scheme="http://pvt5r486.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
</feed>
