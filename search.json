[{"title":"[從 0 開始的 Angular 生活]No.53 將 Angular Universal 專案部屬至 Heroku","url":"%2Ff2e%2F20190809%2F1267942988%2F","content":"\n## 前言\n當我們辛苦地做完網站後，總是會部屬到正式的伺服器上，而因為使用了 SSR 的技術， GitHub Pages 提供的靜態網頁服務已經不能滿足這個需求了，所以可以使用另一個常見的服務 [**Heroku**](https://www.heroku.com/home) 。\n\n![](https://images.unsplash.com/photo-1565213821230-76951fa8b5c7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 關於 Heroku\n這個部分不會著墨太多，僅會說明必要的部分，在此預設已經註冊一組 Heroku 的帳號了。\n\n如果要將專案部屬到 Heroku 可以使用 [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) 來達成，下載安裝後可以開啟終端機輸入 `heroku -v` 確定版本號。\n\n![Heroku CLI 安裝成功](https://i.imgur.com/pKZDXFK.png)\n\n## 調整 Angular Universal 專案\nHeroku 部屬的過程其實也不算太難，它有點像是一般開發過程時我們將專案推到 GitHub 般，所以是相當熟悉的。\n\n但我們目前並不能直接將專案直接推上 Heroku ，因為還需要進行一些**必要的調整**，不然它會死給你看。\n\n### 新增 Procfile 檔案\nProcfile 只是一個文件告訴 Heroku 要啟動你的應用程序需要執行什麼命令。所以需要在裡面填入：\n```\nweb: npm run start:heroku\n```\n接著就可以保存退出了。\n\n### 編輯 package.json\n接著要在 `scripts` 中新增一些指令：\n```\n\"start:heroku\": \"node dist/server\",\n\"postinstall\": \"npm run build:ssr\"\n```\n\n* 第一個命令會啟動由 Angular Universal 構建的 node server\n* `postinstall` 是 Heroku 在 npm 完成每個構建的所有依賴項安裝後自動運行的命令。\n\n**這麼一來前置作業都完成了，可以準備部屬到 Heroku 囉！**\n\n## 部屬到 Heroku\n在部屬之前，務必要確認所有的異動都已經被 commit ，這樣待會推到 Heroku 才會正常哦。\n\n**部屬步驟**\n1. 在終端機執行 `heroku login` ，按照指示操作並且透過瀏覽器登入\n\n![登入 Heroku](https://i.imgur.com/mTp3L5E.png)\n\n2. 在終端機執行 `heroku create` ，新增一台 Heroku 主機\n\n![新增一台 Heroku 主機](https://i.imgur.com/Hl2gOeg.png)\n\n從這個步驟得知我們建立了一台叫 `radiant-refuge-87634` 的 Heroku 主機。\n\n![git remomte -v](https://i.imgur.com/L3uZ6Si.png)\n\n3. 在終端機執行 `git push heroku master` ，將專案推到主機。\n\n![push 成功](https://i.imgur.com/XfsHzGb.png)\n\n> 這個步驟會耗費比較多的時間，如果沒有什麼意外的話通常是會 push 成功。\n\n![部屬成功](https://i.imgur.com/FDVEVwq.png)\n\n![SSR 的效果還在](https://i.imgur.com/gC5Vs4a.png)\n\n## 參考文章 & 程式碼\n推到 Heroku 的過程中其實是遇到蠻多困難的，幸好國外有人整理文章供後人學習：\n* [Deploying an Angular Universal App to Heroku](https://medium.com/augie-gardner/deploying-an-angular-universal-app-to-heroku-eca2b7966947)\n* [universal-starter-heroku](https://github.com/stephengardner/universal-starter-heroku)\n\n**程式碼**\n* [GitHub](https://github.com/pvt5r486/SSRDemo)\n* [推上 Heroku 的結果](https://radiant-refuge-87634.herokuapp.com/)\n\n## 小結\n其實這兩篇文章最初就是自己在想：如果我幫朋友以現代的網頁技術架一個網站，那麼我可以怎麼做的想法作為出發點。\n\n希望這兩篇簡單的筆記可以幫助到有同樣需求的人 & 未來金魚腦忘記的自己。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.52 使用 Angular Universal 讓網站 SEO 提升","url":"%2Ff2e%2F20190809%2F2128364955%2F","content":"\n## 前言\n使用 Angular 建立的網站是屬於 SPA (Single-Page Application) 單頁應用，是一種網路應用程式或網站的模型，它通過動態重寫目前頁面來與用戶互動，而非傳統的從伺服器重新載入整個新頁面。\n\n雖然現在 Google 的爬蟲已經可以看得懂 SPA 架構的網站，但其他的搜尋引擎不見得看得懂，因此使用 SSR (Server Side Render) 技術來輔助網站的 SEO 還是必要的。\n\n關於更詳細的名詞解釋可以參考 **[前後端分離與 SPA - Huli](https://blog.techbridge.cc/2017/09/16/frontend-backend-mvc/)** ，本文不會有太多著墨。\n\n![](https://images.unsplash.com/photo-1565191999001-551c187427bb?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## Angular Universal\n其他前端主流框架如 React 或 Vue 對於 SPA 不利於 SEO 都有相關的解決辦法，如：\n* React 可以使用 [Next](https://nextjs.org/)\n* Vue 可以使用 [Nuxt](https://zh.nuxtjs.org/)\n\n而 Angular 的解決方案就是使用 **[Angular Universal](https://angular.tw/guide/universal)**了。\n\n在早期 Angular 要使用 SSR 技術似乎是相當麻煩的要修改很多地方，但現在卻可以使用少少的幾行指令就達成！而且幾乎是手把手照著　Angular　官網的步驟做，是不是相當友善呢～\n\n### 建立新的空白專案\n在終端機內輸入 `ng new [projectName]` 就可以建立起一個 Angular 的專案，這個示範中建立了 SSRDemo 專案。\n\n![](https://i.imgur.com/OHleM62.png)\n\n![運行 SSRDemo](https://i.imgur.com/rRldqwW.png)\n\n### 加入 @nguniversal/express-engine 到專案中\n在終端機輸入以下指令：\n```\nng add @nguniversal/express-engine --clientProject SSRDemo\n```\n如此一來 Angular CLI 就會幫這個專案產生必要的檔案如： `app.server.module.ts` 。\n\n![執行指令後的異動](https://i.imgur.com/YUTHd6d.png)\n\n不難看出 Angular CLI 幫我們做了相當多的事情，在早期這可是需要自己手動進行的而且不太容易。\n\n### 運行 Universal Web 伺服器\n所有的準備工作都已經就緒，可以在終端機輸入以下指令啟動伺服器：\n```\nnpm run build:ssr && npm run serve:ssr\n```\n**會得到乍看之下與尚未使用 SSR 技術前一樣的結果：**\n![](https://i.imgur.com/NaADLQv.png)\n\n**但實際上原始的程式碼內已經大不相同了！**\n![使用 SSR](https://i.imgur.com/6tiiGTI.png)\n\n![不使用 SSR](https://i.imgur.com/OLz8EeS.png)\n\n> 不難看出有使用 SSR 技術的原始碼內多了不少內容，而這些內容就是要給搜尋引擎爬蟲看的。\n\n### 在 HTTP 中使用絕對位置\n在 Universal 應用中 HTTP 的 URL 必須是絕對位置，只有這樣 Universal 的 Web 伺服器才能處理那些請求。\n \n這意味著當執行在伺服器端時，要使用絕對 URL 發起請求，而在瀏覽器中，則使用相對 URL。\n\n在官網的 Angular 教學 (英雄範例) 中的服務都把請求送到了相對的 URL ，所以為了使其正常運作，需要額外建立 `HttpInterceptor` ，令其使用絕對 URL 發起請求。\n\n**建立 universal-interceptor.ts**\n```ts\nimport {Injectable, Inject, Optional} from '@angular/core';\nimport {HttpInterceptor, HttpHandler, HttpRequest, HttpHeaders} from '@angular/common/http';\nimport {Request} from 'express';\nimport {REQUEST} from '@nguniversal/express-engine/tokens';\n\n@Injectable()\nexport class UniversalInterceptor implements HttpInterceptor {\n\n  constructor(@Optional() @Inject(REQUEST) protected request: Request) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    let serverReq: HttpRequest<any> = req;\n    if (this.request) {\n      let newUrl = `${this.request.protocol}://${this.request.get('host')}`;\n      if (!req.url.startsWith('/')) {\n        newUrl += '/';\n      }\n      newUrl += req.url;\n      serverReq = req.clone({url: newUrl});\n    }\n    return next.handle(serverReq);\n  }\n}\n```\n\n**調整 app.server.module.ts**\n```ts\nimport {HTTP_INTERCEPTORS} from '@angular/common/http';\nimport {UniversalInterceptor} from './universal-interceptor';\n \n@NgModule({\n  ...\n  providers: [{\n    provide: HTTP_INTERCEPTORS,\n    useClass: UniversalInterceptor,\n    multi: true\n  }],\n})\nexport class AppServerModule {}\n```\n> 現在當伺服器發起每個 HTTP 請求時，該攔截器都會被觸發，並把請求的 URL 替換為由 Express 的 Request 物件給出的絕對位置。\n\n\n### 參考文件 & 程式碼\n一開始還沒實作時看了蠻多篇文章的，但距今都有一定的時日了，在前端技術迭代的如此迅速的情況下，一篇幾年前的文章參考價值就不那麼高了，但對於了解整個脈絡還是很有幫助的，因此還是列出大致上看過那些文章：\n\n* **[Angular 官方 - Universal](https://angular.tw/guide/universal)**\n* **[IT 鐵人邦 - Angular Universal](https://ithelp.ithome.com.tw/articles/10195360)**\n* **[保哥 - 如何在 Angular CLI 建立的專案加入 Angular Universal 伺服器渲染功能](https://blog.miniasp.com/post/2017/06/18/How-to-setup-Angular-Universal-in-an-Angular-CLI-project)**\n\n**程式碼**\n* **[GitHub](https://github.com/pvt5r486/SSRDemo)**\n\n## 小結\n結束了本篇的學習後，下一篇文章我們將試著將這份專案正式部屬到 Heroku 讓練習更加完整。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"HTTP Request 的取消與檔案上傳實作","url":"%2Ff2e%2F20190724%2F1338660786%2F","content":"\n## 前言\n前陣子因為專案需求，所以開始研究如何實踐 Drag & Drop 進行拖曳上傳，由於 Team Leader 的要求，希望目標是能達到跟 Google Drive 一樣的操作體感，於是遇到第一個問題，「**Google Drive 允許使用者取消上傳欸，啊我們要怎麼實作取消上傳**」？\n\n![](https://images.unsplash.com/photo-1563861826100-9cb868fdbe1c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 實際觀察 Google Drive\n**模仿的第一步就是先觀察**，所以到 Google Drive 實際操作一次檔案上傳的流程，並且透過開發者工具觀察。\n\n![上傳後取消上傳的 Request](https://i.imgur.com/Suue94c.png)\n\n雖然從這個角度仍無法得知 Google 這段期間在背後做了什麼，但是至少有了可以追查的線索：\n* 有個 HTTP Request 的 Status 在按下取消後變成了 `cancel`\n\n換句話說可以接著從「**如何取消 or 中斷 HTTP 的 Request**」開始著手。\n\n## XMLHttpRequest\n如果多嘗試這些關鍵字，最後會搜尋到再 [`Xhr`](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest) 內有個 [`.abort`](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/abort) 方法可以使用。\n\n![截自 MDN](https://i.imgur.com/7lPJAUT.png)\n\n## 方法嘗試階段\n有了可用的方法，接下來就是試著實作看看了，由於目前沒有後端開 API 給我們測試，在本機端使用 Json-Server 可能回應速度太快來不及按取消就完成了，於是理想方案可以串 [RANDOM USER](https://randomuser.me/) 這支好用的 API 來測試想法。\n\n**Code**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <button type=\"button\" id=\"sendRequest\">發送請求</button>\n  <button type=\"button\" id=\"cancelRequest\">取消請求</button>\n</body>\n<script src=\"./play2request.js\"></script>\n</html>\n```\n\n```js\nconst sendRequest = document.querySelector('#sendRequest');\nconst cancelRequest = document.querySelector('#cancelRequest');\nvar xhr = new XMLHttpRequest();\nsendRequest.addEventListener('click', () => {\n  xhr.open('get', 'https://randomuser.me/api/', true);\n  xhr.send();\n  xhr.addEventListener('load', function () {\n    console.log(xhr.responseText);\n  }, false);\n}, false)\n\ncancelRequest.addEventListener('click', () => {\n  console.log('取消請求');\n  xhr.abort();\n}, false)\n```\n\n![按下發送後馬上取消](https://i.imgur.com/AHutukB.png)\n\n![取消後確實不再取得資料](https://i.imgur.com/8wQdwSz.png)\n\n**至此，足以驗證 `xhr.abort()` 確實是可以中斷請求的發送，那麼如果是用在檔案上傳呢？伺服器真的會因為前端中斷的　HTTP 的請求就停止檔案上傳嗎？**\n\n為了驗證想法，我們必須自己實作一個簡易的 node.js 伺服器。\n\n## 使用 node.js 實作一個簡易的檔案上傳功能\n基於「方法嘗試階段」最後的結論，必須實作一個伺服器才能滿足我的好奇心。\n\n但是我又不太熟 node.js 又有點懶，因此在這裡感謝 [Ray](https://hsiangfeng.github.io/) 幫我產出一個簡易的模板。\n\n至於 node.js 該怎麼實作檔案上傳以及怎麼開 API 我就不多著墨了，畢竟這不是主要的內容。\n\n於是一番努力後，我們有了最基本的 code ，試著調整並搭配剛才的程式碼。\n\n**code**\n```js\nconst express = require('express');\nvar cors = require('cors');\nconst app = express();\nconst multer = require('multer');\nconst path = `./uploads`;\nvar storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, path)\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.originalname);\n  }\n});\n\nvar upload = multer({ storage: storage }).any()\napp.use(cors());\n\napp.post('/upload', function (req, res) {\n  upload(req, res, function (err) {\n    if (err instanceof multer.MulterError) {\n      console.error(err);\n    } else if (err) {\n      console.error(err);\n    }\n    res.json({ message: '上傳完成'});\n  })\n});\n\napp.listen(3000, function () {\n  console.log('Example app listening on port 3000!');\n});\n```\n\n![發送請求 & 接收到回應](https://i.imgur.com/9WbP7nR.png)\n\n![確實有收到檔案](https://i.imgur.com/sXLtfy8.png)\n\n**很快地發現了第一個問題：**\n* 當按下取消請求後，請求確實被終止了，但為什麼後端還是有接收到檔案？\n  * 原因是檔案的上傳並不是直接就上傳一個檔案，而是會分解成很多個封包進行傳送，所以再**取消**請求後，後端仍然會收到殘缺的檔案。\n\n![大型檔案取消請求後](https://i.imgur.com/UYnXnwA.png)\n\n![後端仍然接收到，但大小不正確](https://i.imgur.com/rEvdxBa.png)\n\n**總結現況得出以下結論：**\n* 需要得知前端何時按下取消鈕，這樣才能做出相應的處置，像是刪除不完整的檔案。\n\n## 方法嘗試階段\n於是乎我們又回到了方法嘗試階段，老實說這裡我嘗試了很多方法，仍然無法得知前端何時按下`取消請求`，後來不得已把問題整理乾淨後上[前端社群](https://www.facebook.com/groups/f2e.tw/permalink/2272532992784053/)發問。\n\n最後得知我要的答案或許在 [multer 的 issue 內](https://github.com/expressjs/multer/issues/259?fbclid=IwAR2LIvNnTiUDvafrCx2EM1q552_q0ykqxSNVR7uNtYjXuGB6uRtphISStro)\n\n當然這個過程是不斷的反覆測試、修改的，最終我也實作檔案上傳比較常見的流程：\n1. 當檔案上傳時，會先被放在 `temp` 資料夾\n2. 如果使用者取消請求，則進行刪除\n3. 如果使用者完成上傳，則移動到 `uploads` 資料夾\n\n**另外再進行檔案刪除時，也碰到一個雷：**\n當使用 [fs.unlink()](https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback) 進行檔案的刪除時：\n* VS Code 內的檔案瀏覽器重新整理後的確會看到檔案已經被刪除\n* 但是 Windows 的檔案總管以及終端機指令仍然可以發現檔案還是存在，直到關閉 node.js 伺服器\n\n這個地雷最終也獲得了詳細說明，[詳見此](http://man7.org/linux/man-pages/man2/unlink.2.html)，感謝[胡立](https://medium.com/@hulitw)大大指點。\n\n> 截自連結部分敘述\nunlink() deletes a name from the filesystem.  If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available for reuse.\n\n**所以我們又有了新的實作目標，接著又回到實作階段了！**\n\n## 改良檔案上傳的程式碼\n基於上一階段的結論，所以我使用社群內前輩的建議作法，上傳後先放在 `temp` 資料夾，等到確定上傳完成才移動到 `uploads` 資料夾，而 `temp` 資料夾就可以用各種做法定期清除或者自然等伺服器重啟清除。\n\n而我最終版本的 code 如下：\n\n**node.js**\n```js\nconst express = require('express');\nvar cors = require('cors');\nvar fs = require('fs');\nconst app = express();\nconst multer = require('multer');\nconst path = `./tmp`;\nvar storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, path)\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.originalname);\n    req.filename = file.originalname;\n  }\n});\n\nvar upload = multer({ storage: storage }).any()\napp.use(cors());\n\napp.post('/upload', function (req, res) {\n  req.on('aborted', () => {\n    console.log('req aborted by client');\n    fs.unlink(`${path}/${req.filename}`, function (err) {\n      if (err) throw err;\n      console.error('已經刪除檔案!');\n    });\n  })\n\n  upload(req, res, function (err) {\n    if (err instanceof multer.MulterError) {\n      console.error(err);\n    } else if (err) {\n      console.error(err);\n    }\n    let targetPath = `./uploads/${req.filename}`;\n    fs.rename(`${path}/${req.filename}`, targetPath, function (err) {\n      if (err) throw err;\n      console.log('移動完成');\n    });\n\n    res.json({ message: '上傳完成'});\n  })\n});\n\napp.listen(3000, function () {\n  console.log('Example app listening on port 3000!');\n});\n```\n\n**前端部分**\n```js\nconst sendRequest = document.querySelector('#sendRequest');\nconst cancelRequest = document.querySelector('#cancelRequest');\nconst fileUploader = document.querySelector('#file-uploader');\n\nlet form = new FormData();\nfileUploader.addEventListener('change', (e) => {\n  form.append(\"file\", e.target.files[0])\n});\n\nvar xhr = new XMLHttpRequest();\nsendRequest.addEventListener('click', () => {\n  xhr.open('post', 'http://localhost:3000/upload', true);\n  xhr.send(form);\n  xhr.addEventListener('load', function () {\n    console.log(xhr.responseText);\n  }, false);\n}, false)\n\ncancelRequest.addEventListener('click', () => {\n  console.log('取消請求');\n  xhr.abort();\n  form = new FormData();\n}, false)\n\n\n\nfileUploader.addEventListener('change', (e) => {\n  form.append(\"file\", e.target.files[0])\n});\n```\n\n![上傳大檔案發送後取消](https://i.imgur.com/We9h53x.png)\n\n![上傳小檔案完成](https://i.imgur.com/cXskbXL.png)\n\n> 特別要注意的是，這邊的 code 終究只是我拿來驗證想法而寫的 code ，因此有很多狀況沒有考慮到，所以不建議直接把這段 code 直接複製拿去用。\n\n其實做到這邊已經功德圓滿了～我想知道的都已經知道了，但我們專案都是使用 Angular 寫的，那麼再 Angular 該如何取消請求呢？\n\n## Angular 取消請求\n再 Angular 專案中會使用 `.subscribe()` 方法來訂閱某個 API 的結果，而要取消請求則可以使用 `.unsubscribe()` 方法，具體實作如下：\n\n```html\n<input type=\"file\" id=\"file-uploader\" name=\"file\" (change)=\"selectFile($event)\"/>\n<button type=\"button\" id=\"sendRequest\" (click)=\"sendRequest()\">發送請求</button>\n<button (click)=\"cancelSub()\">取消訂閱</button>\n```\n\n```js\nimport { Component, ViewChild, ElementRef, OnInit } from '@angular/core';\nimport { HttpClient, HttpRequest } from '@angular/common/http';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent implements OnInit {\n  data;\n  subscript: Subscription;\n  form: FormData;\n  constructor(private httpClient: HttpClient) {\n    this.subscript = new Subscription();\n  }\n  ngOnInit() {\n  }\n\n  cancelSub() {\n    this.subscript.unsubscribe();\n  }\n\n  selectFile(e) {\n    this.form = new FormData();\n    this.form.append('file', e.target.files[0]);\n  }\n\n  sendRequest() {\n    this.subscript = this.uploadFile().subscribe((result) => {\n      this.data = result;\n      console.log(this.data);\n    },\n    (error) => {\n      console.log('錯誤資訊', error);\n    });\n  }\n\n  uploadFile() {\n    return this.httpClient.post('http://localhost:3000/upload', this.form);\n  }\n}\n```\n\n這邊運行的結果會跟上一段的結論一樣～就不反覆截圖了。\n\n## 結論\n其實寫程式我覺得就是一直重複「方法嘗試階段」以及「實作階段」。\n\n而這個過程中我覺得最累也最有趣同時也最傷腦筋的就是「方法嘗試階段」，只要過了這個階段，後面的「實作階段」就相對單純很多。\n\n而當「實作階段」結束後肯定會玩看看，如果出現預期外的結果，就回到「方法嘗試階段」，周而復始。","tags":["Node.js"],"categories":["前端學習"]},{"title":"Base64 是編碼不是加密 & 用 Node.js 實作簡易 RSA 非對稱式加密","url":"%2Ff2e%2F20190711%2F4123217379%2F","content":"\n## 前言\n因為專案需求所以有稍微用到一些密碼學的部分，前幾天團隊內的同事在研究的時候，我也好奇的上前圍觀，但才疏學淺，居然脫口說出 base64 是加密的一種然後被噹爆，超想躲進土裡的啊啊啊！！\n\n所以為了雪恥，決定稍微研究一下 RSA 非對稱式加密，以及整理一下 Base64 只是**編碼**不是**加密**這件事情。\n\n![](https://images.unsplash.com/photo-1556742205-e10c9486e506?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## Base64\n在說明之前可以先從 WIKI 上了解 [Base64 是什麼樣的東西](https://zh.wikipedia.org/wiki/Base64)。\n\n**懶人包： Base64 是編碼的一種，並沒有 Base64 加密這回事。**\n\n> 以下節錄自 **WIKI**：\nBase64 是一種基於 64 個可列印字元來表示二進位資料的表示方法，常用於在通常處理文字資料的場合，表示、傳輸、儲存一些二進位資料，包括MIME的電子郵件及 XML 的一些複雜資料。\n\n而如果我們有仔細看 WIKI 的話，會發現這份文檔皆是使用 Base64 **編碼**而非 Base64**加密**，從這邊其實就可以看出一些蛛絲馬跡。\n\n## 加密？編碼？\n這三者無論是用中文、英文來看都有相當大的差異：\n1. 加密 (Encrypt)\n2. 編碼 (Encode)\n\n到底為什麼很多人會把這三種完全不一樣的東西都當成加密呢？\n\n> 主要是因為透過這三種方式處理過後的資料，都會長的跟原本不一樣，一般人無法直接用肉眼辨別，就會讓人覺得像是被加密處理過的天書。\n\n然而並不是把資料變成人看不懂的東西就可以稱為加密，身為一個工程師，如果搞不清楚箇中差異是會被笑的。 (就跟我被噹爆一樣...)\n\n所幸這部分已經有前輩整理好了，以下敘述引用自 [m157q 前輩的部落格 - 如何區分加密、壓縮、編碼](https://blog.m157q.tw/posts/2017/12/23/differences-between-encryption-compression-and-encoding/)，感謝前輩辛苦整理的資料。\n\n### 加密 (Encrypt)\n**對稱式加密 (Symmetric Encryption)**：\n* 首先產生一個新的字串作為密鑰，也就是一把鑰匙\n  * 可以想像成，加密演算法幫你打造出你給它的這把密鑰才可以開啟的寶箱，幫你把原文放入寶箱後，用這把密鑰上鎖，上鎖後的寶盒就是密文，看不到裡面的東西是什麼\n  * 這種只有一把鑰匙的加密演算法被稱為**對稱式加密 (Symmetric Encryption)**\n\n然而對稱式加密的安全性以及在實際應用上不夠理想，於是出現了安全性更高，應用範圍更廣的**非對稱式加密 (Asymmetric Encryption)**\n\n**非對稱式加密 (Asymmetric Encryption)**：\n* 非對稱式加密演算法會有兩把鑰匙，分別為公鑰、私鑰\n* 非對稱式加密除了可以做到加密以外，還可以生成數位簽章，確認密文的傳送方身份真的是本人\n\n> 兩者各有各的優缺點，所以實際應用上通常都是視情況而定。\n\n**常見演算法**\n* 對稱式：DES 、 3DES 、 AES\n* 非對稱式：RSA 、 DSA 、 ECC\n\n根據這一段加密的介紹，再回頭過來想使用 Base64 的場景，可推出如下結論：\n**使用 base64 的時候不需要密鑰，而且任何人編碼的 base64 訊息，誰都可以經過 base64 解碼回來，所以 base64 不是加密。**\n\n### 編碼 (Encoding)\n編碼牽涉的範圍非常廣，如:\n* 字元編碼 (Character Encoding)\n* 音訊編碼 (Audio Encoding)\n* 視訊編碼 (Video Encoding)\n\n而 Base64 屬於字元編碼的部分，而**編碼**的特性為：\n* 將原文轉換成另外一種表達方式\n* 不需要密鑰，只要知道使用哪個編碼演算法，任何人都可以解碼\n  * 這也是單純編碼被拿來誤用成加密演算法最危險的地方，因為完全不需要花時間猜密鑰\n* 不同的編碼演算法有不同的特性\n  * 錯誤偵測 (Error Detection)\n    * 檢查訊息在經過傳送後是否已經改變\n  * 錯誤校正 (Error Correction)\n    * 自動修正在經過傳送後錯誤的內容\n  * 方便資料進行傳輸\n    * 以不同的形式表示相同的資料\n    * 例如: base64 就把二進位的資料用 ASCII 來表示\n\n**常見演算法**\n* [Base64](https://zh.wikipedia.org/wiki/Base64)\n* [URLEncode](https://blog.xuite.net/dizzy03/murmur/44843892-%5B%E8%BD%89%5D+%E6%B7%B7%E4%BA%82%E7%9A%84+URLEncode)\n* [hamming code](https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E7%A0%81)\n\n## RSA 非對稱式加密\n由於看同事們那個時候再弄的範例有公鑰 (public Key) 、私鑰 (private Key) 之分，藉由上面的介紹可知這是一種非對稱式的加密方式，因此更進一步 Google 後，決定使用 node.js 來簡單實作看看 **RSA 非對稱式加密**。\n\n有關 RSA 非對稱式加密的部分，可以參考：\n* [網路安全(1) - 基礎密碼學](https://blog.techbridge.cc/2017/04/16/simple-cryptography/)\n* [RSA加密演算法](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)\n* [[Day27] 非對稱金鑰加密系統(RSA)](https://ithelp.ithome.com.tw/articles/10188824)\n\n### 實作\n技術實作方面，得知 Node.js 已經有相關的加密包 (crypto) 可以使用，於是可以針對這個關鍵字搜尋，得出不少可用資源，整理如下：\n* [Node.js 进阶：5 分钟入门非对称加密方法](https://www.cnblogs.com/chyingp/p/nodejs-asymmetric-enc-dec.html)\n  * 本文範例是基於此改良\n* [Node.js 官方文件 - crypto](https://nodejs.org/api/crypto.html)\n\n**直接上完整程式碼**\n```js\nconst crypto = require('crypto');\n\nconst priPassword = `Nice Password`;\nlet message = `Hello`;\nplay2RSA(message, priPassword);\n\nasync function play2RSA(message, priPassword) {\n  const keyPair = await makeKeyPair(priPassword);\n  console.log('公鑰：',　keyPair.publicKey);\n  console.log('私鑰：',　keyPair.privateKey);\n  let crypted = encrypt(message, keyPair.publicKey);\n  console.log('加密結果：',　crypted.toString('base64'));\n  try {\n    let decrypted = decrypt(crypted, keyPair.privateKey, priPassword);\n    console.log('解密結果：', decrypted.toString());\n  } catch (error) {\n    console.log('解密失敗');\n  }\n};\n\n// 加密方法\nfunction encrypt(data, key) {\n  return crypto.publicEncrypt(key, Buffer.from(data));\n}\n\n// 解密方法\nfunction decrypt(encrypted, key, priPassword) {\n  const keyObj = {\n    key: key,\n    passphrase: priPassword\n  }\n  return crypto.privateDecrypt(keyObj, encrypted);\n}\n\n// 建立 KeyPair, 並單獨針對私鑰再進行一次加密\nfunction makeKeyPair(priPassword) {\n  return new Promise((resolve, reject) => {\n    crypto.generateKeyPair('rsa', {\n      modulusLength: 4096,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem',\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem',\n        cipher: 'aes-256-cbc',\n        passphrase: priPassword\n      }\n    }, (err, publicKey, privateKey) => {\n      const keyPair = {\n        publicKey: publicKey,\n        privateKey: privateKey\n      }\n      err !== null ? reject(err) : resolve(keyPair);\n    });\n  });\n}\n```\n\n這段程式主要是按照希望的格式產生公、私鑰之後，接著使用公鑰加密 `message` 變數的字串，最後在使用私鑰解密。\n\n但因為私鑰的部分，我額外的上了一層加密，所以在進行解密的時候需要額外帶入私鑰的密碼才可以順利進行。\n\n* [範例線上試玩](https://repl.it/repls/RoyalblueOurConnection)\n","tags":["Node.js"],"categories":["前端學習"]},{"title":"滿月紀念","url":"%2Fnote%2F20190708%2F724990059%2F","content":"\n## 前言\n時間過得很快，不知不覺的我就滿月了。期間不斷進行的是與團隊成員的磨合，而之前提到的 Side Project 也如期地進行中。\n\n畢竟是優先度較低的 Side Project ，所以對於其他團隊成員來說，都是運用比較零碎的時間來做，主要還是處理主力專案。\n\n而我因為還沒正式接觸到公司專案，自然重心是放在這個 Side Project 上。\n\n![還有好一段要走](https://images.unsplash.com/photo-1562337680-64ccd42beca3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80)\n\n## 磨合 & 心境\n如上面提到的，這是個團隊的 Side Project ，意味著可以自由地玩很多新東西。\n\nTeam Leader 決定導入 [prettier](https://prettier.io/) 並且提交 `commit` 時觸發 `prettier` 的自動格式化，最後在 GitLab 上 進行 CICD 的檢查，達成團隊的 Coding Style 一致。\n\n然而在開發習慣上，因為之前都是單兵作業，所以比較少顧慮到可能會有其他團隊成員來維護同一份 Code 的情形。\n\n這也導致了寫某些程式時缺少了比較長遠的思考，很多部分都是後來發現「**不能這樣寫、這麼寫不夠好**」而又回頭修改。\n\n團隊基本上是使用 Angular 搭配 TypeScript 進行開發的，而我之前在學習前端時都是使用 JavaScript ，在思維上有一點差異，這也是我目前需要學習與磨合的地方。\n\n### 舉例來說\n在敏捷開發 Sprint 的第一周，我負責的是串接某一支自己 Mock 出來的 API，裡面的內容雖然我有整理好一份文件，但呼叫 API 後的內容仍然只有我一個人知道，團隊的其他成員完全不知道呼叫這支 API 後會回傳什麼結果，導致後續維護不方便。\n\n因為：\n* 如果要知道這支 API 會回傳什麼就得呼叫它，並印出來\n* 翻閱文件\n\n但這對之前的我來說是一件很正常的事情：\n> 接 API 如果不知道內容是什麼，印出來不就好了嗎？或者看文件也行，上面都有寫。\n\n**這樣的確可以，但對團隊來說，這還不夠好。**\n\n所以實作一個 class 並且透過 TypeScript 將該變數型別設定為它，如此一來就可以在接到 API 傳來的資料後，使用「.」看到這個物件下有什麼屬性、方法能使用。\n\n搭配適當的命名就可以讓維護的人明白這支 API 會回傳的內容有哪些。\n\n而這也只是與團隊磨合的一小部分而已，我還必須持續透過這個 Side Project 了解到許多團隊協作的眉角。\n\n### 心境\n在開發上當然也遇到了一些困難，自己歸納後最主要的原因果然還是：\n* 不夠熟悉 Angular 以及 TypeScript 的原理\n\n在 Sprint 的第一周時，我先行使用原生的 JavaScript 快速的把原型給搭建出來，像是 Mock API 、 GitLab API 的串接整理、圖表繪製等等...，過程都蠻順利的，也很少麻煩到團隊內的前端同事。\n\n但在實際轉換成 Angular 時，卻遇到了不少自己想不透的問題需要請教同事，這讓我有點不好意思。\n\n> 像是上面提到的協作問題、舊版本 `ng2charts` 的 Bug 、寫測試、還有一些特殊名詞 & 觀念問題。\n\n最終總算是在交作業的前一天完成了，幸好同事也不厭其煩地與我一同排除掉這些問題，真的是非常感謝。\n\n但我也希望自己能夠早日解除這種狀態，實在是有點擔心自己試用期不會過 (汗)\n\n## 小結\n其實還有很多族繁不及備載的芝麻蒜皮小事，像是命名與程式寫完之後該怎麼調整才能讓結構看起來易讀，這些都是值得我去努力的東西。\n\n然後也借了一本[無瑕的程式碼 番外篇：專業程式設計師的生存之道](https://www.books.com.tw/products/0010598217)，書名看起來就像是我這輩子絕對不會看的東西，但我終究是借來看了。\n\n> **那個當初連 「Hello World」 印出都有困難的人去哪了？**\n\n**一個人可以改變這麼多，每當回頭想起，我還是覺得很不可思議。**","tags":["里程碑"],"categories":["雜記"]},{"title":"[從 0 開始的 Angular 生活]No.51 如何在 Angular 內使用第三方套件","url":"%2Ff2e%2F20190628%2F4197344469%2F","content":"\n## 前言\n在專案的開發中有些時候為了應付特殊的需求會安裝一些第三方的套件，避免重複造輪子。而這第三方套件很可能會是 CSS 框架或者是一些 很方便的 library 等等，而我們要如何在 Angular 環境中使用它們呢？本篇將介紹 Bootstrapt4 以及 json-server 如何再 Angular 的環境下使用。\n\n## 建立新的 Angular 專案\n都已經是 No.51 了，我想對於建立新的 Angular 專案並不是什麼太困難的事情。\n\n執行 `ng new pluginDemo` ，建立起本次範例的專案。\n\n![](https://i.imgur.com/06J2Xik.png)\n\n## 安裝 CSS 框架 - Bootstrap4\n接著來到 [Bootstrap4 的官方](https://getbootstrap.com/)，看看如何取得 Bootstrap4 吧！\n\nBootstrap4 提供下列使用方式：\n* 以 CDN 的方式使用\n* 以 npm / yarn 的方式取得\n\n### 以 CDN 的方式使用 Bootstrap4\n以這個情境來講，一定是整個專案都希望可以用 Bootstrap4 的東西，因此可以在 `src/styles.scss` 這裡做一些調整，這隻檔案會影響到整個 Angular 專案的 CSS 。\n\n**src/styles.scss**\n```scss\n/* You can add global styles to this file, and also import other style files */\n@import url('https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css');\n```\n如果要完整的使用 Bootstrap4 所有的東西，也必須引入相關的 js 檔案才行， js 檔案可以在 `index.html` 內引用。\n\n```html\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <title>PluginDemo</title>\n  <base href=\"/\">\n\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n\n<body>\n  <app-root></app-root>\n  <script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"\n    integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\"\n    crossorigin=\"anonymous\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\"\n    integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\"\n    crossorigin=\"anonymous\"></script>\n  <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\"\n    integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\"\n    crossorigin=\"anonymous\"></script>\n</body>\n\n</html>\n```\n\n接著隨意地找 Bootstrap4 官網上的範例，貼在 appComponent 的 Template 上，測試有無效果。\n\n例如貼上 [modal 的範例程式碼](https://getbootstrap.com/docs/4.3/components/modal/)\n\n![成功執行 modal](https://i.imgur.com/lsv9eFQ.png)\n\n### 以 npm 或 yarn 的方式使用 Bootstrap4\n這部分因為 npm 或 yarn 使用的方式差不多，所以我就只使用 yarn 來示範。\n\n先移除方才所有引入的 js 檔以及 import 進 `src/styles.scss` 的檔案。\n\n接著可以參考[ Package managers ](https://getbootstrap.com/docs/4.3/getting-started/download/#package-managers)得知可以使用 `yarn add bootstrap` 取得 Bootstrap4。\n\n![](https://i.imgur.com/17xvXoR.png)\n\n![package.json 內的紀錄](https://i.imgur.com/RUv01iq.png)\n\n**接著我們一樣要引用這些下載好的檔案。**\n\n![src/styles.scss](https://i.imgur.com/6CVEH8z.png)\n\n可以看到透過這種方式，使用 Bootstrap4 的彈性就更大了，可以單獨選擇想要使用 Bootstrap4 的某部分。但在這裡為了示範，選擇 `bootstrap.scss` 即可。\n\n接著還需要把 Bootstrap4 本身依賴的 js 檔案也引入才可以正常使用所有的功能，但這裡還有個前提是：\n**Bootstrap4 也依賴著 jQuery** ，因此我們還需要額外使用 yarn 下載 jQuery ，才能完整使用 Bootstrap4 。\n\n**以下是 Bootstrapt4 中有使用到 JavaScript 控制的元件：**\n* Alerts for dismissing\n* Buttons for toggling states and checkbox/radio functionality\n* Carousel for all slide behaviors, controls, and indicators\n* Collapse for toggling visibility of content\n* Dropdowns for displaying and positioning (also requires Popper.js)\n* Modals for displaying, positioning, and scroll behavior\n* Navbar for extending our Collapse plugin to implement responsive behavior\n* Tooltips and popovers for displaying and positioning (also requires Popper.js)\n* Scrollspy for scroll behavior and navigation updates\n\n來到 [jQuery 官方](https://jquery.com/download/)得知可以使用 `yarn add jquery` 下載。\n\n**這部分的調整則必須到 `angular.json` 內的 `scripts` 設定了。** \n```json\n\"scripts\": [\n  \"./node_modules/jquery/dist/jquery.min.js\",\n  \"./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js\",\n  \"./node_modules/bootstrap/dist/js/bootstrap.min.js\"\n],\n```\n\n這邊使用 `bootstrap.bundle.min.js` 原因是 Bootstrap4 官方表示 「Our bootstrap.bundle.js and bootstrap.bundle.min.js include Popper」，也就是只要引入這隻檔案即可。\n\n接著運行開發伺服器確認結果吧！\n\n![設置成功](https://i.imgur.com/c33lhpC.png)\n\n## 安裝 json-server\n會使用到這個功能是因為有時候專案開發時，配合的後端不一定會很快就提供 API 給前端串接，為了不浪費時間，前端可以自行透過 json-server 快速 Mock 出一個 API 供自己測試使用。\n\n而[如何在一般的環境下使用 json-server ](https://pvt5r486.github.io/f2e/20190625/2362558207/)也已經再另外一篇介紹過，因此這裡就不會這麼仔細介紹，僅介紹如何安裝使用。\n\n[json-server GitHub 官方](https://github.com/typicode/json-server#getting-started)顯然地並沒有提供 yarn 方式的下載，只能使用 npm 。\n\n**官網提供的安裝方式是全域的**\n```\nnpm install -g json-server\n```\n\n**但如果想被記錄在 package.json 下的話可使用**\n```\nnpm install json-server --save-dev\n```\n\n![](https://i.imgur.com/vB7Pnmx.png)\n\n### 建立運行 json-server 需要的檔案\n如 json-server 官方的起手範例，建立一個 `db.json` 檔案，並貼上如下內容：\n```json\n{\n  \"posts\": [\n    { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n  ],\n  \"comments\": [\n    { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n  ],\n  \"profile\": { \"name\": \"typicode\" }\n}\n```\n\n接著再 package.json 的 `script` 內加入指令，方便使用：\n```json\n\"scripts\": {\n  \"ng\": \"ng\",\n  \"start\": \"ng serve\",\n  \"build\": \"ng build\",\n  \"test\": \"ng test\",\n  \"lint\": \"ng lint\",\n  \"e2e\": \"ng e2e\",\n  \"mock-server\": \"json-server db.json --port 3010\"\n},\n```\n**先運行看看吧～**\n\n![](https://i.imgur.com/9lGDdbK.png)\n\n雖然是成功了，但很快的我們發現了第一個問題：\n* 成功啟動 json-server 後就不能輸入 `ng serve` 了，怎麼辦？\n\n在這裡我們要額外安裝一個叫做 [concurrently](https://www.npmjs.com/package/concurrently) 的套件，它允許多進程以異步並行而​​非順序同步方式運行。\n\n**安裝方式**\n```\nnpm install concurrently --save-dev\n```\n\n安裝完成後，打開 package.json 進行指令的設定：\n```json\n\"scripts\": {\n  \"ng\": \"ng\",\n  \"start\": \"ng serve\",\n  \"build\": \"ng build\",\n  \"test\": \"ng test\",\n  \"lint\": \"ng lint\",\n  \"e2e\": \"ng e2e\",\n  \"mock-server\": \"json-server db.json --port 3010\",\n  \"dev\": \" concurrently \\\"ng serve\\\" \\\"npm run mock-server\\\" \"\n},\n```\n\n**最後，實際運行看看吧～**\n![npm run dev](https://i.imgur.com/Fa8WvPE.png)\n\n運行成功～這樣子就可以同時運行 Angular 的開發伺服器以及 json-server 囉～\n\n**參考資料**\n* [Configuring your local mock server in 10 minutes](http://angular-friday.com/2017/08/20/configuring-your-mock-server/#page)\n* [使用 JSON Server 快速模擬 Restful API](https://andy6804tw.github.io/2018/02/01/json-server-intro/)\n* [json-server 常用自定义路由和简单配置](https://blog.csdn.net/weixin_40817115/article/details/81281454)\n\n**原始碼** - [GitHub](https://github.com/pvt5r486/pluginDemo)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"json-server 與 chart.js","url":"%2Ff2e%2F20190625%2F2362558207%2F","content":"\n## 前言\n好一陣子沒有寫 Blog 了，原因也是因為初階的 Angular 學到一個段落了，團隊的 Leader 決定讓隊伍內的成員們以敏捷開發的方式跑看看一個 Side Project ，順便讓我學習如何與團隊合作一個專案。\n\n而這篇文章主要是簡單記錄自己如何使用 json-server 快速 Mock 一個 API 讓自己串接，並且使用 chart.js 繪製出堆疊長條圖。\n\n![](https://images.unsplash.com/photo-1561336635-c0e118ad72a0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1055&q=80)\n\n## 在專案中使用 json-server\n來到 [json-server 的 GitHub](https://github.com/typicode/json-server) 查看如何使用。\n\n### 下載 json-server\n**使用步驟如下：**\n* 如果是新的專案而且沒有 package.json 檔\n  * 輸入 `npm init` 建立 package.json 檔\n* 輸入 `npm install -g json-server` 安裝 json-server\n\n### 建立 db.json\n接著新增 `db.json` 檔，內容可先複製官網範例進行參考：\n```json\n{\n  \"posts\": [\n    { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n  ],\n  \"comments\": [\n    { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n  ],\n  \"profile\": { \"name\": \"typicode\" }\n}\n```\n\n**輸入 `json-server db.json` 運行 json-serve ，等候呼叫 API**\n\n`db.json` 檔就是當呼叫 API 時會傳回那些資料的檔案，舉例來說：\n* 預設狀態下，在網址列輸入 `http://localhost:3000/posts`\n  * 會傳回 `{ \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }`\n\n這邊因為之後要使用 chart.js 進行圖表繪製，所以我另外有準備資料，因為跟工作有關就不貼上來了。\n\n### 自訂路由\n大多時候 json-server 的預設範例是滿足不了我們的。\n\n舉例來說，我想要 Mock 的 API 路徑希望是：\n```\n/api/v1/issues/analysis?gid=:gid&sDate=:sDate&eDate=:eDate\n```\n\n這時候就需要自訂路由了！\n\n**新增 `route.json` 檔案**\n\n接著在裡面貼上官網的範例：\n```json\n{\n  \"/api/*\": \"/$1\",\n  \"/:resource/:id/show\": \"/:resource/:id\",\n  \"/posts/:category\": \"/posts?category=:category\",\n  \"/articles\\\\?id=:id\": \"/posts/:id\"\n}\n```\n如上設定後，對應結果如下：\n* 輸入 `/api/posts` # → /posts\n* 輸入 `/api/posts/1` # → /posts/1\n* 輸入 `/posts/1/show` # → /posts/1\n* 輸入 `/posts/javascript` # → /posts?category=javascript\n* 輸入 `/articles?id=1` # → /posts/1\n\n**找出規則後，修改 `route.json` 變成我們要的結果。**\n```json\n{\n  \"/api/v1/issues/analysis\\\\?gid=:gid&sDate=:sDate&eDate=:eDate\": \"/api\",\n  \"/api/v1/issues/analysis\": \"/api\"\n}\n```\n\n### 自訂配置\n為了更方便使用，也可以自行配置 json-server 。\n\n**新增 json-server.json**\n\n並且在裡面輸入：\n```json\n  \"port\": 5000,              //自定 port\n  \"watch\": true,             //監聽改動\n  \"routes\": \"route.json\"     //路由配置路徑\n```\n\n因為只有使用到這些配置，更多配置請參考官方 GitHub 文件。\n\n配置已經完成了，最後在 `package.json` 中加入以下指令：\n```json\n\"scripts\": {\n  \"mock\": \"json-server --c json-server.json db.json\"\n},\n```\n\n**之後只需要執行 `npm run mock` 指令即可運行以上這些配置囉！**\n\n**參考文件**\n* [json-server GitHub](https://github.com/typicode/json-server)\n* [json-server常用自定义路由和简单配置](https://blog.csdn.net/weixin_40817115/article/details/81281454)\n\n## 在專案中使用 chart.js\n先到 [chart.js](https://www.chartjs.org/docs/latest/) 官方了解如何使用，發現有兩種使用方式：\n* 使用 [CDN](https://www.jsdelivr.com/package/npm/chart.js)\n* 透過 [npm 安裝](https://github.com/chartjs/Chart.js/releases/tag/v2.8.0)\n\n**為了方便，這裡我使用了 CDN 的方式使用 chart.js**\n\n### 參考官方建立一個範本\n由於我想畫的是堆疊柱狀圖，但我們依然可先參考官方的[起手範例](https://www.chartjs.org/docs/latest/getting-started/)，先行建構一個範本。\n\n```html\n<canvas id=\"myChart\"></canvas>\n```\n\n```js\nvar ctx = document.getElementById('myChart').getContext('2d');\nvar chart = new Chart(ctx, {\n    // The type of chart we want to create\n    type: 'bar',\n    // The data for our dataset\n    data: {\n        labels: ['January', 'February', 'March', 'April', 'May', 'June', 'July'],\n        datasets: [{\n            label: 'My First dataset',\n            backgroundColor: 'rgb(255, 99, 132)',\n            borderColor: 'rgb(255, 99, 132)',\n            data: [0, 10, 5, 2, 20, 30, 45]\n        }]\n    },\n    // Configuration options go here\n    options: {}\n});\n```\n\n官網文件寫得十分詳細，但因為是英文，所以需要花一點時間找相關的方法、屬性如何使用。\n\n最後參考了[這篇文章](https://bbs.csdn.net/topics/392185606)得知如何把柱狀圖堆疊起來，修改程式碼後順利完成本次目標～\n\n因為資料涉及公司，所以就不放上程式碼以及相關圖片了。","tags":["職場經驗"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.50 Angular 表單啟用原生的 HTML5 驗證","url":"%2Ff2e%2F20190618%2F4000441909%2F","content":"\n## 前言\n這是我參考官方文件進行 Angular 表單實作時遇到的問題，當我建立一份 form 表單並且在裡面的 input 內添加 required ，企圖使用原生的 HTML5 驗證卻沒有生效，最後找到解決辦法，因此特別寫下這一篇。\n\n## 問題描述\n**這是一個非常單純的 HTML5 的驗證：**\n[CodePen](https://codepen.io/pvt5r486/pen/KjMbWN?editors=1000)\n\n```html\n<form>\n  <input type=\"text\" required>\n  <button type=\"submit\">submit</button>\n</form>\n```\n這會驗證 form 表單內的 input 是否有值，若為空值則無法提交。\n\n![](https://i.imgur.com/bvUM3qa.png)\n\n\n**我嘗試要在 Angular 內使用，但卻沒有觸發驗證。**\n```js\n<form>\n  <input type=\"text\" (ngSubmit)=\"onSubmit()\" required>\n  <button type=\"submit\">submit</button>\n</form>\n```\n\n![沒有觸發驗證](https://i.imgur.com/rsbXRtN.png)\n\n## 解法\n參考以下文章解決\n* [Angular4+表单提交时未检查“required”属性](https://my.oschina.net/lwenhao/blog/1922844)\n* [Angular 4 enable HTML5 validation](https://stackoverflow.com/questions/43189364/angular-4-enable-html5-validation)\n* [ng_no_validate_directive.ts](https://github.com/angular/angular/blob/master/packages/forms/src/directives/ng_no_validate_directive.ts)\n\n> 而從文章得知，似乎是自從 Angular 4 後，預設把 HTML5 的驗證關閉了，需要手動在 form 元素上添加 `ngNativeValidate` 將其開啟。\n\n![未添加 ngNativeValidate ，出現 novalidate ](https://i.imgur.com/ftIWu2z.png)\n\n```js\n<form  (ngSubmit)=\"onSubmit()\" ngNativeValidate>\n  <input type=\"text\" name=\"name\"  required>\n  <button type=\"submit\">submit</button>\n</form>\n```\n![成功觸發 HTML5 驗證](https://i.imgur.com/1XAze4S.png)\n\n![添加 ngNativeValidate ， novalidate 消失](https://i.imgur.com/314rOz3.png)\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.49 Angular 響應式表單 (Reactive forms) (二)","url":"%2Ff2e%2F20190618%2F751180778%2F","content":"\n## 前言\n承上篇，接著使用 FormBuilder 重構程式碼。\n\n![](https://images.unsplash.com/photo-1560768063-0c81fe6f38b1?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 使用 FormBuilder 來產生表單控制元件\n當需要與多個表單打交道時，手動建立多個表單控制元件例項會非常繁瑣。\n\nFormBuilder 服務提供了一些便捷方法來產生表單控制元件，在幕後也使用同樣的方式來建立和返回這些實例，只是用起來更簡單。\n\n接下來會重構 ProfileEditor 元件，用 FormBuilder 來建立這些 FormControl 和 FormGroup 實例。\n\n### 匯入 FormBuilder 類\n從 @angular/forms 包中匯入 FormBuilder 類。\n\n```js\nimport { FormGroup, FormControl, FormBuilder } from '@angular/forms';\n```\n\n### 注入 FormBuilder 服務\nFormBuilder 是一個可注入的服務提供商，它是由 ReactiveFormModule 提供的。\n\n只要把它新增到元件的建構函式中就可以注入這個依賴。\n\n```js\nconstructor(private fb: FormBuilder) { }\n```\n\n### 產生表單控制元件\nFormBuilder 服務有三個方法：\n* control()\n* group()\n* array()\n\n這些方法都是工廠方法，用於在元件的 class 中分別產生 FormControl 、 FormGroup 和 FormArray。\n\n**所以可以使用 group 方法建立 profileForm 控制元件。**\n\n而目前 profile-editor.component 的 class 是這樣的\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormGroup, FormControl, FormBuilder } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.scss']\n})\nexport class ProfileEditorComponent implements OnInit {\n  profileForm = this.fb.group({\n    firstName: [''],\n    lastName: [''],\n    address: this.fb.group({\n      street: [''],\n      city: [''],\n      state: [''],\n      zip: ['']\n    }),\n  });\n  constructor(private fb: FormBuilder) { }\n\n  ngOnInit() {\n  }\n  onSubmit() {\n    console.log(this.profileForm.value);\n  }\n  updateProfile() {\n    this.profileForm.patchValue({\n      firstName: 'Nancy',\n      address: {\n        street: '123 Drew Street'\n      }\n    });\n  }\n}\n```\n\n不難看出與先前手動建立 FormControl 、 FormGroup 十分相似，而且省下了非常大量的 new 。\n\n每個控制元件名對應的值都是一個陣列，而**陣列中的第一項是其初始值。**\n\n> 可以只使用初始值來定義控制元件，但是如果控制元件還需要同步或非同步驗證器，那就在這個陣列中的第二項和第三項提供同步和非同步驗證器。\n\n**運行看看重構的結果吧！**\n\n![執行成功](https://i.imgur.com/L02nbQ2.png)\n\n## 簡易表單驗證\n表單驗證用於驗證使用者的輸入，以確保其完整和正確。\n\n那麼該如何把單個驗證器新增到表單控制元件中，以及如何顯示表單的整體狀態呢？\n\n### 匯入驗證器函式\n響應式表單包含了一組內建的常用驗證器函式。\n\n這些函式接收一個控制元件，用以驗證並根據驗證結果返回一個錯誤物件或空值。\n\n```js\nimport { Validators } from '@angular/forms';\n```\n\n### 把欄位設為必填（required）\n檢查某個欄位有沒有被正確的填入值是相當常見的驗證：\n* 把 firstName 設為必填項目\n* 在 ProfileEditor 元件中，把靜態方法 Validators.required 設定為 firstName 控制元件值陣列中的第二項。\n\n```js\nprofileForm = this.fb.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.fb.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: ['']\n  }),\n});\n```\n然後使用內嵌繫結觀察表單的驗證狀態。\n\n```html\n<p>\n  Form Value: {{ profileForm.valid }} <br>\n  Form Status: {{ profileForm.status }}\n</p>\n```\n\n![firstName 未輸入，狀態為 INVALID](https://i.imgur.com/1BfGxCG.png)\n\n![輸入後，狀態為 VALID](https://i.imgur.com/yz1vhlh.png)\n\n而我們也可以搭配原生的 HTML5 驗證屬性，可以防止在 Template 檢查完之後表示式再次被修改導致的錯誤。\n\n```html\n<input type=\"text\" formControlName=\"firstName\" required>\n```\n\n可以做得更好！像是把驗證有沒有通過的狀態繫結在提交按鈕的 disabled 屬性上。\n\n```html\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">提交</button>\n```\n![驗證未通過](https://i.imgur.com/c1C4Fkd.png)\n\n![驗證通過](https://i.imgur.com/ixDfSuJ.png)\n\n> 提交按鈕被禁用了，因為 firstName 控制元件的必填項規則導致了 profileForm 也是無效的。\n\n## 使用表單陣列管理動態控制元件\nFormArray 是 FormGroup 之外的另一個選擇，用於管理任意數量的匿名控制元件。\n\n像 FormGroup 實例一樣，可以在 FormArray 中動態插入和移除控制元件，並且 FormArray 實例的值和驗證狀態也是根據它的子控制元件計算得來的。 \n\nFormArray 與 FormGroup 差別在於**不需要為每個控制元件定義一個名字作為 key**。\n\n因此，如果不知道子控制元件的數量，這就是一個很好的選擇。\n\n舉例來說，我們可以加入綽號的部分，因為我們不知道綽號會有幾個。\n\n### 匯入 FormArray\n從 @angular/form 中匯入 FormArray，以使用它的型別資訊。\n\n```js\nimport { FormArray } from '@angular/forms';\n```\n\n### 定義 FormArray\n可以透過把一組（從零項到多項）控制元件定義在一個陣列中藉以初始化一個 FormArray。\n\n為 profileForm 新增一個 alias 屬性，把它定義為 FormArray 型別。\n\n使用 FormBuilder.array() 方法來定義該陣列，並用 FormBuilder.control() 方法來往該陣列中新增一個初始控制元件。\n\n```js\nprofileForm = this.fb.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.fb.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: ['']\n  }),\n  alias: this.fb.array([\n    this.fb.control('')\n  ])\n});\n```\n現在 FormGroup 中的這個 alias 控制元件現在管理著一個控制元件，將來還可以動態新增多個。\n\n### 訪問 FormArray 控制元件\n相對於重復使用 profileForm.get() 方法獲取每個例項的方式， getter 可以讓你輕鬆訪問 FormArray 實例中的綽號。\n\nFormArray 實例用一個陣列來代表未定數量的控制元件。\n\n透過 getter 來訪問控制元件很方便，這種方法還能很容易地重複處理更多控制元件。\n\n使用 getter 語法建立**類屬性 aliases**，以從父表單組中接收表示 aliases 的 FormArray 控制元件。\n\n```js\nget aliases() {\n  return this.profileForm.get('aliases') as FormArray;\n}\n```\n\n> 因為 return 的控制元件的型別是 AbstractControl，所以要為該方法提供一個顯式的型別宣告來訪問 FormArray 特有的語法。\n\n宣告 addAlias 方法來把一個控制元件動態插入到 aliases 的 FormArray 中：\n* 用 FormArray.push() 方法把該控制元件新增為陣列中的新元素\n\n```js\naddAlias() {\n  this.aliases.push(this.fb.control(''));\n}\n```\n在 Template 中，這些控制元件會被迭代，把每個控制元件都顯示為一個獨立的輸入框。\n\n## 在 Template 中顯示 FormArray\n使用 formArrayName 在這個 FormArray 例項和範本之間建立繫結。\n\n```html\n<div formArrayName=\"aliases\">\n  <h3>Aliases</h3> <button (click)=\"addAlias()\">新增綽號</button>\n  <div *ngFor=\"let item of aliases.controls; let i=index\">\n    <label>\n      綽號:\n      <input type=\"text\" [formControlName]=\"i\">\n    </label>\n  </div>\n</div>\n```\n使用 ngFor 指令對 aliases FormArray 提供的每個 FormControl 進行迭代。\n\n因為 FormArray 中的元素是匿名的，所以要把索引號賦值給 i 變數，並且把它傳給每個控制元件的 formControlName 輸入屬性。\n\n每當新的 alias 加進來時，FormArray 的實例就會基於這個索引號提供它的控制元件。\n\n![](https://i.imgur.com/k3yvNLA.png)\n\n![](https://i.imgur.com/2aHrtM6.png)\n\n**至此，我們完成了響應式表單的基礎範例練習。**\n\n* [GitHub 範例程式碼](https://github.com/pvt5r486/ngForm)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.48 Angular 響應式表單 (Reactive forms) (一)","url":"%2Ff2e%2F20190618%2F1504140932%2F","content":"\n## 前言\n玩過範本驅動表單後，接著來體驗看看響應式表單吧～\n\n![](https://images.unsplash.com/photo-1558981420-c532902e58b4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1177&q=80)\n\n## 響應式表單 (Reactive forms)\n> 以下節錄自官網敘述:\n響應式表單使用顯式的、不可變的方式，管理表單在特定的時間點上的狀態。對表單狀態的每一次變更都會返回一個新的狀態，這樣可以在變化時維護模型的整體性。\n響應式表單還提供了一種更直觀的測試路徑，因為在請求時你可以確信這些資料是一致的、可預料的。這個流的任何一個消費者都可以安全地操縱這些資料。\n\n## 環境建置\n如果要使用響應式表單，就要從 @angular/forms 包中匯入 ReactiveFormsModule 。\n\n### 註冊 ReactiveFormsModule\n![](https://i.imgur.com/5GtCzoC.png)\n\n### 產生並匯入一個新的表單控制元件\n輸入 `ng g c NameEditor` 建立元件。\n\n![](https://i.imgur.com/18alxUZ.png)\n\n當使用響應式表單時， `FormControl` 類是最基本的構成要素。\n\n所以要在這個元件中匯入 `FormControl` 類，並 `new` 一個 `FormControl` 實體，把它儲存在 class 的某個屬性中。\n\n**name-editor.component class**\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.scss']\n})\nexport class NameEditorComponent implements OnInit {\n  name = new FormControl('');\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n可以用 `FormControl` 的建構函式設定初始值，這個例子中它是空字串。\n\n我們可以在元件的 class 中建立這些控制元件，直接對表單控制元件的狀態進行監聽、修改和驗證。\n\n### 在 Template 中註冊該控制元件\n剛才的步驟在 class 中建立控制元件後，我們還需要把它和範本中的表單控制元件關聯起來。\n\n**例如：為表單控制元件新增 `formControl` 繫結**\n\n`formControl` 是由 `ReactiveFormsModule` 中的 `FormControlDirective` 提供的，更多class 以及指令可以參考[響應式表單 API](https://angular.tw/guide/reactive-forms#reactive-forms-api)\n\n```html\n<label>\n  Name:\n  <input type=\"text\" [formControl]=\"name\">\n</label>\n```\n\n> 使用這種範本繫結語法，把該表單控制元件註冊給了 Template 中名為 `name` 的輸入元素。\n\n這樣表單控制元件和 DOM 元素就可以互相通訊了\n* View 會反映 model 的變化， model 也會反映 View 中的變化。\n\n實際將元件運行來觀察是否正常：\n\n![](https://i.imgur.com/nVPk7Rp.png)\n\n## 管理控制元件的值\n剛才的步驟已經建立了一個基礎了表單控制元件，而響應式表單讓你可以訪問表單控制元件此刻的狀態和值。\n\n**可以透過元件的 class 或元件的 Template 來操縱其當前狀態和值。**\n\n### 顯示表單控制元件的值\n可以用兩種方式顯示它的值：\n* 透過可觀察物件 valueChanges，可以在 Template 中使用 AsyncPipe 或在元件的 class 中使用 subscribe() 方法來監聽表單值的變化。\n* 使用 `value` 屬性，它能讓你獲得當前值的一份快照。\n\n**這邊示範方法二 - 使用內嵌繫結的方式觀察表單的值。**\n\n```html\n<label>\n  Name:\n  <input type=\"text\" [formControl]=\"name\">\n</label>\n<p>\n  Value: {{ name.value }}\n</p>\n```\n\n![](https://i.imgur.com/2Mnc6tM.png)\n\n> 一旦修改了表單控制元件所關聯的元素， p 標籤內顯示的值也跟著變化了。\n\n### 替換表單控制元件的值\n響應式表單還有一些方法可以用程式設計的方式修改控制元件的值：\n* FormControl 提供了一個 setValue() 方法\n  * 它會修改這個表單控制元件的值，並且驗證與控制元件結構相對應的值的結構\n    * 比如，當從後端 API 或服務接收到了表單資料時，可以透過 setValue() 方法來把原來的值替換為新的值\n\n舉例來說我們在元件的 class 內新增一個 updateName() 方法：\n```js\nupdateName() {\n  this.name.setValue('Nancy');\n}\n```\n\n接著修改 Template 新增一個按鈕，並把剛才新增的方法綁上去。\n\n```html\n<p>\n  <button (click)=\"updateName()\">Update Name</button>\n</p>\n```\n\n![點擊按鈕後](https://i.imgur.com/cNFFubB.png)\n\n> 特別要注意的是：\n在這個例子中，我們只使用單個控制元件，但是當呼叫 `FormGroup` 或 `FormArray` 的 `setValue()` 方法時，傳入的值就必須匹配「控制元件組」或「控制元件陣列」的結構才行。\n\n**接著來談談如何將把表單控制元件分組。**\n\n## 表單控制元件分組\nFormControl 的實例能讓我們控制單個輸入框所對應的控制元件，而 FormGroup 的實例能追蹤一組 FormControl 實例（比如一個表單的狀態）\n\n### 產生新的元件並且匯入 FormGroup 和 FormControl 的 class\n輸入 `ng g c ProfileEditor` ，建立元件。\n\n![](https://i.imgur.com/ELBW2Yb.png)\n\n**匯入 FormGroup 和 FormControl 的 class**\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.scss']\n})\nexport class ProfileEditorComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n### 建立 FormGroup 的實例\n跟剛才單個的 FormControl 蠻像的，差別在於 FormGroup 就是一個物件包著很多 FormControl 的概念，如下：\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.scss']\n})\nexport class ProfileEditorComponent implements OnInit {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\nFormGroup 實例擁有和 FormControl 實例\n* 相同的屬性，比如 value、untouched\n* 相同的方法，比如 setValue()\n\n### 關聯 FormGroup 的 model 和 view\n這個 FormGroup 能追蹤其中每個控制元件的狀態及其變化，所以如果其中的某個控制元件的狀態或值變化了，父控制元件也會發出一次新的狀態變更或值變更事件。\n\n該控制元件組的 model 來自它的所有成員，在定義了這個 model 後，你必須更新 Template ，把該 model 反映到 view 中。\n\n**profile-editor.component**\n```html\n<form [formGroup]=\"profileForm\">\n  <label>\n    First Name:\n    <input type=\"text\" formControlName=\"firstName\">\n  </label>\n  <label>\n    Last Name:\n    <input type=\"text\" formControlName=\"lastName\">\n  </label>\n</form>\n```\n\n就像 FormGroup 所包含的那些控制元件一樣， `profileForm` 這個 FormGroup 也透過 FormGroup 指令繫結到了 form 元素上，在該 model 和表單中的輸入框之間建立了一個通訊層。\n\n藉由 FormControlName 指令把每個輸入框和 FormGroup 中定義的表單控制元件繫結起來。\n\n這些表單控制元件會和相應的元素通訊，如果有修改，把修改傳遞給 FormGroup 。\n\n## 取得表單資料\nProfileEditor 元件從使用者那裡獲得輸入，但在實務上我們可能想要先獲得表單的值。\n\nFormGroup 指令會監聽 form 元素發出的 submit 事件，然後發出一個 ngSubmit 事件，讓你可以繫結一個 callback 函式。\n\n所以之後我們可以在 class 內建立一個 onSubmit() 方法，並且綁在 ngSubmit 事件上。\n\n```html\n<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n```\n\nProfileEditor 元件上的 onSubmit() 方法會捕獲 profileForm 的當前值。要保持該表單的封裝性，就要使用 EventEmitter 向元件外部提供該表單的值。\n\n並且使用 console.log 觀察提交結果。\n\n```js\nonSubmit() {\n  console.log(this.profileForm.value);\n}\n```\n\n最後我們必須新增一個按鈕，並且把 type 設定為 submit 。\n\n```html\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">提交</button>\n```\n\n![輸入後提交](https://i.imgur.com/ccnOaEY.png)\n\n## 巢狀的表單組\nFormGroup 支援巢狀結構，因此我們可以建立更複雜的表單應用。\n\n### 建立巢狀的 FormGroup\n比如說可以在目前的例子中加入地址：\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.scss']\n})\nexport class ProfileEditorComponent implements OnInit {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl(''),\n    }),\n  });\n  constructor() { }\n\n  ngOnInit() {\n  }\n  onSubmit() {\n    console.log(this.profileForm.value);\n  }\n}\n```\n\n雖然 address 這個 FormGroup 是 profileForm 這個整體 FormGroup 的一個子控制元件，但是仍然適用同樣的值和狀態的變更規則。\n\n**來自內嵌控制元件組的狀態和值的變更將會冒泡到它的父控制元件組。**\n\n### 在 Template 中分組內嵌的表單\n因為剛才修改了 class 內的 model ，所以 Template 也需要作出調整。\n\n```html\n<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n  <label>\n    First Name:\n    <input type=\"text\" formControlName=\"firstName\">\n  </label>\n  <br>\n  <label>\n    Last Name:\n    <input type=\"text\" formControlName=\"lastName\">\n  </label>\n  <div formGroupName=\"address\">\n    <h3>Address</h3>\n    <label>\n      Street:\n      <input type=\"text\" formControlName=\"street\">\n    </label>\n    <br>\n    <label>\n      City:\n      <input type=\"text\" formControlName=\"city\">\n    </label>\n    <br>\n    <label>\n      State:\n      <input type=\"text\" formControlName=\"state\">\n    </label>\n    <br>\n    <label>\n      Zip Code:\n      <input type=\"text\" formControlName=\"zip\">\n    </label>\n  </div>\n  <button type=\"submit\">提交</button>\n</form>\n```\n\n測試看看是否仍正常運作。\n\n![](https://i.imgur.com/VIT0YsK.png)\n\n## 部分模型更新\n如果想更新部分 model 的內容而不是整個都替換掉的話，有兩種更新 model 值的方式：\n* 使用 setValue() 方法來為單個控制元件設定新值\n  * setValue() 方法會嚴格遵循表單組的結構，並整體性替換控制元件的值\n* 使用 patchValue() 方法可以用物件中所定義的任何屬性為表單模型進行替換\n\nsetValue() 方法的嚴格檢查可以幫助你捕獲複雜表單巢狀中的錯誤，而 patchValue() 在遇到那些錯誤時可能會默默的失敗。\n\n新增一個更新鈕，並且在 class 內新增一個 updateProfile() 方法。\n\n```html\n<button type=\"button\" (click)=\"updateProfile()\">更新</button>\n```\n\n**使用 patchValue() 方法**\n```js\nupdateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street'\n    }\n  });\n}\n```\n\n![點擊更新後提交](https://i.imgur.com/TRR1S3b.png)\n\n**使用 setValue() 方法**\n```js\n  updateProfile() {\n    // this.profileForm.patchValue({\n    //   firstName: 'Nancy',\n    //   address: {\n    //     street: '123 Drew Street'\n    //   }\n    // });\n    this.profileForm.setValue({\n      firstName: 'Nancy',\n      lastName: '',\n      address: {\n        street: '123 Drew Street',\n        city: '',\n        state: '',\n      }\n    });\n  }\n```\n\n像這樣，使用 setValue() 方法會整體性替換控制元件的值，但在這裡我故意少寫 zip 屬性，並嘗試提交。\n\n![少寫 zip 屬性](https://i.imgur.com/0pCq23Q.png)\n\n因此如果使用 setValue() 方法就必須要把屬性全部寫上去才行。\n\n![補上 zip 屬性後](https://i.imgur.com/7GuUEy5.png)\n\n## 小結\n接下來要使用 FormBuilder 進行重構，都寫在同一篇感覺篇幅太長了，因此拆開兩篇寫。\n\n* [GitHub 範例程式碼](https://github.com/pvt5r486/ngForm)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.47 Angular 範本驅動表單 (Template-Driven Forms)","url":"%2Ff2e%2F20190617%2F1498157669%2F","content":"\n## 前言\n介紹完 Angular 內兩種表單的不同後，接著實作看看範本驅動表單吧。\n\n![](https://images.unsplash.com/photo-1560635041-160852985094?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 需求\nAngular 框架支援：\n* 雙向資料繫結\n* 變更檢測\n* 驗證和錯誤處理\n\n而實作過程中，將學會：\n* 用元件和範本建構 Angular 表單\n* 用 ngModel 建立雙向資料繫結，以讀取和寫入輸入控制元件的值\n* 追蹤狀態的變化，並驗證表單控制元件\n* 使用特殊的 CSS 類來追蹤控制元件的狀態並給出視覺反饋\n* 向用戶顯示驗證錯誤提示，以及啟用/禁用表單控制元件\n* 使用範本參考變數在 HTML 元素之間共享資訊 \n\n這個範例將：\n* 以範本驅動表單的方式實作一個建立英雄的表單\n* 必填的欄位在左側有個綠色的豎條，代表這個欄位是必填的\n  * 如果沒有填寫，表單就會用醒目的樣式把驗證錯誤顯示出來\n* 而如果有條件未達成，則無法按下 Submit 按鈕提交\n\n## 環境準備\n### 建立專案\n建立專案的部分就不再贅述了。\n\n### 建立 hero 的 class \n因為每次輸入表單資料時，資料大致上都是固定的，因此可以建立一個 hero 的 class 來處理這些事情。\n之後要使用時可以透過 `new` 將其實例化成物件後，方便我們取用。\n\n![](https://i.imgur.com/OxD9leO.png)\n\n**hero.ts**\n```js\nexport class Hero {\n  constructor(\n    public id: number,\n    public name: string,\n    public power: string,\n    public alterEgo?: string\n  ) {}\n}\n```\n\n其中 `alterEgo` 屬性後面接了 `?` 號，代表 `alterEgo` 屬性不是必須的，呼叫建構函式時這個參數可以省略。\n\n也就是說之後我們可以這樣來建立一個新英雄：\n```js\nlet myHero =  new Hero(1, '超級牛', '超級牛來拯救雷', '牛妹妹');\nconsole.log('My hero is called ' + myHero.name);\n```\n\n### 建立表單元件\n輸入 `ng g c HeroForm` 建立元件。\n\n![](https://i.imgur.com/e0nScNq.png)\n\n接著在 class 內寫一些東西：\n**hero-form.component**\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'app-hero-form',\n  templateUrl: './hero-form.component.html',\n  styleUrls: ['./hero-form.component.scss']\n})\nexport class HeroFormComponent implements OnInit {\n  // 能力陣列\n  powers = ['噴火', '降雷', '結冰', '呼風'];\n  // 預設的 model 物件\n  model = new Hero(1, '火焰鳥', this.powers[0], '黑火焰鳥');\n  // 阻止提交\n  submitted = false;\n  constructor() { }\n\n  ngOnInit() {\n  }\n  onSubmit() {\n    this.submitted = true;\n  }\n}\n```\n\n**修改 app.module.ts**\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { HeroFormComponent } from './hero-form/hero-form.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeroFormComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n在這裡要匯入：\n* FormsModule\n* 把 FormsModule 新增到 ngModule 裝飾器的 imports 陣列中，這樣應用就能訪問範本驅動表單的所有特性，包括 ngModel\n\n**修改 app.component.ts**\n```html\n<app-hero-form></app-hero-form>\n```\n別忘了在根元件內把這個子元件載入。\n\n### 建立初始 HTML 表單範本\n修改 hero-form 的元件範本 (Template)\n```html\n<div class=\"container\">\n    <h1>Hero Form</h1>\n    <form>\n      <div class=\"form-group\">\n        <label for=\"name\">姓名</label>\n        <input type=\"text\" class=\"form-control\" id=\"name\" required>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"alterEgo\">裏人格</label>\n        <input type=\"text\" class=\"form-control\" id=\"alterEgo\">\n      </div>\n      <button type=\"submit\" class=\"btn btn-success\">提交</button>\n    </form>\n</div>\n```\n\n在這裡添加了兩個欄位：\n* 姓名 - 必填\n* 裏人格 - 非必填\n\n可以發現到這一小段 HTML5 的程式碼，裡面用了一些 Bootstrap4 的 className 。\n\n但這不是必需的，這裡只是因為美觀所以想要使用。\n\n可以透過修改 `src/styles.css` 引入 Bootstrap4。\n\n```scss\n/* You can add global styles to this file, and also import other style files */\n@import url('https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css');\n```\n\n接著運行開發伺服器，觀察一下目前的樣子。\n\n![](https://i.imgur.com/lNeMTKn.png)\n\n**添加能力選單**\n還記得我們在 HeroFormComponent 的 class 內寫的 `powers` 陣列嗎？\n\n接下來要使用 ngFor 建立一個下搭式選單。\n```html\n<div class=\"form-group\">\n  <label for=\"power\">能力</label>\n  <select name=\"power\" id=\"power\" class=\"form-control\">\n    <option [value]=\"item\" *ngFor=\"let item of powers\">{{item}}</option>\n  </select>\n</div>\n```\n\n![](https://i.imgur.com/8jWf7EY.png)\n\n## 使用 ngModel 進行雙向資料繫結\n基礎的表單已經成形，接著我們要將資料雙向繫結到 Input 上。\n\n```html\n<div class=\"container\">\n  <h1>Hero Form</h1>\n  <form #heroForm=\"ngForm\">\n    <div class=\"form-group\">\n      <label for=\"name\">姓名</label>\n      <input id=\"name\" [(ngModel)]=\"model.name\"\n        class=\"form-control\" name=\"name\" required>\n      目前的資料狀態[姓名]：{{model.name}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"alterEgo\">裏人格</label>\n      <input type=\"text\" class=\"form-control\"\n        [(ngModel)]=\"model.alterEgo\" name=\"alterEgo\" id=\"alterEgo\">\n        目前的資料狀態[裏人格]：{{model.alterEgo}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"power\">能力</label>\n      <select name=\"power\" id=\"power\" class=\"form-control\" [(ngModel)]=\"model.power\">\n        <option [value]=\"item\" *ngFor=\"let item of powers\">{{item}}</option>\n      </select>\n      目前的資料狀態[能力]：{{model.power}}\n    </div>\n    <button type=\"submit\" class=\"btn btn-success\">提交</button>\n  </form>\n</div>\n```\n\n![](https://i.imgur.com/p27UHJP.png)\n\n做到這邊的時候，遇到一個小小的阻礙：\n* 當使用 ngModel 時，要記得替 input 補上 name 屬性\n\n### NgForm 指令\n往 form 標籤中加入 `#heroForm=\"ngForm\"`\n\nheroForm 變數是一個到 NgForm 指令的參考，它代表該表單的整體。\n\nNgForm 指令為 form 增補了一些額外特性：\n* 它會控制那些帶有 ngModel 指令和 name 屬性的元素，監聽他們的屬性（包括其有效性）。\n* 它還有自己的 valid 屬性，這個屬性只有在它包含的每個控制元件都有效時才是真。\n\n## 透過 ngModel 追蹤修改狀態與有效性驗證\n現在我們已經可以透過雙向繫結修改資料了，但是還可以透過 ngModel 知道更多資訊：\n* 使用者碰過此控制元件嗎？\n* 值變化了嗎？\n* 資料變得無效了嗎？\n\nngModel 指令不僅僅追蹤狀態。它還使用特定的 Angular CSS 類來更新控制元件，以反映當前狀態。 可以利用這些 CSS 類來修改控制元件的外觀，顯示或隱藏訊息。\n\n![](https://i.imgur.com/gGdsiTj.png)\n\n在姓名的 input 標籤上新增名叫 `spy` 的臨時範本參考變數，然後用這個 `spy` 來顯示它上面的所有 className。\n```html\n<div class=\"form-group\">\n  <label for=\"name\">姓名</label>\n  <input id=\"name\" [(ngModel)]=\"model.name\"\n    class=\"form-control\" name=\"name\" #spy required>\n  目前的資料狀態[姓名]：{{model.name}} <br>\n  input 上的 className 狀態 {{spy.className}}\n</div>\n```\n\n![尚未觸碰過](https://i.imgur.com/pGX88Gl.png)\n\n![focus 後 blur](https://i.imgur.com/jkR1KeE.png)\n\n![修改過資料後](https://i.imgur.com/QudKYuM.png)\n\n![必填欄位但資料完全刪除時](https://i.imgur.com/kfseQdF.png)\n\n## 新增用於視覺反饋的自訂 CSS\n既然可以追蹤 input 上的 className 狀態，我們就可以自訂一些視覺反饋效果。\n\n**hero-form.component.scss**\n```scss\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n```\n\n![驗證失敗](https://i.imgur.com/GBAAP5x.png)\n\n![驗證成功](https://i.imgur.com/3cFB0y9.png)\n\n**甚至可以透過控制 hidden 屬性，自訂一些錯誤訊息。**\n\n```html\n<div class=\"form-group\">\n  <label for=\"name\">姓名</label>\n  <input id=\"name\" [(ngModel)]=\"model.name\"\n    class=\"form-control\" name=\"name\" #name=\"ngModel\" required>\n    <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\">姓名是必填欄位！</div>\n  目前的資料狀態[姓名]：{{model.name}}\n</div>\n```\n\n範本參考變數可以訪問 Template 中的 input ，建立 name 的變數並且賦值為 `ngModel`。\n\n當這個 input 的驗證是有效的 (valid) 或全新的 (pristine) 時，隱藏訊息。\n\n> 全新的 (pristine) 意味著從它顯示在表單中開始，使用者還從未修改過它的值。\n\n![](https://i.imgur.com/U97Naao.png)\n\n**這樣就完成了視覺反饋效果。**\n\n裏人格因為是非必填，所以不需要做處理；下拉式選單則因為設計的關係一定會有值，所以也不需要處理。\n\n## 新增英雄\n在表單的底部放置新增英雄的按鈕，並把它的點選事件繫結到元件上的 newHero 方法。\n**hero-form.component.html**\n```html\n<button type=\"button\" class=\"btn btn-primary\" (click)=\"newHero()\">新增英雄</button>\n```\n**hero-form.component.ts**\n```js\nnewHero() {\n  this.model = new Hero(2, '', '');\n}\n```\n\n**觀察看看結果～**\n\n![尚未點擊新增英雄](https://i.imgur.com/Qb9qjbf.png)\n\n![點擊新增英雄後](https://i.imgur.com/C1lmCDa.png)\n\n使用瀏覽器工具審查這個元素就會發現，這個 name 輸入框並不是全新的。\n\n所以跑出了錯誤提示訊息，但這樣不正確，因為我們並不希望按下新增英雄時跑出錯誤視窗。\n\n發生預期之外的原因是:\n* 表單會記得點選新增英雄前輸入的名字，而更換了英雄物件並不會重置 input 的 全新(pristine) 狀態。\n\n**所以必須在 newHero() 後補上 heroForm.reset() 重置表單狀態。**\n\n因此目前 Template 內的程式碼是這樣的：\n```html\n<div class=\"container\">\n  <h1>Hero Form</h1>\n  <form #heroForm=\"ngForm\">\n    <div class=\"form-group\">\n      <label for=\"name\">姓名</label>\n      <input id=\"name\" [(ngModel)]=\"model.name\"\n        class=\"form-control\" name=\"name\" #name=\"ngModel\" required>\n        <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\">姓名是必填欄位！</div>\n      目前的資料狀態[姓名]：{{model.name}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"alterEgo\">裏人格</label>\n      <input type=\"text\" class=\"form-control\"\n        [(ngModel)]=\"model.alterEgo\" name=\"alterEgo\" id=\"alterEgo\">\n        目前的資料狀態[裏人格]：{{model.alterEgo}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"power\">能力</label>\n      <select name=\"power\" id=\"power\" class=\"form-control\" [(ngModel)]=\"model.power\">\n        <option [value]=\"item\" *ngFor=\"let item of powers\">{{item}}</option>\n      </select>\n      目前的資料狀態[能力]：{{model.power}}\n    </div>\n    <button type=\"button\" class=\"btn btn-primary\" (click)=\"newHero();heroForm.reset()\">新增英雄</button>\n    <button type=\"submit\" class=\"btn btn-success\">提交</button>\n  </form>\n</div>\n```\n\n## 使用 ngSubmit 提交該表單\n填表完成之後，使用者應該要能提交這個表單。\n\n目前這個表單的提交按鈕位於底部，並沒有在這顆按鈕上綁定任何的點擊事件，但因為有特殊的 type 值 (type=\"submit\")，所以會觸發表單提交。\n\n但現在這樣僅僅觸發表單提交是沒用的。 \n\n要讓它有用，就要把該表單的 ngSubmit 事件屬性繫結到英雄表單元件的 onSubmit() 方法上：\n```html\n<form (ngSubmit)=\"onSubmit()\" #heroForm=\"ngForm\">\n```\n\n這樣就可以在按下提交鈕後觸發寫在 class 內的 onSubmit() 方法了。\n\n### 提升使用者體驗\n可以進一步的把表單的總體有效性透過 heroForm 變數繫結到此按鈕的 disabled 屬性，這樣能讓使用者明白如果沒有填寫姓名是不能提交的。\n\n```html\n<button type=\"submit\" [disabled]=\"!heroForm.form.valid\" class=\"btn btn-success\">提交</button>\n```\n\n![未填寫姓名，不得提交](https://i.imgur.com/Vle2LOV.png)\n\n## 切換兩個表單區域\n在我們按下提交後，可以將表單利用先前設置好的屬性 `submitted` 來控制隱藏或顯示。\n\n### 建立提交後的顯示區塊，並且利用 submitted 控制隱藏或顯示\n```html\n<div class=\"container\">\n  <h1>Hero Form</h1>\n  <form (ngSubmit)=\"onSubmit()\" #heroForm=\"ngForm\" [hidden]=\"submitted\">\n    <div class=\"form-group\">\n      <label for=\"name\">姓名</label>\n      <input id=\"name\" [(ngModel)]=\"model.name\"\n        class=\"form-control\" name=\"name\" #name=\"ngModel\" required>\n        <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\">姓名是必填欄位！</div>\n      目前的資料狀態[姓名]：{{model.name}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"alterEgo\">裏人格</label>\n      <input type=\"text\" class=\"form-control\"\n        [(ngModel)]=\"model.alterEgo\" name=\"alterEgo\" id=\"alterEgo\">\n        目前的資料狀態[裏人格]：{{model.alterEgo}}\n    </div>\n    <div class=\"form-group\">\n      <label for=\"power\">能力</label>\n      <select name=\"power\" id=\"power\" class=\"form-control\" [(ngModel)]=\"model.power\">\n        <option [value]=\"item\" *ngFor=\"let item of powers\">{{item}}</option>\n      </select>\n      目前的資料狀態[能力]：{{model.power}}\n    </div>\n    <button type=\"button\" class=\"btn btn-primary\" (click)=\"newHero();heroForm.reset()\">新增英雄</button>\n    <button type=\"submit\" [disabled]=\"!heroForm.form.valid\" class=\"btn btn-success\">提交</button>\n  </form>\n\n  <div [hidden]=\"!submitted\">\n    <h2>英雄能力如下:</h2>\n    <div class=\"row\">\n      <div class=\"col-md-3\">姓名</div>\n      <div class=\"col-md-9\">{{ model.name }}</div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-3\">裏人格</div>\n      <div class=\"col-md-9\">{{ model.alterEgo }}</div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-3\">能力</div>\n      <div class=\"col-md-9\">{{ model.power }}</div>\n    </div>\n    <br>\n    <button class=\"btn btn-primary\" (click)=\"submitted=false\">編輯</button>\n  </div>\n</div>\n```\n\n一開始屬性 `submitted` 為 `false` ，顯示輸入表單\n* 當按下提交後，觸發 onSubmit() 將 `submitted` 修改為 `true`\n  * 輸入表單關閉，顯示提交後的區塊\n* 當按下編輯按鈕時，再度將 `submitted` 修改為 `false`，隱藏提交後的區塊並顯示輸入表單。\n\n![提交前](https://i.imgur.com/2FzmRuz.png)\n\n![按下提交後](https://i.imgur.com/6kzT7cI.png)\n\n**如此我們就完成了範本驅動表單 (Template-Driven Forms) 的簡單範例。**\n\n* [GitHub 範例程式碼](https://github.com/pvt5r486/ngForm)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.46 Angular 表單","url":"%2Ff2e%2F20190617%2F2466170401%2F","content":"\n## 前言\n用表單處理使用者輸入的資料是許多常見應用的基礎功能，像是使用者登入、修改資料、建立資料等等。\n\n而 Angular 提供了兩種不同的方式透過表單處理使用者的輸入：\n* 響應式表單 ( reactive )\n* 範本驅動表單 ( template-driven )\n\n這些名詞看起來相當陌生，實際上用起來最簡單的會是範本驅動表單，因為它的使用方式相當直觀。\n\n![](https://images.unsplash.com/photo-1560553174-28b8e2f73bc1?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1051&q=80)\n\n## 響應式表單 ( reactive )\n然而，根據官方文件的敘述，響應式表單的優點是：\n* 可擴充套件性\n* 可複用性\n* 可測試性\n\n以上這三點特性都比範本驅動表單要強，如果這個表單是專案內相當重要且複雜的部份，推薦使用這種方式來建立表單。\n\n## 範本驅動表單 ( template-driven )\n範本驅動表單的優點就是易於使用，很容易就能在目前的 Angular 應用中添加一個簡易的表單，像是使用者的登入。\n\n白話來說，如果需求的表單功能相當簡易、邏輯不複雜，可以考慮使用範本驅動表單。\n\n## 兩者差異\n以下為官方標註的差異\n\n![](https://i.imgur.com/ZSjobMe.png)\n\n* [Reactive Forms 與 Template-Driven Forms 的特点](https://my.oschina.net/u/2949632/blog/1488455)\n\n## 小結\n具體來說該用哪種呢？\n\n> 實際上這沒有絕對的好壞，還是得看使用情境。\n\n倘若使用的情境既不需要寫測試、需要用到表單的地方邏輯又相當簡單，那就可以使用範本驅動表單搞定；相反的，若是相當複雜那就可以考慮使用響應式表單了。\n\n接下來試著以範本驅動表單的方式來建立一個表單吧～\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.45 在 Angular 內進行測試(五) - 帶有非同步服務的元件","url":"%2Ff2e%2F20190613%2F2750930562%2F","content":"\n## 前言\n也有一種狀況是：依賴的服務元件資料的取得，是透過呼叫 API 等待伺服器吐資料的非同步行為，那麼這又該如何進行測試呢？\n\n![](https://images.unsplash.com/photo-1560278078-d31b4ed980c6?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1036&q=80)\n\n## 帶有非同步服務的元件\n改寫上一個範例，當點選 welcomeComponent 元件內的登入按鈕時，會以 `.subscribe()` 的形式觸發 user 服務元件的 `getData()` 方法取得資料，最後顯示出歡迎提示，並且停用登入按鈕。\n\n**welcome.component 的 Template**\n```html\n<h3 class=\"welcome\" *ngIf=\"data.isLoggedIn\"><i>{{data.user}}，{{data.message}}！</i></h3>\n<h3 class=\"error\" *ngIf=\"!data.isLoggedIn\">未授權，請登入！</h3>\n<button (click)=\"login()\"  [disabled]=\"data.isLoggedIn\">登入</button>\n```\n\n**welcome.component 的 class**\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { UserService } from '../user.service';\n\n@Component({\n  selector: 'app-welcome',\n  templateUrl: './welcome.component.html',\n  styleUrls: ['./welcome.component.scss']\n})\nexport class WelcomeComponent implements OnInit {\n  data = {\n    isLoggedIn: false,\n    user: '',\n    message: ''\n  };\n  constructor(public userService: UserService) { }\n\n  ngOnInit() {\n  }\n  login() {\n    this.userService.getData().subscribe((result) => {\n      this.data = result;\n    });\n  }\n}\n```\n\n**user.service**\n```js\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor() { }\n  getData() {\n    const data = {\n      isLoggedIn: false,\n      user: '',\n      message: ''\n    };\n    setTimeout(() => {\n      data.isLoggedIn = true;\n      data.user = 'Alvan';\n      data.message = '歡迎登入';\n    }, 2000);\n    return Observable.create(observer => observer.next(data));\n  }\n}\n```\n\n## 如何測試帶有非同步服務的元件\n這個範例測試的重點是：\n* 元件上的登入按鈕的 click 觸發事件是否有效\n  * 意思是當透過點擊事件觸發元件內的 `login()` 時，方法真的有被呼叫\n* 元件的渲染是不是正常的\n  * 意思是獲得資料後元件有正確的顯示\n\n## 測試環境建置\n於是我們可以像先前一樣，使用 `jasmine.createSpyObj()` 產生一個假的 `getData()` 方法，並且預先建立好一組假的資料 - `data` 。\n\n**welcome.component.spec**\n```js\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { WelcomeComponent } from './welcome.component';\nimport { UserService } from '../user.service';\n\ndescribe('WelcomeComponent', () => {\n  let component: WelcomeComponent;\n  let fixture: ComponentFixture<WelcomeComponent>;\n  let userService;\n  beforeEach(() => {\n    const spy = jasmine.createSpyObj('UserServiceSpy', ['getData']);\n    TestBed.configureTestingModule({\n      declarations: [ WelcomeComponent ],\n      providers: [\n        { provide: UserService, useValue: spy }\n      ]\n    });\n    fixture = TestBed.createComponent(WelcomeComponent);\n    component = fixture.componentInstance;\n    userService = TestBed.get(UserService);\n    fixture.detectChanges();\n    el = fixture.nativeElement.querySelector('.welcome');\n  });\n```\n\n## 撰寫測試\n前置作業準備完畢，開始撰寫測試吧。\n\n### 第一個測試\n* 元件上的登入按鈕的 click 觸發事件是否有效\n  * 意思是當透過點擊事件觸發元件內的 `login()` 時，方法真的有被呼叫\n\n```js\nit('觸發 Click 事件後，是否有正常呼叫 getData() ', () => {\n  userService.getData.and.returnValue(new Observable());\n  // 模擬點擊\n  component.login();\n  expect(userService.getData).toHaveBeenCalled();\n});\n```\n\n第二行的意思是，當假的 `getData` 方法被呼叫時必須回傳一個觀察者物件 (Observable) 。\n\n因為第三行觸發元件內的 `login` 方法時\n  * user 服務元件內的 `getData()` 被觸發了，並且使用 `.subscribe()` 方法訂閱\n  * 而我們在測試時使用的 `getData()` 是假造的替身，所以必須回傳一個觀察者物件才可以使用 `.subscribe()` ，否則會出錯導致測試失敗\n\n![](https://i.imgur.com/PejzRF8.png)\n\n### 第二個測試\n* 測試元件的渲染是正常的\n  * 意思是獲得資料後元件有正確的顯示\n    * 像是當 `isLoggedIn` 為 `true` 時，登入按鈕為 `disabled`\n\n```js\nit('未登入時元件的渲染', () => {\n  const el: HTMLElement = fixture.nativeElement.querySelector('.error');\n  expect(el.textContent).toContain('未授權，請登入！');\n});\nit('登入獲取資料後，元件的渲染', () => {\n  const data = {\n    isLoggedIn: true,\n    user: 'Alvan',\n    message: '歡迎登入'\n  };\n  component.data = data;\n  fixture.detectChanges();\n  const el: HTMLElement = fixture.nativeElement.querySelector('.welcome');\n  expect(el.textContent).toContain(data.user);\n  const btn: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n  expect(btn.disabled).toBeTruthy();\n});\n```\n\n而這部分測試的關鍵在於「順序」，像是：\n* `component.data = data;` 當我們把假資料重新賦值給元件內的 `data` 後\n  * 必須呼叫 `fixture.detectChanges();` 重新進行資料與元件間的繫結\n    * 如此才可以使用 `fixture.nativeElement.querySelector()` 找到指定目標\n \n### fakeAsync() 進行非同步測試\n[fakeAsync()](https://angular.tw/api/core/testing/fakeAsync)\n\n在這個範例內，我並沒有實際的呼叫 API ，而是在 user 服務元件內透過 `setTimeout()` 模擬呼叫 API 時等待伺服器的時間。\n\n而如果也想在測試過程中模擬這一段情境的話，可以使用 `fakeAsync()` 。\n\n```js\nit('非同步測試渲染情形', fakeAsync(() => {\n  let data = {\n    isLoggedIn: false,\n    user: '',\n    message: ''\n  };\n  const errEl: HTMLElement = fixture.nativeElement.querySelector('.error');\n  expect(errEl.textContent).toContain('未授權，請登入！');\n  setTimeout(() => {\n    data = {\n      isLoggedIn: true,\n      user: 'Alvan',\n      message: '歡迎登入'\n    };\n    component.data = data;\n    fixture.detectChanges();\n  }, 3000);\n  tick(3000);\n  const weEl: HTMLElement = fixture.nativeElement.querySelector('.welcome');\n  expect(weEl.textContent).toContain(data.user);\n}));\n```\n\n這個測試使用了 `setTimeout()` 方法，令 `data` 物件內的屬性三秒後變更，並且重新賦值給元件內的 `data` 屬性，最後重新繫結。\n\n而這個測試另一個關鍵是 [tick()](https://angular.tw/api/core/ApplicationRef#tick) ， `tick()` 函式接受一個毫秒值作為參數（如果沒有提供則預設為 0）。\n\n該參數表示虛擬時鐘要前進多少，也就是說：\n* `setTimeout()` 如果時間設置 3000 ，那麼 `tick()` 也要設置 3000\n\n這樣才能正確取得資料。\n\n![](https://i.imgur.com/985KWgL.png)\n\n![tick() 時間參數設置小於 setTimeout() 的時間參數](https://i.imgur.com/K4XkEEM.png)\n\n> 至此完成了對元件的測試。\n\n* [GitHub 原始碼](https://github.com/pvt5r486/ngTestDemo)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.44 在 Angular 內進行測試(四) - 有依賴關係的元件","url":"%2Ff2e%2F20190613%2F1415116741%2F","content":"\n## 前言\n前一篇大致理解了如何測試一個單純的元件或是帶有繫結的元件。但在實務的應用上，元件經常依賴著其他服務元件，因此這個例子要實作的範例是 - 如何測試一個帶有依賴的元件？\n\n![](https://images.unsplash.com/photo-1556912102-895497aa1c7c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1015&q=80)\n\n* 在這個範例中，一個帶有依賴的元件可以拆成\n  * 製作一個 welcome 元件 + 一個負責提供資料的 user 服務元件\n\n## 環境建立\n輸入 `ng g c welcome -m app` 在產生 welcome 元件後將其註冊到 app.module 內。\n\n![](https://i.imgur.com/GFAqKOC.png)\n\n輸入 `ng g s user` 產生 user 服務元件\n\n![](https://i.imgur.com/vO7Rx2X.png)\n\n> 到 **app.module** 註冊 user 服務元件\n\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { DemoService } from './demo.service';\nimport { Demo2Service } from './demo2.service';\nimport { LightSwichComponent } from './light-swich/light-swich.component';\nimport { BannerComponent } from './banner/banner.component';\nimport { WelcomeComponent } from './welcome/welcome.component';\nimport { UserService } from './user.service';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    LightSwichComponent,\n    BannerComponent,\n    WelcomeComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [DemoService, Demo2Service, UserService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n基本的檔案建立完成後，接著就是撰寫程式碼了。\n\n**user.service**\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  isLoggedIn = true;\n  user = {\n    name: 'Alvan'\n  };\n  constructor() { }\n}\n```\n在服務元件內建立 `isLoggedIn` 屬性以及 `user` 物件，這是待會要提供給 welcomeComponent 的內容。\n\n**welcome Template**\n```html\n<h3 class=\"welcome\"><i>{{welcome}}</i></h3>\n```\n\n**welcome class**\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { UserService } from '../user.service';\n\n@Component({\n  selector: 'app-welcome',\n  templateUrl: './welcome.component.html',\n  styleUrls: ['./welcome.component.scss']\n})\nexport class WelcomeComponent implements OnInit {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit() {\n    this.welcome = this.userService.isLoggedIn ?\n      `歡迎, ${this.userService.user.name}` : `未授權, 請登入！`;\n  }\n\n}\n```\n\n最後把 app-welcome 標籤加到 app.component.html 。\n```html\n<app-welcome></app-welcome>\n```\n\n運行開發伺服器，看看執行結果。\n\n![isLoggedIn 為 true 的情況](https://i.imgur.com/sx5DeEL.png)\n\n![isLoggedIn 為 false 的情況](https://i.imgur.com/zUkNANX.png)\n\n## 測試帶有依賴的元件\n在這個範例裡 WelcomeComponent 依賴著 user 服務元件的資料，接收到資料後根據 `isLoggedIn` 的狀態決定顯示的語句。\n\n**welcome.component.spec**\n```js\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { WelcomeComponent } from './welcome.component';\nimport { UserService } from '../user.service';\n\ndescribe('WelcomeComponent', () => {\n  let component: WelcomeComponent;\n  let fixture: ComponentFixture<WelcomeComponent>;\n  const userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User'}\n  };\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ WelcomeComponent ],\n      providers: [\n        { provide: UserService, useValue: userServiceStub }\n      ]\n    });\n    fixture = TestBed.createComponent(WelcomeComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n```\n\n這裡跟之前練習有依賴關係的服務元件的測試時有點像，我們在 TestBed.configureTestingModule 內宣告了：\n* 待測試的元件 - WelcomeComponent\n* 在 providers 陣列中添加了 UserService 服務元件\n  * 並且透過 useValue 將 UserService 的資料換成測試用的資料\n\n被測試的元件不一定要注入真正的服務，可以是個模擬或偽造出來的資料。\n\n> 這裡的主要目的是測試元件，而不是服務。\n\n有些時候，服務元件可能連自身都有問題，不應該讓它干擾對元件的測試。\n\n注入真實的 UserService 有可能很麻煩，像是：\n* 真實的服務可能詢問使用者登入憑據\n* 也可能試圖連線認證伺服器\n\n這樣會很難處理這些行為，所以建立和註冊 UserService 替身 (userServiceStub) ，會讓測試更加容易。\n\n## 獲得注入的服務\n我們製作了一個 UserService 的替身 - `userServiceStub` ，那麼該如何取用它呢？\n\nAngular 的注入系統是層次化的。\n\n可以有很多層注入器，從根 TestBed 建立的注入器下來貫穿整個元件樹。\n\n因此這邊有兩種做法：\n\n第一種做法 - 最安全並有效的獲取注入服務的方法:\n* 從被測元件的注入器獲取\n* 元件注入器是 fixture 的 DebugElement 的屬性之一。\n\n```js\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n```\n\n第二種做法 - 透過 TestBed.get() 來使用根注入器獲取該服務：\n\n```js\n// UserService from the root injector\nuserService = TestBed.get(UserService);\n```\n不過這只有當 Angular 元件需要的恰好是該測試的根注入器時才能正常使用。\n\n而加入這部分後，我們的程式碼目前是這個樣子的：\n```js\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { WelcomeComponent } from './welcome.component';\nimport { UserService } from '../user.service';\n\ndescribe('WelcomeComponent', () => {\n  let component: WelcomeComponent;\n  let fixture: ComponentFixture<WelcomeComponent>;\n  let userServiceStub;\n  beforeEach(() => {\n    // 模擬物件\n    userServiceStub = {\n      isLoggedIn: true,\n      user: { name: 'Test User'}\n    };\n    TestBed.configureTestingModule({\n      declarations: [ WelcomeComponent ],\n      providers: [\n        { provide: UserService, useValue: userServiceStub }\n      ]\n    });\n    fixture = TestBed.createComponent(WelcomeComponent);\n    component = fixture.componentInstance;\n\n    // 獲取注入的服務\n    const userService = fixture.debugElement.injector.get(UserService);\n    const el = fixture.nativeElement.querySelector('.welcome');\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n```\n\n## 加入一些測試例\n接著補上一些測試例：\n\n```js\n  it('should welcome the user', () => {\n    fixture.detectChanges();\n    const content = el.textContent;\n    expect(content).toContain('歡迎');\n    expect(content).toContain('Test User');\n  });\n\n  it('should welcome \"Bubba\"', () => {\n    // 變更姓名\n    userService.user.name = 'Bubba';\n    fixture.detectChanges();\n    expect(el.textContent).toContain('Bubba');\n  });\n  it('should request login if not logged in', () => {\n    userService.isLoggedIn = false;\n    fixture.detectChanges();\n    const content = el.textContent;\n    // 檢查字串是不是不包含 \"歡迎\"\n    expect(content).not.toContain('歡迎');\n    expect(content).toBe('未授權, 請登入！');\n  });\n```\n\n* 第一個測試檢查 `el.textContent` 有沒有包含「歡迎」、「Test User」\n* 第二個測試檢查當變更姓名時，顯示是否仍包含「Bubba」\n* 第三個測試檢查當未授權登入時，顯示是否**不包含**「歡迎」\n  * 且顯示文字「未授權, 請登入！」\n\n![測試通過](https://i.imgur.com/ENlz6MI.png)\n\n![刻意失敗](https://i.imgur.com/hlgfXEC.png)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.43 在 Angular 內進行測試(三) - 繫結元件","url":"%2Ff2e%2F20190611%2F3397303578%2F","content":"\n## 前言\n同樣是元件的測試，這次試著假設一些不同的狀況，練習如何對這些元件進行測試。\n\n![](https://images.unsplash.com/photo-1559736139-6531cc82432e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1051&q=80)\n\n## 元件的繫結 (一) - 內嵌繫結\n建立一個 BannerComponent 並且透過繫結到元件的 `title` 屬性來展示動態標題。\n\n輸入 `ng g c banner -m app` 產生 BannerComponent 並且於 app.module 內註冊。\n\n**class**\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-banner',\n  templateUrl: './banner.component.html',\n  styleUrls: ['./banner.component.scss']\n})\nexport class BannerComponent implements OnInit {\n  title = 'This is Title';\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n**Template**\n```html\n<h1>{{title}}</h1>\n```\n\n**app.component**\n```html\n<app-banner></app-banner>\n```\n![](https://i.imgur.com/4JBi64D.png)\n\n> 將會寫一系列測試來探查 h1 標籤的值。\n\n### banner.component.spec\n首先在 beforeEach() 中使用標準的 HTML querySelector 來找到該元素。\n\n```js\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: ComponentFixture<BannerComponent>;\n  let h1: HTMLElement;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ],\n    });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    h1 = fixture.nativeElement.querySelector('h1');\n  });\n  it('最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同', () => {\n    expect(h1.textContent).toContain(component.title);\n  });\n});\n```\n\n> 測試看看！\n\n![](https://i.imgur.com/sgkuz7n.png)\n\n**createComponent() 函式不會繫結資料，因為繫結是在 Angular 執行變更檢測時才發生的。**\n\n### 解法 - 補上 detectChanges()\nTestBed.createComponent 不能觸發變更檢測，所以要補上 detectChanges() 。\n\n透過呼叫 fixture.detectChanges() 來要求 TestBed 執行資料繫結。\n\n```js\n  it('最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同', () => {\n    fixture.detectChanges();\n    expect(h1.textContent).toContain(component.title);\n  });\n```\n\n![](https://i.imgur.com/wKoCKRu.png)\n\n這種變更檢測是故意設計的，它給了測試者一個機會：\n* 在 Angular 初始化資料繫結以及呼叫生命週期的鉤子之前探查並改變元件的狀態\n\n像是我們可以這麼做：\n```js\n  it('最終呈現在網頁上的標題文字是否與元件內 title 屬性的值相同', () => {\n    component.title = 'Test Title';\n    fixture.detectChanges();\n    expect(h1.textContent).toContain(component.title);\n  });\n```\n在呼叫 fixture.detectChanges() 之前修改元件的 title 屬性。\n\n### 自動變更檢測\nBannerComponent 的這些測試需要頻繁呼叫 detectChanges() ，而 Angular 測試環境可以做到自動執行變更檢測，如：\n```js\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: ComponentFixture<BannerComponent>;\n  let h1: HTMLElement;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ],\n      providers: [\n        {provide: ComponentFixtureAutoDetect, useValue: true}\n      ]\n    });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    h1 = fixture.nativeElement.querySelector('h1');\n  });\n  it('should display original title', () => {\n    // Hooray! No `fixture.detectChanges()` needed\n    expect(h1.textContent).toContain(component.title);\n  });\n  it('should still see original title after comp.title change', () => {\n    const oldTitle = component.title;\n    component.title = 'Test Title';\n    console.log('第二個測試例', h1.textContent, oldTitle);\n    // Displayed title is old because Angular didn't hear the change :(\n    expect(h1.textContent).toContain(oldTitle);\n  });\n  it('should still see original title after comp.title change', () => {\n    const oldTitle = component.title;\n    component.title = 'Test Title';\n    fixture.detectChanges();\n    console.log('第三個測試例', h1.textContent, oldTitle);\n    expect(h1.textContent).toContain(oldTitle);\n  });\n});\n```\n\n第一個測試的例子展示了自動 detectChanges() 的好處。\n\n第二、三個例子要說明的是，**Angular 測試環境不會知道測試程式改變了元件的 `title` 屬性。**\n\n> 自動檢測只對非同步行為比如承諾的解析、計時器和 DOM 事件作出反應，直接修改元件屬性值是不會觸發自動檢測的。\n\n測試程式必須手動呼叫 detectChange()，來觸發新一輪的變更檢測週期。\n\n![](https://i.imgur.com/e1fKg6V.png)\n\n## 元件的繫結 (二) - 模擬使用者輸入\n修改剛剛的範例，替這個元件增加一個 Input 輸入，根據輸入來變化標題。\n\n**banner Template**\n```html\n<h1>{{title}}</h1>\n<input type=\"text\" [(ngModel)]=\"title\">\n```\n接著需要到 app.module 內 import `FormsModule` 才可以使用**雙向繫結**。\n\n### 使用 dispatchEvent() 修改輸入值\n如果想在測試時模擬使用者輸入，你就要找到 input 元素並設定它的 value 屬性。\n\n而 Angular 不知道我們設定了 input 元素的 value 屬性，所以需要先呼叫：\n* dispatchEvent()\n* 再呼叫 detectChanges()\n\n最後別忘了同樣也必須在 TestBed.configureTestingModule 內 import `FormsModule` 。\n\n```js\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: ComponentFixture<BannerComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ],\n      imports: [\n        FormsModule\n      ],\n      providers: [\n        {provide: ComponentFixtureAutoDetect, useValue: true}\n      ]\n    });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('比較輸入與標題是否一致', () => {\n    const hostElement = fixture.nativeElement;\n    const titleInput: HTMLInputElement = hostElement.querySelector('input');\n    const titleDisplay: HTMLElement = hostElement.querySelector('h1');\n\n    // 模擬使用者輸入的值\n    titleInput.value = 'DCFGBHNJK';\n    titleInput.dispatchEvent(new Event('input'));\n    fixture.detectChanges();\n    expect(titleDisplay.textContent).toBe('DCFGBHNJK');\n  });\n});\n```\n![測試通過](https://i.imgur.com/3NVQHJh.png)\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.42 在 Angular 內進行測試(二) - 元件","url":"%2Ff2e%2F20190611%2F268532028%2F","content":"\n## 前言\n介紹完服務元件的測試後，接著要學習如何測試一個單純的元件。\n\n![](https://images.unsplash.com/photo-1560092056-5669e776fc68?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1052&q=80)\n\n## 元件測試\n在 Angular 中，普通的元件包含了 Template 與 class ，因此想對元件進行充分的測試，勢必得對這兩個部分都進行測試才行。\n\n這些測試需要在瀏覽器的 DOM 中建立元件的宿主元素（就像 Angular 所做的那樣），然後檢查元件的 class 和 DOM 的互動是否如同 Template 中所描述的那樣。\n\nAngular 的 TestBed 為所有這些型別的測試提供了基礎設施。\n\n但是很多情況下，可以單獨測試元件類本身而不必涉及 DOM ，就已經可以用一種更加簡單、清晰的方式來驗證該元件的大多數行為了。\n\n### 建立一個最單純的元件\n測試之前我們要先準備環境，因此建立一個元件 - lightSwitch\n* 當用戶點選按鈕時，它會切換燈的開關狀態 (畫面上的文字狀態)\n\n> 輸入 `ng g c lightSwitch` 建立元件。\n\n**Template**\n```html\n<button (click)=\"clicked()\">Click me!</button>\n<span>{{getMessage()}}</span>\n```\n\n**class**\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-light-swich',\n  templateUrl: './light-swich.component.html',\n  styleUrls: ['./light-swich.component.scss']\n})\nexport class LightSwichComponent implements OnInit {\n  isOn = false;\n  constructor() { }\n  ngOnInit() {}\n  clicked() {\n    this.isOn = !this.isOn;\n  }\n  getMessage() {\n    return `燈現在是 ${this.isOn ? '開' : '關'} 的！`;\n  }\n}\n```\n\n**app.component Template**\n```html\n<app-light-swich></app-light-swich>\n```\n\n![成功運行](https://i.imgur.com/9UoI9OX.png)\n\n### 測試元件的 class\n可以像先前測試服務元件般，單獨測試元件中的 class 。\n\n* 這個範例中要測試 clicked() 方法能否正確切換燈的開關狀態\n* getMessage() 有無回傳合適的訊息\n\n> 而這個元件的 class 並沒有依賴任何的服務元件，是非常單純的。\n\n這種情況下可以直接 new 出物件實體，進行 `isOn` 屬性的狀態測試。\n\n**light-swich.component.spec**\n```js\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { LightSwichComponent } from './light-swich.component';\n\ndescribe('LightSwichComponent', () => {\n  it('點擊 clicked() 後的狀態測試', () => {\n    const comp = new LightSwichComponent();\n    expect(comp.isOn).toBe(false, '一開始的狀態是 false');\n    comp.clicked();\n    expect(comp.isOn).toBe(true, '按下後的狀態是 true');\n    comp.clicked();\n    expect(comp.isOn).toBe(false, '再按一次回到 false');\n  });\n\n  it('點擊 clicked() 後 Message 會顯示 \"開\"', () => {\n    const comp = new LightSwichComponent();\n    expect(comp.getMessage()).toMatch(/關/i, '一開始的狀態是關的');\n    comp.clicked();\n    expect(comp.getMessage()).toMatch(/開/i, '按下後為開');\n  });\n});\n```\n\n![測試成功](https://i.imgur.com/ixV4LKY.png)\n\n![故意出錯的情況](https://i.imgur.com/MvyBOzV.png)\n\n### 測試元件的 DOM\n完整的元件不只有 class ，元件還要和 DOM 以及其它元件進行互動。 \n\n只涉及 class 的測試可以得知元件 class 的行為是否正常，但不能得知元件是否能正常渲染出來、響應使用者的輸入和查詢或與它的父元件和子元件相整合。\n\n要進行完整的測試，我們不得不建立那些與元件相關的 DOM 元素了，必須檢查 DOM 來確認元件的狀態能在恰當的時機正常顯示出來，並且必須透過螢幕來模擬使用者的互動，以判斷這些互動是否如我們預期。\n\n> 而這部分就需要用到 **TestBed** 了。\n\n**當我們建立元件時， Angular CLI 會幫我們寫好預設的測試**\n```js\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { LightSwichComponent } from './light-swich.component';\n\ndescribe('LightSwichComponent', () => {\n  let component: LightSwichComponent;\n  let fixture: ComponentFixture<LightSwichComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ LightSwichComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(LightSwichComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n```\n而有些時候並不需要這些 Angular CLI 幫我們寫好的 Code 。\nAngular CLI 是預設我們可能會用到這些東西，而目前我們可以再精簡一些。\n\n```js\ndescribe('LightSwichComponent (minimal)', () => {\n  it('should create', () => {\n    TestBed.configureTestingModule({\n      declarations: [ LightSwichComponent ]\n    });\n    const fixture = TestBed.createComponent(LightSwichComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n```\n**當元件逐漸演變成更加實質性的東西時，才會用到那些 Angular CLI 幫我們預設產生的測試。**\n\n在這個例子中，傳給 TestBed.configureTestingModule 的元資料物件中只宣告了 **LightSwichComponent** - 也就是待測試的元件。\n\n> 不用宣告或匯入任何其它的東西，預設的測試模組中已經預先配置好了，\n**比如來自 @angular/platform-browser 的 BrowserModule。**\n\n#### createComponent()\n在配置好 TestBed.configureTestingModule() 之後，可以呼叫它的 createComponent() 方法。\n\nTestBed.createComponent() 會建立一個 LightSwichComponent 的元件，把相應的元素新增到  test-runner 的 DOM 中，然後返回一個 [ComponentFixture 物件](https://angular.tw/guide/testing#component-fixture)。\n\n特別要注意的是，**在呼叫了 createComponent 之後就不能再重新配置 TestBed 了。** createComponent 方法凍結了當前的 TestBed 定義，關閉它才能再進行後續配置。\n\n也就是說不能：\n* 呼叫任何 TestBed 的後續配置方法\n* 不能調 configureTestingModule()\n* 不能調 get()\n* 能呼叫任何 override ... 方法\n\n> 如果試圖這麼做，TestBed 就會丟擲錯誤。\n\n#### ComponentFixture\n[ComponentFixture](https://angular.tw/guide/testing#component-fixture) 是用來與所建立的元件及其 DOM 元素進行互動。\n\n從剛才的範例程式碼來看，我們可以透過 `fixture` 來訪問該元件的 instance ，並用 Jasmine 的 expect 語句來確保其存在。\n\n* [.toBeDefined()](https://jestjs.io/docs/en/expect.html#tobedefined)\n  * 使用 .toBeDefined() 檢查一個變數不是 undefined 。\n\n#### beforeEach()\n隨著元件的成長，可能會有很多組測試。\n\n這時除了一直複製之外，還有個比較好的做法：\n* 把重複會用到的程式碼搬到 beforeEach() 內。\n\n因此可以重新調整剛剛那段程式碼：\n```js\ndescribe('LightSwichComponent (minimal)', () => {\n  let component: LightSwichComponent;\n  let fixture: ComponentFixture<LightSwichComponent>;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ LightSwichComponent ]\n    });\n    fixture = TestBed.createComponent(LightSwichComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n```\n\n#### nativeElement\n可以使用 nativeElement 中獲取元件內的元素，像是：\n\n```js\ndescribe('LightSwichComponent (minimal)', () => {\n  let component: LightSwichComponent;\n  let fixture: ComponentFixture<LightSwichComponent>;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ LightSwichComponent ]\n    });\n    fixture = TestBed.createComponent(LightSwichComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n\n  it('檢查元件的元素內有沒有包含 按鈕(button)', () => {\n    const el: HTMLElement = fixture.nativeElement;\n    console.log(el);\n    console.log(el.getElementsByTagName('button').length);\n    expect(el.getElementsByTagName('button').length).toBeGreaterThan(0);\n  });\n});\n```\n\n`console.log(el);` 印出來的內容是：\n\n![](https://i.imgur.com/nANcw17.png)\n\n> 於是可以藉由 .getElementsByTagName() 找到 button 標籤，最後再判斷長度，即可測試這個元件內有沒有按鈕了。\n\n![](https://i.imgur.com/35qo3uE.png)\n\n#### DebugElement\n而除了使用 nativeElement 取得元件內的元素之外，也可以透過 DebugElement 取得元件內的元素。\n\n至於為什麼要使用 [DebugElement](https://angular.tw/api/core/DebugElement) 呢？\n\n以下是官方文件給出的解釋：\n> nativeElement 的屬性取決於執行環境。 你可以在沒有 DOM，或者其 DOM 模擬器無法支援全部 HTMLElement API 的平臺上執行這些測試。Angular 依賴於 DebugElement 這個抽象層，就可以安全的橫跨其支援的所有平臺。 Angular 不再建立 HTML 元素樹，而是建立 DebugElement 樹，其中包裹著相應執行平臺上的原生元素。 nativeElement 屬性會解開 DebugElement，並返回平臺相關的元素物件。\n\n所以上面那個使用 nativeElement 的測試可以改寫成：\n```js\ndescribe('LightSwichComponent (minimal)', () => {\n  let component: LightSwichComponent;\n  let fixture: ComponentFixture<LightSwichComponent>;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ LightSwichComponent ]\n    });\n    fixture = TestBed.createComponent(LightSwichComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n\n  it('檢查元件的元素內有沒有包含按鈕 (button)', () => {\n    const elDebug: DebugElement = fixture.debugElement;\n    const el: HTMLElement = elDebug.nativeElement;\n    console.log(el);\n    console.log(el.getElementsByTagName('button').length);\n    expect(el.getElementsByTagName('button').length).toBeGreaterThan(0);\n  });\n});\n```\n> 改寫後的結果會與改寫前完全一樣。\n\n## 小結\n實務上的元件可能不會像範例上一樣這麼單純，可能會依賴某個服務元件之類的...情況，因為再寫下去可能篇幅會過長，所以決定先在這邊設個中斷點。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.41 在 Angular 內進行測試(一) - 服務元件","url":"%2Ff2e%2F20190610%2F3544502226%2F","content":"\n## 前言\n測試對於一個公司的專案有多重要自然不言而喻，如何在 Angular 中進行測試呢？讓我們一起學習吧。\n\n![](https://images.unsplash.com/photo-1560100261-226dff8daa82?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 關於測試\n相信測試的好處以及壞處網路上隨便搜尋能夠找到相當大量的文章，所以這部份我想應該也不過多著墨在這裡了，以下附上一些文章，目的在於建立對於那些陌生名詞的認知：\n* [一次搞懂單元測試、整合測試、端對端測試之間的差異](https://blog.miniasp.com/post/2019/02/18/Unit-testing-Integration-testing-e2e-testing)\n  * 單元測試 (Unit testing)\n  * 整合測試 (Integration testing)\n  * 端對端測試 (End-to-end testing)\n* [關於『測試』這件事](https://yu-jack.github.io/2017/11/01/how-to-test/)\n  * User Story Test - 測試整個使用情景有沒有跟使用者所想的一樣\n\n## Angular 中的測試\n根據官方的文件描述 Angular CLI 會下載並安裝 [Jasmine 測試框架](https://jasmine.github.io/)，測試 Angular 應用時所需的一切。\n\n而每個新開的 Angular 專案都可以直接運行 `ng test` 指令立即進行測試。\n\n### 建立新的 Angular 專案\n\n![](https://i.imgur.com/QSjg1Rw.png)\n\n接著運行 `ng test` 指令，會看到一些測試的過程\n\n![](https://i.imgur.com/E8rTjnZ.png)\n\n而測試執行完畢後，也會開啟 chrome 瀏覽器並在 Jasmine HTML 報告器中顯示測試結果。\n\n可以直接點選 AppComponent 連結，重新跑過 AppComponent 底下的測試，或者是點擊掛在 AppComponent 下的連結也可以進行單獨的測試。\n\n![](https://i.imgur.com/trRO5M5.png)\n\n而這個由測試指令開啟的 chrome 瀏覽器會持續監聽程式碼的變化，因此可以對 app.component.ts 做一個小修改，並儲存它。 \n\n> 這些測試就會重新執行，瀏覽器也會重新整理，然後新的測試結果就出現了。\n\n而**直接關閉由測試指令開啟的 chrome 瀏覽器會馬上又被開啟**，原因是必須回到終端機按下 CTRL + C 終止指令運行才可以正確關閉。\n\n![](https://i.imgur.com/hro1ORg.png)\n\n### 測試檔案的配置\n通常的情況下 Angular CLI 會自動的產生 Jasmine 和 Karma 的配置檔案。\n\n也可以透過編輯 src/ 目錄下的 karma.conf.js 和 test.ts 檔案來微調很多選項。\n\n![](https://i.imgur.com/z7gIyPX.png)\n\nAngular CLI 會基於 angular.json 檔案中指定的專案結構和 karma.conf.js 檔案，來在記憶體中構建出完整的執行時配置。\n\n而如果要調整這些預設的設定，可能就要到 [Jasmine](https://jasmine.github.io/pages/docs_home.html) 和 [Karma](https://karma-runner.github.io/4.0/index.html) 的官方文件找找了。\n\n## 啟用程式碼覆蓋率報告\n在 Angular CLI 中， `ng test` 指令後面可以額外追加一些參數產生程式碼覆蓋率報告。\n\n### 而什麼是**程式碼覆蓋率**呢？\n根據 [WIKI](https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87) 的解釋，程式碼覆蓋（英語：Code coverage）是軟體測試中的一種度量，描述程式中原始碼被測試的比例和程度，所得比例稱為**程式碼覆蓋率**。\n\n> 白話來說大概可以當成是專案中的健康指標之類的吧，越高越好的那種。\n\n附上一篇雖然年代久遠，但對於名詞的了解上仍有一定的幫助：\n* [[如何提升系統品質-Day24] 測試 - Code Coverage](https://ithelp.ithome.com.tw/articles/10080981)\n\n### 試著產生第一份程式碼覆蓋率報告\n指令 `ng test` 後面可以接的參數可參考\n* [ng test](https://angular.io/cli/test)\n\n執行下列指令，觀察檔案結構有何異動：\n```\nng test --no-watch --code-coverage\n```\n\n![](https://i.imgur.com/JDhmuWw.png)\n\n當測試完成時，該命令會在專案中建立一個新的 /coverage 目錄。\n\n![](https://i.imgur.com/vk1N9Mr.png)\n\n這裡我使用 VS Code 的插件 - [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 開啟其 index.html 檔案以檢視帶有原始碼和程式碼覆蓋率值的報告。\n\n![](https://i.imgur.com/IeYIVpD.png)\n\n除了每次在 `ng test` 指令後方加入參數的作法外，也可以透過 Angular CLI 的 `angular.json` 中設定：\n```json\n\"test\": {\n  \"options\": {\n    \"codeCoverage\": true\n  }\n}\n```\n\n![](https://i.imgur.com/HGKBe0n.png)\n\n> 刪除 coverage 資料夾，執行 `ng test` 指令觀察是否仍產出 coverage 資料夾。\n\n![測試 OK](https://i.imgur.com/ED9RpPt.png)\n\n## 服務元件的測試\n服務元件的測試算是比較單純的，因為服務元件建立後，不像普通的元件含有 Template 的部分。\n\n使用 `ng g s demo` 指令建立服務元件，並且在 demo.service 寫一些程式。\n\n**demo.service.ts**\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DemoService {\n\n  constructor() { }\n  getArray() {\n    return ['en', 'es', 'fr'];\n  }\n  getString(str) {\n    return str;\n  }\n}\n```\n接著在 demo.service.spec 寫測試案例。\n\n```js\nimport { TestBed } from '@angular/core/testing';\n\nimport { DemoService } from './demo.service';\n\ndescribe('DemoService', () => {\n  let demoService: DemoService;\n  it('檢查陣列是否包含特定語系', () => {\n    demoService = new DemoService();\n    const languages = demoService.getArray();\n    expect(languages).toContain('en');\n    expect(languages).toContain('es');\n    expect(languages).toContain('fr');\n    expect(languages.length).toBe(3);\n  });\n\n  it('檢查輸入字串是否等於輸出字串', () => {\n    demoService = new DemoService();\n    expect(demoService.getString('o')).toBe('o');\n  });\n});\n```\n\n> Angular CLI 預設會幫我們把服務元件 import 進該服務元件的測試檔中，方便進行測試。\n\n第一個測試利用了 new 讓 DemoService 實體化，並且得以取用 DemoService 內的方法：\n* getArray()\n* getString()\n\n而這段測試 Code 使用的方法可以從 [jasmine](https://jasmine.github.io/api/3.4/global.html) 的文件中找到詳細描述。\n\n* describe(description, specDefinitions)\n  * 建立一**組**測試規範 (spec)，通常會把性質相近的測試放在一起\n  * description - 這組測試的描述\n  * specDefinitions - 等待被測試的函式\n\n* it(description, testFunction, timeout)\n  * 定義一**個**測試規範\n  * description - 這個測試的描述\n  * testFunction - 包含測試代碼的函式\n  * timeout - 自訂非同步時的規範  \n\n* expect(actual) → {matchers}\n  * 為這個規範建立期望\n  * actual - 用於測試預期的實際值\n\n* toContain(expected)\n  * expect 包含特定值的實際值\n  * 如 `expect(languages).toContain('en');` 為 languages 陣列是否有包含 `en` 字串在某個陣列元素內\n\n* toBe(expected)\n  * 將對 expected 進行三個等號的比較\n\n> 輸入測試指令 `ng test` 並觀察。\n\n![5 個測試都通過了](https://i.imgur.com/QLnPPTv.png)\n\n而刻意營造錯誤的話則會呈現：\n\n![](https://i.imgur.com/LBkhuQ5.png)\n\n\n## 使用 TestBed 測試服務元件\n在實務中，服務元件最終會透過 Angular 的相依注入 (DI) 來建立服務。\n\n而 TestBed 會動態建立一個用來模擬 @NgModule 的 Angular 測試模組，因此我們可以將服務元件注入到 TestBed ，接著就可以進行測試了。\n\n```js\nimport { TestBed } from '@angular/core/testing';\n\nimport { DemoService } from './demo.service';\n\ndescribe('DemoService', () => {\n  let service: DemoService;\n  beforeEach(() => TestBed.configureTestingModule({ providers: [DemoService]}));\n  it('檢查語系陣列是否包含特定語系', () => {\n    service = TestBed.get(DemoService);\n    const languages = service.getArray();\n    expect(languages).toContain('en');\n    expect(languages).toContain('es');\n    expect(languages).toContain('fr');\n    expect(languages.length).toEqual(3);\n  });\n\n  it('檢查輸入字串是否等於輸出字串', () => {\n    service = TestBed.get(DemoService);\n    const returnInput = service.getString;\n    expect(returnInput('a')).toBe('a');\n  });\n```\n\n* beforeEach(function, timeout)\n  * describe 在調用它的每個規範之前運行一些共享設置\n* TestBed.configureTestingModule()\n  * 接收一個元資料物件，其中具有 @NgModule 中的絕大多數屬性。\n  * 要測試某個服務，就要在元資料的 `providers` 屬性中指定一個將要進行測試的陣列。\n* TestBed.get()\n  * 取得 TestBed 中的服務\n\n上面那一段測試 Code 還有可以優化的地方，例如：\n* 可以把 `service = TestBed.get(DemoService);` 提出來放在 beforeEach() 內\n```js\nimport { TestBed } from '@angular/core/testing';\n\nimport { DemoService } from './demo.service';\n\ndescribe('DemoService', () => {\n  let service: DemoService;\n  beforeEach(() => {\n    TestBed.configureTestingModule({ providers: [DemoService]});\n    service = TestBed.get(DemoService);\n  });\n  it('檢查語系陣列是否包含特定語系', () => {\n    const languages = service.getArray();\n    expect(languages).toContain('en');\n    expect(languages).toContain('es');\n    expect(languages).toContain('fr');\n    expect(languages.length).toEqual(3);\n  });\n\n  it('檢查輸入字串是否等於輸出字串', () => {\n    const returnInput = service.getString;\n    expect(returnInput('a')).toBe('a');\n  });\n});\n```\n\n## 使用 jasmine.createSpyObj() 測試一個有相依關係的服務元件\n新增另一個服務元件 demo2 並且把 demo 注入，使 demo2 形成對 demo 的相依關係。\n\n**demo1.service**\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DemoService {\n\n  constructor() { }\n  getArray() {\n    return ['en', 'es', 'fr'];\n  }\n  getString(str) {\n    return str;\n  }\n}\n```\n\n**demo2.service**\n```js\nimport { Injectable } from '@angular/core';\nimport { DemoService } from './demo.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class Demo2Service {\n\n  constructor(private demoService: DemoService) { }\n  getArray() {\n    return this.demoService.getArray();\n  }\n}\n```\n\n撰寫 **demo2.service.spec.ts**\n\n```js\nimport { TestBed } from '@angular/core/testing';\nimport { Demo2Service } from './demo2.service';\n\ndescribe('Demo2Service', () => {\n  let masterService: jasmine.SpyObj<Demo2Service>;\n\n  beforeEach(() => {\n    const spy = jasmine.createSpyObj('ArrayService', ['getArray']);\n    TestBed.configureTestingModule({\n      providers: [\n        { provide: Demo2Service, useValue: spy }\n      ]\n    });\n    masterService = TestBed.get(Demo2Service);\n    console.log(masterService);\n  });\n  it('檢查語系陣列是否包含特定語系', () => {\n    const arr = ['en', 'es', 'fr'];\n    masterService.getArray.and.returnValue(arr);\n    const languages = masterService.getArray();\n    expect(languages).toContain('en');\n    expect(languages).toContain('es');\n    expect(languages).toContain('fr');\n    expect(languages.length).toEqual(3);\n  });\n});\n```\n\n使用 [jasmine.createSpyObj()](https://jasmine.github.io/api/3.4/jasmine.html) 產生一個含有 `getArray` 方法的物件。\n\n而 `useValue` 可以參考[官方說明文件](https://angular.tw/guide/dependency-injection-providers#value-providers)，定義物件使用 `useValue` 作為 key 來把該變數關聯起來。\n\n最後需要透過 `.getArray.and.returnValue()` 設定\n* 當 getArray 方法被呼叫時回傳什麼值\n\n> 如果少了這個步驟，呼叫 getArray 方法的話可是什麼事情都不會發生的。\n\n透過這樣的方式使 demo2 與 demo 脫鉤，就可以單獨測試 demo2 。\n\n![](https://i.imgur.com/26rA6VG.png)\n\n* [GitHub 原始碼](https://github.com/pvt5r486/ngTestDemo)\n\n## 小結\n在學習這一部分的時候，遇到蠻明顯的卡關...。\n\n主要是因為看不懂官方中文的文件，感覺省略了很多東西。\n\n例如[對服務的測試 Service Tests](https://angular.tw/guide/testing#service-tests) ，這邊範例感覺提供的不夠完整，讓我不知從何下手做起。\n\n於是我轉而參考其他篇文章，如：\n* [[Day 30] Angular 2 單元測試 Unit Test](https://ithelp.ithome.com.tw/articles/10189022) 裡面的測試服務 (Service)\n\n並與官方的程式碼交叉參考，反覆撞牆下才完成本次的範例實作。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.40 Angular Router 加上路由守衛 (Route Guards)","url":"%2Ff2e%2F20190609%2F1487025750%2F","content":"\n## 前言\n延續上一篇的情境，現在有了前台與後台的區分。但實務上後台是不允許未經認證的人隨意進入瀏覽的，通常會搭配一個登入介面，而光靠登入介面還不夠，因為使用者很可能會藉由直接輸入網址的方式瀏覽後台頁面，這時候就需要依賴路由守衛 (Route Guards) 了 。\n\n![](https://images.unsplash.com/photo-1559888894-7199667c0558?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 需求\n延續上一份 ngRouteDemo 的範例，現在需求為：\n\n* 前台 (front) - 一般人可以隨意瀏覽的部分\n  * index\n    * page1\n    * page2\n    * page3\n* 後台 (back) - 希望加入路由守衛的部分\n  * index\n    * page1\n    * page2\n    * page3\n\n**範例參考[中文 Angular 官方手冊](https://angular.tw/guide/router#milestone-5-route-guards)**\n\n## 路由守衛 (Route Guards)\n根據官方文件說明，路由守衛被**應用的場合**可能會是：\n* 該使用者可能無權導航到目標元件\n* 可能使用者得先登入（認證）\n* 在顯示目標元件前，可能得先獲取某些資料。\n* 在離開元件前，你可能要先儲存修改。\n* 你可能要詢問使用者：你是否要放棄本次更改，而不用儲存它們？\n\n> 可以藉由路由配置中新增守衛，來處理以上這些應用場合。\n\n### 路由守衛的返回值\n路由守衛會返回一個值，以控制路由器的行為：\n* 如果它返回 `true` 導航過程會繼續\n* 如果它返回 `false` 導航過程就會終止，且**使用者留在原地**\n  * 當返回 `false` 時，也可以告訴路由器導航到別處，例如可以導航到登入頁面\n* 如果它返回 UrlTree 則取消當前的導航，並且開始導航到返回的這個 UrlTree\n\n### 路由守衛的介面種類\n路由器可以支援多種守衛介面：\n* CanActivate - 處理導航到某路由的情況\n* CanActivateChild - 處理導航到某子路由的情況\n* CanDeactivate - 來處理從當前路由離開的情況\n* Resolve - 在路由啟用之前獲取路由資料\n* CanLoad - 處理非同步導航到某特性模組的情況\n\n**路由守衛檢查的順序**\n根據手冊上的描述，在分層路由的每個級別上，可以設定多個守衛。 \n\n* 路由器會先按照從最深的子路由，由下往上檢查的順序來檢查 CanDeactivate() 和 CanActivateChild() 守衛\n  * 然後它會按照從上到下的順序檢查 CanActivate() 守衛。 \n  * 如果特性模組是非同步載入的，在載入它之前還會檢查 CanLoad() 守衛。 \n\n**如果任何一個守衛返回 `false` ，其它尚未完成的守衛會被取消，這樣整個導航就被取消了。**\n\n> 這樣看起來最適合這個範例使用的應該就是 CanActivate 了。\n\n## CanActivate\n所以我們要使用 CanActivate 來保護後台的所有頁面不被未授權的使用者看到。\n\n但是在這個範例中，為了方便示範：\n* 將使用 CanActivate 並把路由守衛回傳值設為 `false` \n  * 藉以證明無法透過輸入網址進入保護頁面\n\n## 建立路由守衛\n輸入指令，以下兩種指令則一即可\n```\nng generate guard auth/auth\n```\n\n```\nng g g auth/auth\n```\n\n輸入後 Angular CLI 也會很貼心的問我們要使用哪一種\n![](https://i.imgur.com/7ZSY4yy.png)\n\n選擇 CanActivate 後按下 Enter ，發現 Angular CLI 建立了兩隻檔案，分別為測試檔以及主要檔案。\n\n![](https://i.imgur.com/iOp8vzY.png)\n\n### 觀察 auth.guard\n這支由 Angular CLI 建立的檔案，剛打開時什麼都沒有，而且還會跳出錯誤。\n\n```js\nimport { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements  {\n  \n}\n```\n\n![](https://i.imgur.com/OyKwQWS.png)\n\n**顯然的需要在這裡寫一些東西才行。**\n\n於是可以先使用官方提供的範例，觀察一下運作情形，稍後再來修改成我們要的。\n\n* 從 `@angular/router` 中 import `CanActivate`\n* 貼上官方的範例程式\n\n**auth.guard**\n```js\nimport { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivate } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): boolean {\n    console.log('AuthGuard#canActivate 被觸發了');\n    return true;\n  }\n}\n```\n> 這樣基本的路由守衛配置就完成了。\n\n## 匯入路由守衛\n接著把剛才設定好的路由守衛匯入 back-routing.module 。\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { IndexComponent} from './index/index.component';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\nimport { AuthGuard } from '../auth/auth.guard';\n\nconst routes: Routes = [\n  {\n    path: 'back',\n    component: IndexComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: 'page1',\n        component: Page1Component,\n      },\n      {\n        path: 'page2',\n        component: Page2Component,\n      },\n      {\n        path: 'page3',\n        component: Page3Component,\n      }\n    ],\n  },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class BackRoutingModule { }\n```\n\n> 搞定，先運行看看吧！\n\n![位於前台時](https://i.imgur.com/MKaXtw4.png)\n\n![切換到後台時](https://i.imgur.com/hEWSLPb.png)\n\n![手動輸入後台的 URL](https://i.imgur.com/6GLD9IN.png)\n\n**成功了，接著我們回過頭來研究 auth.guard.ts 檔內的 canActivate() 吧！**\n\n## 調整 auth.guard 內的 canActivate()\n可以參考官方提供的文件 \n* [CanActivate()](https://angular.tw/api/router/CanActivate)\n* [navigate()](https://angular.tw/api/router/Router#navigate)\n\n```js\nimport { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivate, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private router: Router) {}\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): boolean {\n    console.log('AuthGuard#canActivate 被觸發了, 你沒有授權！將跳轉回前台頁面');\n    this.router.navigate(['/front']);\n    return false;\n  }\n}\n```\n\n* [ActivatedRouteSnapshot](https://angular.tw/api/router/ActivatedRouteSnapshot) 包含了即將被啟用的路由\n* [RouterStateSnapshot](https://angular.tw/api/router/RouterStateSnapshot) 包含了該應用即將到達的狀態\n\n為了使未認證的使用者能導航到指定頁面，我們需要匯入 `Router` 類別，並且在建構式內實例化，接著使用底下的方法 `navigate()` 。\n\n**強制返回 `false` ，並且觀察當觸發路由守衛時，是否會正確的導航到指定頁面。**\n\n> 搞定了！測試看看吧。\n\n![點擊後台連結，被導航回前台](https://i.imgur.com/fjKK3se.png)\n\n嘗試輸入後台子頁面的網址仍被路由守衛攔下，由於畫面相同就不重複張貼了。\n\n## 小結\n於是靠著官方手冊的指引，我們成功地建立了一個路由守衛，使得未通過驗證的人不得訪問後台的網頁。\n\n當然這部分省略了很多東西，但我目的僅為了實作一個簡單的路由守衛範例，並驗證它是真的有效，所以就省略了登入步驟，直接設定不管如何都是 `false` ，藉以觀察當未通過驗證時是否正確導航到指定目的地。\n\n* [GitHub - 範例原始碼](https://github.com/pvt5r486/ngRouterDemo)\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"轉職成為菜鳥前端的第一個禮拜","url":"%2Fnote%2F20190607%2F2705349571%2F","content":"\n## 前言\n還記得那個下定決心的夜晚是 2018 年的 6 月 11 日，那個時候的我仍任職於鄉下某間負責修理電腦、偶爾打雜，職稱卻掛 MIS 的公司。距今也已經差不多快要一年了，換句話說我花了一年的時間努力，才終於跨過轉職的門檻，得以成為 Junior 前端工程師。\n\n![](https://images.unsplash.com/photo-1559830772-73d4ede5bcac?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjF9&auto=format&fit=crop&w=1350&q=80)\n\n## 轉職契機\n我本身是私立科大資工系畢業的，那個時候系上還在推寫 APP ，不過那個時候很混，算是把大學的時間都玩掉了，畢業的時候連點像樣的東西都沒有。\n\n接著就去當兵了，退伍後更是什麼程式語言、演算法都不記得了。\n\n> 幸好本科系的加持還是有差的，雖然大學期間頗混，但在耳濡目染下一些基礎的計算機概論常識還是有的。\n\n### 第一個誘因\n後來應徵上了一間公司，雖然職稱是掛 MIS ，不過就如同前言所提到的：\n* 修電腦、排除操作系統、軟體上的障礙 (例如 office 系列) - 60%\n* 打雜 - 30%\n* 寫程式 - 10%\n\n雖然寫程式的比例頗低，但我第一件進公司的事情是：\n* 負責把公司的 ASP 網頁改成 ASP.NET Web Forms\n* 資料庫的部分使用 MSSQL Server 2012 Express\n\n> 其實我不會這些東西，當時面試時就只是說了「我願意試試看」就錄取了。\n\n後來事實證明我辦到了，雖然從現在的角度看來那網頁有點慘不忍睹，不過至少階段性任務還是達成了。\n\n而我在接觸網頁的過程中逐漸的喜歡上這部分，對我來說網頁最大的魅力莫過於：\n* 基礎網頁非常容易上手，容易建立成就感\n  * 你可以看到那些文字、圖片呈現在瀏覽器畫面上\n* 初期學習曲線平緩\n\n### 第二個誘因\n由於任職的公司對於前端網頁的技術能量需求不大，而我任職快滿 2 年時逐漸萌生轉職的念頭，覺得自己這樣下去不行。\n\n對我來說這樣的職涯，學習已經停滯了，而且這份工作技術含量太低了。\n\n我也不敢想像三、四十歲時仍然蹲在桌子下幫人安裝電腦、修理電腦的那個畫面。\n\n**話是這麼說沒錯，但辭掉這份工作後，我會什麼？**\n\n我說不上來。\n\n基於先前替公司寫網頁時的感覺，有了一個不太肯定的答案「**或許我可以寫看看網頁？**」\n\n現在看來也不是什麼破釜沉舟的決定，就只是相較之下比較合理的選擇。\n\n## 往前端前進的方向\n既然都決定要轉職成一個以「寫網頁」當作工作的人，那具體來說該怎麼辦呢？\n\n> 那時候的我連**前端**這個名詞都不知道，我只知道我想把寫網頁當成工作，就這麼簡單。\n\n但我一點方向都沒有，那個時候看著自己替公司做的網頁醜到不行，朋友說可以試試看套 Bootstrap 4 ，至少不會這麼醜。\n\n### 一切起於 Bootstrap 4\n我按照朋友的建議，看了一下 Bootstrap 4 該怎麼用，但是怎麼用就是不順。\n\n後來因為一直看到網頁內的某個廣告，好奇驅使下就點擊了，這也是認識六角學院的開始。\n\n因為**六角學院**的資源下，我知道了前端工程師大致上是在做什麼的、也有了一些方向。\n\n**更不可思議的是也間接地拓展了一些人脈。**\n\n### 寫筆記帶來意想不到的收穫\n拓展人脈這點也是始料未及的，**起因只是因為被建議可以寫寫筆記、記錄學習心得，讓自己學得更好。**\n\n那個時候我選擇 Medium 並且寫了 「JavaScript 的奇怪部分」筆記，並且被建議可以試著貼到社團，這樣可以幫助同樣在學習這個部分的新手。\n\n> 而這個建議奠定了到現在我還仍然喜歡寫文章的基石，也認識了一些同樣愛分享的前端朋友。\n\n因為這些人脈，對於前端的知識在這些日子裡有飛躍式的提升，亦獲得一些實質的建議與資源，諸如：\n* 履歷怎麼改善、面試技巧等等\n* 前端技術的學習資源\n  * 例如被邀請去參加 [程式導師實驗計畫第三期](https://medium.com/hulis-blog/mentor-program-3rd-47a2e85e33b3)\n    * 這是一個需要投入非常大量時間自學的[計畫](https://github.com/Lidemy/mentor-program-3rd-pvt5r486)，但因為跑到一半我就找到工作了，所以沒有跑完\n* 思維的轉換\n* 情報交換\n\n**而更重要的是，也是因為寫了這些文章，儘管我不會 Angular ，但我的履歷仍被現在的主管看中。**\n\n後來與現任主管閒聊時，他說「**寫技術筆記這件事，可以當成是一種自學能力的展現，雖然你不會 Angular ，但我認為可以讓你試試看。**」\n\n> 所以直到現在，我仍然維持著寫作的習慣，相信這可以讓人變得更好，也可以讓更多比我菜的新手得到幫助。\n\n## 轉職成為菜鳥前端的第一個禮拜\n雖然現在連試用期都還沒過，但我總算是完成了當初自己設下的里程碑，這對肯定自己過去投入的那些時間學習是很有幫助的。\n\n而現在的公司也蠻符合內心的期望：\n* 同事們都蠻幽默且好相處的\n* 技術能量相當充沛\n* 上班時間很彈性\n\n剛進公司的第一個禮拜就參與了自家產品的優化會議\n* 這也讓我了解到原來一個產品要優化大概是怎麼一回事\n* 由那些團隊一起討論解決方案之類的\n\n總之剛進公司的第一個禮拜什麼事情都蠻新鮮的，除了很多陌生的名詞要記憶以及熟悉專案結構外，主管也決定要先在我們 UI Team 內試著跑跑看 Scrum 敏捷開發，並且試著利用這種開發模式做一個 Side Project ，當成是讓我練習 Angular 以及與團隊其他成員的協作。\n\n> 對我來說一切才剛要開始，這些都是還我沒有經歷過的，目前一切是這麼的令人期待，我也不能浪費這些機會，得好好把握才行。\n\n\n","tags":["里程碑"],"categories":["雜記"]},{"title":"[從 0 開始的 Angular 生活]No.39 實作一個 Angular Router 切換元件頁面(二)","url":"%2Ff2e%2F20190607%2F3107809513%2F","content":"\n## 前言\n在上一篇的實作中，我們完成了一個最基礎的 Angular Router ，而本文將修改需求，將其擴充並實作出一個具有子路由功能的範例。\n\n![](https://images.unsplash.com/photo-1556742504-16b083241fab?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 需求\n延續上一份 ngRouteDemo 的範例，現在需求變更為：\n* 有前台 (front) 與後台 (back) 的區分\n  * 前台就是一般人可以隨意瀏覽的部分\n    * 裡面有 index 、 page1 、 page2 、 page3\n  * 後台就是會套用路由守衛，要滿足條件才可以進入\n    * 裡面有 index 、 page1 、 page2 、 page3\n\n## 建立環境 - 區分前後台\n先從區分前後台開始做起吧！\n\n### 新增功能模組\n新增兩個功能模組分別為：\n* front - 前台\n* back - 後台\n\n新增功能模組，如：\n```\nng g m front\n```\n\n> 執行完指令後 Angular CLI 會自動將我們新增的功能模組 import 至 AppModule 內。\n\n此時 `app.module` 內容如：\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { FrontModule } from './front/front.module';\nimport { BackModule } from './back/back.module';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    FrontModule,\n    BackModule,\n    AppRoutingModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n> 特別注意此處 `imports` 陣列內的順序，父路由最後只會負責**萬用字元路由與預設路由**，因此應將其順序放於最後。\n\n### 新增元件 & 搬運元件\n我們新加入了兩個功能模組用來區分前後台，接著要建立前後台都有的 index 元件，目的是作為殼使用。\n\ncd 進剛才建立的功能模組內，並新增元件，如：\n```\nng g c index\n```\n\n最後將之前建立好的 Page1 、 Page2 、 Page3 元件搬進 front / back 功能模組內。\n\n**最後結構上會像是這樣**\n* AppComponent - 父路由\n  * front - 功能模組\n    * index - 子路由\n      * page1\n      * page2\n      * page3\n  * back - 功能模組\n    * index - 子路由\n      * page1\n      * page2\n      * page3\n\n> 別忘了要在建好的功能模組內， import 相關的元件進來，並且設置要 `exports` 的元件，因為最後配置父路由時會需要用到。\n\n**front.module**\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IndexComponent } from './index/index.component';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\n\n\n@NgModule({\n  declarations: [\n    IndexComponent,\n    Page1Component,\n    Page2Component,\n    Page3Component\n  ],\n  imports: [\n    CommonModule,\n  ],\n  exports: [IndexComponent]\n})\nexport class FrontModule {  }\n```\n\n> back.module 同 front.module 設置。\n\n### 調整各個元件的 Template\n**front 功能模組 IndexComponent 的 Template**\n```html\n<h2>現在位於 front 元件，請點擊以下連結切換頁面</h2>\n<ul>\n  <li>\n    <a routerLink=\"page1\" routerLinkActive=\"active\">page1</a>\n  </li>\n  <li>\n    <a routerLink=\"page2\" routerLinkActive=\"active\">page2</a>\n  </li>\n  <li>\n    <a routerLink=\"page3\" routerLinkActive=\"active\">page3</a>\n  </li>\n</ul>\n<router-outlet></router-outlet>\n```\n\n**back 功能模組 IndexComponent 的 Template**\n```html\n<h2>現在位於 back 元件，請點擊以下連結切換頁面</h2>\n<ul>\n  <li>\n    <a routerLink=\"page1\" routerLinkActive=\"active\">page1</a>\n  </li>\n  <li>\n    <a routerLink=\"page2\" routerLinkActive=\"active\">page2</a>\n  </li>\n  <li>\n    <a routerLink=\"page3\" routerLinkActive=\"active\">page3</a>\n  </li>\n</ul>\n<router-outlet></router-outlet>\n```\n\n**AppComponent 的 Template**\n```html\n<h1>點擊以下連結切換元件</h1>\n<ul>\n  <li>\n    <a routerLink=\"/front\" routerLinkActive=\"active\">前台</a>\n  </li>\n  <li>\n    <a routerLink=\"/back\" routerLinkActive=\"active\">後台(需驗證)</a>\n  </li>\n</ul>\n<router-outlet></router-outlet>\n```\n\n## 替功能模組設置子路由\n複製 `app-routing.module` 並且貼進 front 功能模組內，重新命名為 `front-routing.module` 。\n\n**修改 `front.module` ，將剛才新增的路由設定檔引入，如：**\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IndexComponent } from './index/index.component';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\nimport { FrontRoutingModule } from './front-routing.module';\n\n\n@NgModule({\n  declarations: [\n    IndexComponent,\n    Page1Component,\n    Page2Component,\n    Page3Component\n  ],\n  imports: [\n    CommonModule,\n    FrontRoutingModule\n  ],\n  exports: [IndexComponent]\n})\nexport class FrontModule {  }\n```\n\n**修改 `front-routing.module`**\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { IndexComponent} from './index/index.component';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\n\nconst routes: Routes = [\n  {\n    path: 'front',\n    component: IndexComponent,\n    children: [\n      {\n        path: 'page1',\n        component: Page1Component,\n      },\n      {\n        path: 'page2',\n        component: Page2Component,\n      },\n      {\n        path: 'page3',\n        component: Page3Component,\n      }\n    ],\n  },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class FrontRoutingModule { }\n```\n\n> 這部分 back 功能模組同 front 功能模組配置。\n\n## 修改 app-routing.module 配置\n配置完功能模組的子路由後，最後只需要微調一下這邊就可以了。\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { IndexComponent } from './front/index/index.component';\n\nconst routes: Routes = [\n  { path: '',   redirectTo: '/front', pathMatch: 'full' },\n  { path: '**', component: IndexComponent },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n> 這裡 import front 功能模組內的 IndexComponent 元件，因為我希望當使用者胡亂輸入時會顯示這個元件。\n\n## 測試看看\n\n![預設狀態](https://i.imgur.com/wOh4I8I.png)\n\n![胡亂輸入時](https://i.imgur.com/zSXE5f0.png)\n\n![切換到後台的狀態](https://i.imgur.com/Lg5fO3D.png)\n\n![處於前台且 page1 的狀態](https://i.imgur.com/ESm6VJi.png)\n\n## 小結\n本來以為這部分應該不會太複雜，但在不熟 Angular 的情況下我還是搞了蠻久的。\n\n當初預計這一篇要一起實作路由守衛的部分，看來只能下一篇了，不然篇幅太長囉。\n\n* [GitHub - 範例原始碼](https://github.com/pvt5r486/ngRouterDemo)\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.38 實作一個 Angular Router 切換元件頁面(一)","url":"%2Ff2e%2F20190605%2F512374788%2F","content":"\n## 前言\n今天是進入公司的第三天，為了能盡快投入專案與成為團隊可用的戰力，我正在努力啃官方文件學習 Angular 的知識，所以這一篇文章主要是記錄我如何閱讀官方文件後，實作這個非常基本的、帶導航的網頁應用。\n\n## 需求\n需求大概是這樣的：\n* 開一個新的 Angular 專案，並且一開始選擇加入 Router 功能\n  * 根元件是 AppComponent ，然後下方有三個子元件分別是\n    * page1\n    * page2\n    * page3\n  * 可以在 AppComponent 內點擊連結切換到這三個頁面\n\n**參考文件:**\n* [路由與導航](https://angular.tw/guide/router#routing--navigation)\n* [Routes](https://angular.tw/api/router/Routes#simple-configuration)\n\n## 建立環境\n輸入 `ng new ngRouterDemo` 建立新專案，並直接選擇要使用 Router 。\n\n![](https://i.imgur.com/in0naEz.png)\n\n### 觀察檔案結構\n這次選擇加入 Router 後，發現 app 資料夾內多了 `app-routing.module.ts`\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nconst routes: Routes = [];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n然後 `app.module.ts` 中也把 `app-routing.module.ts` 這隻檔案給引入了。\n\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n> 對照一下有無加入 Router 的部分\n\n![app.module](https://i.imgur.com/ng0fBOP.png)\n\n除此之外就是 app 資料夾內多了 `app-routing.module.ts` 這隻檔案。\n\n**運行結果**\n\n![](https://i.imgur.com/XtHwZdA.png)\n\n沒有什麼明顯的變化。\n\n## 分別建立三個元件\n輸入指令建立本次範例用的元件\n* page1\n* page2\n* page3\n\n如 `ng g c page1`\n\n![](https://i.imgur.com/K3wk8Gy.png)\n\n## 配置路由\n因為是選擇使用 Router 的模式，所以 Angular CLI 預設幫我們加入了 `router-outlet` 標籤，這代表路由切換後的畫面都會在這個標籤裡面呈現。\n\n> **以下引用自官方說明：**\nRouterOutlet 是一個來自路由模組中的指令，它的用法類似於元件。 它扮演一個佔位符的角色，用於在範本中標出一個位置，路由器將會把要顯示在這個出口處的元件顯示在這裡。\n有了這份配置，當本應用在瀏覽器中的 URL 變為 /heroes 時，路由器就會匹配到 path 為 heroes 的 Route，並在宿主檢視中的 RouterOutlet 之後顯示 HeroListComponent 元件。\n\n\n### 加入 RouterLink 連結\n因為要點擊連結後透過路由配置切換到該元件，所以必須先設置路由器連結 (Router links)：\n\n**對 Appcomponent 進行 Template 上的調整**\n```html\n<h1>點擊以下連結切換元件</h1>\n<ul>\n  <li>\n    <a routerLink=\"/page1\" routerLinkActive=\"active\">Page1</a>\n  </li>\n  <li>\n    <a routerLink=\"/page2\" routerLinkActive=\"active\">Page2</a>\n  </li>\n  <li>\n    <a routerLink=\"/page3\" routerLinkActive=\"active\">Page3</a>\n  </li>\n</ul>\n<router-outlet></router-outlet>\n```\n\n* RouterLink\n  * a 標籤上的 RouterLink 指令讓路由器得以控制這個 a 元素，這裡的導航路徑是固定的，因此可以把一個字串賦給 routerLink（\"一次性\"繫結）。\n  * 這後面接的就是實際上網址列顯示的路徑\n* RouterLinkActive\n  * 在每個 a 標籤上，你會看到一個 `RouterLinkActive` 的屬性繫結，像是 `routerLinkActive=\"...\"`\n  * 等號右邊可以填入包含一些用空格分隔的 CSS 類名，當這個連結啟用時，路由器將會把它們加上去\n    * 並在處於非活動狀態時移除\n\n**為了方便辨識效果，所以也加入 .active 的樣式吧**\n```css\n.active{\n  color: red;\n}\n```\n> 這邊要注意的是 CSS 樣式要寫在 Appcomponent 內。\n\n### 註冊路由器與路由定義\n要使用路由的話，必須要把要使用的元件 import 進來，並且在 `routes` 陣列內配置它們，陣列內傳入一個物件，而物件內可以傳入參數：\n* path - 切換到這個元件的路徑\n* component - 切換的元件名稱\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\n\nconst routes: Routes = [\n  { path: 'page1', component: Page1Component },\n  { path: 'page2', component: Page2Component },\n  { path: 'page3', component: Page3Component },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n當我們定義好路由陣列 routes 並把它傳給 RouterModule.forRoot() 方法後：\n* 它會返回一個模組，其中包含配置好的 Router 服務提供商，以及路由庫所需的其它提供商。 \n\n一旦啟動了應用 Router 就會根據當前的瀏覽器 URL 進行首次導航。\n\n> 存檔，試著運行看看。\n\n![page1](https://i.imgur.com/TO8A5PM.png)\n\n![page2](https://i.imgur.com/qqY6dEB.png)\n\n**這樣基礎的 Angular 路由範例就完成了！**\n\n而因為我們有在 RouterModule.forRoot() 把 `enableTracing` 打開，所以當切換路由時時可以看到一些額外訊息：\n\n![](https://i.imgur.com/nSkIDMn.png)\n\n## 設置萬用字元與預設路由\n雖然我們基礎的範例完成了但還不夠好，因為：\n* 如果在網址列隨意輸入會跳出錯誤\n  * 而使用者是這麼白目\n* 需要設定一組預設路由，也就是使用者初次進入網頁時會顯示的畫面\n\n### 設置萬用字元\n新增一個萬用字元路由來攔截所有無效的 URL 並處理它們。 萬用字元路由的 path 是兩個星號（**），它會匹配任何 URL。 當路由器匹配不上以前定義的那些路由時，它就會選擇這個路由。 \n\n萬用字元路由可以導航到自訂的 \"404 Not Found\" 元件，也可以重定向到一個現有路由。\n\n特別要注意的是：\n**路由器使用先匹配者優先的策略來選擇路由，萬用字元路由是路由配置中最沒有特定性的那個，因此務必確保它是配置中的最後一個路由。**\n\n因此修改 **app-routing.module**\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\n\nconst routes: Routes = [\n  { path: 'page1', component: Page1Component },\n  { path: 'page2', component: Page2Component },\n  { path: 'page3', component: Page3Component },\n  { path: '**', component: Page1Component },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n![胡亂輸入路徑](https://i.imgur.com/suunvI6.png)\n\n> 像這樣，永遠確保萬用字元在最後一組路由就可以了，而且也不會跳錯誤。\n\n### 設置預設路由\n與設置萬用字元時差不多，由於路由是有順序性的，因此應該其放在萬用字元路由的前一個。\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { Page1Component } from './page1/page1.component';\nimport { Page2Component } from './page2/page2.component';\nimport { Page3Component } from './page3/page3.component';\n\nconst routes: Routes = [\n  { path: 'page1', component: Page1Component },\n  { path: 'page2', component: Page2Component },\n  { path: 'page3', component: Page3Component },\n  { path: '',   redirectTo: 'page2', pathMatch: 'full' },\n  { path: '**', component: Page1Component },\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, { enableTracing: true })\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n為了方便辨識，我將預設路由設置為 `page2` ，也就是預期當使用者初次進入網站時會看到這個畫面。\n\n重定向路由需要一個 pathMatch 屬性，來告訴路由器如何用 URL 去匹配路由的路徑，否則路由器就會報錯。 \n\n> 在本範例中路由器應該只有在完整的 URL 等於 '' 時才選擇 Page2Component 元件，因此要把 `pathMatch` 設定為 'full'。\n\n![](https://i.imgur.com/U33vD2t.png)\n\n> 可以觀察下方的 log ，發現一開始如果網址都沒輸入時，會自動跳轉到 `page2` \n\n### 順序錯誤的場合\n前面提到路由器使用先匹配者優先的策略來選擇路由，所以順序很重要，如果把萬用字元的順序稍微挪動，如：\n```js\nconst routes: Routes = [\n  { path: 'page1', component: Page1Component },\n  { path: 'page2', component: Page2Component },\n  { path: 'page3', component: Page3Component },\n  { path: '**', component: Page1Component },\n  { path: '',   redirectTo: 'page2', pathMatch: 'full' },\n];\n```\n\n![路由順序調換](https://i.imgur.com/dYvHME9.png)\n\n因為匹配到的路由會變成萬用字元的路由，因此就不會跳轉到 `page2` 了。\n\n## 小結\n透過實作這個非常基本的、帶導航的網頁應用學到了如何：\n* 載入路由庫\n* 在根元件的 Template 中新增一個導覽列，導覽列中有一些 A 標籤、routerLink 指令和 routerLinkActive 指令\n* 在根元件的 Template 中新增一個 router-outlet 指令，頁面將會被顯示在那裡\n* 用 RouterModule.forRoot 配置路由器模組\n* 使用萬用字元路由來處理無效路由\n* 當應用在空路徑下啟動時，導航到預設路由\n\n* [GitHub - 範例原始碼](https://github.com/pvt5r486/ngRouterDemo)\n\n> 之後會嘗試實作路由守衛的部分。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"使用 nvm 切換 node 版本","url":"%2Ff2e%2F20190603%2F3226447527%2F","content":"\n## 前言\n在公司的專案中若有部分是屬於較早之前的專案，很可能在使用 `npm install` 或 `yarn` 指令時跳出因版本過高而無法順利下載專案相依套件，此時就只能考慮將目前的 node 版本降下來，或者透過 nvm 切換 node 版本了。\n\n![](https://images.unsplash.com/photo-1559494007-9f5847c49d94?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=334&q=80)\n\n## 安裝 nvm\n取得 nvm 的方式有很多種：\n* 透過 curl\n  * [取得 curl](https://curl.haxx.se/download.html)\n* 透過 wget\n  * [取得 wget](https://eternallybored.org/misc/wget/)\n* Windows 系統有安裝檔可以使用\n  * [nvm-windows](https://github.com/coreybutler/nvm-windows/releases)\n\n因為我的筆電環境沒有 curl 也沒有 wget ，索性就直接吃安裝檔了，最方便。\n\n**關於詳細安裝方式可以看官方的 [GitHub](https://github.com/nvm-sh/nvm)**\n\n之後可以打開終端機輸入 `nvm version` 查看目前版本，有看到版本代表安裝成功。\n\n![](https://i.imgur.com/HQAnPrt.png)\n\n## 使用 nvm\n\n**輸入以下指令取得 node 其他版本：**\n```\nnvm install <version>\n```\n如 `nvm install 9.0.0` ，如此一來就會安裝 node 9.0.0 的版本\n\n\n**查看目前可切換的版本**\n```\nnvm ls\n```\n\n**切換 node 版本**\n```\nnvm use <version>\n```\n如 `nvm use 9.0.0` ，切換到 node 9.0.0 的版本\n\n\n**使用別名稱呼版本號**\n```\nnvm alias <Name> <version>\n```\n如 `nvm alias forWork 9.0.0` ，這樣就完成別名的命名，爾後就能使用 `nvm use forWork` 切換到 node 9.0.0 版了。\n\n> 因為我的電腦工作時已經安裝一次，這部分就偷懶不補圖片了。\n\n## 小結\n今天是到職的第一天，在完成報到手續以及認識環境後，隨即就正式開始對公司專案的探索了，持續的督促自己，也謝謝今天給予我指點的前輩。","tags":["職場經驗"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.37 使用 async 管道元件訂閱 Observable 物件","url":"%2Ff2e%2F20190602%2F184648847%2F","content":"\n## 前言\n不知不覺也到了 No.37 了，最後還想要再介紹一個名為 Async 的管道元件，說到管道元件一定不陌生，因為先前就介紹蠻多常用的管道元件了。\n\n![](https://images.unsplash.com/photo-1559298400-3770039ce246?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## Async 管道元件\n管道元件可以讓我們用在 Template 上的屬性繫結或者內嵌繫結的地方。\n\n使用方法也相當簡單，加上 | 符號後再加上要使用的 Pipe 元件即可。\n\nAsync 管道元件 也可以在官網找到相關文件\n* [Async 管道元件](https://angular.cn/api/common/AsyncPipe)\n\nAsync 管道元件就是用來訂閱任何一個 Observable 物件 (觀察者物件)\n  * 所以這個 Async 管道元件通常是用於 HttpClient 的回傳值或者是 Observable 的情況\n  * 可以省略在類別中的方法內使用 .subscribe() 的動作\n    * 意思就是透過 Async 管道元件幫我們做 .subscribe() 的動作\n\n因此，讓我們再度進行重構吧！\n\n## ArticleList 的重構\n* 將屬性 `atticleData` 重新命名為 `atticleData$`\n  * $ 字號是命名觀察者物件的一個命名習慣\n    * 必要時也使用 TypeScript 將 Observable 的型別也加上\n      * 而 Observable 是泛型語法，因此也需要加上角括號 `<any>`\n* 而修改了屬性 `atticleData` ，所以有用到屬性 `atticleData` 的方法全部都報錯\n  * 這部分可以先暫時刪除，因為這篇只是為了要介紹 Async 管道元件\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\nimport { Observable } from 'rxjs';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  atticleData$: Observable<any>;\n  constructor(public datasvc: DataService) {\n  }\n  ngOnInit() {\n    this.atticleData$ = this.datasvc.getData();\n  }\n}\n```\n而 Template 部分一樣要修改，豪邁的砍掉錯誤的部分\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData$ | async; let idx = index\">\n  <app-article-header [item]=\"item\"></app-article-header>\n  <app-article-body [item]=\"item\" [counter]=\"counter\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n最後來看一下結果吧：\n![](https://i.imgur.com/v4f0GU7.png)\n\n透過這個簡單的範例介紹 Async 管道元件的用途。\n\n> 而通常 Async 管道元件會被用於只需要單純取得資料且來源又是 Observable 時可以簡化不少程式碼。\n\n## 小結\n總算是跑完這一系列了，也逐漸覺得 Angular 有不少好用的地方是 Vue 所體會不到的，但有部分的觀念其實很類似，所以學習起來不會感到特別吃力。\n\n但是儘管我完成了這一系列，不可置否的是我仍然對於 Angular 語法以及 TypeScript 的語法不夠熟悉，這樣是沒辦法熟練應用於實務上的，因此還必須持續的努力、複習。\n\n這一系列完成於到新公司上班的前一天，而我也是因為這間公司才開始投入學習 Angular 的，希望透過這樣職前的自我訓練，能在進入公司後盡快地掌握公司內 Angular 的專案。\n\n一系列的文章通常只有最初跟最後有人看，所以我還是在這裡把環境稍微交代一下：\n* 專案使用的 Angular CLI 版本是 7.3.9\n* 使用 Angular 7 的語法撰寫\n* [GitHub Repo](https://github.com/pvt5r486/firstAngular)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.36 重構 DataService 服務元件","url":"%2Ff2e%2F20190602%2F2466431500%2F","content":"\n## 前言\n用得好好的為啥要重構呢？原因是目前這個 DataService 並沒有寫得很漂亮，原因是通常不會直接在服務元件內直接做 .subscribe() 的動作，大部分的情況都是在其他元件內進行。畢竟什麼時候要訂閱是各個元件自己才知道，服務元件單純的提供服務就好。\n\n## 重構 DataService\n移除先前為了介紹寫在建構式內的程式碼，並且新增一個方法叫 `getData()`\n  * httpClient.get() 方法會最後會產生一個觀察者物件，將其回傳\n    * 而這麼做，意味著資料最後不會出現在服務元件內，因此先註解其他程式碼\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  constructor(private httpClient: HttpClient) {\n  }\n  getData() {\n    return this.httpClient.get('http://localhost:4200/api/articles.json');\n  }\n  // doDelete(item) {\n  //   this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  // }\n  // doModify(post: any) {\n  //   this.atticleData = this.atticleData.map((item) => {\n  //     if (post.id === item.id) {\n  //       return Object.assign({}, item, post);\n  //     }\n  //     return item;\n  //   });\n  // }\n}\n```\n\n## 調整 ArticleList 元件\n因為先前的調整，ArticleList 內幾乎已經沒有程式碼了，原因是該元件的 Tamplate 內是直接讀取 DataService 的資料。\n\n**但現在 DataService 已經沒有 `atticleData` 屬性了，怎麼辦呢？**\n\n解決辦法：\n* 呼叫 DataService 內的 getData 方法\n  * 因為這個方法將回傳一個觀察者物件 (Observable Object)，因此可以使用 .subscribe() 方法\n    * 成功取得資料後，將資料賦值給 `atticleData` 屬性\n      * 因為之前把元件內的 `atticleData` 屬性移除了，現在必須加回去\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  atticleData;\n  constructor(public datasvc: DataService) {\n  }\n  ngOnInit() {\n    this.datasvc.getData().subscribe((result) => {\n      this.atticleData = result;\n    });\n  }\n}\n```\n\n這樣看起來就合理多了，應該是由元件來決定何時訂閱，而不是由服務元件來決定。\n\n因為可能會有多種不同的事件來處發 API ，所以由個別元件來決定是最合理的。\n\n**調整完後還有 Template 要修改：**\n* 目前資料已經透過訂閱回到 ArticleList 本身了\n  也因為資料已經在自身元件，所以刪除與改標題的方法也必須移動回元件本身。\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"doDelete($event)\" (changeTitle)=\"doModify($event)\"></app-article-header>\n  <app-article-body [item]=\"item\" [counter]=\"counter\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n最終 ArticleList 是這樣的：\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  atticleData;\n  constructor(public datasvc: DataService) {\n  }\n  ngOnInit() {\n    this.datasvc.getData().subscribe((result) => {\n      this.atticleData = result;\n    });\n  }\n\n  doDelete(item) {\n    this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  }\n  doModify(post: any) {\n    this.atticleData = this.atticleData.map((item) => {\n      if (post.id === item.id) {\n        return Object.assign({}, item, post);\n      }\n      return item;\n    });\n  }\n}\n\n```\n\n重新整理一下想法：\n* 目前 ArticleList 透過服務元件上的 getData() 方法取得 文章資料\n  * 而現在的資料都是來自於 Server 端，我們只是把 Server 端的資料抓下來暫存在 atticleData 屬性而已\n* 因此 doDelete() 、 doModify() 都是修改存放在 local 端的資料，並不是真正修改 Server 端的資料\n\n**也就是說需要回到 DataService 上調整 doDelete() 、 doModify() 這兩個方法。**\n \n## 調整 DataService 服務元件\ndoDelete()\n* 使用 httpClient.delete() 發送一個 delete 請求給伺服器刪除特定資料，並帶上文章 id\n\ndoModify()\n* 使用 httpClient.put() 發送一個 put 請求給伺服器更新特定資料，並帶上文章 id\n  * 第二個參數則傳入 `post` ， httpClient 會自動把 `post` 這個物件轉換成 json 格式\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  constructor(public httpClient: HttpClient) {\n  }\n  getData() {\n    return this.httpClient.get('http://localhost:4200/api/articles.json');\n  }\n  doDelete(item) {\n    return this.httpClient.delete(`http://localhost:4200/api/articles.json/${item.id}`);\n  }\n  doModify(post: any) {\n    return this.httpClient.put(`http://localhost:4200/api/articles.json/${post.id}`, post);\n  }\n}\n```\n**至此 DataService 就調整完畢了，最後再次回到 ArticleList 元件完成真正的刪除與修改！**\n\n## 觸發 DataService 上的 doDelete() 及 doModify()\n用法是這樣的：\n* 當 ArticleList 元件內的 doDelete() 被觸發時\n  * 呼叫 DataService 上的 doDelete() 並傳入 `item` 並且訂閱結果\n    * 當結果成立時 (伺服器端的資料被刪除了) 才執行 local 端的資料刪除\n\n同理 doModify() 也是。\n\n另外，串接 API 時常常會遇到一些意外的狀況，此時\n* 可以用上 .subscribe() 第二個參數 error ，同樣也是個 callback function\n  * 可以透過這個 callback 取得錯誤的結果\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  atticleData;\n  constructor(public datasvc: DataService) {\n  }\n  ngOnInit() {\n    this.datasvc.getData().subscribe((result) => {\n      this.atticleData = result;\n    });\n  }\n\n  doDelete(item) {\n    this.datasvc.doDelete(item).subscribe((result) => {\n      this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n    },\n    (error) => {\n      console.log('錯誤資訊', error);\n    });\n  }\n  doModify(post: any) {\n    this.datasvc.doModify(post).subscribe((result) => {\n      this.atticleData = this.atticleData.map((item) => {\n        if (post.id === item.id) {\n          return Object.assign({}, item, post);\n        }\n        return item;\n      });\n    },\n    (error) => {\n      console.log('錯誤資訊', error);\n    });\n  }\n}\n```\n\n**大功告成，來試試看吧！**\n\n![順利取得全部資料](https://i.imgur.com/12tOtrH.png)\n\n![進行刪除時因為找不到這隻 API 所以報錯](https://i.imgur.com/ZRDDezU.png)\n\n![進行編輯時因為找不到這隻 API 所以報錯](https://i.imgur.com/ACfmnGQ.png)\n\n**一切都符合我們的預期 :D**\n\n## 小結\n[這一系列的原始碼](https://github.com/pvt5r486/firstAngular)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.35 了解 @Injectable() 裝飾器與注入 HttpClient 服務元件","url":"%2Ff2e%2F20190602%2F951431477%2F","content":"\n## 前言\n之前介紹服務元件的時候就已經看過 @Injectable() 但那個時候並沒有詳加著墨介紹，究竟 @Injectable() 是什麼意思呢？\n\n![](https://images.unsplash.com/photo-1559376210-54a1b73ddb88?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1189&q=80)\n\n## @Injectable()\nInjectable 本身是一個裝飾器 (Decorator) ，主要目的是用於描述這個類別 (class) 是否可以被注入其他的服務元件，事實上如果把之前服務元件上寫的 @Injectable() 刪除，還是可以成功地注入其他元件上，舉例來說：\n\n```js\nimport { Injectable } from '@angular/core';\n\nexport class DataService {\n  atticleData: Array<any>;\n  constructor() {\n  /* tslint:disable */\n    this.atticleData = [\n      {\n        \"id\": 1,\n        \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n        \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n        \"date\": \"2016/04/30 18:05\",\n        \"author\": \"GHJKL\",\n        \"category\": \"Visual Studio\",\n        \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n        \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n      },\n      // ... 省略 ...\n    ];\n  }\n\n  doDelete(item){\n    this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  }\n  doModify(post: any){\n    this.atticleData = this.atticleData.map((item)=>{\n      if(post.id === item.id) {\n        return Object.assign({}, item, post);\n      }\n      return item;\n    });\n  }\n}\n```\n\n刪除 `@Injectable()` 後功能依然正常，也就是說移除裝飾器後，服務元件依然有被注入成功。\n![](https://i.imgur.com/JD3LjlA.png)\n\n## 既然可以被移除又何必要寫 @Injectable()\n因為它可以注入一些額外其它的服務元件，什麼意思呢？\n\n我們可以透過 @Injectable() 注入 HTTP Client 的元件，從伺服器取得動態的資料。\n\n## 注入服務元件 HTTP Client\n在 Angular 中有內建一個服務元件 HTTP Client ，所以先將其注入目前的 Data Service 中。\n\n![Image](https://i.imgur.com/4kPqPH5.png)\n\n* 值得一提的是這裡的自動完成匯入的路徑並不是我們要的，應修正為：\n  * `import { HttpClient } from '@angular/common/http';`\n\n**這才是正確的 HTTP 模組來源**\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  atticleData: Array<any>;\n  constructor(private httpClient: HttpClient) {\n  /* tslint:disable */\n    this.atticleData = [\n      {\n        \"id\": 1,\n        \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n        \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n        \"date\": \"2016/04/30 18:05\",\n        \"author\": \"GHJKL\",\n        \"category\": \"Visual Studio\",\n        \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n        \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n      },\n      // ... 省略 ...\n    ];\n  }\n\n  doDelete(item){\n    this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  }\n  doModify(post: any){\n    this.atticleData = this.atticleData.map((item)=>{\n      if(post.id === item.id) {\n        return Object.assign({}, item, post);\n      }\n      return item;\n    });\n  }\n}\n```\n\n**處理完之後，這個 httpClient 注入還是失敗的，因為還沒將它加入到 ArticleModule 下。**\n\n![](https://i.imgur.com/O6HsUGq.png)\n\n錯誤訊息說明了必須匯入 HttpClientModule 到 ArticleModule\n\n![import HttpClientModule](https://i.imgur.com/WPuQhX5.png)\n\n此時網頁又可以正常運作了\n![](https://i.imgur.com/IpHKT25.png)\n\n前面有提到如果把 `@Injectable()` 刪除不影響程式運作，但此時如果直接將 `@Injectable()` 移除可是會出錯的。\n\n![](https://i.imgur.com/QeLM8K8.png)\n\n意思是無法解析 DataService 內所有的參數，雖然不太懂是什麼意思，但如果看到 resolve 通常是跟相依注入有關。\n\n因為此時相依注入是從建構式內找到一個 httpClient 參數，然後參數標註 HttpClient 型別\n  * 所以它必須解析 httpClient 的內容從何而來\n    * 此時 Angular 會去找出 HttpClient 並且將其 new 出來成為一個物件實體\n      * 再把這個物件實體丟給 httpClient 參數，然後就解析完成 (resolve 就是這個意思)\n\n當透過 Angular CLI 建立服務元件時，預設都會自動加入 `@Injectable()` ，建議還是不要把它胡亂移除比較好。\n\n> 於是 HttpClient 服務元件就注入完成了！\n\n## 如何使用 HttpClient 服務元件\n目前文章資料都是寫死的，可以透過 HttpClient 服務元件當中的 get() 方法，動態的取得伺服器上的文章資料。\n\n詳細的 http.get() 方法可以參考[官網](https://angular.cn/api/common/http/HttpClient#get)\n\n而這邊要注意的是 Ajax 的操作在瀏覽器內是非同步的，因此沒辦法在建構式內直接回傳取得的結果\n  * 在 Angular 內則是透過 Rxjs 幫忙訂閱 http.get() 資料的結果\n    * 而這個 .get() 的資料類型是 Observable 物件 (觀察者物件)\n      * 所有的 Observable 物件都必須透過 .subscribe() 方法來訂閱結果\n關於 HttpClient 使用方式可以參考這篇 - [HttpClient 功能介紹](https://ithelp.ithome.com.tw/articles/10195344)\n\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  atticleData;\n  constructor(private httpClient: HttpClient) {\n    httpClient.get('http://localhost:4200/api/articles.json').subscribe((result) => {\n      console.log(result);\n      this.atticleData = result;\n    });\n  }\n\n  doDelete(item) {\n    this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  }\n  doModify(post: any) {\n    this.atticleData = this.atticleData.map((item) => {\n      if (post.id === item.id) {\n        return Object.assign({}, item, post);\n      }\n      return item;\n    });\n  }\n}\n```\n\n![](https://i.imgur.com/9a4gS98.png)\n\n透過 HttpClient 服務元件，正確的接收到資料了！","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.34 透過服務元件重構現有的元件程式碼","url":"%2Ff2e%2F20190602%2F1279142451%2F","content":"\n## 前言\n呈上篇，在掌握如何使用服務元件並且透過 DI 將其注入元件中使用後，緊接著我們就可以利用此技巧將原本元件內的邏輯抽出進行重構了。\n\n## 判斷服務元件的範圍\n在這個例子中 Data Service 只會用在 ArticleModule ，所以最好是把 data.service 的兩隻檔案都搬進去模組資料夾內，比較方便管理。\n\n> 但是現在的情況下並不能直接移動，因為這個服務很可能在不同地方被引用了，一旦移動位置就必須跟著改其他地方。\n\n做法有二：\n* 在建立服務元件時就必須確定這個服務元件要被放在哪個模組下，這樣就 OK 了\n* 或者使用 [Move TS](https://marketplace.visualstudio.com/items?itemName=stringham.move-ts) 這個 VS Code 上的插件，協助移動 TS 檔案\n\n> 現在這個情況就使用 Move TS 來處理吧！\n\n如果已經裝好了這個插件，那麼在移動 TS 檔案的時候，這個插件就會自動地幫我們把所有參考到這個檔案的 TypeScript 檔一併修改路徑，讓我們測試看看。\n\n![移動前](https://i.imgur.com/A8tWHhB.png)\n\n* 對著要移動的檔案點右鍵，使用 Move TS 來搬運檔案　\n![](https://i.imgur.com/yh2N2Yu.png)\n\n![輸入指定資料夾](https://i.imgur.com/oURgnhK.png)\n\n![搬運成功](https://i.imgur.com/2VipsQi.png)\n\n![移動後](https://i.imgur.com/kM6ERvu.png)\n\n## 搬運並重構程式碼\n接著開始搬運 ArticleList 的部分程式碼包含資料與邏輯的部分，都搬進 Data Service 。\n\n### Data Service\n* 把 doDelete() 、 doChange() 搬出去\n  * 但搬運到服務元件內之後，此時方法的命名就沒這麼好了，因此也需要調整\n* 搬運文章的資料並建立屬性 `articleData`\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  atticleData: Array<any>;\n  constructor() {\n  /* tslint:disable */\n    this.atticleData = [\n      {\n        \"id\": 1,\n        \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n        \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n        \"date\": \"2016/04/30 18:05\",\n        \"author\": \"GHJKL\",\n        \"category\": \"Visual Studio\",\n        \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n        \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n      },\n      //...以下省略...\n    ];\n  }\n\n  doDelete(item){\n    this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n  }\n  doModify(post: any){\n    this.atticleData = this.atticleData.map((item)=>{\n      if(post.id === item.id) {\n        return Object.assign({}, item, post);\n      }\n      return item;\n    });\n  }\n}\n```\n\n這樣 Data Service 的部分算是處理好了，接下來回到 ArticleList 。\n\n### ArticleList\n* 由於我們先前在測試時已經時做了相依注入\n  * 所以在建構式執行完之後會得到一個 Data Service 物件的實體\n    * 而且存在 `datasvc` 這個屬性裡面，因此可以從這取得原本文章的資料維持畫面的呈現。\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  atticleData: Array<any>;\n  constructor(private datasvc: DataService) {\n  }\n  ngOnInit() {\n    this.atticleData = this.datasvc.atticleData;\n    setTimeout(() => {\n      this.counter++;\n    }, 2000);\n  }\n\n}\n```\n程式碼都搬運了，自然 Template 的部分也需要做調整：\n* 因為 doDelete() 以及 doModify() 已經被轉移到 Data Service ，所以必須做調整\n  * 使用 `datasvc` 屬性即可取用服務元件下的方法\n    * 特別注意如果前面冠有 `private` 是無法在 Template 內取用的，要改成 `public`\n      * 因此將其修正為 `public`\n\n**修正後即可順利取用方法**\n\n![](https://i.imgur.com/38OPit9.png)\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"datasvc.doDelete($event)\" (changeTitle)=\"datasvc.doModify($event)\"></app-article-header>\n  <app-article-body [item]=\"item\" [counter]=\"counter\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n### 測試運行\n迫不及待地馬上測試看看！\n\n然後會發現完全沒有效果。\n\n**為什麼？明明 console.log 也沒有錯誤訊息？**\n![](https://i.imgur.com/qAbIImL.png)\n\n問題在於，在 JavaScript 中有個非常重要的語言特性是:\n* 所有的屬性、變數物件參考到的永遠是物件的本身\n\n什麼意思呢？ 先來看看服務元件內 doModify() 的寫法\n\n```js\ndoModify(post: any){\n  this.atticleData = this.atticleData.map((item)=>{\n    if(post.id === item.id) {\n      return Object.assign({}, item, post);\n    }\n    return item;\n  });\n}\n```\n\n意思是 `this.atticleData` 透過 map() 被賦值一個全新的物件\n* 所以每一次進行 doModify() 時所得到的 `atticleData` 值都是一個全新的物件\n\n但是第一次進行相依注入時， ArticleList 元件內的 ngOnInit() 我們是這麼寫的：\n```js\nngOnInit() {\n  this.atticleData = this.datasvc.atticleData;\n}\n```\n\n> 就是把 `this.datasvc.atticleData` 所指向的物件參考傳給了 `atticleData` 這個屬性\n\n**所以當服務元件 DataService 內重新又建立一個元件時，這裡的 ngOnInit() 可不會重新又執行一次，也就是說我們在 DataService 上做的任何修改 ArticleList 完全看不到。**\n\n## 如何修改\n既然方法可以直接從服務元件內取用，那麼資料想必也是可以的。\n\n所以我們修改 ArticleList 的 Template\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of datasvc.atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"datasvc.doDelete($event)\" (changeTitle)=\"datasvc.doModify($event)\"></app-article-header>\n  <app-article-body [item]=\"item\" [counter]=\"counter\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n因為改用 `datasvc.atticleData` 所以可以刪除 class 內不再用到的 `atticleData` 屬性\n* 因為資料的來源就是由服務元件提供，自然就不需要寫 `this.atticleData = this.datasvc.atticleData;`\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  counter = 0;\n  constructor(public datasvc: DataService) {\n  }\n  ngOnInit() {\n    setTimeout(() => {\n      this.counter++;\n    }, 2000);\n  }\n}\n```\n\n> 於是現在這個 ArticleList 元件的 class 基本上快被搬光了，只剩下一個服務元件 Data Service 的注入，所有的邏輯都在服務元件上，而 Template 是直接取用服務元件上的資料以及邏輯。\n\n**再次進行測試**\n![編輯成功](https://i.imgur.com/aFQWq2n.png)\n\n![刪除成功](https://i.imgur.com/zKBwXew.png)\n\n大功告成！\n\n## 小結\n實作完成後發現服務元件蠻吃 JavaScript 觀念，如果基礎沒有打穩，當發生這個 Bug 時肯定找不到問題，更別說這個問題連開發者工具都沒顯示錯誤，若基礎不穩肯定不知道發生什麼事了。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.33 建立 Angular 服務元件與實作相依注入","url":"%2Ff2e%2F20190602%2F3971501155%2F","content":"\n## 前言\n到目前為止大部分的程式碼都放在 ArticleModule ，而這個 Module 內包含三個元件，其中 ArticleList 是父元件 ； ArticleHeader 與 ArticleBody 為子元件。大部分的程式邏輯與資料全部都放在 ArticleList 內，那麼我們要如何利用服務元件來協助處理這部分呢？\n\n![](https://images.unsplash.com/photo-1559373753-acae56e06ae3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 服務元件\n服務元件是一個類別，而類別內只有兩種東西\n* 屬性\n* 方法\n\n> 既然類別內只有這兩種東西，此時就可以想著該把什麼東西給獨立抽離使其變成服務元件。\n\n**以 ArticleList 元件為例**\n在設計元件的時候，通常會把相關的資料或邏輯放在同一的元件做管理。\n\n而這個元件的 OnInit() 內放有文章的初始化資料內容，因此：\n* 可以把這些資料與資料處理邏輯抽離，建立一個 Data Service 的服務元件\n\n## 建立一個服務元件 - Data Service\n建立的方式同樣透過 Angular CLI 指令，以下則一即可：\n* `ng generate service 名稱`\n* `ng g s data 名稱`\n\n![建立成功](https://i.imgur.com/yBzbeXI.png)\n\n> 此時會發現專案內多了兩支檔案，單元測試檔及服務元件主要的程式碼。\n\n**data.service.ts**\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n\n  constructor() { }\n}\n\n```\n\n這樣的程式碼結構是不是跟之前建立元件時看到的很相似呢？\n\n## 註冊 Data Service\n建立好 Data Service 後，接著還需要將其註冊進模組 (Module) 內才可以使用。\n\n目前有兩個模組，分別是 AppModule 以及 ArticleModule \n* 要選擇的是 ArticleModule ，因為我們是要幫這個模組建立服務元件\n\n如果要將服務元件註冊進模組內，必須：\n* 加入一個 providers 屬性，值為陣列型別\n  * 這樣就可以放入多個服務的提供者，如\n    * `providers: [DataService]`\n\n![](https://i.imgur.com/lReyqnj.png)\n\n![](https://i.imgur.com/oZspiFs.png)\n\n**article.module**\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ArticleListComponent } from './article-list/article-list.component';\nimport { ArticleHeaderComponent } from './article-header/article-header.component';\nimport { ArticleBodyComponent } from './article-body/article-body.component';\nimport { FormsModule } from '@angular/forms';\nimport { DataService } from '../data.service';\n\n@NgModule({\n  declarations: [ArticleListComponent, ArticleHeaderComponent, ArticleBodyComponent],\n  imports: [\n    CommonModule,\n    FormsModule\n  ],\n  providers: [DataService],\n  exports: [ArticleListComponent]\n})\nexport class ArticleModule { }\n```\n這樣子服務元件就註冊完成了！\n\n**而任何一種元件內都可以透過相依注入 (DI) ，把服務元件取出來使用。**\n\n## 測試 Data Service\n目前 Data Service 的確沒有任何程式碼在裡面，但我們可以做個小測試驗證一下。\n\n### 準備 Data Service 內的程式碼\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n\n  constructor() { }\n\n  run() {\n    console.log('DataService!');\n  }\n}\n```\n\n### 將服務注入到元件內\n接著使用相依注入，注入到 ArticleList 內。\n\n如何進行相依注入：\n* 宣告一個 `dService` 屬性，並且利用 TypeScript 宣告型別為 DataService \n  * 不一定會叫做 DataServie ，是根據剛才建立的服務名稱不同也會改變\n* 在元件的 constructor () 內宣告一個參數 `datasvc` ，並且利用 TypeScript 宣告型別為 DataService\n  * 當我們透過建構式成功注入時，將 `dService` 屬性值給定 `datasvc` 參數\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from 'src/app/data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  atticleData: Array<any>;\n  counter = 0;\n  dService: DataService;\n  constructor(datasvc: DataService) {\n    this.dService = datasvc;\n  }\n  //...以下省略\n}\n```\n\n第一次做相依注入的同時 Angular 會自動的 `new` 出 DataService 的 `class` ，所以參數 `datasvc` 得到的其實是一個**物件的實體**。\n\n>而不管有幾個 Component 要注入相同的元件，在預設的情況下 Angular 只會 `new` 一次，也就是最終只會得到一個唯一的物件實體。\n\n如此一來不管是在任何的 Component 內，只要是相同的服務元件，就可以確保得到的物件是**唯一**的，因此可以更輕易的在不同元件間共享一些必要的資料。\n\n### 將服務注入到元件內 - 利用 TypeScript\n透過 TypeScript 有效的簡化使用相依注入時的語法\n* 在建構式傳入的參數前面加上 `public` 或 `private` \n  * 加上之後 TypeScript 預設會在 ArticleList 這個元件的類別自動宣告一個 DataServie 型別的屬性\n* 也就是說屬性不再需要自己額外宣告了，只需要宣告建構式內的參數即可。\n* 也不再需要將注入成功的值賦予給屬性\n\n修改如下：\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from 'src/app/data.service';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  atticleData: Array<any>;\n  counter = 0;\n  constructor(private datasvc: DataService) {\n  }\n  //...以下省略\n}\n```\n> 修改後一行就搞定了～而且完全等價於剛剛三行的寫法。\n\n所以未來再進行其他的相依注入時，只是要適當地在建構式參數前面加上 `public` 或 `private` ，後面再透過 TypeScript 的型別標註，就可以快速完成 DI 。\n\n\n### 如何在元件內使用注入的服務元件\n以 ngOnInit() 為例：\n* 直接調用剛才傳入建構式的參數名 (此時是 DataService 物件)，可以印出觀察\n* 因為是物件，可以使用 . 運算子執行裡面的方法\n\n```js\nngOnInit() {\n  console.log(this.datasvc);\n  this.datasvc.run();\n}\n```\n\n**最後，看看結果是否如我們預期吧！**\n\n![](https://i.imgur.com/AwjaUNd.png)\n\n## 小結\n本篇介紹了如何建立服務元件以及注入到其他元件內，下一篇我們要使用這個技巧替 ArticleList 進行重構。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.32 介紹 ngOnChanges 生命週期 Hook","url":"%2Ff2e%2F20190601%2F3408173890%2F","content":"\n## 前言\n之前曾經介紹到 Angular 元件生命週期的 Hook分別是 ngOnInit 與 ngOnDestroy ，在那篇文章內曾經說過元件被實體化的過程，第一個先執行的是建構式 constructor ，也提到盡量不要再建構式裡面寫程式碼。這次要介紹的式另一個生命週期的 Hook - ngOnChanges 。\n\n![](https://images.unsplash.com/photo-1557739820-f55c4bd03537?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## ngOnChanges() 、 constructor() 、 ngOnInit()\n在介紹之前，來一張元件生命週期的圖表：\n\n![](https://i.imgur.com/eMUPWsS.png)\n\nngOnChanges() 與 constructor() 、 ngOnInit() 之間的執行順序是如何，可以很容易地從這張圖表上看出來。\n\n但秉持著實踐精神，我們還是實際寫一些程式測試看看～\n\n```js\nimport { Component, OnInit, Input, OnChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-article-body',\n  templateUrl: './article-body.component.html',\n  styleUrls: ['./article-body.component.scss']\n})\nexport class ArticleBodyComponent implements OnInit, OnChanges {\n  @Input()\n  item;\n  constructor() {\n    console.log('ArticleBodyComponent: constructor');\n  }\n\n  ngOnInit() {\n    console.log('ArticleBodyComponent: ngOnInit');\n  }\n\n  ngOnChanges() {\n    console.log('ArticleBodyComponent: ngOnChanges');\n  }\n}\n```\n\n因為有跑 ngFor 而文章資料總共有 6 筆，因此產生 6 個 ArticleBody 元件。\n\n![](https://i.imgur.com/C0ZVl6K.png)\n\n* 可以從這裡觀察出無論如何一定會先執行 constructor() ，但執行過程中元件還沒被初始化。\n  * 此時元件內什麼東西都沒有，也沒有透過屬性繫結傳進來的資料。\n* 緊接著執行 ngOnChanges() 然後才是 ngOnInit()\n\n這就是它們的執行順序。\n\n## 什麼是 ngOnChanges()\nngOnChanges() 觸發的時機點\n* 元件裡面的屬性如果有套用 @input() ，只要該元件的父元件透過屬性繫結傳資料進來的話， ngOnChanges() 就會被觸發\n\n### 驗證 ngOnChanges() 觸發的時機點\n* 在 ArticleBody 元件內新增一個屬性 `counter`\n  * `counter` 值會從父元件透過屬性繫結傳入\n  * 當 `counter` 發生改變時 ngOnChanges() 就會觸發，由此驗證\n\n**ArticleBody**\n```js\nexport class ArticleBodyComponent implements OnInit, OnChanges {\n  @Input()\n  item;\n\n  @Input()\n  counter;\n\n  constructor() {\n    console.log('ArticleBodyComponent: constructor');\n  }\n\n  ngOnInit() {\n    console.log(`ArticleBodyComponent ${this.item.id} : ngOnInit`);\n  }\n\n  ngOnChanges() {\n    console.log(`ArticleBodyComponent ${this.item.id} : ngOnChanges`);\n  }\n}\n```\n```html\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"doDelete($event)\" (changeTitle)=\"doChange($event)\"></app-article-header>\n  <app-article-body [item]=\"item\" [counter]=\"counter\"></app-article-body>\n</article>\n```\n\n**ArticleList**\n```js\nexport class ArticleListComponent implements OnInit {\n  atticleData: Array<any>;\n  counter = 0;\n  constructor() { }\n  ngOnInit() {\n    setTimeout(() => {\n      this.counter++;\n    }, 2000);\n  }\n}\n```\n為了方便所以補上 `item.id` ，接著運行開發伺服器，觀察 `console.log` 變化：\n\n![重新整理](https://i.imgur.com/b6UurMk.png)\n\n![兩秒後](https://i.imgur.com/80PGWhX.png)\n\n**由此可知，在兩秒後六個不同的 ArticleBody 元件都觸發了 ngOnChanges()** ，證明了只有在屬性繫結傳入資料發生改變時才會觸發 ngOnChanges() 。\n\n### ngOnChanges() 參數的作用\n\n另外 ngOnChanges() 可以傳入一個參數，比較傳入前與傳入後的資料：\n```js\nngOnChanges(changes) {\n  console.log(`ArticleBodyComponent ${this.item.id} : ngOnChanges`);\n  console.log(changes);\n}\n```\n![](https://i.imgur.com/KAvpajv.png)\n\n發現這個 `changes` 接收到一個叫物件，點開後會發現裡面還有一層以 `counter` 屬性命名的物件：\n* 該物件的型別為 SimpleChange\n* 代表當前值為多少的屬性 `currentValue`\n* 代表前一個值為多少的屬性 `previousValue`\n* `firstChange` 是不是第一次發生改變\n  * 目前已經是第二次改變了，所以是 `false`\n  * 第一次改變發生於重新整理時那一次的 ngOnChanges()\n\n> 透過這個例子得知可以利用這個參數在觸發 ngOnChanges() 時多做一些額外的判斷。\n\n## ngOnChanges() 實務應用\n前面幾篇文章提到，建議不要在子元件上直接使用雙向繫結修改傳入的資料，因為這樣會直接的修改到原始資料。\n\n但現在我們懂得使用 ngOnChanges() 這個 Hook ，因此可以針對這個部分對整個程式碼進行重構。\n\n### ActicleHeader\n切回 ActicleHeader 元件觀察：\n* 目前有一個 `@input()` 綁定了 `item` 屬性\n  * 所以當接到 `item` 資料時 ngOnChanges() 會被觸發\n* 透過 `ngOnChanges(changes)` ，當接收到值時建立一份與原始資料不同的新物件\n  * 如此一來就可以放心地使用雙向繫結，也不怕修改到原始資料\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter, OnChanges} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit, OnChanges {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n\n  @Output()\n  changeTitle = new EventEmitter<any>();\n\n  isEdit = false;\n  newTitle = '';\n  constructor() { }\n\n  ngOnInit() {\n    this.newTitle = this.item.title;\n  }\n  ngOnChanges(changes) {\n    if (changes.item) {\n      this.item = Object.assign({}, changes.item.currenValue);\n    }\n  }\n\n  deleteArticle() {\n    this.delete.emit(this.item);\n  }\n  editTitle(e) {\n    console.log('editTitle', e.target);\n    this.newTitle = e.target.value;\n    this.changeTitle.emit({ title: this.newTitle, id: this.item.id });\n  }\n  editExit(e) {\n    console.log('editExit', e.target);\n    e.target.value = this.item.title;\n    this.isEdit = false;\n  }\n}\n```\n\n接著修改 Template\n* 在 Input 內補上雙向繫結\n  * 因為改為使用雙向繫結 `editTitle()` 與 `editExit()` 不再需要傳入 `$event` 參數\n* 調整取消編輯上的點擊事件，當點擊時觸發 `editExit()`\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\" >\n    <a *ngIf=\"!isEdit\" [href]=\"item.href\">{{ item.title }}</a>\n    <input *ngIf=\"isEdit\" type=\"text\" size=\"70\" [(ngModel)]=\"item.title\"\n      (keyup.enter)=\"editTitle()\" (keyup.escape)=\"editExit()\">\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span>\n    <button (click)=\"deleteArticle()\">刪除</button>\n    <button *ngIf=\"!isEdit\" (click)=\"isEdit=true\">編輯標題</button>\n    <button *ngIf=\"isEdit\" (click)=\"isEdit=false\">取消編輯</button>\n  </span>\n</header>\n```\n\n因為調整了 Template ，所以 class 內的方法也需要跟著調整。\n\n邏輯部分\n* 新增了一個屬性 `originData` 用途是保存原始傳入的資料，用於取消編輯時使用\n  * 並於 ngOnChanges() 觸發時將原始資料賦值給 `originData`\n    * 特別注意這裡不可以寫 ` this.originData = this.item;` 因為此時還沒有 `item`\n* 刪除不再需要的屬性 `newTitle`\n* 調整 `editTitle()` ，此時發射的 `this.item` 已經不是原始資料了\n* 調整 `editExit()` ，實作不可變物件特性，使用原始資料重新建立新物件還原\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter, OnChanges} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit, OnChanges {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n\n  @Output()\n  changeTitle = new EventEmitter<any>();\n  originData;\n  isEdit = false;\n  constructor() { }\n\n  ngOnInit() {\n  }\n  ngOnChanges(changes) {\n    if (changes.item) {\n      this.originData = changes.item.currentValue;\n      this.item = Object.assign({}, changes.item.currentValue);\n    }\n  }\n\n  deleteArticle() {\n    this.delete.emit(this.item);\n  }\n  editTitle() {\n    this.changeTitle.emit(this.item);\n  }\n  editExit() {\n    this.item = Object.assign({}, this.originData);\n    this.isEdit = false;\n  }\n}\n```\n\n**現在 ArticleHeader 這個元件邏輯已經完成，可以測試一下。**\n\n![編輯成功](https://i.imgur.com/w0oJckd.png)\n\n![編輯中](https://i.imgur.com/PoQ8LqM.png)\n\n![取消編輯](https://i.imgur.com/h1gvitC.png)\n\n* 倘若這個步驟沒辦法完成，可能是雙向繫結出了問題\n  * 應檢查是否有在 Article 功能模組內匯入 `FormsModule` ，需匯入才可在 input 上使用雙向繫結\n\n> 至此程式的運作都如預期，唯獨刪除功能出狀況了，所以我們到 ArticleList 父元件調整一下程式碼。\n\n### ArticleList\n\n* 造成刪除失敗的原因是，現在的 item 物件已經不是原本的 item 物件了\n  * 而任意兩個物件在 JavaScript 中相比都是 False ，因此刪除導致失敗\n  * 修正方法為改採 `item.id` 比較即可\n\n因此程式碼修改如下:\n\n```js\ndoDelete(item){\n  this.atticleData = this.atticleData.filter(v => v.id !== item.id);\n}\n```\n\n測試看看是否如我們預期。\n\n![](https://i.imgur.com/qeWNmVM.png)\n\n## 小結\n透過 ngOnChanges() 的特性在屬性繫結的階段時，讓 `item` 屬性變成是一個「不可變的物件」，因為只是有任何新的資料進來，馬上就會重新產生新的物件，並且賦值給 `item` ，藉由這種方式讓 `item` 值與原本傳進子物件的 `item` 值得以脫鉤。\n\n脫鉤後就可以在 Template 內放心地使用雙向繫結而不會影響到父物件內的原始資料，這麼做也確保了修改 `item` 屬性時不會一併的修改到其他元件內 `item` 屬性的內容。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.31 實作單向資料流與不可變的物件","url":"%2Ff2e%2F20190531%2F736106338%2F","content":"\n## 前言\n上一篇解釋了什麼是單向資料流以及不可變的物件，這一篇要透過實作來了解。\n\n![](https://images.unsplash.com/photo-1559163232-cf9427758ee6?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## 需求描述\n我想要實作一個修改文章標題的功能\n* 在 ArticleHeader 內新增一個按鈕叫做編輯標題\n  * 按下後標題顯示輸入框供使用者輸入新標題，按下 Enter 確定修改；按下 ESC 則退出\n\n了解需求後立馬動手吧～\n\n## 先從 UI 開始\n因為這個需求所以要調整 ArticleHeader 元件下的 Template 以及 class ，順便移除掉一些不相干的東西讓這個範例看起來更單純。\n\n### ArticleHeader Template 的調整\n* 新增編輯標題按鈕、取消編輯按鈕並加上點擊事件\n* 把之前的 PipeComponent 給取消\n* 重新調整一下文章的資料格式，讓範例更簡單易懂\n  * 把 `subject` 那一層拿掉、刪除 `subtitle`\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\" >\n    <a [href]=\"item.href\">{{ item.title}}</a>\n    <input type=\"text\" size=\"70\" [value]=\"item.title\">\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span>\n    <button (click)=\"deleteArticle()\">刪除</button>\n    <button (click)=\"\">編輯標題</button>\n    <button (click)=\"\">取消編輯</button>\n  </span>\n</header>\n```\n現在網頁呈現的畫面是這樣的：\n\n![](https://i.imgur.com/XY4RgNv.png)\n\n邏輯是這樣的：\n* 使用結構型指令 ngIf 控制標題與輸入框以及編輯與取消按鈕的顯示\n* 當使用者點擊編輯標題按鈕時修改 `isEdit` 的值為 `True` 、點擊取消編輯按鈕時 `isEdit` 的值為 `False` \n\n> 為了做到這些事情，所以必須先到 ArticleHeader class 進行調整\n\n\n### ArticleHeader class 的調整\n這裡需要做的調整如下：\n* 新增屬性　`isEdit` 用來判斷是不是處於編輯模式，預設為 `False`\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n\n  isEdit = false;\n  constructor() { }\n  ngOnInit() {\n  }\n}\n```\n\n**回到 Template 補上 ngIf**\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\" >\n    <a *ngIf=\"!isEdit\" [href]=\"item.href\">{{ item.title}}</a>\n    <input *ngIf=\"isEdit\" type=\"text\" size=\"70\" [value]=\"item.title\">\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span>\n    <button (click)=\"deleteArticle()\">刪除</button>\n    <button *ngIf=\"!isEdit\" (click)=\"isEdit=true\">編輯標題</button>\n    <button *ngIf=\"isEdit\" (click)=\"isEdit=false\">取消編輯</button>\n  </span>\n</header>\n```\n\n**測試一下目前的邏輯是否正確**\n\n![非編輯模式](https://i.imgur.com/MKSogOE.png)\n\n![編輯模式](https://i.imgur.com/vRK5l1Q.png)\n\n## 實作編輯文章標題\n這邊有個一個簡單但不太建議的做法：\n* 直接在 input 上使用雙向繫結綁定 `item.title`\n\n> 這麼做會直接把修改的內容直接寫回去，而需求瞬間就完成了。\n\n**但伴隨而來的缺點是**\n* 會讓子元件與父元件間相依性太重\n* 因為是雙向繫結，一但修改後是沒辦法透過取消編輯取消的，會直接修改到原始的資料。\n\n> 所以這個做法肯定是不太行的，得換個方式。\n\n**比較好的方式** - 透過單向資料流與不可變的物件方式 \n* 在 ArticleHeader Template 的 input 上建立二個 Keyup 事件，並傳入參數 `$event`\n  * 當使用者按下 Enter 時觸發 `editTitle` 方法\n  * 當使用者按下 ESC 時觸發 `exitEdit` 方法\n* 在 ArticleHeader class 內建立一個屬性值 `newTitle`\n* 進行 `ngOnInit()` 時將 `newTitle` 賦值為 `item.title`\n* input 上使用屬性繫結 value 的值改用 `newTitle`\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\" >\n    <a *ngIf=\"!isEdit\" [href]=\"item.href\">{{ item.title}}</a>\n    <input *ngIf=\"isEdit\" type=\"text\" size=\"70\" [value]=\"newTitle\"\n      (keyup.enter)=\"editTitle($event)\" (keyup.escape)=\"editExit($event)\">\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span>\n    <button (click)=\"deleteArticle()\">刪除</button>\n    <button *ngIf=\"!isEdit\" (click)=\"isEdit=true\">編輯標題</button>\n    <button *ngIf=\"isEdit\" (click)=\"isEdit=false\">取消編輯</button>\n  </span>\n</header>\n```\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n  isEdit = false;\n  newTitle = '';\n  constructor() { }\n\n  ngOnInit() {\n    this.newTitle = this.item.title;\n  }\n  deleteArticle() {\n    this.delete.emit(this.item);\n  }\n  editTitle(e) {\n    console.log('editTitle', e.target);\n    this.newTitle = e.target.value;\n  }\n  editExit(e) {\n    console.log('editExit', e.target);\n    e.target.value = this.item.title;\n    this.isEdit = false;\n  }\n}\n```\n\n* 當觸發 `editTitle` 方法時，會將 input 內的 value 值取出並賦值給 `newTitle` ，等待傳送給父元件\n* 當觸發 `editExit` 方法時，將原始資料塞回 input 內的 value \n\n**前置作業都做完了，剩下就是通知父元件 ArticleList 囉！**\n\n* 建立一個新的 `@Output()` 並宣告一個 `titleChange` 的事件\n* 當觸發 `editTitle` 方法時，使用 `emit` 發射要變更的資料給父元件\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n\n  @Output()\n  changeTitle = new EventEmitter<any>();\n\n  isEdit = false;\n  newTitle = '';\n  constructor() { }\n\n  ngOnInit() {\n    this.newTitle = this.item.title;\n  }\n  deleteArticle() {\n    this.delete.emit(this.item);\n  }\n  editTitle(e) {\n    console.log('editTitle', e.target);\n    this.newTitle = e.target.value;\n    this.changeTitle.emit({ newTitle: this.newTitle, id: this.item.id });\n  }\n  editExit(e) {\n    console.log('editExit', e.target);\n    e.target.value = this.item.title;\n    this.isEdit = false;\n  }\n}\n```\n> 接下來就是到父元件上設定接收並做出實際的改變啦～\n\n* 事件繫結 `changeTitle` 並且當這個事件被觸發時執行 `doChange()` 方法，使用 `$event` 參數接收子元件送來的資料\n\n**ArticleList Template**\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"doDelete($event)\" (changeTitle)=\"doChange($event)\"></app-article-header>\n  <app-article-body [item]=\"item\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n> 到了最後這個步驟了，為了讓底下的所有子元件都知道資料物件發生改變，所以 `atticleData` 屬性指向的陣列要重新建立，而陣列裡面的物件如果裡面的屬性有發生修改，也要重新建立。\n\n\n**ArticleList class**\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  atticleData: Array<any>;\n  constructor() { }\n  ngOnInit() {\n    /* tslint:disable */\n    this.atticleData = [\n      {\n        \"id\": 1,\n        \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n        \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n        \"date\": \"2016/04/30 18:05\",\n        \"author\": \"GHJKL\",\n        \"category\": \"Visual Studio\",\n        \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n        \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n      },\n      ...以下省略\n    ];\n  }\n  doDelete(item){\n    this.atticleData = this.atticleData.filter(v => v !== item);\n  }\n  doChange($event: any){\n    this.atticleData = this.atticleData.map((item)=>{\n      if($event.id === item.id) {\n        // 不要這樣寫 item.title = $event.title;\n        // 當屬性被改動時，要建立新的物件\n        return Object.assign({}, item, $event);\n      }\n      return item;\n    });\n  }\n}\n```\n\n* 為了讓陣列重新建立，使用 ES6 的陣列方法 map ，它會回傳一個新的陣列\n* 值得注意的是，當進入 if 判斷時，不可以直接寫 `item.title = $event.title` 這樣就落入之前說的陷阱了\n  * 正確應該使用 `Object.assign` 方法，回傳一個新的物件並且合併 `item` 以及 `$event`\n    *  [MDN - Object.assign()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n> 根據 MDN 的解釋，使用 `Object.assign` 方法時，如果在目標物件裡的屬性名稱 (key) 和來源物件的屬性名稱相同，將會被覆寫。若來源物件之間又有相同的屬性名稱，則後者會將前者覆寫。\n\n**都完成了，來測試看看吧！**\n\n![編輯中](https://i.imgur.com/0MpYqhW.png)\n\n![無法順利變更標題](https://i.imgur.com/01hAhDu.png)\n\n糟糕程式好像出了點問題，加上幾行 `console.log` 觀察看看吧。\n\n![](https://i.imgur.com/Za4CO0u.png)\n\n**原來問題是沒有正確合併，因位子元件傳送給父元件的資料物件內的屬性名稱要與標題的屬性名稱一致才會覆蓋，因此必須回去修改。**\n\n```js\neditTitle(e) {\n  console.log('editTitle', e.target);\n  this.newTitle = e.target.value;\n  this.changeTitle.emit({ title: this.newTitle, id: this.item.id });\n}\n```\n**重新測試！**\n\n![修改成功](https://i.imgur.com/kk6Afog.png)\n\n## 小結\n這個範例主要是練習實作一個稍微複雜一點的單向資料流與不可變物件特性的開發技巧，透過這個練習未來在開發多個元件時，可以有效降低元件與元件間的相依性也提升可維護性。\n\n看來有空必須要常常回來這篇文章複習哩～","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.30 解釋單向資料流與不可變的物件","url":"%2Ff2e%2F20190531%2F2148310774%2F","content":"\n## 前言\n單向資料流與不可變的物件，究竟這是什麼意思呢？\n\n![](https://images.unsplash.com/photo-1559157865-4982964542a3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## 目前架構\n\n我們目前的專案結構大致如下：\n\n![](https://i.imgur.com/PuCHg6s.png)\n\n* ArticleList 元件 - 擁有所有的資料，並透過屬性繫結把資料傳給子元件\n  * ArticleHeader - 擁有屬性 item ，承接來自父元件的物件資料\n  * ArticleBody - 擁有屬性 item ，承接來自父元件的物件資料\n\n## 功能需求\n\n假設今天有一個需求是要更改文章標題，最簡單的做法就是直接從 ArticleHeader 動手，修改 item 這個物件的屬性值，這個屬性值只要一改變，父元件 data 下的這些物件值也會跟著改變。\n\n> 而雖然這個改法很簡單，不過建議最好不要這麼做。\n\n盡量不要在子元件內直接對資料進行任何修改，否則元件間的相依性會太重，當有 Bug 產生時也不容易除錯。\n\n最好是透過**單向資料流**的方式來達成。\n\n\n## 單向資料流\n單向資料流的意思就是，**所有資料的變更永遠是從上層元件傳給下層元件。**\n\n換句話說，比較好的做法是：\n* ArticleHeader 內提供一個編輯的介面，讓使用者設定新的標題\n* 當確定送出時才把要變更的內容透過事件繫結傳遞給父元件，也就是 ArticleList 元件\n* ArticleList 元件做實際物件的操作 (變更資料等等)\n\n## 不可變的物件\nJavaScript 物件本身是可變的，所以當物件發生改變時如果希望另一個元件也能知道這個物件發生改變，這在 JavaScript 內非常不容易做到。\n\n舉例來說，在 ArticleHeader 內修改了 item 物件，那麼 ArticleBody 如何知道 ArticleHeader 內修改了 item 物件的哪個屬性呢？\n\n要怎麼樣 Angular 這個物件確實發生了改變、讓 ArticleBody 能反映出相對應的資料呢？\n\n**Angular 確實做得到，但是這樣效能會很差。**\n\n像是在 ArticleHeader 新增了一個點擊事件，並且觸發一個 `test` 方法，執行 `item` 物件內 `summary` 屬性值的修改。\n\n```html\n<header class=\"post-header\" (click)=\"test()\">\n  <h2 class=\"post-title\" >\n    <a [href]=\"item.href\">{{ item.subject?.title|lowercase|slice:-20 }}</a>\n    <small>{{item.subject?.subtite}}</small>\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span><button (click)=\"deleteArticle()\">刪除</button></span>\n</header>\n```\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter} from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n  constructor() { }\n\n  ngOnInit() {\n  }\n  deleteArticle() {\n    this.delete.emit(this.item);\n  }\n  test() {\n    console.log(this.item);\n    this.item.summary = 'aaa';\n  }\n}\n```\n\n![](https://i.imgur.com/bU0KI9w.png)\n\n> 點擊後的確影響到 ArticleBody 內的資料了，但是非常不推薦這麼做。\n\n**好的作法**\n* 當在 ArticleHeader 修改了 item 物件的內容，應該把修改過的內容往上傳給父元件\n* 在父元件內找出是哪一筆資料更動，假設是第一筆\n  * 接著重新建立一個全新的物件、連同陣列的部分也產生新的\n\n而這樣就是所謂的**不可變的物件特性**。\n\n只要物件不管哪個屬性發生變更，通通都重新產生物件的話，在 Angular 內很容易就可以辨識出那些物件發生了變化。\n\n舉例來說\n* 只要陣列變成新的，那麼 ngFor 就會重新渲染\n* 陣列的其中一個元素的物件是新的，Angular 就會知道這個物件在做資料繫結時要把新的資料渲染到畫面上。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.29 定義 Angular 元件的輸出介面 - @Output()","url":"%2Ff2e%2F20190531%2F3041477683%2F","content":"\n## 前言\n在物件導向程式的領域，有個稱為 OCP ( Open Closed Principle ) 的原則，中文稱為開放封閉原則。這原則說的是，在進行物件導向程式設計時要能符合開放擴充但封閉修改的要素，這樣子才能把每個不同的物件獨立切開、互不干擾。\n\n這段前言又跟這篇文章有什麼關係呢？\n\n![](https://images.unsplash.com/photo-1559149517-3ab947621a90?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## 截至目前為止的結構\n可整理出如下列表\n* AppModule - 根模組\n  * AppComponent\n    * ArticleList\n      * ArticleHeader\n      * ArticleBody\n\n而元件一層包一層的好處是，一次只要關注一個想要修改的地方就好了，不管應用程式多複雜透過元件化的架構，就可以把一份複雜的網頁切割成多個元件，每個元件只單純負責幾件事情就好。\n\n## 製作刪除文章的功能\n假使想要實作出刪除文章的按鈕，想要將這個按鈕放在 ArticleHeader 的 Template 內，點擊後能夠將刪除的資訊傳給父元件 ArticleList ，最後達成刪除文章的效果。\n\n### 添加刪除按鈕\n首先在 ArticleHeader 的 Template 內做出一顆按鈕。\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\">\n    <a [href]=\"item.href\">{{ item.subject?.title|lowercase|slice:-20 }}</a>\n    <small>{{item.subject?.subtite}}</small>\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span><button>刪除</button></span>\n</header>\n```\n但是這樣是沒辦法刪除的，因為資料是由父元件 ArticleList 傳遞給子元件 ArticleHeader ，子元件本身並不具有這份資料。\n\n**解決辦法是將要刪除哪筆篇文章的資料往上傳遞給父元件，透過父元件刪除該篇文章。**\n\n白話來說，以刪除文章這個功能而言：\n* 子元件 ArticleHeader 扮演的角色是：**透過點擊事件通知父元件哪一篇文章的刪除按鈕被點擊了。**\n* 接著父元件 ArticleList 接收到訊息後把對應資料刪除，重新透過 ngFor 渲染網頁。\n\n### 註冊 ArticleHeader 內的事件\n**從父元件傳值給子元件是透過屬性繫結；從子元件傳值給父元件則必須透過事件繫結。**\n\n在 Angular 元件內要註冊一個事件必須先宣告一個屬性，同時宣告一個 `@Output` 裝飾器，跟之前介紹過的 `@Input` 一樣。\n\n首先來到 ArticleHeader 的 `class` 內進行修改：\n\n```js\nimport { Component, OnInit, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete;\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n> 這樣就完成了 delete 事件的註冊，接著要將這個事件繫結到父元件上。\n\n**事件的名稱可以自由命名。**\n\n### 在父元件上繫結 delete 事件\n\n剛才已經在子元件內註冊了 delete 事件，此時在 ArticleList 內已經可以從自動完成中看到對應的選項。\n\n![](https://i.imgur.com/l4Hl1aK.png)\n\nArticleList 內的 Template\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=\"item\" (delete)=\"doDelete($event)\"></app-article-header>\n  <app-article-body [item]=\"item\"></app-article-body>\n</article>\n<!-- Article END-->\n```\n> 當接收到 `delete` 事件發出的通知時，就會觸發 ArticleList 內的 `doDelete()` 方法，而且還要讓它傳入一個 `$event` 參數，這樣才能知道使用者點擊的是哪一篇文章的刪除按鈕。\n\n### 完成 ArticleHeader 內的 delete 事件\n剛才雖然已經註冊 `delete` 事件，但還有很多細節尚待處理。\n\n* 例如剛才宣告的 `delete` 屬性需要 new 一個 EventEmitter 物件\n  * EventEmitter 是一個事件的發射器。\n  * EventEmitter 後面可以接 `<any>` ，代表要傳送的資料可以是任意型別\n\n![選擇正確的 EventEmitter](https://i.imgur.com/S0vTXFQ.png)\n\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n\n```\n\n**什麼時候發射 delete 的事件？自然是按下刪除按鈕的時候**\n回到 ArticleHeader 的 Template :\n\n```html\n<header class=\"post-header\">\n  <h2 class=\"post-title\">\n    <a [href]=\"item.href\">{{ item.subject?.title|lowercase|slice:-20 }}</a>\n    <small>{{item.subject?.subtite}}</small>\n  </h2>\n  <div class=\"post-info clearfix\">\n    <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n    <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n        href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n    <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n        [href]=\"item['category-link']\">{{item.category}}</a></span>\n  </div>\n  <span><button (click)=\"deleteArticle()\">刪除</button></span>\n</header>\n```\n\n> 當點擊按鈕時透過點擊事件，觸發 ArticleHeader 內的 `deleteArticle` 方法。\n因此我們必須實作 `deleteArticle` 方法。\n\n```js\nimport { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n\n  @Output()\n  delete = new EventEmitter<any>();\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n  deleteArticle(){\n    this.delete.emit(this.item);\n  }\n}\n```\n當 `deleteArticle` 方法被觸發時，透過 `delete.emit()` 這個事件發射器，將 `this.item` 向父元件射出。\n\n而父元件上的 `$event` 接收的資料就會是剛才被射出的 `this.item` 。\n\n### 實作 doDelete 方法\n回到 ArticleList 的 `class` 內，實作刪除文章。\n\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-article-list',\n  templateUrl: './article-list.component.html',\n  styleUrls: ['./article-list.component.scss']\n})\nexport class ArticleListComponent implements OnInit {\n  atticleData: Array<any>;\n  constructor() { }\n  ngOnInit() {\n    /* tslint:disable */\n    this.atticleData = [\n      {\n        \"id\": 1,\n        \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n        \"subject\": {\n          \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n          \"subtite\": \"Visual Studio Code\"\n        },\n        \"date\": \"2016/04/30 18:05\",\n        \"author\": \"GHJKL\",\n        \"category\": \"Visual Studio\",\n        \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n        \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n      },\n      ...\n    ];\n  }\n  doDelete(item){\n    this.atticleData = this.atticleData.filter((data)=>{\n      return data.id !== item.id;\n    })\n  }\n}\n```\n因為 `atticleData` 屬性並沒有明確的型別，所以使用自動完成並沒有提示可以使用什麼方法，因此手動補上 `Array<any>` 代表這是一個可以傳入任何資料的陣列。\n\n最後透過 ES6 的 filter 方法篩選被刪除的文章，達成本次需求。\n\n> 搞定～測試看看吧！\n\n![把文章全刪除了](https://i.imgur.com/Ijsd8NI.png)\n\n## 小結\n可以很明顯的看出，從子元件將資料傳遞給父元件是要透過比較多道手續的，但整體而言也不難理解，就花點時間好好地記住吧。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.28 Angular 的生命週期 Hook - ngOnInit 與 ngOnDestroy","url":"%2Ff2e%2F20190530%2F3127782962%2F","content":"\n## 前言\n每一個 Angular 元件都有自己的生命周期，元件隨時會被建立也有可能隨時被註銷，之前介紹到結構性指令的時候也有稍微提到一些。而這一篇文章主要介紹的是，元件被建立的過程中程式碼運行的順序是如何？\n\n![](https://images.unsplash.com/photo-1559163206-6615672fad34?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## 元件的生命週期 Hook\n之前在建立元件時，常常會在元件的 class 內看到兩個方法，但是從來沒有使用過。\n\n分別是：\n* constructor(){}\n* ngOnInit(){}\n\n### 最先執行 - 建構式 constructor()\nconstructor 是一個建構式，而建構式會在 class 被建立時，第一時間被執行，換句話說在 Angular 的生命週期裡面，這是第一個執行的程式碼。\n\n不過幾乎不會寫任何程式在 constructor 內，因為當 constructor 執行時，元件尚未被初始化，所以是接不到任何資料的。\n\n儘管如此， constructor 還是有特殊的用途，例如拿來做**相依注入 ( DI )**\n\n### 生命週期 Hook - ngOnInit()\n從這個名稱來看，應該多少會猜到是 Angular 進行 Init 初始化後會執行的程式碼。\n\n從 ngOnInit() 開始，該元件的初始化、該元件所有必要的屬性繫結都已經完成。\n> 也就是說可以對目前這個元件做一些初始化的動作。\n\n舉例來說\n* 設定屬性的預設值\n* 發出 Ajax 的要求跟伺服器要資料，並把值寫到屬性內，透過屬性繫結呈現在 Template 上\n\n> 所以這個方法算是蠻常用到的。\n\n**當 ngOnInit() 結束後就會正式進入到 Angular 的生命週期，像是進行屬性繫結、事件繫結等等。**\n\n### 生命週期 Hook - ngOnDestroy()\n當父元件決定要摧毀目前這個子元件時，這個方法可以讓元件在被摧毀前執行特定的程式碼。\n\n但是這個 Hook 的使用機會比較少，大部分的情況元件裡面的記憶體通常都會自動回收。\n\n所以不需要特別地去寫程式處理這一塊，但是在少數的情況下像是搭配 Rxjs 去做一些非同步事件的訂閱，有些時候確實就必須在這個時間點做處理。\n\n### 小結\n關於元件的生命週期還有很多沒有介紹到，同樣也是可以等用到時在了解即可，在撰寫這篇的過程中也找到一些前輩整理好的資料：\n\n* [[Angular 大師之路] Day 04 - 認識 Angular 的生命週期](https://ithelp.ithome.com.tw/articles/10203203)\n* [[功能介紹-3] Hooks的生命週期](https://ithelp.ithome.com.tw/articles/10194566)\n\n![Lifecycle Hooks](https://i.imgur.com/eMUPWsS.png)","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.27 定義 Angular 元件的輸入介面 - @input()","url":"%2Ff2e%2F20190530%2F1773530928%2F","content":"\n## 前言\n承接上一篇文章，目前資料是存放於父元件的，但卻是子元件需要這份資料做輸出，那要如何將父元件的資料傳遞給子元件呢？\n\n![](https://images.unsplash.com/photo-1559032806-99a331d600b4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1498&q=80)\n\n## @input()\n現在專案內發生的問題就是:\n* 兩個子元件 ArticleHeader 與 ArticleBody 的 Template 內有使用到 item 變數\n  * 但是 `item` 變數並沒有被傳進來，它仍然存在於 ArticleList 內\n\n**如何把 `item` 變數傳入這兩個子元件呢？**\n\n### 在子元件的 class 內加入 @input() 裝飾器 \n如同先前提到的，要將父元件的資料傳遞到子元件，必須透過屬性繫結的方式。\n\n> 意味著子元件必須要有一個屬性可以承接，於是在這邊宣告屬性 item ，並且不賦予任何值。\n\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  item;\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n但這麼做還不夠，因為目前這個 item 只隸屬於 ArticleHeader 元件，在預設的情況下 `item` 是無法被父元件透過屬性繫結注入資料的。\n\n**還必須加入 @input() 這個 declarator 裝飾器**，並且匯入相依模組才可以使用。\n\n而這個步驟同樣也有自動完成可以使用，因此修正後如下：\n```js\nimport { Component, OnInit, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-article-header',\n  templateUrl: './article-header.component.html',\n  styleUrls: ['./article-header.component.scss']\n})\nexport class ArticleHeaderComponent implements OnInit {\n  @Input()\n  item;\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n> 我們必須也在 ArticleBody 的 class 進行相同的操作，就不贅述了。\n\n而經過上述這些步驟可以發現原本的錯誤已經不見了。\n\n原因是我們已經定義了 `item` ，但是這樣還不算完成，先看一下目前網頁的狀態。\n\n![](https://i.imgur.com/dHqzlMO.png)\n\n**可以看到目前是沒有資料傳進來的，還需要做一些處理。**\n\n### 透過屬性繫結傳入資料\n回到 ArticleList 的 Template 內，並且對兩個子元件加入屬性繫結。\n\n**居然有支援自動完成，太神啦！**\n\n![](https://i.imgur.com/JtmlJ7D.png)\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <app-article-header [item]=item></app-article-header>\n  <app-article-body [item]=item></app-article-body>\n</article>\n<!-- Article END-->\n```\n\n> 我們就完成了子元件的屬性繫結，中括號 [] 裡面的 `item` 是剛才在子元件內定義的屬性，而等號後面接的是要傳入的資料也就是區域變數 `item` 。 \n\n來測試看看吧！\n\n![](https://i.imgur.com/3qkwND0.png)\n\n至此，我們就完成了一個功能模組的建立，並且這個功能模組內有三個元件，其中父元件為 ArticleList 與它的兩個子元件 ArticleHeader 、 ArticleBody 。\n\n![](https://i.imgur.com/pVrmA9I.png)\n\n## 小結\nAngular 應用程式的架構，就是把網頁變成一個個大大小小的元件，這是屬於元件化的架構。\n\n在元件化的架構下只要能妥善規劃，在開發、維護、管理層面上複雜度可以大幅地降低。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.26 建立 Angular 功能模組","url":"%2Ff2e%2F20190530%2F2381478941%2F","content":"\n## 前言\n當專案的架構越來越龐大時，此時會將一些較相關的元件與服務元件獨立封裝成一個 Angular 的模組，像這種根據特定功能建立的模組，有時候也被稱為**功能模組 (Feature Module)**\n\n![](https://images.unsplash.com/photo-1559056427-6fe5ce77f06d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 事前規劃\n假使我想要逐步地將目前部落格版型改成這張圖片上畫的那樣，該怎麼做呢？\n\n![](https://i.imgur.com/qRLnhnv.png)\n\n> 目前專案內並沒有 Article 相關的三個元件， ArticleModule 也還沒建立，讓我們一一的完成它吧。\n\n## 建立 ArticleModule 模組 (Feature Module)\n我要建立一個 Article 的模組，而這個模組在建立完成後，必須匯入到 AppModule 內，如此一來 Angular 才知道有 ArticleModule 的存在。\n\n### 透過 Angular CLI 建立模組並加入根模組\n這裡有兩種方式可以建立模組，則一即可：\n* `ng generate Module article`\n* `ng g m article`\n\n**模組名稱打小寫就可以了，不用特地加上 Module 字樣**\n\n執行成功後 app 資料夾內會產生一個 article 的資料夾\n\n![](https://i.imgur.com/jNME8ll.png)\n![](https://i.imgur.com/vDY17aw.png)\n\n比較一下 app.module 與 article.module 的內容差異\n\n**app.module**\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n**article.module**\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule\n  ]\n})\nexport class ArticleModule { }\n```\n\napp.module 是根模組、 article.module 是功能模組\n* article.module 內的 declarations 是空的，因為目前還沒有任何元件\n\n**而下一步則是把 article.module 加入 app.module**，讓 Angular 知道我們新增了功能模組。\n\n調整如下：\n![自動完成](https://i.imgur.com/8I5SEx5.png)\n\n![不費吹灰之力](https://i.imgur.com/2nhRZAF.png)\n\n> 這是因為新版的 VS Code 內建 TypeScript 新的版本，而 TypeScript 新版支援 Auto Import 的功能。\n\n存檔後確認有無任何錯誤。\n\n![](https://i.imgur.com/4mW7bDU.png)\n\n**非常好，沒有任何問題產生！**\n\n## 其實剛剛做的事情只需要一行就完成\n剛才介紹了如何透過 Angular CLI 建立模組，但其實這些指令後面還可以加入一些參數，例如：\n* `ng generate Module article -m app`\n* `ng g m article -m app`\n\n> `-m` 後面可以接一個模組名稱，像是上面的指令示範。\n\n**這麼做就會使 Angular CLI 建立 article 模組後自動地向 app.module 註冊。**\n\n![](https://i.imgur.com/vixBlID.png)\n\n![](https://i.imgur.com/5W8R2ji.png)\n\n> **超棒的功能，不是嗎？**\n\n## 將現有的元件加入功能模組\n目前這個功能模組內是空的，因此要開始拆解部落格內關於 Article 的 HTML 並封裝成元件了。\n\n將  Article 的 HTML 拆分為以下三個元件：\n* ArticleList\n  * ArticleHeader\n  * ArticleBody\n\n最後向 ArticleModule 註冊這些元件。\n\n### ArticleList 元件拆解\n首先將 AppComponent 底下 Article 的部分，全部拆解成一個新的元件 - ArticleList\n\n* 輸入 `ng g c articleList` 建立 ArticleList 元件。\n\n但此時我們不能直接輸入這道命令，因為預設 Angular CLI 會把元件註冊到 app.module ，但事實上必須將其註冊到 article.module 才正確。\n\n**因此應該先使用 CD 指令，將資料夾切換至 article 資料夾底下**\n\n![](https://i.imgur.com/X5HpCAz.png)\n\n接著就可以一如往常地建立元件了～\n\n![](https://i.imgur.com/ChJehi5.png)\n\n> 而且也會發現元件在 article.module 內被註冊了。\n\n**除了在 app.module 內註冊 article.module 外， article.module 也必須匯出元件才行！**\n\n因此修改 article.module\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ArticleListComponent } from './article-list/article-list.component';\n\n@NgModule({\n  declarations: [ArticleListComponent],\n  imports: [\n    CommonModule\n  ],\n  exports: [ArticleListComponent]\n})\nexport class ArticleModule { }\n```\n\n**接著開始搬運 AppComponent 底下 Article 的 HTML**\n* 在 app.component.html 剪下 HTML ，並補上 `<app-article-list>`\n* 把剪下的 HTML 貼到 article-list.component.html\n* 之前文章的資料存放於 app.component.ts ，因此也必須移轉到 article-list.component.ts\n\n> 搞定！執行看看吧～\n\n![](https://i.imgur.com/oHlKsrc.png)\n\n\n### 把剩餘的兩個元件拆完\n跟剛才建立 article-list 元件一樣，必須將目錄切換過去才能開始建立元件，過程就不贅述了。\n\n* 輸入指令建立 article-header 、 article-body\n\n![](https://i.imgur.com/0FY1nmC.png)\n\n**這時我們可能會想要把這些元件給匯出，畢竟記取剛才的教訓嘛～**\n\n> 從外部的角度而言，只需要看到 article-list 元件，並不需要看到 article-header 、 article-body 。\n因為這兩個子元件是被封裝在 article-list 元件內的，所以僅匯出 article-list 元件即可。\n\n接著就繼續搬動 HTML 囉，過程就不贅述了\n* 拆分 article-list.component.html 內的 HTML 給\n  * article-header.component.html\n  * article-body.component.html\n\n最後於 article-list.component.html 內補上對應的元件標籤就完成了。\n\n至此已經將架構大致完成，但細部還需要做調整。\n\n**此時網頁會是壞掉的，因為目前 article 的資料仍停留在 article-list 並未向下傳遞**，\n\n下一篇將介紹如何把資料往子元件傳遞。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.25 Angular 元件架構","url":"%2Ff2e%2F20190530%2F3387203766%2F","content":"\n## 前言\nAngular 是採用元件化模組開發的框架，可以想像就是不同大大小小元件堆砌而成的網頁，這樣的情況下元件架構又是如何呢？\n\n![](https://images.unsplash.com/photo-1558713089-d1aad46c19bf?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## Angular 元件架構\n\n![](https://i.imgur.com/Z3wEIRK.png)\n\n從這張圖可以看出完整個的 Angular 應用程式，是由不同的元件所組成。\n\n最上層的根元件預設名稱為 AppComponent ，而底下可能包含了 Header 元件與 ArticleList 元件。\n* 而 Header 元件裡面可能只有單純的 HTML 或一些互動\n* 而元件內可以放入其他元件，如 ArticleList 元件可以在包含其他不同的元件，像是\n  * ArticleHeader 元件\n  * ArticleBody 元件\n\n**也就是說在 Angular 的世界，網頁是由一層層的元件所組成。**\n\n而元件跟元件之間就有父子的關係，像是 \n* ArticleList 元件可以說是 ArticleHeader 、 ArticleBody 的父元件\n  * 反過來就是 ArticleHeader 、 ArticleBody 元件是 ArticleList 的子元件\n\n## 元件之間的溝通\n元件與元件之間是可以互相溝通的，例如：\n* 資料存放於 ArticleList 元件上，而需要把資料往下傳送給子元件 ArticleBody\n  * 此時會在 ArticleBody 建立一個屬性準備接收資料，因此就能形成屬性繫結的關係\n\n相反的，如果是子元件往父元件溝通呢？\n* ArticleHeader 、 ArticleBody 有一個共同的父元件 ArticleList\n  * 此時可以透過事件繫結的方式來通知父元件\n    * 具體來說就是會在子元件內寫一些屬性、程式來通知父元件\n\n![](https://i.imgur.com/F3XGWYO.png)\n\n## 服務元件？\n進階的元件與元件的溝通會藉由建立服務元件來達成。\n\n而服務元件有可能會透過一種稱為**相依注入 ( Dependency Injection ) 簡稱 DI** 的技術，把預先設計好的服務元件直接注入到某個特定得元件內。\n\n**舉例來說，可以透過 DI 技術將某個服務元件注入到 ArticleList 元件內，或者是 ArticleHeader 元件等等。**\n\n> 而服務元件內封裝的就是不同元件之間需要共用的資料、方法等等\n\n## 模組化\n雖然這個架構看起來相當不錯，當網站越來越大時，通常會將相關的元件像是：\n* ArticleList\n* ArticleHeader\n* ArticleBody\n* 服務元件\n\n把這些相關的元件封裝起來，獨立成為一個 Angular 的模組，像這種根據特定功能建立的模組，有時候也被稱為**功能模組 (Feature Module)**。\n\n![](https://i.imgur.com/FPb4bnF.png)\n\n## 小結\n好的，現在我了解在 Angular 內不同元件間是如何溝通的了，而且也覺得蠻熟悉的，儘管方法可能完全不同，但卻有點類似。\n\n* 像是在 Vue 中 父子元件溝通的方式可以透過 props 傳入 、 emit 傳出，來達成父子元件溝通\n* 也可以使用 event bus 或者 Vuex 來管理元件間的溝通\n\n**好了，讓我們繼續探索 Angular 吧。**","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.24 避免在範本中出現 TypeScript 型別錯誤","url":"%2Ff2e%2F20190529%2F3182105266%2F","content":"\n## 前言\n從我開始學習 Angular 到現在雖然不是很久，但也有一段時間了。蠻容易在 Template 內跑出 TypeScript 的型別錯誤，那麼又該如何避免呢？\n\n![](https://images.unsplash.com/photo-1559056408-94245a95e30e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n##  Template 內跑出 TypeScript 的型別錯誤\n像這樣，這種類似的情況其實蠻容易發生的，很容易看到類似像這樣 TypeScript 型別的錯誤。\n\n![](https://i.imgur.com/wFFr3qI.png)\n\n這段錯誤的意思是說，這個 item 的區域變數並沒有定義它有個屬性叫做 subjec ，所以它認不得這是什麼。\n\n這種情況下有兩個解法：\n* 使用中括號選取屬性的方式，透過這種方式 TypeScript 就沒辦法檢查 item 下是否有 subjec 這個屬性，此時就會回傳 任意 ( any ) 型別\n![](https://i.imgur.com/9HokSjx.png)\n* 另一個解法則是官網提供的[類型轉換函式](https://angular.cn/guide/template-syntax#the-any-type-cast-function-any-expression-)\n\n## 類型轉換函式\n[類型轉換函數](https://angular.cn/guide/template-syntax#the-any-type-cast-function-any-expression-)的用法的則是在一個區域變數或者屬性的前後加上一個 `$any()` 的函式將其包覆，而官網的範例是這樣的：\n\n```html\n<!-- Accessing an undeclared member -->\n<div>\n  The hero's marker is {{$any(hero).marker}}\n</div>\n```\n透過這個函式回傳的型別的一定是 any 型別，這樣也能使 Angular 跳過 TypeScript 型別的檢查\n\n於是我們依樣畫葫蘆的嘗試看看\n\n![](https://i.imgur.com/lwvZfv7.png)\n\n**這時會發現出現錯誤 Unknown Method ，原因是目前 Angular language service 這個擴充套件還不支援 $any()**，未來等這個套件更新後這個問題應該會自然消失。\n\n不過網頁仍然可以正常運行沒有錯誤，代表這個語法其實是可以用的。\n\n![](https://i.imgur.com/2aNQsEz.png)\n\n**如果真的覺得這個錯誤很礙眼，那還是使用第一種介紹的方法吧～**\n\n\n\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.23 在範本中使用安全導覽運算子","url":"%2Ff2e%2F20190529%2F3651132835%2F","content":"\n## 前言\n安全導覽運算子 (Safe Navigation Operator) ，又是一個讓人摸不著頭緒的新名詞，讓我們一起看看吧。\n\n![](https://images.unsplash.com/photo-1555932339-5d13d6a9ae5e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 安全導覽運算子 (Safe Navigation Operator)\n直接在官網上搜尋 「template syntax」，這被官網歸納在模板的語法，相關說明如下：\n* [安全導覽運算子](https://angular.cn/guide/template-syntax#the-safe-navigation-operator----and-null-property-paths)\n\n**這個運算子可以使用在 Template 內，語法相當的特別是一個問號在加上一個點 「?.」**\n\n直接從範例來了解如何使用吧！\n\n### 前置準備\n* 今天有一個情境，需要改變原先我們 ngFor 使用的資料，因此修改如下：\n\n**app.component.ts**\n```js\natticleData = [\n  {\n    \"id\": 1,\n    \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n    \"subject\": {\n      \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n      \"subtitle\": \"\"\n    },\n    ...略\n  },\n]\n```\n因為資料結構改變了，所以 Template 也必須跟著調整\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.subject.title|lowercase|slice:-20 }}</a>\n</h2>\n```\n測試看看是否仍能正常運行。\n\n![](https://i.imgur.com/fsoJeFL.png)\n\n**此時，如果還需要額外輸出一個副標題的話該怎麼做？**\n\n* 很直覺的會回答可以使用內嵌繫結來達成\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.subject.title|lowercase|slice:-20 }}</a>\n  <small>{{item.subject.subtitle}}</small>\n</h2>\n```\n接著回到 **app.component.ts** 補一下第一筆資料的 subtitle 。\n\n運行開發伺服器，觀察畫面呈現。\n\n![](https://i.imgur.com/DMoawul.png)\n\n很好，一切都如預期執行。\n\n### 使用安全導覽運算子 (Safe Navigation Operator)\n前置作業準備完成後，現在要模擬另一種情境。\n\n這些資料在正式開發的時候，都會藉由 API 向後端取得資料，而從前端的角度來看，沒有辦法確保後端給我們的資料一定是完整的。\n\n舉例來說，**可能第一筆資料內有 subject 屬性，但第二筆就沒有 subject 屬性了，此時就會產生問題。**\n\n像是這樣，第一筆資料之後的文章都沒有顯示出來。\n\n![](https://i.imgur.com/0mM0zsx.png)\n\n該怎麼辦呢？\n\n這時候**安全導覽運算子 (Safe Navigation Operator)**就派上用場啦！\n\n**使用方式就是在可能會是 `null` 或是 `undefined` 的這些屬性或者是變數名稱後面加上一個問號而已。**\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.subject?.title|lowercase|slice:-20 }}</a>\n  <small>{{item.subject?.subtitle}}</small>\n</h2>\n```\n在這個情境裡 `subject` 不存在，所以當嘗試存取 `subject` 時會跳出 `undefined` ，而 `undefined` 並不是物件，所以沒有屬性 `subtitle` 。\n\n> 因此必須於 `subject` 後面補上一個 `?` \n\n接著運行開發伺服器，觀察情況吧！\n\n![](https://i.imgur.com/YIN6vq0.png)\n\n搞定！只要在屬性後方補上問號，就會形成安全導覽屬性。\n\n這個語法可以幫助 Angular 去判斷如果該屬性為 `null` 或是 `undefined` 的話，會直接回傳 `null` 就不會嘗試讀取這個屬性，也就不會出錯了。\n\n**這就是安全導覽運算子好用的地方，可以避免 Template 出現諸如此類的問題，另外安全導覽運算子只能使用在 Template 內。**","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.22 使用 Pipes 管線元件","url":"%2Ff2e%2F20190529%2F2426750085%2F","content":"\n## 前言\n這是一個我之前沒聽過的新名詞 Pipes 管線元件 ( Pipes Component )，究竟這是一個什麼樣的元件呢？\n\n![](https://images.unsplash.com/photo-1555685812-4b943f1cb0eb?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## Pipes 管線元件\n當我們對一項東西不了解的時候，很直覺的我們會想要上網去查資料。\n\n幸運的， Angular 官方就可以找到相關資訊，而且還是中文的\n* [Pipes 管線元件](https://angular.cn/guide/pipes)\n\n> Pipes 管線元件主要是讓我們在透過內嵌繫結或者是屬性繫結時可以透過 Pipes 的符號 `|` 將我們原本的輸出丟給另一個 Pipes 元件處理，再把新的結果輸出到畫面上。\n\n**聽到這裡，我又有一種似曾相似的感覺。**\n\n> 在 Vue 裡面可以使用 [filters](https://cn.vuejs.org/v2/guide/filters.html) ，同樣也是會使用到 Pipes 的符號 `|` 將原本的輸出丟給某個東西處理後，在把新的結果呈現在畫面上。\n\n扯遠了。\n\nAngular 內有幾個內建的 Pipes 元件\n* DatePipe\n* UperCase \n* LowerCase\n* Currency\n* PercentPipe\n\n**未羅列出全部，詳細請參考[這裡](https://angular.cn/api?type=pipe)**\n\n這幾個 Pipes 元件預設就可以讓我們使用在任何的 Template 上，若這些內建的 Pipes 元件不符合需求，也可以自行撰寫 Pipes 元件哦。\n\n## UperCase\n顧名思義這個 UperCase 的 Pipes 元件，就是幫我們把原本輸出有英文的部分全部轉換成大寫。\n\n這是還沒有套用 UperCase 前，標題的英文有大寫有小寫\n\n![](https://i.imgur.com/BFEh906.png)\n\n因此我要把這個 Pipes 元件套用到目前的 Template 上。\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.title|uppercase }}</a>\n</h2>\n```\n![](https://i.imgur.com/7j2rhVz.png)\n\n> 如此簡單的一行就搞定，而且有支援自動完成功能，很方便！\n\n## LowerCase\n與 UperCase 相同，顧名思義就是有英文的部分全部轉換成小寫，使用方式也非常簡單:\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.title|lowercase }}</a>\n</h2>\n```\n![](https://i.imgur.com/o8F4nc6.png)\n\n## DecimalPipe\n關於 DecimalPipe 的使用同樣可以在官方文件找到\n* [DecimalPipe](https://angular.cn/api/common/DecimalPipe)\n\n使用方式如：\n```js\n{{ value_expression | number [ : digitsInfo [ : locale ] ] }}\n```\n\n* value 是輸入值\n* number 是這個 Pipes 元件的名稱\n* digitsInfo 為字串型態的參數，非必填項目\n  * 格式如 `{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}`\n  * minIntegerDigits：在小数点前的最小位数。默认为 1。\n  * minFractionDigits：小数点后的最小位数。默认为 0。\n  * maxFractionDigits：小数点后的最大为数，默认为 3。\n* locale 為字串型態的參數，非必填項目\n  * 用來設定這一串數字要用哪一個地區的數值格式呈現\n\n因此可以按照官方提供的範例，複製一份並且在 Template 內隨意找個地方貼上玩看看：\n\n**Template**\n```html\n<div>\n  <!--output '2.718'-->\n  <p>e (no formatting): {{e | number}}</p>\n\n  <!--output '002.71828'-->\n  <p>e (3.1-5): {{e | number:'3.1-5'}}</p>\n\n  <!--output '0,002.71828'-->\n  <p>e (4.5-5): {{e | number:'4.5-5'}}</p>\n\n  <!--output '0 002,71828'-->\n  <p>e (french): {{e | number:'4.5-5':'fr'}}</p>\n\n  <!--output '3.14'-->\n  <p>pi (no formatting): {{pi | number}}</p>\n\n  <!--output '003.14'-->\n  <p>pi (3.1-5): {{pi | number:'3.1-5'}}</p>\n\n  <!--output '003.14000'-->\n  <p>pi (3.5-5): {{pi | number:'3.5-5'}}</p>\n\n  <!--output '-3' / unlike '-2' by Math.round()-->\n  <p>-2.5 (1.0-0): {{-2.5 | number:'1.0-0'}}</p>\n</div>\n```\n\nTemplate 有用到 `e` 以及 `pi` 這兩個內嵌繫結，因此必須在 class 內補上這兩個屬性。\n\n```js\nexport class AppComponent {\n  inputValue = '';\n  pi: number = 3.14;\n  e: number = 2.718281828459045;\n}\n```\n> 運行開發伺服器，看看效果如何～\n\n![](https://i.imgur.com/zqZBBLG.png)\n\n* 第一個結果 e 輸出是 2.718 ，對照後也就是說預設的情況下 DecimalPipe 會輸出小數點後三位的數字，其餘全部捨去。\n  * 而這個結果是因為沒有填寫任何參數，是參數的默認值導致\n* 第二個結果傳入一個參數 `3.1-5` ，對照上面的格式與參數解釋後，得到結果 e 為 002.71828\n\n> 可透過修改第一個參數達成想要的數字格式。\n\n* 第四個結果，傳入的第二個參數為 fr ，代表採用法國的數值格式\n  * 在法國，小數點是當作千分號使用，而千分號則是使用空白替代\n  * 透過不同的國家的 locale id 就可以轉換成對應的地區數值格式\n    * 台灣為 zh-TW\n    * 日本為 jp\n\n**不僅僅第一個參數可以利用，配合第二個參數一起使用才是王道。**\n\n> 而這個 Pipes 元件好玩的地方是，它的名稱叫做 DecimalPipe ，但實際使用卻是輸入 number ，這是容易搞混的地方要特別注意。\n\n## CurrencyPipe\n這是個貨幣格式的 Pipe 元件，官網文件如下：\n* [CurrencyPipe](https://angular.cn/api/common/CurrencyPipe)\n\n用法跟先前介紹的 DecimalPipe 蠻類似的，使用方式如下：\n\n使用方式如：\n```js\n{{ value_expression | currency [ : currencyCode [ : display [ : digitsInfo [ : locale ] ] ] ] }}\n```\n\n* value 是輸入值\n* currency 是這個 Pipes 元件的名稱\n* currencyCode 是貨幣代碼，比如 USD 表示美元，這部分是選填的，且格式須遵守 [ISO4217](https://en.wikipedia.org/wiki/ISO_4217)\n* display 是貨幣的符號，同樣是可選的，預設是顯示貨幣的符號。\n* digitsInfo 為字串型態的參數，非必填項目\n  * 格式如 `{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}`\n  * minIntegerDigits：在小数点前的最小位数。默认为 1。\n  * minFractionDigits：小数点后的最小位数。默认为 0。\n  * maxFractionDigits：小数点后的最大为数，默认为 3。\n* locale 為字串型態的參數，非必填項目\n  * 用來設定這一串數字要用哪一個地區的數值格式呈現\n\n**直接參考官網範例：**\n```js\n@Component({\n  selector: 'currency-pipe',\n  template: `<div>\n    <!--output '$0.26'-->\n    <p>A: {{a | currency}}</p>\n\n    <!--output 'CA$0.26'-->\n    <p>A: {{a | currency:'CAD'}}</p>\n\n    <!--output 'CAD0.26'-->\n    <p>A: {{a | currency:'CAD':'code'}}</p>\n\n    <!--output 'CA$0,001.35'-->\n    <p>B: {{b | currency:'CAD':'symbol':'4.2-2'}}</p>\n\n    <!--output '$0,001.35'-->\n    <p>B: {{b | currency:'CAD':'symbol-narrow':'4.2-2'}}</p>\n\n    <!--output '0 001,35 CA$'-->\n    <p>B: {{b | currency:'CAD':'symbol':'4.2-2':'fr'}}</p>\n\n    <!--output 'CLP1' because CLP has no cents-->\n    <p>B: {{b | currency:'CLP'}}</p>\n  </div>`\n})\nexport class CurrencyPipeComponent {\n  a: number = 0.259;\n  b: number = 1.3495;\n}\n```\n\n> 這部分因為跟 DecimalPipe 很類似，所以就不一個個解釋了。\n\n## PercentPipe\n這是一個百分比的 Pipe 元件，官網文件如下：\n* [PercentPipe](https://angular.cn/api/common/PercentPipe)\n\n使用方式如：\n```js\n{{ value_expression | percent [ : digitsInfo [ : locale ] ] }}\n```\n\n* value 是輸入值\n* percent 是這個 Pipes 元件的名稱\n* digitsInfo 為字串型態的參數，非必填項目\n  * 格式如 `{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}`\n  * minIntegerDigits：在小数点前的最小位数。默认为 1。\n  * minFractionDigits：小数点后的最小位数。默认为 0。\n  * maxFractionDigits：小数点后的最大为数，默认为 3。\n* locale 為字串型態的參數，非必填項目\n  * 用來設定這一串數字要用哪一個地區的數值格式呈現\n\n**直接參考官網範例：**\n```js\n@Component({\n  selector: 'percent-pipe',\n  template: `<div>\n    <!--output '26%'-->\n    <p>A: {{a | percent}}</p>\n \n    <!--output '0,134.950%'-->\n    <p>B: {{b | percent:'4.3-5'}}</p>\n \n    <!--output '0 134,950 %'-->\n    <p>B: {{b | percent:'4.3-5':'fr'}}</p>\n  </div>`\n})\nexport class PercentPipeComponent {\n  a: number = 0.259;\n  b: number = 1.3495;\n}\n```\n\n**從這邊可以發現， DecimalPipe 、 CurrencyPipe 、 PercentPipe 使用方式感覺上其實都差不多**\n\n## DatePipe\n這是一個關於日期的 Pipe 元件，關於這個元件的官網說明如下:\n* [DatePipe](https://angular.cn/api/common/DatePipe)\n\n使用方式如：\n```js\n{{ value_expression | date [ : format [ : timezone [ : locale ] ] ] }}\n```\n\n* value 是輸入值，可以是 Date 物件、數字（从 UTC 时代以来的毫秒数）或 [ISO 字符串](https://www.w3.org/TR/NOTE-datetime) \n* date 是這個 Pipes 元件的名稱\n* format 為字串型態的參數，為非必填項目\n  * 要包含的日期、時間部分的格式，或者是使用預先定義好的格式\n  * 預設值是 'mediumDate'.\n* timezone 為字串型態的參數，為非必填項目\n  * 可以加上一個時區偏移（比如 '+0430'）或使用標準的 UTC/GMT\n  * 預設為本地系統時區\n* locale 為字串型態的參數，非必填項目\n  * 用來設定日期要用哪一個地區的日期格式呈現\n\n> 接著利用 DatePipe 來修改部落格文章上的日期格式吧\n\n**Template**\n```html\n<span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n```\n\n![修改前](https://i.imgur.com/uLsDMpj.png)\n\n![修改後](https://i.imgur.com/cBZmn1L.png)\n\n這樣子的用法是直接轉換成我們希望的格式，但其實 format 參數內有一些已經預先定義好的格式可以使用，例如：\n\n**Template**\n```html\n<span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'shortDate'}}</span>\n```\n![shortDate](https://i.imgur.com/dyLOgal.png)\n\n## JsonPipe\nJsonPipe 可以把任意值全部轉換成 Json 的格式，所以這些值可以是字串、數字、物件。\n\n而官網的文件如下：\n* [JsonPipe](https://angular.cn/api/common/JsonPipe)\n\n> JsonPipe 的功能主要是拿來偵錯，像是輸出之前在練習 ngFor 時的用到的資料。\n\n**Template**\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <header class=\"post-header\">\n    <h2 class=\"post-title\">\n      <a [href]=\"item.href\">{{ item.title|lowercase }}</a>\n    </h2>\n    <div class=\"post-info clearfix\">\n      <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n      <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n          href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n      <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n          [href]=\"item['category-link']\">{{item.category}}</a></span>\n    </div>\n  </header>\n  <section class=\"post-body text\" [innerHTML]=\"item.summary\">\n  </section>\n  <pre>{{item}}</pre>\n</article>\n<!-- Article END-->\n```\n\n如果直接把 `item` 進行內嵌繫結輸出的話，只會得到奇怪的結果\n\n![](https://i.imgur.com/AAMZcs2.png)\n\n> 如果想要得到 `item` 物件序列化之後的 Json 資料，則可以使用 JsonPipe 來達成。\n\n**Template**\n```html\n<pre>{{item|json}}</pre>\n```\n\n![](https://i.imgur.com/qIAN6xH.png)\n\n## SlicePipe\nSlice 這個單字有切割的意思，所以這個 SlicePipe 可以幫助我們把某個物件、集合切割出其中的某一塊資料出來。\n\n而官網的文件如下：\n* [SlicePipe](https://angular.cn/api/common/SlicePipe)\n\n使用方式如：\n```js\n{{ value_expression | slice : start [ : end ] }}\n```\n\n* value 是輸入值，可以是陣列或字串\n* slice 是這個 Pipes 元件的名稱\n* start 必填參數，表示要返回的子集的初始索引，數值型別\n  * 正整數的情況：從列表或字符串表達式中返回從 start 索引處及之後的所有項目\n  * 負整數的情況：從列表或字符串表達式中返回從结尾开始的第 start 索引處及之後的所有項目\n  * 如果是正整數而且大於表達式的項目數：返回空列表或空字符串\n  * 如果是正整數而且大於表達式的項目數：返回整個列表或字符串\n* end 非必填參數，表示所要返回的子集的结尾索引，數值型別\n  * 省略：返回结尾之前的全部項目\n  * 正整數的情況：從列表或字符串中返回 end 索引之前的所有項目\n  * 負整數的情況：從列表或字符串末尾返回 end 索引之前的所有項目\n\n> 看完這些敘述似乎有點混亂，可以先試著把 SlicePipe 用在部落格的標題看看情況。\n\n**順帶一提， Pipe 與 Pipe 之間是可以串接的。**\n\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.title|lowercase|slice:0:20 }}</a>\n</h2>\n```\n**這麼寫的意思代表，我希望標題的英文可以是小寫，且字數可以從 0 取到第 20 的位置**\n\n觀察一下情況\n\n![](https://i.imgur.com/7px4gGO.png)\n\n> 可以看到標題顯示到 visual st 就結束了，因為前面加起來剛好是 20 個字元。\n\n如果想要取標題從後面數來第 20 個字元後的內容，也是辦的到的：\n**Template**\n```html\n<h2 class=\"post-title\">\n  <a [href]=\"item.href\">{{ item.title|lowercase|slice:-20 }}</a>\n</h2>\n```\n![](https://i.imgur.com/SOU69Z1.png)\n\n> 可以看到標題顯示從 「o code 如何避免顯示惱人的偵錯訊息」，這邊數來剛好 20 個字元。\n\n**以上是 SlicePipe 用在字串上的範例** ，而 SlicePipe 還可以用在陣列上。\n\n舉例來說，之前在練習 ngFor 時傳入的資料總共有六筆，而傳入的資料型態是個陣列。\n\n**這代表可以將 SlicePipe 用在這個地方，像是一頁只顯示二筆資料這樣。**\n\n**Template**\n```html\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData|slice:0:2; let idx = index\">\n  <header class=\"post-header\">\n    <h2 class=\"post-title\">\n      <a [href]=\"item.href\">{{ item.title|lowercase|slice:-20 }}</a>\n    </h2>\n    <div class=\"post-info clearfix\">\n      <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date|date:'yyyy-MM-dd HH:mm'}}</span>\n      <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n          href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n      <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n          [href]=\"item['category-link']\">{{item.category}}</a></span>\n    </div>\n  </header>\n  <section class=\"post-body text\" [innerHTML]=\"item.summary\">\n  </section>\n</article>\n```\n![](https://i.imgur.com/2N5rZar.png)\n\n## 小結\n介紹了這麼多的 Pipes 元件，一時之間想必很難完全記起來，好在這些資料全部都可以在官方文件上查到，而且全部都具有範例程式碼。\n\n所以不用死背這些東西，只需要記幾個最常用的像是 DatePipe 、 PercentPipe 、 CurrencyPipe 就可以了，其餘的等有用到再查也不遲。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.21 Angular 結構型指令 (Structural Directives)","url":"%2Ff2e%2F20190528%2F504997113%2F","content":"\n## 前言\n總算到介紹到最後一個 Angular 的指令 - 結構型指令 (Structural Directives) 啦，打起精神繼續往下學習吧！\n\n![](https://images.unsplash.com/photo-1519052537078-e6302a4968d4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 結構型指令 (Structural Directives)\n這種結構型的指令會透過新增或刪除 DOM 的元素動態改變 DOM 的結構，內建有三種語法：\n* ngIf\n* ngSwitch\n* ngFor\n\n> 相信看到這些語法大概也猜得出七八成是在做什麼的，以下一一示範如何使用。\n\n## ngIf\nngIf 的用法相當簡單，可以透過這個指令動態的新增或者是刪除一整段 HTML 的內容。\n\n假設這個 ICON 區塊會根據 Counter 的數字動態的顯示或隱藏，那該怎麼做呢？\n![](https://i.imgur.com/75oo2zQ.png)\n\n首先找到 Template 內對應的 HTML 區塊，並進行修改\n```html\n<div id=\"social-icons\" class=\"pull-right social-icon\" *ngIf=\"counter % 2 == 0\">\n  <a href=\"https://www.google.com\" target=\"_blank\">\n    <img src=\"/assets/images/facebook.png\">\n  </a>\n  <a href=\"https://www.google.com\" target=\"_blank\">\n    <img src=\"/assets/images/twitter.png\">\n  </a>\n  <a href=\"https://www.google.com\" target=\"_blank\">\n    <img src=\"/assets/images/googleplus.png\">\n  </a>\n  <a href=\"https://www.google.com\" target=\"_blank\">\n    <img src=\"/assets/images/plurk.png\">\n  </a>\n  <a href=\"https://www.google.com\" target=\"_blank\">\n    <img src=\"/assets/images/weibo.png\">\n  </a>\n  <a href=\"https://www.google.com\" title=\"RSS 訂閱\" target=\"_blank\">\n    <img src=\"/assets/images/rss.png\">\n  </a>\n</div>\n```\n特別的是 ngIf 前面必須加上一個 * 號，這個星號是結構型指令專屬的語法，算是語法糖的一種。\n\n**只要是結構型指令，記得加上 * 號就對了。**，不過我們也不需要真的死背，可以善用 code snippet 來輔助。\n\n而 `*ngIf` 的等號後方同樣也是接布林值，因此在這裡我們填入 `counter % 2 == 0` 這樣就可以了。\n\n* 只要回傳 True ，那麼就新增這個 HTML 區塊，反之則刪除\n\n> 測試看看吧！\n\n![新增](https://i.imgur.com/xW7JaSG.png)\n\n![刪除](https://i.imgur.com/7L0XvQy.png)\n\n**這邊要強調的是 ngIf 是真的操作 DOM 元素動態改變結構進行新增或是刪除，也就是當回傳 False 時該區塊是完全不存在網頁中的，並非單純的隱藏。**\n\n### 需要注意的地方\n使用 ngif 時，雖然語法相當的簡單，可是有生命週期的細節需要注意。\n\n使用 ngif 新增或刪除某個區塊的 HTML 時，那些區塊可能含有其他的 Component \n* 當 `*ngif = false` 時 Component 會一起被刪除\n* 當 `*ngif = True` 時 Component 被新增回來\n\n也就是說這樣的情況下會影響到 Component 的生命週期，當 Component 被刪除時生命週期也就跟著結束了。\n\n**因此下一次新增回來的 Component 狀態肯定會跟之前的不同，這點需要特別注意**\n\n> 這個 Component 狀態好比 HeaderComponent 內的 counter ，假如目前 `counter = 5` 當元件被刪除又新增後，這個時候的 `counter` 已經被重置了。\n\n## ngSwitch\nngSwitch 也是個結構型指令，假設我們有個需求是這樣：\n* 根據 ngSwitch 去切換前三個 ICON 與後三個 ICON 的內容\n* 切換的條件根據 `counter % 2` 產生的不同的餘數來切換\n\n首先找到 Template 內對應的 HTML 區塊，並進行修改\n```html\n<div id=\"social-icons\" class=\"pull-right social-icon\">\n  <div [ngSwitch]=\"counter % 2\">\n    <div *ngSwitchCase=\"0\">\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/facebook.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/twitter.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/googleplus.png\">\n      </a>\n    </div>\n    <div *ngSwitchCase=\"1\">\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/plurk.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/weibo.png\">\n      </a>\n      <a href=\"https://www.google.com\" title=\"RSS 訂閱\" target=\"_blank\">\n        <img src=\"/assets/images/rss.png\">\n      </a>\n    </div>\n    <div *ngSwitchDefault>N / A</div>\n  </div>\n</div>\n```\n`[ngSwitch]` 後面接的是條件，在這裡我們的條件設定為 `counter % 2` ，而 `*ngSwitchCase` 後面接的是「當遇到 0 或 1 時要顯示哪些東西」，那如果都不符合的話的則顯示 `*ngSwitchDefault` 的結果。\n\n> 存檔測試看看吧！\n\n![](https://i.imgur.com/xYwqq38.png)\n\n![](https://i.imgur.com/f7LyRPF.png)\n\n**成功是成功了，但這時會發現使用 ngSwitch 導致 HTML 結構不一致。**\n\n![](https://i.imgur.com/ERC9ezY.png)\n\n### 使用 ngSwitch 導致 HTML 結構不一致\n這該怎麼修正呢？\n\n> 可以使用 `ng-container` 來取代使用 ngSwitch 時產生的 div 標籤\n\n```html\n<div id=\"social-icons\" class=\"pull-right social-icon\">\n  <ng-container [ngSwitch]=\"counter % 2\">\n    <ng-container *ngSwitchCase=\"0\">\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/facebook.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/twitter.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/googleplus.png\">\n      </a>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"1\">\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/plurk.png\">\n      </a>\n      <a href=\"https://www.google.com\" target=\"_blank\">\n        <img src=\"/assets/images/weibo.png\">\n      </a>\n      <a href=\"https://www.google.com\" title=\"RSS 訂閱\" target=\"_blank\">\n        <img src=\"/assets/images/rss.png\">\n      </a>\n    </ng-container>\n    <ng-container *ngSwitchDefault>N / A</ng-container>\n  </ng-container>\n</div>\n```\n\n> 再次觀察 DOM 結構\n\n![](https://i.imgur.com/QS3vLtz.png)\n\n此時就沒有多餘的 DIV 標籤了。\n\n**從這邊我們知道，當使用結構型指令時可以使用 ng-container 標籤，使其不會產生出額外的 HTML 標籤。**\n\n## ngFor\nngFor 的功能相當強大，使用的時機也相當頻繁。\n\n舉例來說，當我們串接 API 的時候，會取得一份資料。此時可能會透過迴圈的方式顯示在畫面上，這時後就有機會用上 ngFor 。\n\n因為目前網頁的文章是寫死的，接下來要透過 ngFor 動態的把文章的資料呈現在網頁上。\n\n### 處理資料部分\n先整理好要給 ngFor 跑的陣列資料，可以先寫死一份假資料在 app.component.ts 內。\n\n**app.component.ts**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\n/* tslint:disable */\nexport class AppComponent {\n  inputValue = '';\n  atticleData = [\n    {\n      \"id\": 1,\n      \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n      \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n      \"date\": \"2016/04/30 18:05\",\n      \"author\": \"GHJKL\",\n      \"category\": \"Visual Studio\",\n      \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n      \"summary\": \"<p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n    },\n    {\n      \"id\": 2,\n      \"href\": \"http://blog.miniasp.com/post/2016/03/22/Does-Certification-Exam-Useful.aspx\",\n      \"title\": \"考證照真的沒用嗎？一個從業 20 年的 IT 主管告訴你他怎麼看！\",\n      \"date\": \"2016/03/22 19:28\",\n      \"author\": \"GHJKL\",\n      \"category\": \"心得分享\",\n      \"category-link\": \"http://blog.miniasp.com/category/%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB.aspx\",\n      \"summary\": \"<p>其實無論在哪個國家都有推行證照制度，且行之有年，台灣當然也不例外，這件事一開始的立意都是好的，就是希望透過一套公平的考試制度，評估一個人的技術能力是否達到一定程度水準，不但能當成一個人的能力指標，也可以讓大家有個明確目標朝專業之路邁進。其他的行業我不清楚，但就我本身熟悉的 IT 產業來說，不知何年何月開始，大家開始對證照制度嗤之以鼻、不屑一顧，甚至覺得是一個人能力的<strong>負指標</strong> (也就是能力不好的人才需要靠證照證明自己)。你說這現象是何等的詭異？是什麼樣的天時、地利、人和，可以讓一個原本立意良善的制度，變成人人喊打的落水狗，可能連有張證照都還不敢承認的地步。今天，就來談談我的個人見解。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/03/22/Does-Certification-Exam-Useful.aspx#continue'>繼續閱讀</a>...</p>\"\n    },\n    {\n      \"id\": 3,\n      \"href\": \"http://blog.miniasp.com/post/2016/03/14/ASPNET-MVC-Developer-Note-Part-28-Understanding-ModelState.aspx\",\n      \"title\": \"ASP.NET MVC 開發心得分享 (28)：深入瞭解 ModelState 內部細節\",\n      \"date\": \"2016/03/14 12:14\",\n      \"author\": \"GHJKL\",\n      \"category\": \"ASP.NET MVC\",\n      \"category-link\": \"http://blog.miniasp.com/category/ASPNET-MVC.aspx\",\n      \"summary\": \"<p>在 ASP.NET MVC 的 <strong>模型繫結</strong> (Model Binding) 完成之後，我們可以在 Controller / Action 中取得 <span style='font-family: Consolas;'>ModelState</span>                  物件，一般來說我們都會用 <span style='font-family: Consolas;'><strong>ModelState.IsValid</strong></span> 來檢查在「模型繫結」的過程中所做的<strong>輸入驗證</strong> (Input Validation) 與 <strong>模型驗證</strong> (Model Validation) 是否成功。不過，這個 <span style='font-family: Consolas;'>ModelState</span>物件的用途很廣，裡面存有非常多模型繫結過程的狀態資訊，不但在 Controller 中能用，在 View 裡面也能使用，用的好的話，可以讓你的 Controller 更輕、View 也更乾淨，本篇文章將分享幾個 ModelState 的使用技巧。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/03/14/ASPNET-MVC-Developer-Note-Part-28-Understanding-ModelState.aspx#continue'>繼續閱讀</a>...</p>\"\n    }\n  ]\n\n  cleanInput() {\n    this.inputValue = '';\n  }\n}\n```\n在這邊因為 tslint 要求我把所有的雙引號改成單引號，為了開發方便，我先暫時把 tslint 給關閉。\n\n就這樣我們新增了一個 `atticleData` 屬性，裡面是一個陣列，陣列內又有一個個物件，而每一個物件又有相關的屬性。\n\n**接著我們透過 ngFor 這個結構型指令來把這些通通顯示在畫面上吧！**\n\n### 處理 Template 的 HTML 部分\n回過頭來處理 HTML 部分，同樣我們使用 code snippet 幫助撰寫程式碼\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post0\" *ngFor=\"let item of atticleData\">\n  <header class=\"post-header\">\n    <h2 class=\"post-title\">\n      <a [href]=\"item.href\">{{ item.title }}</a>\n    </h2>\n    <div class=\"post-info clearfix\">\n      <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date}}</span>\n      <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n          href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n      <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n          [href]=\"item['category-link']\">{{item.category}}</a></span>\n    </div>\n  </header>\n  <section class=\"post-body text\">\n    {{item.summary}}\n  </section>\n</article>\n<!-- Article END-->\n```\n\n這裡的 `*ngFor` 後面接的語法有點像是 JavaScript 中 ForEach() 的感覺， `item` 代表當前陣列的元素而 `atticleData` 則是要遍歷的目標陣列。\n\n蠻像 Vue 中的 `v-for` 指令的，如果有學習過 Vue 肯定對這個部分不陌生。\n\n> 運行開發伺服器，觀察結果吧！\n\n![](https://i.imgur.com/bJU48Re.png)\n\n![](https://i.imgur.com/TwIZCvw.png)\n\n至此，我們已經成功地透過 ngFor 快速的把資料轉換成網頁的內容，而且程式碼相當的簡潔。\n\n**不過還需要修正最後一個小地方，那就是文章 summary 部分的 HTML 標籤居然直接被輸出了，這該怎麼辦呢？**\n\n### 透過屬性繫結的方式\n先把 HTML 中的 `{{item.summary}}` 這段內嵌繫結刪除，並且套用屬性繫結\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post0\" *ngFor=\"let item of atticleData\">\n  <header class=\"post-header\">\n    <h2 class=\"post-title\">\n      <a [href]=\"item.href\">{{ item.title }}</a>\n    </h2>\n    <div class=\"post-info clearfix\">\n      <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date}}</span>\n      <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n          href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n      <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n          [href]=\"item['category-link']\">{{item.category}}</a></span>\n    </div>\n  </header>\n  <section class=\"post-body text\" [innerHTML]=\"item.summary\">\n  </section>\n</article>\n<!-- Article END-->\n```\n\n**這一段的作法是將屬性繫結在 section 標籤的 DOM 物件內的 innerHTML 屬性上，這麼一來 HTML 的標籤就會直接寫入 innerHTML 這個屬性內。**\n\n![](https://i.imgur.com/mKprMp1.png)\n\n> 如此一來就全部搞定啦～\n\n值得注意的是這個作法是有風險的，因為這些 HTML 可能含有一些惡意的內容，可能會導致 **Cross-Site Script** 的攻擊。\n\n不過 Angular 有幫我們做到一些很基本的防護，例如在資料的部分偷偷的加一些料：\n\n```js\natticleData = [\n  {\n    \"id\": 1,\n    \"href\": \"http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx\",\n    \"title\": \"從命令提示字元中開啟 Visual Studio Code 如何避免顯示惱人的偵錯訊息\",\n    \"date\": \"2016/04/30 18:05\",\n    \"author\": \"GHJKL\",\n    \"category\": \"Visual Studio\",\n    \"category-link\": \"http://blog.miniasp.com/category/Visual-Studio.aspx\",\n    \"summary\": \"<script>alert('XSS!!!')</script><p>由於我的 Visual Studio Code 大部分時候都是在命令提示字元下啟動，所以只要用 <strong><font color='#ff0000' face='Consolas'>code .</font></strong>就可以快速啟動 Visual Studio Code 並自動開啟目前所在資料夾。不過不知道從哪個版本開始，我在啟動 Visual Studio Code 之後，卻開始在原本所在的命令提示字元視窗中出現一堆惱人的偵錯訊息，本篇文章試圖解析這個現象，並提出解決辦法。</p><p>... <a class='more' href='http://blog.miniasp.com/post/2016/04/30/Visual-Studio-Code-from-Command-Prompt-notes.aspx#continue'>繼續閱讀</a>...</p>\"\n  },\n  ...\n]\n```\n**回到網頁上會發現 Angular 自動的把 script 標籤過濾掉了，所以什麼都事情都沒發生，而且還很智慧的顯示這一段提示**\n\n![](https://i.imgur.com/sLhRAtb.png)\n\n> 意思是 Angular 幫我們從 HTML內了清除了一些有害的內容，而後面的連結則是關於 XSS 的資安文件。\n\n### 替 ngFor 加上索引值\n最後我們要替每一篇文章的 id 補上索引值，而 ngFor 裡面提供了一個好用的方法。\n\n```html\n<!-- Article START-->\n<article class=\"post\" id=\"post{{idx}}\" *ngFor=\"let item of atticleData; let idx = index\">\n  <header class=\"post-header\">\n    <h2 class=\"post-title\">\n      <a [href]=\"item.href\">{{ item.title }}</a>\n    </h2>\n    <div class=\"post-info clearfix\">\n      <span class=\"post-date\"><i class=\"glyphicon glyphicon-calendar\"></i>{{item.date}}</span>\n      <span class=\"post-author\"><i class=\"glyphicon glyphicon-user\"></i><a\n          href=\"http://blog.miniasp.com/author/will.aspx\">{{item.author}}</a></span>\n      <span class=\"post-category\"><i class=\"glyphicon glyphicon-folder-close\"></i><a\n          [href]=\"item['category-link']\">{{item.category}}</a></span>\n    </div>\n  </header>\n  <section class=\"post-body text\" [innerHTML]=\"item.summary\">\n  </section>\n</article>\n<!-- Article END-->\n```\n**只有在 ngFor 指令下才可以使用，能自行宣告一個變數 `idx` ，並且賦值為 `index` ，如此一來就能取得目前的索引值。**\n\n這時的文章 id 就會按照索引值增加了。\n\n![](https://i.imgur.com/C9y8wIn.png)\n\n> 當然這邊也可以直接使用屬性繫結把資料內的 id 綁上去即可，只是這邊要介紹索引值的用法。\n\n## 小結\n總算是介紹完 Angular 的三種類型的指令了，有沒有覺得這些指令都似曾相似呢？就我來說的話肯定是有的，而大部分的用法都蠻接近的，只是細節上有不同之處。\n\n希望能早日把 Angular 給掌握起來！","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.20 Angular 屬性型指令 (Attribute Directives)","url":"%2Ff2e%2F20190528%2F1619485620%2F","content":"\n## 前言\n學完元件型指令後，接著介紹第二種 Angular 指令 - 屬性型指令 (Attribute Directives)\n\n![](https://images.unsplash.com/photo-1482066490729-6f26115b60dc?ixlib=rb-1.2.1&auto=format&fit=crop&w=1002&q=80)\n\n## 屬性型指令 (Attribute Directives)\n這種 Directives 有個特性，就是本身不會有自己的 Template ，但是套用這個 Directives 的地方，會修改那一個元素或者是那一個標籤的外觀或者是行為。\n\n在 Angular 內建的屬性型指令內有三種：\n* ngModule - 雙向繫結\n* ngStyle - 動態設置 CSS 的 Style\n* ngClass - 動態設置 CSS 的 className\n\n> 透過第二與第三個 Directives 可以很容易地去修改現有 HTML 的外觀、 CSS 的 Style 、 或動態的套用一些 class 。\n\n## 如何使用 ngStyle\n現在我們替 HeaderComponent 內加入一個新功能，當點擊網站 LOGO 時，計算被點了幾下。\n\n### 前置作業\n* 首先我們在 HeaderComponent 的 `class` 內做調整，加入 `counter` 屬性並補上點擊時 counter++ ：\n\n```js\nexport class HeaderComponent implements OnInit {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  counter = 0;\n  constructor() { }\n\n  ngOnInit() {\n  }\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n    this.counter++;\n  }\n}\n```\n\n* 並且修改 HeaderComponent 的 Template 使用內嵌繫結\n\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3>Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n\n> 搞定！運行開發伺服器確認功能是否正常運作\n\n![](https://i.imgur.com/VvXEOpn.png)\n\n### 動態調整 h3 標籤內的字體大小\n**修改 HeaderComponent 的 Template**\n\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [ngStyle]=\"{'font-size': (12 + counter) + 'px'}\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n\n這邊做了一個 ngStyle 的屬性繫結，但是 ngStyle 並不是 h3 標籤的 Property 也不是 Attribute 。\n\n**ngStyle 本身就是一個 Diretive ，這個 Diretive 可以透過 [] 繫結一個物件，然後這個物件的屬性就是要套用的 CSS 的 Style ，而值就是我們希望套用的值。**\n\n因此再次運行開發伺服器確認功能是否正常運作\n\n![](https://i.imgur.com/ke5GTnN.png)\n\n> 這樣就有隨著點擊次數字體越來越大的感覺了！\n\n### 進階用法\n值得注意的是， ngStyle 後面跟著的是一個物件，這代表其實可以傳入多組 CSS 的 Style ，但是通通寫在 HTML 內會顯得很難看，所以我們也可以這麼處理：\n\n**在 `class` 內撰寫方法並回傳**\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [ngStyle]=\"getStyle()\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n\n```js\nexport class HeaderComponent implements OnInit {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  counter = 0;\n  constructor() { }\n\n  ngOnInit() {\n  }\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n    this.counter++;\n  }\n  getStyle() {\n    return {'font-size': (12 + this.counter) + 'px'};\n  }\n}\n```\n這麼處理的結果會跟剛才的結果一模一樣。\n\n![](https://i.imgur.com/B42rfw4.png)\n\n**或者是直接透過屬性**\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [ngStyle]=\"getStyle\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n```js\nexport class HeaderComponent implements OnInit {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  counter = 0;\n  getStyle = {\n    'font-size': 20 + 'px'\n  };\n  constructor() { }\n\n  ngOnInit() {\n  }\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n    this.counter++;\n  }\n}\n```\n> 這麼做也是沒問題的！\n\n### ngStyle 的簡單用法\nngStyle 還有更簡單的使用方式，像是：\n\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [style.font-size]=\"(12+counter) + 'px'\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n直接在中括號內輸入 `style` 後面接上 `.` 直接加上想要套用的樣式即可，而等號後面則與剛才設定相同。\n\n而如果你想要同時套用多種，可以這麼做：\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [style.font-size]=\"(12+counter) + 'px'\"\n  [style.color]=\"'red'\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n**而這個方法也可以使用 class 內的屬性或方法使其更易讀**\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [style.font-size]=\"fontSize\" [style.color]=\"fontColor\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n\n```js\nexport class HeaderComponent implements OnInit {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  counter = 0;\n  fontSize = 16 + 'px';\n  fontColor = 'red';\n  constructor() { }\n\n  ngOnInit() {\n  }\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n    this.counter++;\n  }\n}\n```\n執行結果如下\n\n![](https://i.imgur.com/Mx54siL.png)\n\n**這些方式可以選擇一種使用即可，看哪個順手就用哪個吧。**\n\n## 如何使用 ngClass\n如果已經知道如何使用 ngStyle ，那麼 ngClass 肯定難不倒我們，兩者的用法幾乎是一樣的。\n\n我們將剛才設定過 ngStyle 的地方全部刪除，並且加上 ngClass ：\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [ngClass]=\"{cssClass: expression}\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n可以看到整體結構上基本同於 ngStyle ，等號後方一樣是接收一個物件，因此**剛才介紹的簡化方法 (寫在 class 的屬性、方法內) 同樣適用於 ngClass 。**\n\n**於是可以修改成這樣**\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [ngClass]=\"{'highlight': counter % 2 == 0}\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n**物件屬性就是要設定的 className ， 而不同於 ngStyle 的是，這個地方的值要輸入布林值。**\n\n* 當值為 True 時套用這個 className ，反之則不套用\n\n> 接著新增 highlight 這個 className 吧\n\nheader.component.scss\n```css\n.highlight{\n  background-color: red;\n}\n```\n> 搞定，接著測試看看吧！\n\n![當 counter 除以 2 餘數等於 0 時套用 highlight](https://i.imgur.com/yLyoVkn.png)\n\n![當 counter 除以 2 餘數不等於 0 時不套用 highlight](https://i.imgur.com/Aglsviq.png)\n\n### ngClass 的簡單用法\n聰明如你，想必已經猜到了如何使用，不囉嗦直接看範例！\n\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\" id=\"title\">{{title}}</a></h1>\n  <h3 [class.highlight]=\"counter % 2 == 0\">Lorem ipsum dolor sit amet. {{counter}}</h3>\n</div>\n```\n**等號後方直接給布林值就可以了，這樣是不是更簡單了呢？**\n\n> 也就是說等號後方可以直接寫一個布林值、或者透過 class 內的屬性、方法回傳布林值，這些都是合法的。只要是 `True` 就套用這個 className ，反之則不套用。\n\n## 小結\n終於介紹完屬性型指令了，整理這些東西的時候不禁讓我回想起 Vue 裡面的 `:class` 、 `:style` 這些東西，而新學會的這些東西也是相當的好記，語法本身也是蠻簡單的。\n\n接下來就是 Angular 的第三種指令 - 結構型指令囉！ ","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.19 Angular 元件型指令 (Componemt Directives)","url":"%2Ff2e%2F20190528%2F2420780077%2F","content":"\n## 前言\n接下來要介紹三種不同的 Angular 指令，而這裡的指令就是之前一直提到的 Directives 。 Angular 指令有元件型、屬性型、結構型這三種指令，接下來會一一介紹當中差異。\n\n![](https://images.unsplash.com/photo-1466618786657-4df462be674e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 三種 Angular 指令 ( Directives )\n* 元件型指令\n  * 預設的元件就是一個含有樣板的指令\n* 屬性型指令\n  * 這種指令會修改元素的外觀或行為\n  * 如 ngStyle 、 ngClass 指令可以自由的調整樣式\n* 結構型指令\n  * 這種指令會透過新增或者刪除 DOM 元素改變 DOM 結構\n  * 例如 ngIf 、 ngFor 、 ngSwitch 就可以控制 DOM 結構\n    * 特別注意 ngSwitch 前面不要加上星號\n    * ngIf 、 ngFor 、 ngSwitchDefault 、 ngSwitchCase 前面要加上 * 號\n\n## 元件型指令\n之前建立的 HeaderComponent 就是屬於元件型指令，它是 Component 同時也是 Directives 。\n\n接下來再次新建一個 Component 練習吧，輸入 `ng g c footer` ，這次我們建立 FooterComponent 。\n* 同先前建立 HeaderComponent 步驟，在此不贅述，把程式碼搬運到對應檔案即可\n\n最後別忘了在 AppComponent 內輸入 FooterComponent 的元件型指令，也就是\n```html\n<app-footer></app-footer>\n```\n\n> 接著測試看看是否正常運行\n\n![](https://i.imgur.com/I91XvML.png)\n\n## 觀察 footer.component.ts\n觀察 FooterComponent 的 `class` ，可以發現只要這是一個 Conponent ，那麼就一定會有一個 裝飾器 ( decorater ) 宣告在上方，如：\n\n**FooterComponent**\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-footer',\n  templateUrl: './footer.component.html',\n  styleUrls: ['./footer.component.scss']\n})\nexport class FooterComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n### 裝飾器 ( decorater )\n* 裝飾器的語法為 `@` 開頭，後面接一個 decorater 的名稱。\n  * 所有的 Conponent 都會有一個名為 Conponent 的 decorater\n* 然後傳入一個物件，這個物件用來描述 Conponent 有哪些特性，如\n  * `selector` 選取器\n  * `templateUrl` - 指出 template 路徑在哪裡，如果不輸入路徑也可以使用 `template` 屬性，直接輸入該 template 內容即可\n  * `styleUrl` - 與 `templateUrl` 不同，後面接的是一個陣列的型態，意思也就是可以輸入多個不同的 CSS 檔\n\n#### template 的例子，如果不想把 template 獨立成一個檔案，可以這麼寫\n![擷取畫面片段](https://i.imgur.com/MZkt7zW.png)\n\n可以發現這麼做之後，網頁的 footer 仍然是正常的。\n![](https://i.imgur.com/D6TCONp.png)\n\n> 不過還是建議獨立成一個檔案比較好，畢竟這樣子實在是不容易閱讀。\n\n**事實上裝飾器內可以使用的屬性還有非常多，用到時再查文件就可以了。**\n\n#### styleUrl 的例子，來寫一點 CSS\n這個檔案是由 Angular CLI 自動幫我們產生的，因此預設是空白的，讓我們隨意寫一點樣式吧。\n\n* 把 footer 底下的 copyright 字樣改成黃色\n```html\n<p class=\"text-muted credit\">\n  Copyright © 2016 by <a href=\"https://www.facebook.com/will.fans\" target=\"_blank\">XCVGYU</a>\n  @ <a href=\"http://www.miniasp.com/\" target=\"_blank\">XCVGYUXCVGYU</a> -\n  Powered by <a href=\"http://dotnetblogengine.net/\" target=\"_blank\">BlogEngine.NET</a> 3.2.0.3 -\n  Design by <a href=\"http://seyfolahi.net/\" target=\"_blank\"\n    title=\"Farzin Seyfolahi - UI/UX Designer at BlogEngine.NET\">FS</a>\n</p>\n```\n\n調整 `credit` ，這邊為了方便示範所以直接使用 `!important` 強制覆蓋。\n```CSS\n.credit{\n  color: yellow !important;\n}\n```\n\n接著執行開發伺服器查看效果：\n![](https://i.imgur.com/KAhwMgt.png)\n\n## 元件內的 CSS 不會影響到其他元件？\n\n之前有提到，在這裡設定的 CSS 只會套用到該元件，不會影響到其他元件，超出 FooterComponent 範圍外的通通不會吃到這裡設定的 CSS 樣式。\n\n這可以透過開發者工具觀察 Angular 是如何辦到的！\n\n![](https://i.imgur.com/acBHG8e.png)\n\nAngular 在這些動態產生的 diretive 下所有的標籤全都被加上了一個底線開頭的 attribute 屬性，而且有一定的規律可循。\n\n**像是根元件上的 `_nghost-tij-c0` ， 0 是個編號，只要遇到不重複的 Component 就會有一個唯一的、不重複的編號。**\n\n> .credit 類別被動態注入到頁面上時，它的選取器並不是單純的 .credit ，而是 .credit 後面加上中括號包覆 attribute 的選取器。\n\n而這個 attribute 剛才說過是個**唯一**的值，這也是為什麼寫在元件內的 CSS 不會影響到其他元件的原因。\n\n![](https://i.imgur.com/XEsLNeF.png)\n\n## 讓元件內的 CSS 會影響到其他元件\n可以在裝飾器內新增一個屬性 `encapsulation` ，要把這部分的封裝調整成 `none` ，具體設定如下：\n```js\n@Component({\n  selector: 'app-footer',\n  templateUrl: './footer.component.html',\n  styleUrls: ['./footer.component.scss'],\n  encapsulation: ViewEncapsulation.\n})\n```\n![](https://i.imgur.com/pt2v0H9.png)\n\n* 預設是 `Emulated` ，也就是模擬的意思，就是指 CSS Style 的封裝，\n  * 在此要把它改成 `none` ，意思是不需要進行 CSS Style 的封裝。\n\n**如此一來，這個 .credit 就會渲染到整個網頁了。**\n\n![Image](https://i.imgur.com/bDBRwp7.png)\n\n> 設定後，現在當 .credit 類別被動態注入到頁面上時，它的選取器已經是單純的 .credit 了，也就是說這個網頁所有用到 .credit 這個 class 都會吃到字體顏色變成黃色的設定。\n\n\n**以上就是元件型指令在使用上可能會用到的一些設定與注意事項，接下來要介紹的是屬性型指令。**","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.18 認識範本參考變數","url":"%2Ff2e%2F20190528%2F591780736%2F","content":"\n## 前言\n結束資料繫結的學習後，接著介紹關於範本參考變數 ( Template Reference Variables ) ，讓我們一起看看吧！\n\n![](https://images.unsplash.com/photo-1494256997604-768d1f608cac?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1101&q=80)\n\n## 範本參考變數 ( Template reference variables )\n從字面上來解讀，這是一種可以用在 Template 上的一種設定變數的方式。\n\n* 它的語法就是在任意的標籤裡面使用一個 # 字號加上一個變數名稱，如 `#name` 。\n  * 會在這個 Template 中建立一個名為 name 的區域變數\n  * 該變數僅存在於目前這個元件 Template 中\n  * 而這個區域變數會儲存這個標籤的 DOM 物件\n  * 可以透過**事件繫結**將任意 DOM 物件傳回元件類別中 ( Component Class )\n\n* 以下語法完全相等，差別在於使用 # 字號是語法糖\n  * `#name`\n  * `ref-name`\n\n## 實際宣告範本參考變數\n我們將修改上次那份計算輸入字數的 Template ，觀察當中的差異。\n\n> 需要特別注意的是，替範本參考變數取名時，盡量不要與之前設定過的屬性 ( Property ) 重複名稱，否則可能會有一些問題產生。\n\n**Template**\n```html\n<div class=\"widget-content\">\n  <div id=\"searchbox\">\n    <input type=\"text\" placeholder=\"請輸入搜尋關鍵字\" accesskey=\"s\"\n      #tinputValue\n      [(ngModel)]=\"inputValue\"\n      (keydown.escape)=\"cleanInput()\">\n    <input type=\"button\" value=\"搜尋\" id=\"searchbutton\">\n  </div>\n  輸入文字：{{inputValue}} 目前字數 <span>{{tinputValue.value.length}}</span>\n</div>\n```\n\n**於是在普通的 input 上設定一組範本參考變數 `#tinputValue` ，此時 `#tinputValue` 的值會是這個 input 的 DOM 物件。**\n\n因此可以直接操作 DOM 物件，取得當中的 `value` 屬性並且計算其長度，而這個部分就是所謂的範本參考變數。\n\n而且可在任何標籤上，設定唯一的範本參考變數，只要名稱不同即可。\n\n## 建立一個新元件 HeaderComponent\n範本參考變數除了使用在一般的 HTML 標籤上，也可以使用在 Directive ，具體來說怎麼做呢？\n\n* 建立一個新的 Component\n  * 輸入 `ng g c header` 建立新的 Component ，並且取名叫 header\n* 將網頁中 header 區塊移入這個 Component ，並將新的 Component 加到 AppComponent 的 template 內\n* 因為 HeaderComponent 內有使用到一些屬性，因此還需要調整 `class` 內的程式碼\n  * 到 app.component.ts 內把有用到的屬性都搬到 header.component.ts\n\n**調整完畢後 header.component.ts 內容如下**\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-header',\n  templateUrl: './header.component.html',\n  styleUrls: ['./header.component.scss']\n})\nexport class HeaderComponent implements OnInit {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n  }\n}\n```\n\n接著運行開發伺服器，確認 HeaderComponent 是否正確執行。\n\n![](https://i.imgur.com/FFXIzam.png)\n\n> 看來是設定成功了，接著我們要在這個 Directive 上使用範本參考變數。\n\n### 在 Directive 上使用範本參考變數\n首先一樣在 `<app-header #tHeader></app-header>` 上加入 `#tHeader` ，意思是建立一個範本參考變數。\n\n接著我們隨意找一個 HTML 標籤上加入事件繫結，如：\n```html\n<section class=\"container\" (click)=\"tHeader.\">\n```\n這時會發現 VS Code 會跳出 HeaderComponent 內所有的屬性給我們選取。\n\n![](https://i.imgur.com/HxNDtCn.png)\n\n![HeaderComponent 內所有的屬性](https://i.imgur.com/HpTtvaJ.png)\n\n之前說如果把範本參考變數使用在普通的 HTML 標籤上，則代表的值是該標籤的 DOM 物件。\n\n**而如果把範本參考變數使用在 directive 上，則代表的值就是背後所對應的 Component ，在這個範例內也就是 HeaderComponent 。**\n\n因此可以存取這個 Component 底下所有的屬性，如：\n\n```html\n<section class=\"container\" (click)=\"tHeader.title='Title Change'\">\n```\n接著運行開發伺服器，並且任意的點一下，觀察標題是否改變。\n\n![](https://i.imgur.com/DVAoHNV.png)\n\n## 小結\n以上就是範本參考變數在 Directive 上的應用，值得一提的是**範本參考變數只能在範本( Template ) 內使用，在 Component 內預設是沒辦法使用的**。不過還是有一些進階的技巧可以幫助我們在 Component 中取用範本參考變數，但眼下還是先學習其他基礎的部分吧，進階技巧等之後碰到再來談。\n\ndirective 看了很多次但卻不太清楚是什麼意思，接下來要好好針對這個名詞做了解囉。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.17 資料繫結的四種方法 - 雙向繫結","url":"%2Ff2e%2F20190527%2F2547380556%2F","content":"\n## 前言\n終於來到資料繫結的第四種方法 - 雙向繫結 ( Two-way Binding ) 了，而這種繫結方式跟其他三種有何不同呢？\n\n![](https://images.unsplash.com/photo-1509092909911-0dbb345f4de9?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1004&q=80)\n\n## 雙向繫結 ( Two-way Binding )\n到目前為止介紹了三種資料繫結的方法，分別是內嵌繫結、屬性繫結、事件繫結，這三種的前兩種都是屬於從 Component 單向將資料傳送到 Template 的繫結方式。而事件繫結也算是單向的繫結方式，這是從 Template 內透過瀏覽器的事件觸發之後呼叫 Component 內的方法。\n\n而我們這次要介紹的繫結方式就是雙向的繫結方式，這種繫結方式會自動的做到屬性繫結與事件繫結，也因此我們寫的程式碼會更少、更精簡。\n\n### 拿上一篇的練習改寫，使其具有雙向繫結效果\n我們將之前的練習改寫，見識見識雙向繫結的威力。\n\n**template**\n```html\n<div class=\"widget-content\">\n  <div id=\"searchbox\">\n    <input type=\"text\" placeholder=\"請輸入搜尋關鍵字\" accesskey=\"s\"\n      [(ngModel)]=\"inputValue\"\n      (input)=\"calcLength($event.target.value)\"\n      (keydown.escape)=\"cleanInput($event.target)\">\n    <input type=\"button\" value=\"搜尋\" id=\"searchbutton\">\n  </div>\n  目前字數 <span>{{inputStrLen}}</span>\n</div>\n```\n\n> 要使用雙向繫結的話辦法相當簡單，使用 `[(ngModel)]` 語法後面接一個想要雙向繫結並且在 component 內的屬性即可。\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  inputValue = '';\n  inputStrLen = 0;\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n  }\n  calcLength(str: string) {\n    this.inputStrLen = str.length;\n  }\n  cleanInput(inputEl: HTMLInputElement) {\n    this.inputStrLen = 0;\n    inputEl.value = '';\n  }\n}\n```\n\n> 當運行開發伺服器後會發現， Angular 又掛掉了。\n\n![](https://i.imgur.com/wWIBDi1.png)\n\n**意思就是 Angular 看不懂 ngModel 這個屬性是什麼。**\n\n也就是說如果我們想要使用雙向繫結，還有一個步驟要做，那就是把 Angular 表單的模組匯入到 AppModule 內。\n\n**於是打開 AppModule 這支檔案進行修改**\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n> 修改完成後，再次運行開發伺服器，發現可以成功運行網頁了，但我們還需要調整程式碼的部分。\n\n可以透過內嵌繫結，測試一下剛才設置的雙向繫結 `inputValue` 有沒有成功\n\n**template**\n```html\n<div class=\"widget-content\">\n  <div id=\"searchbox\">\n    <input type=\"text\" placeholder=\"請輸入搜尋關鍵字\" accesskey=\"s\"\n      [(ngModel)]=\"inputValue\"\n      (input)=\"calcLength($event.target.value)\"\n      (keydown.escape)=\"cleanInput($event.target)\">\n    <input type=\"button\" value=\"搜尋\" id=\"searchbutton\">\n  </div>\n  輸入文字：{{inputValue}} 目前字數 <span>{{inputStrLen}}</span>\n</div>\n```\n\n![](https://i.imgur.com/ezQ1Zwd.png)\n\n**藉由這個測試知道，目前這個 input 的輸入框跟 component 內的 `inputValue` 已經建立了雙向繫結。**\n\n## 完成這個練習\n我們已經成功地建立了雙向繫結，接著把其他地方的程式碼也修改一下吧。\n\n**template**\n```html\n<div class=\"widget-content\">\n  <div id=\"searchbox\">\n    <input type=\"text\" placeholder=\"請輸入搜尋關鍵字\" accesskey=\"s\"\n      [(ngModel)]=\"inputValue\"\n      (keydown.escape)=\"cleanInput()\">\n    <input type=\"button\" value=\"搜尋\" id=\"searchbutton\">\n  </div>\n  輸入文字：{{inputValue}} 目前字數 <span>{{inputValue.length}}</span>\n</div>\n```\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  inputValue = '';\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n  }\n  cleanInput() {\n    this.inputValue = '';\n  }\n}\n```\n\n> 搞定！最後運行開發伺服器，測試功能是否仍然正常。\n\n![](https://i.imgur.com/KxfP696.png)\n\n## 雙向繫結不是萬靈丹\n雙向繫結既然這麼好用，我們是不是應該不管怎麼樣都使用雙向繫結呢？\n\n事實上，過度濫用雙向繫結也會給網頁效能造成一些負擔，可能導致網頁的反應會變慢，但具體來說還是得看實際狀況而定就是了。\n\n## 小結\n到這裡我們已經學會了 Angular 內四種資料繫結的方式了，接下來要介紹的是範本參考變數。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.16 實作練習","url":"%2Ff2e%2F20190527%2F1236863731%2F","content":"\n## 前言\n學習完三種資料繫結方法後，雖然還有一種尚未提到，但是我們已經可以嘗試寫一點有趣的東西了，因此弄了 2 題小問題來測試自己有沒有完全吸收。\n\n![](https://images.unsplash.com/photo-1522793626404-2103bc5bbf7d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 題目需求\n![](https://i.imgur.com/P38xdP9.png)\n如圖所示，希望實作出兩個小功能\n* 能自動計算輸入的字數\n* 按下 ESC 鍵時能清空輸入\n\n## 實作過程\n沒有遇到太多的困難，主要是查詢有什麼事件可以使用。\n\n* 輸入這部分我使用了 [oninput 事件](http://www.runoob.com/jsref/event-oninput.html)\n* 然而要求按下 ESC 鍵時能清空輸入，這部分則是使用 [onkeydown 事件](http://www.runoob.com/jsref/event-onkeydown.html)\n  * 而這部分一開始我沒想到原來有類似 Vue 的事件修飾符可以使用，所以是使用 if 判斷，後來才改用事件修飾符\n* 在目前字數那一區塊使用內嵌繫結來計算字數\n\n**因此調整後的 template 如下：**\n```html\n<div class=\"widget-content\">\n  <div id=\"searchbox\">\n    <input type=\"text\" placeholder=\"請輸入搜尋關鍵字\" accesskey=\"s\" \n      (input)=\"calcLength($event.target.value)\" \n      (keydown.escape)=\"cleanInput($event.target)\">\n    <input type=\"button\" value=\"搜尋\" id=\"searchbutton\">\n  </div>\n  目前字數 <span>{{inputStrLen}}</span>\n</div>\n``` \n**接著來到 component 補上適當的程式碼**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  inputStrLen = 0;\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n  }\n  calcLength(str: string) {\n    this.inputStrLen = str.length;\n  }\n  cleanInput(inputEl: HTMLInputElement) {\n    this.inputStrLen = 0;\n    inputEl.value = '';\n  }\n}\n```\n\n> 程式碼的部分，卡最久的地方卻是「不知道怎麼定義型別符合 TypeScript 的規則又能清除 input」。\n\n因為我以為 `$event.target` 要填的是 `KeyboardEvent` ，因為我使用的是 onkeydown 事件，後來發現不是這麼一回事。而是要根據傳入參數的型別來寫，折騰了好一陣才知道要寫 `HTMLInputElement` 。\n\n其實可以不要定義型別就沒有這些問題。但我想既然都要寫 TypeScript 了，就還是好好的學習如何正確撰寫 TypeScript ，才是正道。\n\n## 成果截圖\n\n![成功計算字數](https://i.imgur.com/t8jRsYy.png)\n\n![按下 ESC 清空](https://i.imgur.com/GYpoN3u.png)\n\n[成果範例 GitHub](https://github.com/pvt5r486/firstAngular)\n\n## 小結\n嗯，看起來是沒有什麼大問題，只是還不太熟 TypeScript 以及 Angular 的語法。\n\n接下來要講到最後一種繫結方式囉！","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.15 資料繫結的四種方法 - 事件繫結","url":"%2Ff2e%2F20190527%2F2149510389%2F","content":"\n## 前言\n在 Angular 內，第三種資料繫結的方法是事件繫結 ( Event Binding )，具體來說怎麼實踐，讓我們繼續看下去。\n\n![](https://images.unsplash.com/photo-1473849353781-2533844cec8d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80)\n\n## 事件繫結 ( Event Binding )\n這是我們目前網頁上的一張 Q 版的 chrome LOGO ，假設我們要在這張圖片加上 Click 點擊事件，點下去之後網站標題會跟著改變。\n\n![](https://i.imgur.com/TyNJYHP.png)\n\n### 事件繫結語法 (一) \n在事件中間加上 「-」，代表這是 Angular 的語法，並且在雙引號內放入 function ，但是在 **Angular 內並沒有 function 只有類別**，而**類別內只有屬性以及方法**。\n\n**template**\n```html\n<img on-click=\"changeTitle()\" [title]=\"title\" [src]=\"imgUrl\" [attr.data-title]=\"title\" class=\"pull-left logo\">\n```\n讓我們宣告一個方法叫做 `changeTitle` 。\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  changeTitle() {\n    this.title = 'changeTitle';\n  }\n}\n```\n\n### 事件繫結語法 (二) \n除了上述的作法外，也可以使用這種方式添加事件繫結。\n\n**template**\n```html\n<img (click)=\"changeTitle()\" [title]=\"title\" [src]=\"imgUrl\" [attr.data-title]=\"title\" class=\"pull-left logo\">\n```\n\n這樣的方式跟上一篇提到的屬性繫結是不是有點相似呢？\n\n**差別在於屬性繫結是使用中括號 [] 表示，而事件繫結是使用小括號 () 表示。** \n\n而大部分的 Angular 開發者都是使用第二種方法來進行事件綁定，較少使用第一種方法。\n\n\n### 接著運行開發伺服器，測試看看結果。\n![點擊 LOGO 後](https://i.imgur.com/5shPMfI.png)\n\n標題的確被更新了，但這是怎麼辦到的呢？\n\n### 事件繫結的背後\n我們在 LOGO 上執行了 Click 動作，然後註冊 Angular 的事件繫結，而這個事件繫結到了 `changeTitle` 方法，因此當有人點了 LOGO 時，就會跳到 AppComponent 內去執行 `changeTitle` 方法。\n\n而這個方法會藉由執行 `this.title = 'changeTitle';` 來變更 class 內的 `title` 屬性，又因為先前我們對網站標題使用了內嵌繫結，所以當 class 內的 `title` 屬性有異動時， Angular 就會管理頁面 DOM 的狀態，也就是所有頁面中有繫結 `title` 屬性的地方一起改變。\n\n## 事件繫結 - 使用 $event 參數\n當撰寫事件繫結時必須要傳入一個方法，預設可以不用傳入任何參數，但是在這裡確實可以傳入一個很特別的參數 `$event` ，讓我們觀察看看。\n\n**這個 `$event` 可以幫助我們取得事件的詳細資訊**\n\n**template**\n```html\n<img (click)=\"changeTitle($event)\" [title]=\"title\" [src]=\"imgUrl\" [attr.data-title]=\"title\" class=\"pull-left logo\">\n```\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  changeTitle($event) {\n    this.title = 'changeTitle';\n    console.log($event);\n  }\n}\n```\n接著運行開發伺服器，按下 F12 開啟開發者工具並點擊 LOGO 圖案。\n\n![](https://i.imgur.com/bIwuT8k.png)\n\n> 可以看到跑出了很多東西，而這個 MouseEvent 其實就是 DOM 的 MouseEvent ，因此這一次觸發的滑鼠事件內可以找到相當多的屬性。\n\n### $event 參數內 - target\n`target` 屬性代表的是剛剛點下去的那個 DOM 物件，例如說剛剛我們是點擊 img 觸發的，也就是說它的 `target` 屬性會是：\n\n![img 標籤的 DOM](https://i.imgur.com/xWBHVGL.png)\n\n### $event 參數內 - altkey\n`altkey` 屬性代表的是點擊時有沒有按下 「alt」 這個按鍵，因此我們可以替剛剛那個範例加上一個新的需求，必須要按下 「alt」 這個按鍵才可以更改標題。\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  changeTitle($event) {\n    if ($event.altKey) {\n      this.title = 'changeTitle';\n    }\n    console.log($event);\n  }\n}\n```\n我在這邊踩到了一的雷，那就是 altKey 的 K 是大寫，因此這部分要特別注意英文的大小寫部分。\n\n> 搞定！運行開發伺服器測試看看\n\n![](https://i.imgur.com/vz5vUD6.png)\n\n**但是這個部分可以有更好的寫法，那就是使用具有型別的 $event 參數**\n\n## 事件繫結 - 使用具有型別 $event 參數\n在上一個範例裡，因為英文的大小寫導致程式沒有按我們預期的跑，但我們現在是使用 TypeScript 進行開發，所以我們可以利用 TypeScript 帶來的好處，利用型別來標註參數的型別，具體來說我們可以這麼做:\n\n* 由剛才範例可知 `$event` 的內容其實是 MouseEvent\n  * 也就是說傳入方法的參數其實是 MouseEvent 的型別\n\n因此可以在 **Component** 內這麼寫：\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  changeTitle($event: MouseEvent) {\n    if ($event.altKey) {\n      this.title = 'changeTitle';\n    }\n    console.log($event);\n  }\n}\n```\n接著神奇的事情發生了，當我們輸入 `$event` 並按下 `.` 時，VS Code 會列出所有 MouseEvent 內所有可以選擇的屬性。\n\n![](https://i.imgur.com/KcPe3tN.png)\n\n### 巧妙的利用型別重構\n我們知道可以在事件繫結中傳入 `$event` 參數，但其實這個部分可以更進一步的改寫，並且結合剛才的提到的型別，例如：\n\n**template**\n```html\n<img (click)=\"changeTitle($event.altKey)\" [title]=\"title\" [src]=\"imgUrl\" [attr.data-title]=\"title\" class=\"pull-left logo\">\n```\n> 可以直接在這個地方就傳入 `$event.altKey` 。\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n  changeTitle(altKey: boolean) {\n    if (altKey) {\n      this.title = 'changeTitle';\n    }\n  }\n}\n```\n然而因為 `$event.altKey` 的值是 true 或 false ，因此型別是布林。\n\n接著可以再次確認運作是否正常。\n\n![](https://i.imgur.com/9MUzB9n.png)\n\n## 小結\n在事件繫結中，有些同樣的事情會有不同的方法可以實作，至於要用哪種方式撰寫就見仁見智了。對我來說，怎麼樣的寫法是易懂又容易維護的，那就是值得學習的好方法。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.14 資料繫結的四種方法 - 屬性繫結","url":"%2Ff2e%2F20190527%2F2295068610%2F","content":"\n## 前言\n學習完內嵌繫結後，接著介紹到 Angular 第二種資料繫結方式 屬性繫結 ( Property Binding )。話不多說讓我們馬上開始吧！\n\n![](https://images.unsplash.com/photo-1518467166778-b88f373ffec7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1489&q=80)\n\n## 屬性繫結 ( Property Binding )\n> 值得注意的是屬性繫結 ( Property Binding ) 的屬性英文單字是 Property ，而 Attribute 的中文翻譯也叫做屬性。因此很有可能跟上一篇介紹到的內嵌繫結也可以應用在 HTML 標籤的屬性 ( Attribute ) 上搞混。\n\n**實際看個例子，這次我們不使用內嵌繫結來改變 `a` 標籤上的 `href` 屬性：**\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n}\n```\n**template**\n```html\n<div class=\"pull-left\">\n  <h1><a [href]=\"link\">{{title}}</a></h1>\n  <h3>Lorem ipsum dolor sit amet.</h3>\n</div>\n```\n\n打開開發伺服器，觀察 `a` 標籤上的 `href` 屬性，發現跟內嵌繫結是一模一樣的。\n\n![](https://i.imgur.com/TosD0M6.png)\n\n\n**同理，也可以對 img 圖片做屬性繫結：**\n\n**component**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n  imgUrl = '/assets/images/logo.png';\n}\n```\n**template**\n```html\n<img [title]=\"title\" [src]=\"imgUrl\" class=\"pull-left logo\">\n```\n![](https://i.imgur.com/oUPUBst.png)\n\n## Property 與 Attribute 的差異\n接下來透過一些範例，釐清 Property 與 Attribute 的差異。\n\n\n### Attribute\n一般而言，要擴充 HTML 標籤上的 Attribute 會使用 `data-*` 自由的擴充 HTML 標籤上的 Attribute ，例如：\n\n**template**\n```html\n<img [title]=\"title\" [src]=\"imgUrl\"　data-title=\"\" class=\"pull-left logo\">\n```\n接著我們可以實驗看看自訂的 HTML Attribute 可不可以使用屬性繫結。\n\n**template**\n```html\n<img [title]=\"title\" [src]=\"imgUrl\"　[data-title]=\"title\" class=\"pull-left logo\">\n```\n\n運行開發伺服器，可以發現錯誤訊息\n\n![](https://i.imgur.com/j9Xjjes.png)\n\n> 這段訊息大意上是說，綁定 Property 的時候， Angular 發現 `img` 底下並沒有 `data-title` 這個 Property ，因為 `data-title` 是我們自訂的 Attribute ，因此不能任意的使用屬性繫結，儘管它們中文翻譯都是**屬性**。\n\n### Property\n運行開發伺服器，並且使用開發工具觀察 `img` 標籤，可以看到非常多的 attribute。\n\n![Image](https://i.imgur.com/JMcDMw0.png)\n\n這個標籤裡面 `class` 、 `title` 、 `src` 都是 Attribute\n\n然而什麼是 Property 呢？\n\n> 如果想知道 `img` 標籤的 Property ，可以查詢 `img` 的 DOM 物件所有的 Property 。\n\n**透過開發者工具查詢**\n可以點選 Properties 頁籤，切換過去後就可以看到 `img` 標籤下所有的 Property 了。\n\n![](https://i.imgur.com/jXdpnzC.png)\n\n而在這裡面可以發現如 `class` 、 `title` 、 `src` 的 Property 。\n\n### 什麼叫做 屬性繫結 ( Property Binding )\n**屬性繫結 ( Property Binding ) 真正的對象，其實是 HTML 標籤下 DOM 的 Property ，而不是指 HTML 標籤上的 Attribute 。**\n\n> 套用在剛才的範例上就是 `img` 標籤，這一個 DOM 的 Property。\n\n### 透過標準的作法讓剛才自訂的 Attribute 也能使用屬性繫結\n其實方法也不困難，只需要在前面補上 `attr.` ，如：\n\n**template**\n```html\n<img [title]=\"title\" [src]=\"imgUrl\"　[attr.data-title]=\"title\" class=\"pull-left logo\">\n```\n這樣子就可以成功設定 data Attribute 的自動綁定。\n\n這時我們可以再次回到網頁上觀察情況。\n\n![](https://i.imgur.com/HstJv91.png)\n\n可以發現 data-title 這個 Attribute 被綁定，而且也可以使用屬性繫結方法了。\n\n## 小結\n屬性繫結的用法也是蠻直觀的，沒有太多困難的語法要記憶，只是要搞清楚 Attribute 與 Property 的差異，而就算忘記了也沒關係，畢竟開發者工具是這麼的好用，只要到 Properties 頁籤上就可以看到這一個 DOM 所有的 Property 了。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.13 資料繫結的四種方法 - 內嵌繫結","url":"%2Ff2e%2F20190527%2F123375935%2F","content":"\n## 前言\n接著介紹 Angular 中是如何進行資料繫結的，以及 Angular 內共有幾種資料繫結的方式呢？\n\n![](https://images.unsplash.com/photo-1556227834-c4b0b0f7d533?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1041&q=80)\n\n## 何謂資料繫結\n在 Angular 內總共有四種資料繫結的方法，分別是\n\n* 內嵌繫結 ( interpolation )\n  * {% raw %}{{property}}{% endraw %}\n* 屬性繫結 ( Property Binding )\n  * [property] = 'statemant'\n* 事件繫結 ( Event Binding )\n  * (event) = 'someMethod($event)'\n* 雙向繫結 ( Two-way Binding )\n  * [(ngModel)] = 'property'\n\n**接下來我們將分成好幾篇逐步介紹這些繫結的方法。**\n\n## 內嵌繫結 ( interpolation )\n之前把靜態網頁版型加到 Angular 專案內以 Component 方式管理後就沒有再動過了，這回我們從 `app.component.ts` 這裡開始。\n\n**`app.component.ts` 內容**\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n}\n```\n\n可以看到這個元件裡面除了一些必要的程式碼之外，沒有其他的東西了，相當的單純。而 `class` 裡面有一個 `title` 的屬性，這是一開始我們建立專案時 Angular CLI 自動幫我們添加的。\n\n接著來到 `app.component.html` ，可將 `<h1>` 標籤處使用內嵌繫結 ( interpolation ) 的語法，替換成 `class` 內的 `title` 的屬性。\n```html\n<div class=\"pull-left\">\n  <h1><a href=\"http://blog.miniasp.com/\">{{title}}</a></h1>\n  <h3>Lorem ipsum dolor sit amet.</h3>\n</div>\n```\n\n打開 Angular 開發伺服器，可以觀察到 `<h1>` 標籤內容的確是 `title` 的屬性值。\n\n![](https://i.imgur.com/6PDNO3P.png)\n\n內嵌繫結是屬於單向的繫結，也就是說**畫面上呈現的 `title` 資料，只會從 Component 內把值傳送給 template 顯示。**\n\n## 把內嵌繫結用於屬性上\n**內嵌繫結的語法除了放在標籤內，也可以使用在 HTML 標籤的屬性上。**\n\n舉個例子，我們在 `app.component.ts` 內的屬性上新增一個 `link` 屬性：\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n  link = 'http://www.google.com';\n}\n```\n\n接著回到 `app.component.html` 將某一段 `a` 標籤的 `href` 內容給替換掉：\n```html\n<div class=\"pull-left\">\n  <h1><a href=\"{{link}}\">{{title}}</a></h1>\n  <h3>Lorem ipsum dolor sit amet.</h3>\n</div>\n```\n\n打開 Angular 開發伺服器，發現 `a` 標籤的 `href` 內容的確被替換了\n\n![](https://i.imgur.com/fYSK8KA.png)\n\n## 小結\n{% raw %}\n這個單元讓我感到相當熟悉尤其是 {{}} 符號， Vue 裡面也有類似的用法。所以這一部分學習起來特別容易理解。\n{% endraw %}\n\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"擔任六角遠端助教的那一段日子","url":"%2Fnote%2F20190524%2F3138494786%2F","content":"\n## 前言\n不知不覺的快到五月的尾聲了，因受到洧杰老師邀請而擔任課程的遠端助教，用意是希望能幫助想轉職前端的學員們能夠用自己的知識賺回學費，並且能緩和轉職的陣痛期。因為我終於找到轉職前端後的第一份前端工作了，所以這個遠端助教的身分五月底就會交棒給之後的學員們，因此想藉由這篇把點點滴滴記錄下來。\n\n![](https://images.unsplash.com/photo-1557962677-131278db2213?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1100&q=80)\n\n## 菜鳥助教起手式\n好的，既然答應老師的邀約了，那麼具體來說要做些什麼呢？\n\n於是我跟老師敲了個時間當面討論細節，順便拜訪六角學院，我也是從那次才知道六角人力真的是很精簡。\n\n**總結整理如下：**\n* 討論支援時段\n  * 我被安排上午時段，周一至周五有 7 小時自由分配\n* 支援課程\n  * 我主要負責 Vue 課程，而如果當天學員問題較少就支援 JavaScript 課程的問題\n* 教育訓練\n  * 初期會有老師們挑選好的 30 道題目，要試著回答出來\n\n### 教育訓練\n覺得自己可以當上助教蠻開心的，可以賺取學費又可以透過回答問題加深自己對 Vue 、 JavaScript 的掌握度，更重要的是可以培養溝通能力。\n\n但對於如何擔任一個助教而言，我是沒有什麼頭緒的。\n\n好在這部分也有考量到了，因為我主要負責 Vue 課程，所以我的 30 道問題是由該課程講者 - [卡斯伯老師](https://wcc723.github.io/) 挑選。\n\n回覆這 30 道問題的時候，必須同時記錄一些項目：\n* 你的回答\n* 回答耗時\n\n也因為需要紀錄花了多少時間回這道問題，所以我在做這些練習時反而因為緊張花掉很多時間，而且有些時候根據你的回答，還必須附上適當的文件佐證說明，所以整體而言是相當耗時的。\n\n都完成後老師也會根據每一條問題給你回覆建議，並且視情況來安排。\n\n這邊也附上我的練習截圖給各位參考\n\n![](https://i.imgur.com/K4vjkUg.png)\n\n> 幸好實力有被老師肯定，做完這些題目後沒有太大問題就直接上工了。\n\n## 菜鳥助教上工初期\n在很久之前，我有想過一個問題。\n我花錢就是希望直接得到老師的指點，可是回答的都是助教，這樣感覺很虧欸。\n\n> 但是在我當上助教後才知道，代誌不是傻人想的那樣。\n\n### 回覆審核機制\n助教也不是想回學生什麼就任意回答的。\n\n這個機制是為了保證助教的回答是正確且有一定品質，所以我們都會加入助教專屬的 Slack ，要回覆時需要把回覆內容貼到群組內，通過老師審核後才可以正式對外回覆。\n\n具體大概像這個樣子：\n\n![非當事樹精](https://i.imgur.com/M6462I3.png)\n\n**如果審核通過就會有個讚，反之老師會在你的留言下方給回覆建議，修正後重跑一次流程。**\n\n### 實際上陣\n一開始肯定是非常手忙腳亂，因為畢竟是收人錢替人做事，效率肯定要有。\n\n在這個心態的前提下，精神異常的緊繃，所以基本上我如果安排早上 9 點上工，我就會在 08:40 開始看題目，大概有個底。\n\n> 大多時候看到待回覆問題題數時，臉就黑一半了。\n\n工作時螢幕切分大概是這樣的，沒有雙螢幕所以很彆扭。\n\n![](https://i.imgur.com/XMWNwWF.png)\n\n> 左上是審核區；左下是回覆的內容；右上是問題敘述；右下是待命用的 VSCode\n\n這個時期的我回覆問題的速度真的很慢，一題 20 ~ 30 分、甚至有一題花到 1 小時的，當天沮喪到不行，還偷偷跑去跟卡斯伯老師 QQ\n\n![幫 QQ](https://i.imgur.com/h52FdOr.png)\n\n結果後來就在直播上被公開處刑了(?\n\n**後來我仔細反思後，變更了回覆問題的方式：**\n* 先掃一遍，沒有頭緒就先跳過，優先回答會的\n* 花了 5 分鐘還是沒有頭緒時就直接回 Slack 求救\n* 永遠不要把發問的人說的話當真，要跳出他的邏輯除錯\n\n## 成為獨當一面的助教\n經過了大概一個多月的努力，老師們認為我的回覆水平有達一定水準，有把握回覆的問題就不需要特地貼到 Slack 審核。\n\n而每小時回覆的問題數量也漸趨穩定，至少不像一開始這麼悲劇。\n\n處刑用對照圖\n![初期](https://i.imgur.com/MrIpNqK.png)\n\n![中後期](https://i.imgur.com/XSLiViq.png)\n\n後來我又有了另一個體悟\n有些時候回答問題的效率除了自己可能不夠熟 Vue 之外，很大的一部分是因為\n\n* 學員不會描述問題，有些問題我看完都懷疑自己是不是中文不好\n* 幾乎沒有描述問題，只貼了一張錯誤訊息的圖片，說了句「為什麼錯誤」，就沒後續了\n* 絕大多數都是問問題不附程式碼，所以必須進行二次問答\n* 貼上 codepen 連結，點開裡面全部都沒有排版 (瞬間眼神死\n\n> 遺憾的是，在我成為助教之前也是其中問爛問題的其中一人\n\n**也就是因為這樣，助教常常必須通靈才有辦法回答問題。**\n\n對我來說最好的問問題方式就是\n1. 問程式的問題，一定要附上原始碼\n2. 有條理的敘述前因後果，提交問題的時候可以先自己讀個一二次在提交\n\n強烈推薦老師之前線上問答會的影片[發問的智慧](https://www.youtube.com/watch?v=ZzJOcFCxRXQ)\n\n雖然口頭上是這麼說，但請不要誤會，助教群們都很歡迎學員問問題哩 :D\n\n只是希望透過這篇稍微提一下...這應該也是**其他助教的心聲**吧？\n\n要知道一個問題被描述的越精確，那麼這個問題就會越快被解答，省下你我的時間**這是雙贏的局面**。\n\n## 畢業感想\n雖然距離畢業還有快一個禮拜，但在擔任遠端助教的期間，我學到了\n\n* 如何問問題\n  * 觀察學員提問方式反思如何正確的問一個問題\n* 如何與團隊溝通\n  * 例如同時有助教回覆到同一題，如何避開撞車等等\n* Vue 技術上的成長\n  * 有時候學員遇到的 Bug 也是我從沒想過的，知道原因並解決時很有成就感\n* 如何與其他人溝通\n  * 把你會的東西清楚的用文字表達給他人知道\n\n我要謝謝所有我在轉職路上幫助過我的人，雖然我目前還很不成熟，不過我會繼續在這個領域努力下去。\n\n特別感謝六角學院的 **[廖洧杰](https://www.facebook.com/sfismy)** 校長以及 **[王志誠](https://www.facebook.com/chihcheng.wang.3)** 副校長，在我轉職的路上給的幫助特別多，也很感謝有這一次的機會擔任遠端助教。\n\n最後也要謝謝 Slack 群內的 **Jackson** 助教以及**葉子**，在我不知道怎麼回覆時給予建議、幫我坦了不少條難回的問題。\n\n**希望我回的每個問題都有幫助到這些學員們！**\n","tags":["里程碑"],"categories":["雜記"]},{"title":"[從 0 開始的 Angular 生活]No.12 升級 Angular 應用程式到新版的方法","url":"%2Ff2e%2F20190523%2F2615543464%2F","content":"\n## 前言\n介紹完如何使用 Angular CLI 部屬 Angular 專案後，緊接著要提到如何更新 Angular CLI 或 Angular 的版本。但是這部分可能只有純介紹，因為我也是最近才剛開始開發 Angular ，所以環境基本上都是最新的，就不提供更新前後的對照圖了。\n\n## 確認目前版本\n使用 VSCode 開啟專案並打開終端機，我們可以輸入 `ng v` 或是 `ng --version` 指令確認目前專案的 Angular CLI 的版本。\n\n![Image](https://i.imgur.com/AT72QhJ.png)\n\n可知\n* 我的 Angular 目前是 7.2.15 版\n* 而 Angular CLI 則是 7.3.9 版\n\n## 透過 Angular CLI 進行版本升級\n我們可以透過 Angular CLI 提供的指令進行 Angular 專案的升級\n```\nng update\n```\n> 透過這個指令可以把 Angular CLI 以及 Angular 甚至 TypeScript 、 Webpack 、 Rxjs 等等直接升級到最新版本。\n\n所以我們不用擔心 Angular 要如何升級版本的問題，可以透過 `ng update` 輕鬆地把版本升級到最新版，而這個指令也會處理掉一些版本升級時可能會遇到的問題。\n\n**而背後的原理就是 Angular CLI 修改了 package.json 內記載的版本號，然後執行 `npm update` 命令。**\n\n當我們執行過 `ng update` 安裝完畢後，可以確認一次目前的版本，會發現到已經升級到最新了。\n\n延伸讀物：\n* [NPM 指令 Install 與 Update 的差異](https://soarlin.github.io/2017/04/21/Composer-NPM-install-update/)\n\n## 如何更新 Global 的 Angular CLI 版本\n如果想更新全域的 Angular CLI 版本，可以打開命令提示字元，並輸入 `npm list -g --depth=0`\n\n使用這個指令列出目前全域環境中，安裝了那些 npm 套件，並只顯示第一層目錄。\n\n![](https://i.imgur.com/9Cnw53J.png)\n\n可以發現全域的 Angular CLI 版本同樣也是 7.3.9 版。\n\n透過 `npm outdate -g` 指令查詢目前全域環境安裝的套件是否有最新版本\n\n**如果沒有任何資訊出現，代表目前已經是最新版。**\n\n> 如有出現訊息，則透過 `npm install -g @angular/cli` 重新安裝一次即可。\n\n## 小結\n大部分的情況，如果是小幅度的升級，像是小數點後小版本的變更，基本上是不會動到程式碼的。\n\n如果是大幅度的升級，像是 Angular 2 升級到 Angular 4 或者其他情況，可能就需要進行一些評估了。\n\n而這部分 Angular 也很貼心的設有一個網站可以幫助我們快速查詢各個版本的 Angular 升級時需要注意的事項：\n* [Angular Update Guide](https://update.angular.io/)\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.11 發行與部屬 Angular 應用程式的方法","url":"%2Ff2e%2F20190523%2F2814372360%2F","content":"\n## 前言\n現在我們 Angular 專案內的環境非常的單純，只有一個 Component ，而未來如果我們開發完成時，要如何透過 Angular CLI 發行與部屬 Angular 應用程式呢？\n\n![](https://images.unsplash.com/photo-1558382487-0986fe3131b0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1051&q=80)\n\n## Angular CLI 發行與部屬\n可以透過 Angular CLI 的指令辦到這件事情，叫出 VS Code 的終端機，並輸入以下指令：\n```\nng build \n```\n這麼做 Angular CLI 會透過 webpack 幫我們把專案的內容通通打包並且輸出到 dist 資料夾內，而且是沒有進行 minify 的版本。\n\n而如果是正式發布的產品版，則應該額外加入 `--prod` 參數，進行 minify 優化，如：\n```\nng build --prod\n```\n\n## 讓我們看看有無 minify 的差距吧\n首先是沒有加入 `--prod` 的結果\n![Image](https://i.imgur.com/rSD6XkM.png)\n\n> vendor.js 居然約有 3.3 MB ，真是驚人！\n\n接著是有加入 `--prod` 的結果\n\n![Image](https://i.imgur.com/S3UaNlJ.png)\n\n> 從快 3.3 MB 的大小被壓縮到不到 200 KB ，而且剛才看到的 vendor.js 不見了，因為它跟 main.js 合併在一起了。\n\n## 小結\n這次的實驗告訴我們，一定一定要記得部屬時幫這些 .js 檔好好的進行 minify 瘦身一番！\n\n看看這個差距，的確是蠻誇張的...","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.10 將網頁加入 Angular 應用程式","url":"%2Ff2e%2F20190523%2F512922220%2F","content":"\n## 前言\n上一篇提到了如何把靜態資源加入到以 Angular CLI 建立的專案內，但這樣子是不夠的。我們希望能夠把這個網頁版型加入到 Angular 內，以 Component 的形式被管理，那該怎麼做呢？\n\n![](https://images.unsplash.com/photo-1558497446-1fd7429d9be4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 觀察 index.html\n打開 index.html ，整份網頁大致上可以拆分成 head 區塊以及 body 區塊。head 區塊是沒辦法拆成 Component 的，只有在  body 區塊才可以拆 Component 。\n\n**index.html**\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>FirstAngular</title>\n  <base href=\"/\">\n\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n<body>\n  <app-root></app-root>\n</body>\n</html>\n```\n> 我用的網頁版型 HTML 部分還蠻多的，就不貼上來了。\n\n也就是說：\n* 可以直接將靜態網頁的版型 head 部分直接複製貼上到 index.html\n* 把網頁版型中的 body 區塊貼到 AppComponent 的 HTML Template 內\n\n了解該怎麼做之後，我們就動手吧！\n\n## head 部分的處理\n這邊只有一點要注意，在 index.html 中有一個標籤很特別 `<base>` 。\nbase 標籤是用來控制網頁內的其他超連結，而這個標籤在這裡的用意是規定一個基準的 Url 路徑，也就是之後這張網頁內的其他超連結的基準都是從 / 開始找起。\n\n* [關於 base 標籤的詳細說明](https://www.wibibi.com/info.php?tid=418)\n* [base 標籤 應用例子](http://jartto.wang/2016/10/01/about-html-base-tag/)\n\n所以我們把複製的內容放到 base 標籤下方，像這樣：\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <base href=\"/\">\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n  <link href=\"/assets/styles/mainapp.css\" rel=\"stylesheet\">\n  <link rel=\"shortcut icon\" href=\"http://blog.miniasp.com/favicon.ico\" type=\"image/x-icon\">\n  <meta name=\"description\" content=\"Lorem, ipsum dolor.\">\n  <meta name=\"author\" content=\"pvt5r486\">\n  <title>Lorem, ipsum dolor.</title>\n</head>\n<body>\n  <app-root></app-root>\n</body>\n</html>\n```\n\n## body 部分的處理\n這部分因為 HTML 很多，所以就不貼上來了，將網頁版型中的 body 區塊貼到 AppComponent 的 HTML Template 內。\n\n這邊有個小技巧，可以按下 `Ctrl + E` 透過搜尋的方式快速找到檔案，找到後就整個取代貼上吧。\n\n## 實際執行看看\n執行 `npm start` 命令，觀察實際在瀏覽器上呈現的情形。\n\n> 但畫面上空空如也，為什麼？\n\n打開開發者工具發現一段錯誤：\n\n![](https://i.imgur.com/q87FA2W.png)\n\n在 Angular 中，只能使用 HTML5 規範的 HTML 標籤，而我使用的這個版型用到的這個 hgroup 標籤並不符合 HTML5 規範。\n\n**處理方式有很多種，其中最簡單的就是將其改成 div 標籤即可。**\n\n[以下轉自保哥 Blog](https://blog.miniasp.com/post/2016/09/19/Angular-2-Custom-Element-Tips)\n> 關於 hgroup 標籤的補充：\n早期在 HTML5 規格尚未發佈正式版的時候，當時是有 hgroup 元素的，但 HTML5 工作小組在 2013/4/2 的一次[會議結論](http://lists.w3.org/Archives/Public/public-html-admin/2013Apr/0003.html)中決定從規格中移除 hgroup 元素，因此請大家不要再用這個 hgroup 元素。\n\n這樣就搞定了！\n\n![Image](https://i.imgur.com/S5fx2NL.png)\n\n## 小結\n這樣我們就成功地把一份網頁版型加入到 Angular 內並且以 Component 的方式管理，所以可以到上一篇提到的 angular.json 檔案內把之前加入到 `assets` 內的 `src/blog-index.html` 給移除囉，因為已經用不到了。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.9 將靜態檔案加入 Angular CLI 建立的專案","url":"%2Ff2e%2F20190522%2F1867149427%2F","content":"\n## 前言\n現在有個狀況是，如果我們有一份靜態網頁的版型或者是一些靜態的圖片資源、 json 檔，那麼要如何地加入到 Angular 專案內呢？\n\n![](https://images.unsplash.com/photo-1555939765-9b78f509d500?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 將靜態檔案加入 src 資料夾\n首先我有一份靜態網頁的版型叫做 BlogSiteHtml ，解壓縮後的內容有：\n* api 資料夾\n* assets 資料夾\n* blog-index 網頁版型\n\n接著把這些檔案全部貼到 Angular 專案的 src 資料夾內，並且輸入指令 `npm start` 重啟開發伺服器。\n\n## 這樣就完成了嗎？\n重啟開發伺服器後，我們可以在網址列輸入\n```\nhttp://localhost:4200/blog-index.html\n```\n會發現什麼事情都沒發生，畫面還是原本那樣。\n\n**為什麼？**\n\n因為當我們把這些新的靜態檔案加入到 src 目錄後，還需要設定 angular.json ，告訴這支檔案我們做了什麼異動。\n\n## angular.json 的設定\n進入到這支檔案後，可以看到非常多密密麻麻的設定，而我們這次要修改的是 `assets` 區塊的內容，而它位於 `architect` 物件下的 `build` 物件下的 `options` 物件內。\n\n修改前\n```json\n\"assets\": [\n  \"src/favicon.ico\",\n  \"src/assets\"\n],\n```\n**修改的目的就是要告訴這支檔案我們在 src 資料夾內增加了什麼東西，希望它一起編譯。**\n\n修改如下：\n```json\n\"assets\": [\n  \"src/favicon.ico\",\n  \"src/assets\",\n  \"src/api\",\n  \"src/blog-index.html\"\n],\n```\n接著再度重啟開發伺服器，並且重新輸入對應網址觀察。\n\n![](https://i.imgur.com/Xh1TIIQ.png)\n\n這次就成功地看到一個漂亮的部落格版型囉。\n\n## 小結\n透過這樣的操作得知，如果未來開發時加入了一些新的靜態資源，除了將檔案複製進 src 外，也必須調整相關的設定檔，使其可以對應，這樣才能找到我們要的檔案哦。\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.8 使用 Angular CLI 快速建立元件與範本","url":"%2Ff2e%2F20190522%2F1258474476%2F","content":"\n## 前言\n聽人家說 Angular CLI 相當的強大，可以幫助開發者在開發 Angular 時省下不少功夫。本篇要介紹 Angular CLI 是如何幫助我們快速建立元件與範本。\n\n![](https://images.unsplash.com/photo-1425082661705-1834bfd09dca?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1055&q=80)\n\n## 透過 Angular CLI 建立 Component\n可以使用 VSCode 下方的終端機 (按下 Ctrl + ` 開啟)，值得注意的是 Angular CLI Component 類型不只有一種，可以輸入以下指令查看它可以幫我們產生哪些 Component 範本：\n```js\nng generate -h\n```\n執行後可以得知它還能幫我們產生以下這些 Component 範本，是不是很方便呢？\n\n![](https://i.imgur.com/9S8VBbj.png)\n\n如果要透過 Angular CLI 建立 Component ，並且把這個元件加到 AppComponent 下，以下指令擇一即可。\n\n完整指令\n```js\nng generate component myFirstCompoent\n```\n\n簡寫指令\n```js\nng g c myFirstCompoent\n```\n\n執行後得到以下結果：\n\n![](https://i.imgur.com/2ZwTwkn.png)\n\n**得知 Angular CLI 幫我們建立了 4 個檔案，並且更新了 app.module.ts 這支檔案。**\n\n並發現於 app 資料夾中多出了剛才輸入的 myFirstCompoent 資料夾 (不一致是因為 Angular CLI 會自動轉換成適合的名稱)\n\n![](https://i.imgur.com/CSHd3fy.png)\n\n> 之後當我們使用這個方式來建立 Component 時，都會產生類似的檔案結構來建立 Angular 應用程式。\n\n### 觀察 my-first-component.component.ts\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-my-first-component',\n  templateUrl: './my-first-component.component.html',\n  styleUrls: ['./my-first-component.component.scss']\n})\nexport class MyFirstComponentComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n```\n\n剛剛建立的 Component 的 selector 預設就叫做 `app-my-first-component` ，而 `class` 名稱就是 `MyFirstComponentComponent` ，第一個字母自動會變成大寫。\n\n接著還有相對應的 HTML Template 與 SCSS ， SCSS 的內容是空的 、 Template 的預設內容如下：\n```html\n<p>\n  my-first-component works!\n</p>\n```\n而透過 Angular CLI 還有一支 my-first-component.component.spec.ts 檔，這主要是拿來做單元測試用的檔案。\n\n所以**一個 Component 預設會有 4 支檔案被建立**，還記得剛才 Angular CLI 有更新 app.module.ts ，讓我們看看它做了什麼。\n\n### 觀察 app.module.ts\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { MyFirstComponentComponent } from './my-first-component/my-first-component.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    MyFirstComponentComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\nAngular CLI 很智慧地幫在 `declarations` 內註冊了剛才建立的 `MyFirstComponentComponent` 元件，而且也自動的把 `MyFirstComponentComponent` 元件給 import 進 app.module.ts ，相當的便利。\n\n那麼，接下來我們要如何把剛剛建立的 `MyFirstComponentComponent` 呈現在畫面上呢？\n\n## 把新建立的元件加到 AppComponent 下\n如果我們直接運行開發伺服器，是看不見剛才建立的元件的。\n\n![Image](https://i.imgur.com/8IpnQoO.png)\n\n如果要把 `MyFirstComponentComponent` 加入到 `AppComponent` 下，那麼就要把 `MyFirstComponentComponent` 的 directive 註冊到 `AppComponent` 的 HTML Template 內，像是這樣：\n```html\n<!--The content below is only a placeholder and can be replaced.-->\n<div style=\"text-align:center\">\n  <h1>\n    Welcome to {{ title }}!\n  </h1>\n  <!--這邊有一張圖片進行 base64 編碼，太佔空間了所以我把它移除 .-->\n</div>\n<app-my-first-component></app-my-first-component>\n<h2>Here are some links to help you start: </h2>\n<ul>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\">Tour of Heroes</a></h2>\n  </li>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/cli\">CLI Documentation</a></h2>\n  </li>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\">Angular blog</a></h2>\n  </li>\n</ul>\n```\n而 VSCode 也很貼心的提供的自動完成的功能。\n\n![](https://i.imgur.com/wCWn09u.png)\n\n於是可以到瀏覽器觀察修改過後的結果：\n\n![](https://i.imgur.com/fdIKu7x.png)\n\n> 接著可以把寫在 `AppComponent` 下的某幾段 HTML 全部搬到新建立的元件內\n\n## 調整 MyFirstComponentComponent 元件\n來到 `MyFirstComponentComponent` 的 HTML Template 進行如下修改：\n```html\n<h2>Here are some links to help you start: </h2>\n<ul>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\">Tour of Heroes</a></h2>\n  </li>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/cli\">CLI Documentation</a></h2>\n  </li>\n  <li>\n    <h2><a target=\"_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\">Angular blog</a></h2>\n  </li>\n</ul>\n```\n而 `AppComponent` 修改如下\n```html\n<!--The content below is only a placeholder and can be replaced.-->\n<div style=\"text-align:center\">\n  <h1>\n    Welcome to {{ title }}!\n  </h1>\n  <!--這邊有一張圖片進行 base64 編碼，太佔空間了所以我把它移除 .-->\n</div>\n<app-my-first-component></app-my-first-component>\n```\n\n**接著看看是否能順利運行！**\n\n![](https://i.imgur.com/rHePY1o.png)\n\n## 小結\nAngular CLI 真的是蠻強大的，而且提供了許多便利的功能，而本篇僅介紹了其中一個元件類型的範本，而之後我也會建立其他的元件範本玩玩看。","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.7 Angular 應用程式的啟動過程","url":"%2Ff2e%2F20190522%2F589237579%2F","content":"\n## 前言\n當我們透過 VSCode 的終端機執行 「npm start」 時，這段時間發生了什麼事情，讓我們好好地整理一下。\n\n![](https://images.unsplash.com/photo-1558433916-90a36b44753f?ixlib=rb-1.2.1&auto=format&fit=crop&w=1050&q=80)\n\n## npm start\n首先開啟一個之前就建立好的 Angular 專案範本，接著在 VSCode 的終端機執行 `npm start` 。\n\n![](https://i.imgur.com/yAmjSev.png)\n\n透過這張圖可以觀察到，當執行 `npm start` 時，其實是呼叫執行 Angular CLI 的命令 `ng serve` ，這個過程會啟動一個開發伺服器，而這個開發伺服器在啟動之前，背後透過 Webpack 將目前的 Source Code 內所有的 TypeScript 進行編譯。\n\n編譯之後把所有的 JavaScript 檔案合併在一起，而這個過程中產生了幾支檔案：\n* es2015-polyfills.js, es2015-polyfills.js.map\n* polyfills.js, polyfills.js.map\n* runtime.js, runtime.js.map\n* styles.js, styles.js.map\n* vendor.js, vendor.js.map\n\n**那麼這些檔案會用在什麼地方呢？**\n\n## index.html\n在首頁打開的時候，預設會把剛才編譯產生的這些檔案給載入，我們可以透過觀察原始碼來了解。\n\n### 對著 index.html 按右鍵 > 檢視網頁原始碼\n\n![](https://i.imgur.com/72OS6Vn.png)\n\n首先我們看到一個 <base> 標籤，這個標籤可能比較少用，詳細的應用可以到[這邊](https://www.wibibi.com/info.php?tid=418)查看。\n\n接著是 <app-root> 標籤，這個標籤事實上就是 Angular 裡面的根元件，也可以稱它為一個 directive ，關於 directive 之後會有更詳細的說明。\n\n然後發現 </body> 之前被插入了剛剛編譯出來的 .js 檔，而 Angular 應用程式也在載入這些 .js 檔後正式開始運行。\n\n**然而執行的過程中，也有一個啟動的流程。**\n\n啟動的流程結束後， <app-root> 標籤的內容就會被動態的插入一些 DOM 物件，最後顯示在畫面上。\n\n### 對著 index.html 按右鍵 > 檢查\n從 chrome 的開發者工具底下，可以看到 <app-root> 標籤包含了一些從剛剛的原始碼內看不到的標籤。\n\n![](https://i.imgur.com/3usbsPx.png)\n\n因為這些內容全部都是透過 Angular 應用程式動態運算出來的結果。\n\n### 實際觀察專案內的 index.html 檔案\n這支檔案也就是剛才 chrome 瀏覽器開啟的檔案，而裡面確實有個 <app-root> 標籤。\n\n可以發現檔案內的 <body> 標籤內並沒有插入剛才那些 .js 檔，也就是說那是 **Webpack 幫我們編譯後動態插入的**。\n\n> 也就是說我們在開發 Angular 網頁時，它的 JavaScript 在開發時期是動態被注入的。\n\n## 從哪支 .js 檔開始跑呢？\n之前有提過， Angular 應用程式的進入點是 main.ts 檔案，而它的長相如下：\n\n```js\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n```\n\n前面 5 行主要是引用從某一些模組匯入程式運行時必要的物件進來。\n而第 11 行的地方，則是透過 `platformBrowserDynamic().bootstrapModule(AppModule)` 去執行啟動模組這件事，接著會進入到 `AppModule` 裡面執行相關的程式碼，讓我們一起觀察下去吧。\n\n> 小提示：在 VSCode 內可以對著 `AppModule` 點一下接著按 F12 會自動追蹤到該檔案喔\n\n### AppModule 內\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n> 這支檔案可以說是在 Angular 應用程式裡面最重要的一支程式，而程式碼結構不難看出它是一個 `class` 而且被 export 出來，神奇的是裡面沒有任何的程式碼。\n\n在大部分的情況，我們寫 Angular 應用程式時確實是不需要寫程式在裡面的。\n\n我們只需要套用一個 `declarator` ，而這個 `declarator` 要設定成 `NgModule` ，去宣告這個類別它是一個 Angular 的 Module ，然後我們在這個 Module 裡面又有好幾個 Property (屬性) 需要宣告：\n* declarations - 用來宣告一些跟 view 有關的元件\n* imports - 用來匯入一些跟這個模組會用到的其他模組，而模組說穿了就是多個元件封裝後的東西 \n  * 而 `BrowserModule` 就是把 `BrowserModule` 內所有的元件一起匯入進來的意思\n* providers - 註冊服務的提供者\n* bootstrap - 啟動根元件 `AppComponent` ，也就是 Angular 最上層的元件 (預設名稱為 `AppComponent`)\n\n**接著我們使用剛才介紹的追蹤方式，繼續追蹤 `AppComponent`**\n\n### AppComponent 內\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n}\n```\n\nAppComponent 元件的程式碼結構也一樣是個被 export 的 `class` ，然後這個範例程式預設有一個屬性 `title` 。\n\n這個元件一樣有使用到 `declarator` ，叫做 `Component` ，這個 `Component` 在 Angular 內有特殊的涵義，這是用來宣告這個 `class` 代表的是一個 Component 。\n\n而這個 Component 同樣有一些屬性如：\n* selector - 如果寫過 JQuery 肯定不會陌生，就是一個選取器，如同範例的 `app-root` 就是選取到 HTML 中 `app-root` 標籤，並且把這個標籤的內容，修改為這個元件執行的結果。\n  * 同理，如果改寫成 `.app-root` 則是選取具有 `.app-root` 的 className\n\n舉例來說可以這麼做，我們修改 AppComponent 與 index.html 如下：\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: '.app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n}\n```\n\n```html\n<body>\n  <!-- <app-root class=\"app-root\"></app-root> -->\n  <div class=\"app-root\"></div>\n</body>\n```\n之後回到瀏覽器觀察，發現仍然是可以運行的。\n\n![](https://i.imgur.com/pYc3KFD.png)\n\n而 HTML 中不管是直接在元件寫上 className 或者是新建一個具有 `app-root` className 的 div 標籤都是有效果的。\n\n在我們把 `selector` 修改成 `.app-root` 後，下方突然多出綠色的蚯蚓，這是因為我使用了 TSLint ，而 TSLint 這個套件是遵照 Angular 官方發布的 Style Guide 規範，這當中就包含了 Component 的 selector 最好都以 element 的 selector 為主。\n\n![](https://i.imgur.com/mGbaM2T.png)\n\n* templateUrl - 指這個 AppComponent 的 HTML Template 的所在之處，而這堆內容就是我們在瀏覽器上看到的 HTML 內容\n\n![](https://i.imgur.com/z22zGRb.png)\n\n**所以我們的每一個 Component 都會有一個相對應的 HTML Template 做搭配，一個負責程式的邏輯、另一個負責呈現於瀏覽器。**\n\n* styleUrls - 指 AppComponent 的 HTML Template 有用到的 CSS 樣式，需要注意的是這裡的樣式預設只針對這個 Component ，並不會與其他 Component 互相衝突，當然這個預設值也是可以調整的。\n\n## 小結\n以上就是 Angular 應用程式的啟動流程，透過這樣的描述能讓自己更加地了解 Angular 的運作過程。\n\n\n\n\n\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.6 理解 Angular 應用程式與元件","url":"%2Ff2e%2F20190521%2F3465317465%2F","content":"\n## 前言\nAngular 採用模組化的元件開發，因此一個 Angular 專案裡面會看到非常多不同種類、大大小小的元件，而網頁畫面的構成也都是透過 JavaScript 切換這些大大小小元件渲染而成。可見元件在 Angular 中有多麼重要，所以我們要來理解 Angular 與元件的部分。\n\n![](https://i.imgur.com/x0srOd1.png)\n\n## Angular 應用程式的組成\n一個完整的 Angular 應用程式，它會包含一個模組，通常稱它為 AppModule ，而一個模組下會包含非常多的元件，如以下這張圖：\n\n![](https://i.imgur.com/Fh3dlQw.png)\n\n一個模組下可能會有:\n* App Componet 根元件\n* Child Componet 子元件\n* Services Componet 服務元件\n* Pipe Componet 管道元件\n\n元件的類型可能會有很多種，我們會透過一個模組把這些元件封裝起來。\n\n> 因為一個完整的 Angular 應用程式至少會包含一個模組，也至少會有一個元件以上，因此我們可以說一個 Angular 應用程式就是由元件所組成的\n\n## Angular 頁面的組成\n今天我有一個頁面想要呈現在瀏覽器內，不外乎會有 HTML 、 CSS 、 JavaScript 這幾支檔案，最終瀏覽器呈現出完整的網頁。\n\n而 Angular 的開發模式，全部都是元件化的開發模式跟以往我們使用 JQuery 的開發模式是不一樣的，我們不需要頻繁的操作 DOM 。在元件化的開發方式裡，我們鮮少會直接操作 DOM 元素，都是透過元件的切換來達成畫面的渲染。\n\n**可以想像成一個網頁載入後， HTML 內的 body 都是空白的，只有 JavaScript 。**\n\n所以頁面要如何渲染到瀏覽器上呢？\n* JavaScript 呼叫 元件\n* 元件 再呼叫 樣板\n* 樣板呈現到畫面上\n\n**而這個過程是動態的透過 JavaScript 達成。**\n\n我們可以再次想像一個 Angular 頁面：\n* 最外層是由一個 AppComponent 元件(或稱為根元件)包覆\n* 最上方頁首的部分可以拆成 HeaderConponent 為獨立元件\n* 左邊則是拆成子選單的部分 AsideCompoent\n* 右邊則是網站主要內容 ArticleCompoent\n\n![](https://i.imgur.com/KU2LunY.png)\n\n> 如圖，AppComponent 包覆著 HeaderConponent 、 AsideCompoent 、 ArticleCompoent 這些元件，也就是說 AppComponent 就是父元件，而被包覆在裡面的就稱為子元件，最後組合成一個完整的網頁。\n\n然而實際上的網頁開發可能元件架構上沒有這麼單純，一個元件內可能又包覆一個子元件，而這個子元件可能又有另一個子元件，這種狀況是蠻常見的。像這樣一層包著一層的開發方式，就是所謂的元件化的開發方式。\n\n而這樣的開發方式，會幾乎碰不到 DOM 元素的操作，我們只需要專注頁面邏輯以及商業邏輯的撰寫就可以了，而且商業邏輯會跟 view (template) 的部分是分離的，所以可維護性也會提升。\n\n**而這個部分就是 Angular 應用程式與元件之間的關係**\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.5 認識 TypeScript","url":"%2Ff2e%2F20190521%2F2979055715%2F","content":"\n## 前言\n在 Angular 的世界中，並不是使用一般的 JavaScript 進行開發，而是使用 TypeScript 進行程式語言的撰寫。然而 TypeScript 與 JavaScript 又有什麼關係呢？\n\n![](https://i.imgur.com/Dk8VBHz.png)\n\n## 認識 TypeScript\n我們可以從一張圖了解 TypeScript 與 JavaScript 的關係：\n\n![](https://i.imgur.com/cpWoxQT.png)\n\n從這張圖我們可以得知， TypeScript 是包覆著整個 JavaScript 的每個版本，換句話說， TypeScript 是 JavaScript 的超集合。\n\n### 如何撰寫 TypeScript\n而要撰寫 TypeScript 的語言並不困難，我們仍然使用 JavaScript 來撰寫 TypeScript ，差別在於多了一些語言特性，但很多時候都還是仰賴我們在 JavaScript 建立起的觀念，因此擁有扎實的 JavaScript 基礎是相當重要的。\n\n### 使用 TypeScript 的好處\nJavaScript 是動態型別的語言，也被稱為弱型別的程式語言，是在執行時期才真正擁有型別，而且會因為內容的不同而更改型別。相較於習慣靜態型別的程式語言(如 C#)的開發者來說，這樣是非常困惑的事情，因為沒有辦法很明確的知道某個變數是什麼型別。\n\n> 而 TypeScript 的其中一個特性是，可以讓 JavaScript 直接宣告某個變數應該是什麼型別。\n\n### 不用擔心瀏覽器語法相容問題\n在前端領域中往往要考量到瀏覽器的相容性，舉例來說我們可能使用 ES6、7 的某個語法，但是在 IE8、IE9 卻沒辦法支援這些語法，這時候就必須安裝額外的套件像是 Babel 來處理這個情況，或者乾脆改用別的語法。\n\n> 而 TypeScript 有 JavaScript 的編譯器，用來將 TypeScript 編譯成瀏覽器看得懂的 JavaScript ，而這個過程中 TypeScript 也會自動地幫我們把較高版本的 JavaScript 轉換成較低版本如 ES5 的語法，這是相當方便的。\n\n### 親自體會\n到 TypeScript 的官方網站，有個 Playgrund，我們可以觀察 TypeScript 轉換成 JavaScript 後會是什麼樣子，這邊只是幫助我們了解 TypeScript 可以做些什麼，而一些 TypeScript 的語言特性等用到再說。\n\n像這樣隨意地寫一個 ES6 的 `class`\n```ts\nclass greet {\n  sayHello() {\n    console.log('Hello');\n  }\n}\n\nlet obj = new greet();\nobj.sayHello();\n```\n會被編譯成這樣\n```js\nvar greet = /** @class */ (function () {\n  function greet() {\n  }\n  greet.prototype.sayHello = function () {\n    console.log('Hello');\n  };\n  return greet;\n}());\nvar obj = new greet();\nobj.sayHello();\n```\n> 因此我們只需要專注於 TypeScript 即可，不需要理會編譯出來的 JavaScript ，只需要知道 TypeScript 會幫我們搞定相容性的問題。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.4 Angular 的優點與特色","url":"%2Ff2e%2F20190521%2F724990059%2F","content":"\n## 前言\n新一代的 Angular 可以為我們做哪些事情，又相較於 AngularJS 而言有哪些特色呢？\n\n![](https://images.unsplash.com/photo-1558350310-4ec674fb415d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## Angular 主要特色\n* 跨平台\n  * [Progressive Web Apps](https://blog.techbridge.cc/2018/10/13/pwa-in-action/)\n    * 結合網頁與應用程式優點\n  * Desktop Apps\n    * 可搭配 [Electron](https://zh.wikipedia.org/wiki/Electron) 框架開發出跨越作業系統的桌面應用程式\n  * Native Apps\n    * 可搭配 [lonic Nactive](https://ionicframework.com/)、 [NativeScript](https://www.nativescript.org/) 開發跨行動平台的原生應用程式\n\n* 速度與效能\n  * Code generation (AOT)\n    * 將元件範本預先編譯成 JS 程式碼\n  * Universal\n    * 將開啟頁面的首頁預先產生完整的 HTML 與 CSS 原始碼，加快載入速度\n    * 可支援 Node.js 、 .NET 、 PHP 等等任何其他伺服器端網頁架構\n  * Code Splitting\n    * 透過元件路由機制，讓使用者只載入需要的程式碼\n\n* 生產力提升\n  * Templates\n    * 使用簡易又強大的範本語法提高開發效率\n  * [Angular CLI](https://cli.angular.io/)\n    * 透過命令列快速建立 Angular 專案、新增元件、執行測試與部屬\n  * IDE\n    * 可以在現有編輯器及開發工具中使用程式碼自動完成、即時錯誤提示、程式碼建議\n\n* 完整的開發體驗\n  * Testing\n    * 結合 Karma 執行單元測試，結合 Protractor 進行各種 E2E 測試情境\n  * Animation\n    * 透過 Angular API 完成複雜的頁面動畫處理\n  * Accessibility\n    * 透過 ARIA-enabled 元件、開發者指引與內建的 a11y 測試基礎架構，建構具有可行性的應用程式\n\n## 與 AngularJS 相比\n\n* 效能改進 (Performance)\n  * 偵測變更：比 AngularJS 快 10 倍\n  * 更小的 Library Size 與 延遲載入\n  * 範本編譯：支援 Template 預先編譯機制\n  * 渲染速度：比 AngularJS 快 5 倍 (Render & Re-render)\n  * 支援伺服器渲染機制 (PHP & ASP.NET)\n\n* 高生產力 (Productivity)\n  * 開發應用程式能用更簡潔的語法讓團隊更加上手與維護\n  * 更強大的開發工具 Augury\n  * 移除超過 40+ 個 directives\n\n* 多平台 (Versatility)\n  * 支援 Broeser 、 Node.js 、 NativeScript and more ...\n\n## Angular 優勢\n\n* 熟悉的開發架構\n  * 採用 TypeScript 開發語言，使用以類別為基礎的物件導向架構開發網頁應用程式，幫助 C# 、 Java 、 PHP 等開發人員快速上手。\n\n* 更低的學習門檻\n  * 相較於 AngularJS 減少了許多抽象的架構與概念，對於剛入門的 Angular 開發者將更容易上手\n    * 例如 AngularJS 的 directives 就有非常多抽象概念\n\n* 更好的執行效率與行動化體驗\n  * 不同行動裝置之間的各種特性接考量在內，例如觸控、螢幕大小、硬體限制等\n  * 內建伺服器渲染技術 (server rendering) 與 Web Worker 技術改善頁面載入效率\n  * 不僅僅做到預先產生 HTML 畫面，更能透過 NativeScript 或 Ionic 建立起網站框架與 Mobile App 之間的橋樑，開發效率與速度更好的行動瀏覽體驗。\n\n* 更清晰的專案架構與可維護性\n  * 使用 ES6 模組管理機制，搭配 Webpack 或 SystemJS 等工具即可上手\n  * 元件模組化架構，幫助大家更快理解程式碼結構，降低維護成本\n  * 好的模組化架構能降低開發難度，也更適合開發大型的網站應用\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.3 AngularJS 與 Angular","url":"%2Ff2e%2F20190521%2F292071729%2F","content":"\n## 前言\n在還沒正式踏入開始寫 Angular 時，身為一個初心者自然會在網上查詢很多關於 Angular 的資料。這時肯定會注意到，怎麼好像有兩種不一樣的 Angular 圖案呢？而名稱似乎也有點不同，一個叫 AngularJS、另一個叫 Angular，兩者之間是不是有什麼關係呢？\n\n![](https://i.imgur.com/Frf1uBI.png)\n\n## Angular 前世今生\nAngular 最早是由 Google 團隊主導且全球領先的 JavaScript 應用程式框架，但在發展過程中都是由開源社群共同參與的。\n\n### Angular 1.X\n那為什麼 Angular 有兩個名字呢？\n\n因為早期在第一代的時候，它的名字也被稱為 Angular ，所以我們稱 Angular 1.X 版是第一代產品。第一代產品剛推出的時候得到非常大的迴響，有非常多的開發者使用這一套框架建置他們的網站，由於 Angular 框架的問世，造福了不少開發者。\n\n![AngularJS](https://i.imgur.com/vU23T0u.png)\n\nAngular 1.X \n* 有廣大的開發社群\n* 透過全新的、抽象化的架構大幅簡化網頁應用程式的開發\n\n### Angular 2\n但在發展了幾年之後發現有一點缺陷，後來 Angular 團隊花了兩年多的時間發展第二代的產品，我們稱它 Angular 2.X 。\n\n![Angular 2+](https://i.imgur.com/xPMdsCR.png)\n\nAngular 2\n* 重新打造的下一代 AngularJS 開發框架\n* 更高的執行效率、更佳的延展性架構\n* 透過全新的元件化技術建構現代化的開發框架\n\n從兩者的比較來看，第二代與第一代的產品有相當大的差別，從開發架構、使用的開發工具、甚至於有些部分開發觀念也都修改了。\n\n> 換句話說，如果你使用的是第一代的 Angular 開發的網站，沒有辦法很快地升級成第二代的 Angular 。\n\n### AngularJS 與 Angular\n這兩代產品差異這麼大但是名字又一樣，這對於大家討論 Angular 時造成很大的困擾。\n\n因此大家就協議：\n* 使用 **AngularJS** 稱呼 Angular 第一代的產品，也就是 Angular 1.X 版\n* 使用 **Angular** 稱呼 Angular 第二代的產品，也就是 Angular 2 版\n\n## 後來的版本\n在我寫這篇文章的時候 Angular 已經出到 7 版了，從 2 到 7 之間的版本差異會不會很大呢？\n\n差異肯定是有的，但不像從 AngularJS 到 Angular 這種層級的大翻新，因此從 Angular 2 之後的版本幾乎都可以很快速的升級成新版本，而 Angular 2 之後的版本我們也都統稱為 Angular 。\n\n甚至 Angular CLI 有個命令是 `ng update` ，可以幫助我們把現有的專案升級成新版本的 Angular ，所以我們可以放心地使用 Angular 開發網站哦。\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.2 檔案架構","url":"%2Ff2e%2F20190520%2F3222844657%2F","content":"\n## 前言\n緊接著了解 Angular 專案內的檔案結構，我覺得這是相當重要的。畢竟只有在認識了這些檔案結構後，才有辦法因應日後專案的調整，也才知道要在哪裡修改對應的配置。\n\n![](https://images.unsplash.com/photo-1558147060-6849949a1b56?ixlib=rb-1.2.1&auto=format&fit=crop&w=1050&q=80)\n\n## Angular 專案的檔案結構\n開啟 VS Code ，並且載入 Angular 專案，會看到旁邊一排的檔案結構。\n\n![](https://i.imgur.com/ccGlubr.png)\n\n### angular.json\nangular.json 這隻檔案是 Angular CLI 的設定檔，所以這個檔案裡面可以看到有非常多的參數，未來我們也可能會到裡面調整一些參數，用到的時候再來了解就可以了。\n\n### .editorconfig\n.editorconfig 是一個非常常見的編輯器設定檔，這個檔案會告訴我們目前使用的編輯器怎麼處理 tab 符號、斷行符號等等。\n\n詳細的設定可以到[這裡](https://editorconfig.org)了解。\n\n### .gitignore\n.gitignore 是一個 git 專用的檔案，用來告訴 git 要忽略這個資料夾那些檔案不要加入版本控管。\n\n### karma.conf.js\n[karma](https://karma-runner.github.io/latest/index.html) 是一個單元測試工具，當我們需要做單元測試時可能會需要用到它。\n\n### package.json\n目前專案 npm 的設定檔，這個檔案相當的重要，因為上面記載著這個專案用了哪些相依套件。\n\n而其中的 `scripts` 區塊更是定義了未來在開發 Angular 時經常用到的命令，這邊也可以看到之前用過的命令。\n\n### protractor.conf.js\n同樣也是測試時使用的設定檔，這是 Angular 實作 End-To-End Testing 時會用到的設定檔，到時候用到再來研究就好了。\n\n### tsconfig.json\n這個設定檔則是 TypeScript 的相關設定存放的地方，這個檔案通常也不太需要修改。\n\n### tslint.json\n[TSLint](https://palantir.github.io/tslint/) 是一套開源的 TypeScript 程式碼風格檢查器，白話點就是類似 ESLint ，這個設定檔就是用來設定 TSLint 所有檢查的規則。\n\n### node_modeles 資料夾\n這個資料夾非常肥大，主要內容為我們使用 `npm install` 後所有被下載下來所有的套件，基本上這個資料夾的內容都是透過 npm 來管理的，不太需要自己管理它。\n\n### e2e 資料夾\n跟先前提到的 protractor.conf.js 有關，是一個 End-To-End Testing 所有測試的指定檔都被放在這裡。而在 Angular ，所有 End-To-End Testing 的程式碼都是使用 TypeScript 撰寫，如果未來會用到再回過頭來寫這些檔案吧。\n\n## 重頭戲 src 資料夾\nsrc 顧名思義就是整個 Angular 應用程式主要的原始碼，全部都放在這個資料夾底下。而這個資料夾的目錄結構完全按照 Angular 官網的 Style Guide 建立而成，所以我們只要按照這些規範來開發基本上不會出什麼大錯。\n\n> 接著我們來看 src 底下的目錄結構\n\n### app 資料夾\n這個資料夾裡面就是應用程式的主要檔案。\n\n### index.html、style.css\n畢竟 Angular 還是一個 web 的應用程式，既然是 web 就有 HTML，檔名預設就是 index.html。\n\n同理，自然也會有 style.css ，所以當我們需要 CSS 定義時，可以修改這隻檔案，但是這支並不是單純的 CSS ，在這裡它是 「global styles」也就是整個應用程式都會套用到的 CSS 定義，全部都可以寫在這裡。\n\n### main.ts\n在 Angular 內，我們只能寫 TypeScript，所以這個 main.ts 就是 Angular 中 JavaScript 程式的進入點，也就是主程式。\n\n```js\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n```\n其中 `platformBrowserDynamic().bootstrapModule(AppModule)` 傳入了 `AppModule` 參數，而這個參數我們循著它的路徑找到位於 app 資料夾內的 app.module.ts 檔。\n\n發現這隻檔案同樣的引用了其他的檔案：\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n從這邊我們可以看出一些端倪，看起來 app.module.ts 像是在管理要載入那些元件。\n而從程式碼看來又載入了 `AppComponent` ，於是順著追查找到了 app.component.ts 檔案，而這支檔案裡面記載著對應那些 template、style 的路徑，如：\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'firstAngular';\n}\n```\n回到 app.module.ts ，這裡的 `bootstrap` 是啟動的意思，意思就是要啟動 `AppComponent` 。\n\n> 也就是說 app.module.ts 指定了 `AppComponent` 當成整個 Angular 應用程式的根元件。\n\n而目前我們看到的這些東西都是透過 Angular CLI 自動產生的範本，之後會一一的修改這些檔案。\n\n最後還有一個 app.component.spec.ts 檔案，這是一個單元測試的定義檔，我們可以透過 component 附屬的 spec 檔來去定義要如何測試這個 component，所以當我們之後要寫單元測試時，我們就會需要修改這個檔案。\n\n### assets 資料夾\n這個 assets 在英文上有資產的意思，通常意味著所有的靜態檔案，當 Angular 應用程式需要一些靜態檔案，如額外的 JavaScript、JQery、CSS、圖片等等，我們可以統一放置在這個資料夾下。\n\n而這個資料夾底下的 .gitkeep 是給 Git 看的，因為我們在做 Git 版控時，如果有一個資料夾底下一個檔案都沒有，這個資料夾是不會進入版控的。因此這個 .gitkeep 檔是為了這個目的設計的，讓 assets 資料架內就算沒有任何檔案也能被加入 Git 版控。\n\n### environments 資料夾\n這個資料夾裡面所定義的是 Angular 專案內的環境變數，而這裡面的檔案也都是由 TypeScript 寫成，也就是說我們會透過 TypeScript 定義一些環境變數。說白一點就只是個物件，我們可以在裡面新增一些額外的屬性。\n\n這個資料夾內有兩個檔案，分別是 environment.ts 與 environment.prod.ts ，差別在於 environment.prod.ts 是只有當 build 出 production 版的應用程式時才用得上，否則在開發時期都是使用另一個設定檔。\n\n### polyfills.ts\npolyfills 代表的是，當 Angular 執行時，如果使用者使用相對較舊的瀏覽器像是萬惡的 IE 系列，有些功能由於使用了一些全新的瀏覽器特性，所以有可能導致程式碼無法順利執行。而這個 polyfills 就是幫助 Angular 在這些比較舊的瀏覽器也能順利運行的關鍵。\n\n### test.ts\n這個檔是被前面介紹到的 Karma.conf.js 檔案使用，是拿來做單元測試才會用到的。\n\n### tsconfig.app.json\n剛才我們講過一個類似的，不過那個是在根目錄下的 tsconfig.json ，而這個設定檔是繼承 tsconfig.json 並做出一些額外的定義。而這個檔案就是針對 app 資料夾裡面所有 TypeScript 來進行一些設定，比起最外層的設定，我們比較有可能修改到這一份，一樣是有用到再來修改即可。\n\n### tsconfig.spec.json\n是我們在寫單元測試的 TypeScript 程式碼的時候可能會需要用到的一些設定檔。\n\n### typings.d.ts\n這個也是 TypeScript 會用到的設定檔，主要的用途是定義那些額外的 TypeScript 型別定義，比方說當我們想把 JQuery 也整合進 Angular ，我們就很有可能修改到這隻檔案，可以在這隻檔案內宣告一些 Angular 內會用到的全域變數，例如 $ ：\n```js\ndeclare var $: any;\n```\n這麼做之後，所有 Angular 內的 TypeScript 程式碼都可以使用 $ 這個全域變數，於是在編譯時就不會出錯了，而這部分也是需要用到時才要修改的。\n\n不過這支檔案，我的 Angular CLI 版本是 7.3.9 版，似乎沒有自動產生這隻檔案，因此這隻檔案很可能之後要自己手動增加或是已經捨棄不用了。\n\n## 小結\n總算是介紹完 Angular 的檔案結構了，除了 TypeScript 相關的檔案之外，其他都是蠻眼熟的檔案，然後也明白 Angular 也是元件、元件、元件堆起來的網站，這點跟 Vue 蠻像的，目前比較在意 TypeScript 的部分，設定檔這麼多支感覺起來頗複雜，再加上不熟 Angular 語法，可以預期是場硬仗。\n\n\n\n\n\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.1 建立專案","url":"%2Ff2e%2F20190520%2F1704649665%2F","content":"\n## 前言\n安裝好開發 Angular 需要的環境後，緊接著就是建立起 Angular 專案的骨架了，讓我們一塊來了解如何使用 Angular CLI 建立一個 Angular 的專案吧。\n\n![](https://images.unsplash.com/photo-1558254026-f13859e884d8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 建立 Angular 專案資料夾\n那麼，該如何 Angular 專案資料夾呢？\n\n### 手動建立一個空的資料夾\n首先，我們可以先手動替專案建立一個資料夾，像是我在 D 槽建立一個 learnAngular 的資料夾，這樣比較方便管理。\n\n![](https://i.imgur.com/5sDBaux.png)\n\n### cd 切換到自訂的資料夾\n接著打開 CMD 並且輸入以下指令，切換到剛才建立的資料夾內。\n```\ncd /d D:learnAngular\n```\n\n![](https://i.imgur.com/ru9HPDA.png)\n\n### 初始化專案環境\n* `ng new 專案名稱` - 透過指令建立 Angular 專案\n```\nng new firstAngular\n```\n輸入後， Angular CLI 會問我們一些事項：\n* 要不要加入 Angular Routing (y/N) [在此我選 N]\n* 要使用哪一種 CSS 預處理器 (多選) [在此我選 SCSS]\n\n> 接著進入一連串的套件安裝，安裝完後可以發現多了 firstAngular 資料夾，且裡面建立了不少檔案。\n\n![](https://i.imgur.com/kVlrz5e.png)\n\n## 執行專案\n然後再次使用 cd 指令，進入 firstAngular 資料夾。\n```\ncd firstAngular\n```\n正確切換到這個資料夾後，輸入 `npm start` 運行 Angular 專案。\n\n如操作正確，應看到如下畫面，可複製網址至瀏覽器網址列貼上觀察。\n> 注意：此時 CMD 視窗不可關閉，因為執行 `npm start` 指令後，其實是透過 `ng serve` 的指令啟動 node.js 的 web server ，這樣我們才可以在瀏覽器上看到對應的網頁。\n\n![](https://i.imgur.com/TX05iCF.png)\n\n![專案正確執行](https://i.imgur.com/8y4ZWKc.png)\n\n## 小結\n進行到這個階段，目前我們已經掌握了:\n* 知道開發 Angular 需要那些套件並且安裝他們\n* 使用 Angular CLI 建立一個 Angular 專案\n* 透過 `npm start` 運行 Angular 的開發伺服器，並透過瀏覽器觀察這個網頁\n\n接下來我們要了解 Angular 專案內的檔案結構。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"[從 0 開始的 Angular 生活]No.0 環境準備","url":"%2Ff2e%2F20190520%2F1659785282%2F","content":"\n## 前言\n本來是沒有打算要學習 Angular 的，目前前端的三大框架 Angular、React、Vue 我已經學習了 Vue ，想說應該是精通一種框架運用即可。但人算不如天算，在新的工作環境中需要掌握 Angular 的技術，當作給自己的挑戰，那就硬著頭皮上吧。\n\n![](https://images.unsplash.com/photo-1558216629-a2f7fe856792?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80)\n\n## 開發 Angular 前的環境準備\n「工欲善其事，必先利其器」，下面這些軟體可以單獨到各自官網安裝，也可以透過 **Chocolatey** 一鍵安裝，總之讓我們先準備一下環境吧。\n* 安裝 node.js\n* 安裝 Git\n* 安裝 VS Code\n* 透過 **Chocolatey** 安裝以上\n\n### 安裝 Chocolatey\n[Chocolatey](https://zh.wikipedia.org/wiki/Chocolatey) 是一個 Windows 下的軟體包管理器，可以像在類 Unix 系統中使用 Yum 和 APT 一樣使用它，在 Windows 中實現自動化輕鬆管理 Windows 軟體的所有方面（安裝，組態，更新和解除安裝）\n\n首先進到 [Chocolatey](https://chocolatey.org/) 網站內，可以看到 install 的按鈕。\n![](https://i.imgur.com/dLT3Aj2.png)\n\n接著往下捲一點，這邊有兩個選擇\n* 使用 CMD 並輸入指令安裝\n* 使用 PowerShell 並輸入指令安裝\n\n![](https://i.imgur.com/J6nPAyP.png)\n\n這裡我使用 CMD 安裝，以「管理員身分」打開 CMD 後貼上這一串\n```\n@\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\"\n```\n執行結束後，輸入 `choco /?` 確認版本號，若安裝成功則出現對應版本號，出現錯誤則代表沒有安裝成功。\n\n![](https://i.imgur.com/xnn3UAz.png)\n\n### 透過 Chocolatey 安裝開發 Angular 的其他必要工具\n我們可以透過 Chocolatey 官網提共的[搜尋](https://chocolatey.org/packages)功能，快速找到我們要安裝的軟體，例如搜尋 node.js 。\n\n![](https://i.imgur.com/CAe58Q5.png)\n\n由於我們要安裝 Git、VSCode、Node.js ，所以打開 CMD 並且輸入以下\n```\nchoco install -y git nodejs vscode\n```\n**參數說明**\n* `-y` - 安裝時默認同意，不再詢問是否同意安裝\n\n![](https://i.imgur.com/zNLKbMc.png)\n\n> 透過這樣的方式，我們僅需要一行指令，就安裝好這些軟體，這是相當方便的，當然 Chocolatey 並非必要的，我們還是可以手動進行軟體的安裝。\n\n### 測試上述軟體是否安裝成功\n**如果是使用 Chocolatey 方式安裝，必須先把當前的 CMD 關閉重啟，才可以正確執行指令。**\n\n> 依序輸入 `npm -v` 、 `node -v` 、 `git --version` ，若都有安裝成功則回應版本號。\n\n![](https://i.imgur.com/O1vPkyh.png)\n\n最後打開 VS Code ，就可以開始我們的第一個專案囉。\n\n![](https://i.imgur.com/xg0FHj7.png)\n\n## 安裝 Angular CLI\n接下來我們要安裝 [Angular CLI](https://cli.angular.io/) ，看到這邊覺得蠻熟悉的， Vue 也有 CLI。\n\n同樣是透過 npm 來安裝，打開 CMD 輸入指令如下：\n```\nnpm install -g @angular/cli\n```\n> 輸入 `ng --version` 檢測是否正確安裝\n\n![](https://i.imgur.com/Fet4r8V.png)\n\n## 安裝 VS Code 的擴充插件\n這部分就屬於非必需的了，這部分可以自由挑選喜歡的擴充插件讓開發 Angular 時更加得心應手。所以這裡推薦保哥的 Angular Extension Pack ，下載次數有 26 萬，評價也蠻高的，看來是個不錯的插件。觀察相依性的部分，也安裝了一些開發 Angular 時會用到的額外插件，算是安裝一套，就全部搞定的感覺。\n\n![](https://i.imgur.com/JOsg19d.png)\n\n## 小結\n以上就是開發 Angular 時可能會用到的所有工具，接下來我們就可以著手建立 Angular 專案囉。\n","tags":["學習筆記"],"categories":["前端學習"]},{"title":"HTTP_Game攻略(二)","url":"%2Fnote%2F20190515%2F1070876814%2F","content":"\n## 前言\n重提一下 **[Lidemy HTTP Challenge](https://lidemy-http-challenge.herokuapp.com/start)**\n是 Huli 在程式導師計畫中推出來讓我們練習的小遊戲，用來加深對於 HTTP 通訊協定的觀念。\n\n在 [HTTP_Game攻略(一)](https://pvt5r486.github.io/note/20190513/2430981100) 中，我們完成了前面 10 關的挑戰，但是前面 10 關只是開胃菜，繼續往前邁進吧！\n\n![](https://images.unsplash.com/photo-1491193348662-47874a96c621?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1355&q=80)\n\n## LV.10\n休息關卡，前往下一關的網址為\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv11?token={IhateCORS}\n```\n\n## LV.11\n新的挑戰就要搭配新的 [API 文件](https://gist.github.com/aszx87410/0b0d3cabf32c4e44084fadf5180d0cf4)\n\n### 關卡要求\n利用此 API 文件內提供的方法，跟伺服器打個招呼。\n\n### 解法\n這一題如果直接使用 GET 方法，會得到這段系統提示：\n> 您的 origin 不被允許存取此資源，請確認您是從 lidemy.com 送出 request\n\n因此，我們需要在 `header` 內偽造 `origin` ，具體作法如下\n```js\nvar request = require('request');\nvar options = {\n  url: 'https://lidemy-http-challenge.herokuapp.com/api/v3/hello',\n  headers: {\n    'origin': 'lidemy.com',\n  }\n};\nfunction callback(error, response, body) {\n  console.log(body);\n}\nrequest.get(options, callback);\n```\n> 執行後得知 `token` 為 `{r3d1r3c7}`\n\n## LV.12\n### 關卡要求\n使用 API 文件提供的方法，獲得藏在其中的 `token`\n### 解法\n這一關不需要寫程式碼，要考驗的是會不會使用 chrome 開發者工具，打開瀏覽器後，按下 F12 ，然後在 Network 分頁中預備觀察 request ，並於網址列中輸入以下網址，訪問 API\n```\nhttps://lidemy-http-challenge.herokuapp.com/api/v3/deliver_token\n```\n會發現當訪問該 API 後，我們被轉址到其他地方了。\n順序如下:\ndeliver_token > stopover > deliver_token_result\n\n> 因此，中間的 stopover 就是關鍵！\n\n可以透過 Network 分頁觀察 stopover ，發現 header 內夾帶 `X-Lv13-Token: {qspyz}` 。\n\n## LV.13\n### 關卡要求\n這部份比較難敘述，因此直接引用題目內文：\n> 太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍\n可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗\n我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？\n從系統日誌裡面應該可以找到一些端倪。\n\n### 解法\n如果直接使用 GET 方法，會得到這段系統提示：\n> 此 request 不是來自菲律賓，禁止存取系統資訊。\n\n沒什麼頭緒，代入 `hint=1` 看看提示吧：\n> 你有聽過代理伺服器 proxy 嗎？\n\n看來是要我們設定跟 proxy 有關的東西了。\n\n我們可在 chrome 的設定頁面中搜尋 proxy ，即可開啟設定視窗\n![設定視窗](https://i.imgur.com/K48UDGk.jpg)\n![Imgur](https://i.imgur.com/1qaBsIw.jpg)\n\n接著就是上網搜尋 proxy 的站點了：\n* [菲律賓 proxy](http://free-proxy.cz/zh/proxylist/country/PH/http/ping/all)\n\n**勾選協議是 HTTP 按下搜尋，並挑選可用性高且速度快的設定上去吧。**\n這個步驟可能要重複多次，畢竟不是每個 proxy 都能用。\n\n接著在網址列輸入以下，訪問該 API\n```\nhttps://lidemy-http-challenge.herokuapp.com/api/v3/logs\n```\n> 成功可以看到以下畫面，得知 `token` 為 `{SEOisHard}`\n\n![取得 token](https://i.imgur.com/K6UEAxO.jpg)\n\n## LV.14\n### 關卡要求\n同樣是很難敘述的一關，直接上文章敘述：\n> 跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！\n不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的\n為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了\n他們的網站明明就什麼都沒有，怎麼會排在那麼前面？\n難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？\n算了，還是不要瞎猜好了，你幫我們研究一下吧！\n\n### 解法\n依然沒什麼頭緒，代入 `hint=1` 看看提示吧：\n> 伺服器是怎麼辨識是不是 Google 搜尋引擎的？仔細想想之前我們怎麼偽裝自己是 IE6 的。\n\n我們之前是透過修改 `User-Agent` 假裝自己是 IE6 ，所以這一題也是要從 `User-Agent` 著手。\n\n但在這之前，我們需要先了解，所謂的 `User-Agent` 是什麼：\n* [User-Agent 說明與使用](https://ithelp.ithome.com.tw/articles/10209356)\n\n在還沒接觸這個挑戰時，我一直以為 `User-Agent` 就是設定一串透過哪種瀏覽器名稱、瀏覽器版本號的字串，但解完這一題後，發現 `User-Agent` 其實還可以設定要使用哪種搜尋引擎。\n\n* [各个搜索引擎的User-Agent](http://www.lrxin.com/archives-325.html)\n\n因此這題的答案也呼之欲出了，只需要修改之前偽裝 IE6 瀏覽器那一題的程式碼即可。\n```js\nvar request = require('request');\nvar options = {\n  url: 'https://lidemy-http-challenge.herokuapp.com/api/v3/index',\n  headers: {\n    'origin': 'lidemy.com',\n    'User-Agent': 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',\n  },\n};\nfunction callback(error, response, body) {\n  console.log(body);\n}\nrequest.get(options, callback);\n```\n> 執行後得知 `token` 為 `{ILOVELIdemy!!!}`\n\n## LV.15\n恭喜破關～謝謝你跟著本文一路前進到這裡。\n如果覺得這個遊戲好玩，也請多多支持遊戲的開發者。\n* HTTP 遊戲開發者 [Huli](https://www.facebook.com/lidemytw/)\n* 作者聯絡信箱 huli@lidemy.com\n\n另外我也把這幾關有寫到程式的部份，放到 [Github](https://github.com/pvt5r486/HTTP_Challenge) 中，有需要可以自行下載研究哩 :D","tags":["程式導師計畫"],"categories":["雜記"]},{"title":"HTTP_Game攻略(一)","url":"%2Fnote%2F20190513%2F2430981100%2F","content":"\n## 前言\n[Lidemy HTTP Challenge](https://lidemy-http-challenge.herokuapp.com/start)\n是 Huli 在程式導師計畫中推出來讓我們練習的小遊戲，用來加深對於 HTTP 通訊協定的觀念。在第三期還沒正式開始之前，我就已經先玩過一次了，不過當時是使用 POSTMAN 通關，這次我打算使用 Node.js 搭配 [Request 套件](https://www.npmjs.com/package/request#promises--asyncawait)通關。\n\n![](https://images.unsplash.com/photo-1445499348736-29b6cdfc03b9?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80)\n\n## LV.0\n只是教學關卡，按照說明文建操作即可。\n\n**參數部份**\n* `token={...}` ，當成功解決關卡就會得知 token 內容，代入即可前往下關。\n* `&hint=1` ，看提示用\n\n因此輸入下列網址，前往下一關。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}\n```\n\n## LV.1\n* 得到一份之後會用到的 [API 文件](https://gist.github.com/aszx87410/3873b3d9cbb28cb6fcbb85bf493b63ba)\n\n### 關卡要求\n使用 get 方法把自己的 namr 傳給 Server 。\n\n### 解法\n操作網址列帶入參數即可。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}&name=Alvan\n```\n> 得知 `token` 為 `{HellOWOrld}`\n\n## LV.2\n### 關卡要求\n有本書的 id 是兩位數，介於 54 ~ 58 之間，找到是哪一本之後，把書的 id 傳給 Server 。\n\n### 解法\n操作網址列帶入參數 (id: 54 ~ 58 間) 即可。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv2?token={HellOWOrld}&id=56\n```\n> 用硬 A 法得知 `token` 為 `{5566NO1}`\n\n## LV.3\n查看 LV.1 時得到的[API 文件](https://gist.github.com/aszx87410/3873b3d9cbb28cb6fcbb85bf493b63ba)\n\n### 關卡要求\n新增一本書名是《大腦喜歡這樣學》，ISBN 為 9789863594475 ，接著把 id 傳給 Server\n\n### 解法\n```js\nrequest.post({\n  url:'https://lidemy-http-challenge.herokuapp.com/api/books', \n  form: \n    {\n      name:'《大腦喜歡這樣學》',\n      ISBN: 9789863594475\n    }\n  }, \n  function(err,httpResponse,body){\n    console.log('httpResponse', httpResponse);\n    console.log('body:', body);\n});\n```\n執行後獲得 `id` 為 1989 ，從網址列傳給 Server。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv3?token={5566NO1}&id=1989\n```\n> 得知 `token` 為 `{LEarnHOWtoLeArn}`\n\n## LV.4\n之後的關卡大多都需要查看 API 文件，就不贅述了。\n### 關卡要求\n搜尋書名有：「世界」兩字，而且是村上春樹寫的，接著把 id 傳給 Server\n\n### 解法\n直接代入參數 `q` 查詢是無效的，本題關鍵點在於使用 `encodeURI()` 轉換網址。\n```js\nlet str = '世界';\nlet uri = encodeURI(`https://lidemy-http-challenge.herokuapp.com/api/books?q=${str}`);\nrequest.get(uri, function (error, response, body) {\n  console.log(JSON.parse(body));\n});\n```\n執行後獲得 `id` 為 79 ，從網址列傳給 Server。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv4?token={LEarnHOWtoLeArn}&id=79\n```\n> 得知 `token` 為 `{HarukiMurakami}`\n\n## LV.5\n### 關卡要求\n刪除一本 id 是 23 的書\n\n### 解法\n使用 delete 方法，得到系統回傳的 `token`\n```js\nrequest.delete('https://lidemy-http-challenge.herokuapp.com/api/books/23', function (error, response, body) {\n  console.log(JSON.parse(body));\n});\n```\n> 得知 `token` 為 `{CHICKENCUTLET}`\n\n## LV.6\n獲得新的 [API 文件](https://gist.github.com/aszx87410/1e5e5105c1c35197f55c485a88b0328a)，往後都使用這一份。\n\n### 關卡要求\n獲得一組帳號密碼：\n* 帳號：admin\n* 密碼：admin123\n登入後，呼叫 /me 的 endpoint，得到一組 email 並傳給 Server\n\n### 解法\n由文件可知，必須準備好一組字串，內容為 `base64(username:password)` 。\n\n所以要對帳號以及密碼進行 base64 編碼， Node.js 可使用 `Buffer.from()` 進行 base64 編碼。\n得到 base64 編碼後，將其加入請求的 header 中。\n\n* 關鍵字 `http basic authorization` \n```js\nvar request = require('request');\nlet account = 'admin';\nlet pwd = 'admin123';\nlet base64Str = Buffer.from(`${account}:${pwd}`).toString('base64');\n//console.log(base64Str);\n\nvar options = {\n  url: 'https://lidemy-http-challenge.herokuapp.com/api/v2/me',\n  headers: {\n    'Authorization': `Basic ${base64Str}`\n  }\n};\n \nfunction callback(error, response, body) {\n  console.log(error);\n  console.log(JSON.parse(body));\n}\n \nrequest.get(options, callback);\n```\n執行後得知 `email` 為 lib@lidemy.com ，使用 `query string` 傳給 Server 。\n\n> 得知 `token` 為 `{SECurityIsImPORTant}`\n\n## LV.7\n### 關卡要求\n刪除 id 是 89 的書籍\n\n### 解法\n與上題差別不大，修改方法以及 API 即可\n```js\nvar request = require('request');\nlet account = 'admin';\nlet pwd = 'admin123';\nlet base64Str = Buffer.from(`${account}:${pwd}`).toString('base64');\n//console.log(base64Str);\n\nvar options = {\n  url: 'https://lidemy-http-challenge.herokuapp.com/api/v2/books/89',\n  headers: {\n    'Authorization': `Basic ${base64Str}`\n  }\n};\n \nfunction callback(error, response, body) {\n  console.log(error);\n  console.log(JSON.parse(body));\n}\n \nrequest.delete(options, callback);\n```\n> 執行後得知 `token` 為 `{HsifnAerok}`\n\n## LV.8\n### 關卡要求\n修改某書內名稱有個「我」且作者的名字是四個字， 輸入錯的 ISBN 最後一碼為 7 ，只要把最後一碼改成 3 就行了。\n\n### 解法\n* 查詢書籍，獲得正確 id 為 72\n* 修改書籍\n```js\nvar request = require('request');\nlet account = 'admin';\nlet pwd = 'admin123';\nlet base64Str = Buffer.from(`${account}:${pwd}`).toString('base64');\n//console.log(base64Str);\n\nfunction findBook(queryStr) {\n  let encodeUri = encodeURI(`https://lidemy-http-challenge.herokuapp.com/api/v2/books?q=${queryStr}`);\n  var options = {\n    url: encodeUri,\n    headers: {\n      'Authorization': `Basic ${base64Str}`\n    }\n  };\n  function callback(error, response, body) {\n    console.log(JSON.parse(body));\n  }\n  request.get(options, callback);\n}\n\nfunction updateISBN(content) {\n  var options = {\n    url: 'https://lidemy-http-challenge.herokuapp.com/api/v2/books/72',\n    contentType: 'application/x-www-form-urlencoded',\n    headers: {\n      'Authorization': `Basic ${base64Str}`\n    },\n    form: {\n      name: '日日好日：茶道教我的幸福15味【電影書腰版】',\n      ISBN: content\n    }\n  };\n  function callback(error, response, body) {\n    console.log(error);\n    console.log(JSON.parse(body));\n  }\n  request.patch(options, callback);\n}\n\n\n// 找出符合的書籍\nfindBook('我');\n// 修改資料\nupdateISBN(9981835423);\n```\n> 執行後得知 `token` 為 `{NeuN}`\n\n## LV.9\n### 關卡要求\n根據敘述，需要符合兩個條件才能使用這個 API\n* 帶上一個 `X-Library-Number` 的 header，我們圖書館的編號是 20\n* 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉\n拿到系統資訊之後取得 version 欄位內的值，並傳回 Server\n\n### 解法\n* 補上對應的 header\n* 偽造 IE6 的 `User-Agent` \n```js\nvar request = require('request');\nlet account = 'admin';\nlet pwd = 'admin123';\nlet base64Str = Buffer.from(`${account}:${pwd}`).toString('base64');\n//console.log(base64Str);\n\nlet encodeUri = encodeURI(`https://lidemy-http-challenge.herokuapp.com/api/v2/sys_info`);\nvar options = {\n  url: encodeUri,\n  headers: {\n    'Authorization': `Basic ${base64Str}`,\n    'X-Library-Number': 20,\n    'User-Agent': 'Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)',\n  }\n};\nfunction callback(error, response, body) {\n  console.log(JSON.parse(body));\n}\nrequest.get(options, callback);\n```\n執行後得知 `version` 值為 1A4938Jl7 ， 使用 `query string` 傳給 Server 。\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv9?token={NeuN}&version=1A4938Jl7\n```\n> 執行後得知 `token` 為 `{duZDsG3tvoA}`\n\n## LV.10\n### 關卡要求\n猜數字遊戲，規則如下：\n出題者會出一個四位數不重複的數字，例如說 9487。\n你如果猜 9876，我會跟你說 1A2B， 1A 代表 9 位置對數字也對， 2B 代表 8 跟 7 你猜對了但位置錯了。\n\n把要猜的數字放在 `query string` 用 num 當作 key 傳給 Server 。\n\n### 解法\n就慢慢嘗試，這是邏輯問題\n```\nhttps://lidemy-http-challenge.herokuapp.com/lv10?token={duZDsG3tvoA}&num=9876\n```\n最後得知正確數字為 9613\n\n> 執行後得知 `token` 為 `{IhateCORS}`\n\n## 後記\n到這邊基礎的 1 ~ 10 關已經全破了，然而後面還有 5 關比較進階的關卡可以挑戰，寫到這邊篇幅已經很長了，下一篇再繼續寫攻略。\n\n","tags":["程式導師計畫"],"categories":["雜記"]},{"title":"參加程式導師計劃的前四周心得","url":"%2Fnote%2F20190510%2F2820273868%2F","content":"\n## 前言\n因緣際會下參加了這個[**計劃**](https://medium.com/hulis-blog/mentor-program-3rd-47a2e85e33b3)，開始不間斷的自主學習，這是我的[**計劃 repo**](https://github.com/Lidemy/mentor-program-3rd-pvt5r486) ，有興趣的朋友可以點開來看看，每周我提交的作業也都會在上面。不過之後要是找到工作，可能就沒辦法兼顧這邊了，但我還是會想辦法完成它。\n\n![](https://cdn-images-1.medium.com/max/1600/0*pfbQln0L5sgsQa91)\n\n## Week 5\n這一周算是比較放鬆的週，主要就是拿來回顧、寫寫心得。\n\n前面幾周因為自己並不是毫無程式基礎的人，所以就算因為被其他的事情耽擱到一些進度也不要緊，算是還可以處理的範圍，因此前面幾周並沒有感受到特別的壓力。\n\n我也覺得自己真的很幸運，幾個月前我從來沒想到自己會走到這裡、參加這個第三期的實驗計劃，也不清楚自己是哪一點特質願意讓胡立免費讓我參加這一次的計劃，我只想說「**謝謝**」。\n\n在轉職前端的路上，我有太多的人要感謝了，大家都很熱情的幫助我，在我做的到的範圍裡，我也會持續的分享自己學習的紀錄。\n\n## Week 1\n因為自己是本科生的關係，所以計算機概論的知識算是有的，並沒有耗費太多時間在課程上，但我還是很認真的全部看完了。也算是複習了已經還給老師的排序法。\n\nGit 的部份雖然我之前已經有先學習過了，但我覺得多聽幾次有益無害，而且也多認識到如何發一個 PR 給別人，這還蠻有趣的。也讓我知道從開分支起到一系列的操作過程、發 PR 給別人 Merge ，這樣子的過程就是所謂的 GitHub flow ，算是又多了解一個名詞。\n\nCommand Line 的部份我也很喜歡，就覺得工程師就是要用 Command Line 輸入指令才帥啊，雖然比較不直覺是真的，需要一點時間適應。\n\n## Week 2\n這周開始進入到 基礎 JavaScript 的部份了，因為之前有學習過的關係，也沒有花太多時間在理解課程上，同樣是全部看過一次就開始練習寫題目了。透過這樣的題目練習，我明白果然學程式不能只用看的，還是要實際寫才能知道水深。\n\n而且，把**大問題逐步分解成一個個小問題**的心法很受用，覺得這一周最重要的莫過於這個心法了。\n\n## Week 3\n第三周是上一周的進階，而這一周的課程就是我比較欠缺的了，如:\n* npm\n* Webpack\n* ES6 語法\n* Jest\n* Babel\n\n等等一些較進階的東西，所以我也在自己的部落格寫了 8 篇跟 Webpack 相關的應用：\n\n* [[Webpack]No.1 模組化 JavaScript 的方法](https://pvt5r486.github.io/2019/04/30/Webpack/[Webpack]No.1%20%E6%A8%A1%E7%B5%84%E5%8C%96%20JavaScript%20%E7%9A%84%E6%96%B9%E6%B3%95/)\n* [[Webpack]No.2 package.json 設置專屬我倆的小咒語](https://pvt5r486.github.io/2019/05/01/Webpack/[Webpack]No.2%20package.json%20%E8%A8%AD%E7%BD%AE%E5%B0%88%E5%B1%AC%E6%88%91%E5%80%86%E7%9A%84%E5%B0%8F%E5%92%92%E8%AA%9E/)\n* [[Webpack]No.3 使用 Jest 進行 Unit Test](https://pvt5r486.github.io/2019/05/01/Webpack/[Webpack]No.3%20%E4%BD%BF%E7%94%A8%20Jest%20%E9%80%B2%E8%A1%8C%20Unit%20Test/)\n* [[Webpack]No.4 Babel 結合 Webpack 進行開發](https://pvt5r486.github.io/2019/05/02/Webpack/[Webpack]No.4%20Babel%20%E7%B5%90%E5%90%88%20Webpack%20%E9%80%B2%E8%A1%8C%E9%96%8B%E7%99%BC/)\n* [[Webpack]No.5 第二份 webpack.config 設定](https://pvt5r486.github.io/2019/05/04/Webpack/[Webpack]No.5%20%E7%AC%AC%E4%BA%8C%E4%BB%BD%20webpack.config%20%E8%A8%AD%E5%AE%9A/)\n* [[Webpack]No.6 讓 SCSS 也加入打包的行列](https://pvt5r486.github.io/2019/05/05/Webpack/[Webpack]No.6%20%E8%AE%93%20SCSS%20%E4%B9%9F%E5%8A%A0%E5%85%A5%E6%89%93%E5%8C%85%E7%9A%84%E8%A1%8C%E5%88%97/)\n* [[Webpack]No.7 把 HTML 也加入 Webpack](https://pvt5r486.github.io/2019/05/09/Webpack/[Webpack]No.7%20%E6%8A%8A%20HTML%20%E4%B9%9F%E5%8A%A0%E5%85%A5%20Webpack/)\n* [[Webpack]No.8 使用 Webpack 打包圖片](https://pvt5r486.github.io/2019/05/10/Webpack/[Webpack]No.8%20%E4%BD%BF%E7%94%A8%20Webpack%20%E6%89%93%E5%8C%85%E5%9C%96%E7%89%87/)\n\n花了不少時間，但我覺得很值得。用自己會一點點的技術去探索、到完成一個好像可以動的東西，這樣的成就感是非常巨大的。而這一周的作業也是相當的有挑戰性，我第一次寫大數加法，不過幸好沒遇到太大的瓶頸，因為提示蠻多的。\n\n## Week 4\n這一周開始提到網路原理，不得不說我覺得這個章節比喻得很好，最驚訝的是居然有發大財的梗，還以為這是出很久的課程了。\n\n而很巧的是，在這周之前我已經不知不覺地提早預習好了，原因是我有花 280 去買付費的講座，剛好有提到這些觀念。因此在本周的時候特別的得心應手，聽胡立講賣便當的故事時，也可以知道那些比喻的背後是在說些什麼，也更佳的佩服 Huli 怎麼可以把比喻成這樣 (稱讚意味)\n\n這周的作業我最喜歡的莫過於串接 Twitch API 了，我本來就是一個很喜歡看實況、打電動的宅宅，覺得可以串接這些 API ，撈出這些遊戲、頻道的資料感到相當開心，亦從中學習了不少東西，像是如何在 header 內加入對方要求的東西，使得請求可以通過驗證。","tags":["自我投資"],"categories":["雜記"]},{"title":"[Webpack]No.8 使用 Webpack 打包圖片","url":"%2Fwebpack%2F20190510%2F3988138546%2F","content":"\n## 前言\n總算是來到這個系列最後一篇了，前面雖然有提到如何使用 Webpack 打包 SCSS ，但如果 SCSS 內的語法有使用到圖片相關資源的話，可是會編譯失敗的，因為這部份又需要另外的 loader 處理，讓我們趕快來看看吧。\n\n![](https://cdn-images-1.medium.com/max/1600/0*hXoers0y8F6mARu7)\n\n## 先從 SCSS 內載入圖片開始\n### 準備環境\n* 新增資料夾 img 並放入圖片 A\n* 安裝 file-loader 這樣才能在 SCSS 內載入圖片\n```\nnpm install file-loader --save-dev\n```\n### 接著到 webpack.config 進行調整\n* 加入一組新的 `rules`\n```\n{  \n  test: /\\.(png|jpg|gif|jpe?g|svg)$/,  \n  use: [  \n    {  \n      loader: 'file-loader',  \n      options: {  \n        name: '[name].[ext]',  \n        publicPath: './img',  \n        emitFile: false  \n      }    \n    }  \n  ]  \n}\n```\n`file-loader` 有一些 `options` 可以設定，如果沒有特別設定圖檔名會是 hash 值，因此 `options` 內的設定分別為：\n\n* `name` ： `[name]` 為使用原本檔案的名稱； `[ext]` 則是副檔名，組合起來的意思就是，我們希望可以**保留原本檔案的名稱以及副檔名**\n* `publicPath` ：設定目標文件的路徑，白話說就是 SCSS 編譯後產生的 CSS 檔內圖檔的路徑\n* `emitFile` ：默認為 `true` ，如果為 `true` ，則將該檔案輸出。如果為 `false` ，則僅在 CSS 內寫入 `publicPath` ，而不會輸出該檔案。\n\n**另外還有很多設定可以調整，[詳見此](https://github.com/webpack-contrib/file-loader)**\n\n設定完之後 webpack.config 如下：\n\n![](https://cdn-images-1.medium.com/max/1600/1*TLWcPfRY66ioEfpmVnKGEQ.png)\n\n## 測試看看\n\n* 觀察 SCSS\n\n![引用背景圖片](https://cdn-images-1.medium.com/max/1600/1*IU9a534TdPdIHs_weUFl3g.png)\n![import 進 all.scss](https://cdn-images-1.medium.com/max/1600/1*r_dBEns-ZpIk4tuS2-yXyg.png)\n\n* 執行指令 `npm run dev`\n* 觀察編譯後的 all.min.css\n\n![背景圖路徑成功替換](https://cdn-images-1.medium.com/max/1600/1*VJ9PHb1tDP4RxAKC4LHSpQ.png)\n\n* 打開瀏覽器確認圖片是否成功載入\n\n![](https://cdn-images-1.medium.com/max/1600/1*z5Gf9TRZO5ZfqVDNdwx_cQ.png)\n\n> 到此，開發環境的設定成功！但還沒結束，我們也必須對 webpack.prod.conf 進行特別的調整才行。\n\n## webpack.prod.conf 的調整\n加入一組跟 webpack.config 一樣的 `rules` ，但在此我們必須做一些微調：\n```\n{  \n  test: /\\.(png|jpg|gif|jpe?g|svg)$/,  \n  use: [  \n    {  \n      loader: 'file-loader',  \n      options: {  \n        name: '[name].[ext]',  \n        publicPath: './img',  \n        outputPath: './img'  \n      }    \n    }  \n  ]  \n}\n```\n* `outputPath` ：檔案輸出的路徑\n\n## 測試看看\n\n* 輸入指令 `npm run build`\n\n![圖片輸出成功](https://cdn-images-1.medium.com/max/1600/1*Y--2t8cXdf5GH8aDuxBB4w.png)\n![CSS 內路徑也被替換了](https://cdn-images-1.medium.com/max/1600/1*dU0-eK28f3KK3mp8YCYWoQ.png)\n![瀏覽器運作正常](https://cdn-images-1.medium.com/max/1600/1*G2v2SQYROKODEjvXY8PJIA.png)\n\n> 確認圖片輸出沒問題後，我們還要額外加上圖片壓縮的功能。\n\n## 圖片壓縮\n\n要**部屬**出去的圖片是需要進行**壓縮**的，否則圖片動輒幾 MB 哪受的了。\n\n* 安裝 [image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader)\n```\nnpm install image-webpack-loader --save-dev\n```\n比較不同的是，這個 loader 的執行必須在 `file-loader` 之前，畢竟要**先壓縮後打包**。因此修改配置如下：\n```\n{  \n  test: /\\.(png|jpg|gif|jpe?g|svg)$/,  \n  use: [  \n    {  \n      loader: 'file-loader',  \n      options: {  \n        name: '[name].[ext]',  \n        publicPath: './img',  \n        outputPath: './img'  \n      }    \n    },  \n    {  \n      loader: 'image-webpack-loader',  \n      options: {  \n        bypassOnDebug: true,  \n      }  \n    }  \n  ]  \n}\n```\n## **搞定，接著我們試試看吧！**\n* 觀察原始圖片大小\n\n![](https://cdn-images-1.medium.com/max/1600/1*GXKYQQKLVxX4azxP4nST9g.png)\n\n* 執行指令 `npm run build`\n\n![壓縮成功](https://cdn-images-1.medium.com/max/1600/1*68HlNYs6vuCIUPz_ag3MpQ.png)\n壓縮成功\n\n> **至此，設定全部成功，享受這份成果吧！**\n\n## 心得\n終於寫完 Webpack 系列了，這一系列並不是很深入研究 Webpack 每個細節的類型，我寫這些文章只是為了記錄自己如何把 Webpack 應用在實務上，並且逐步的探索有哪邊需要學習。\n\n所以這一系列的起點從「如何模組化 JavaScript」開始，模組化之後我可以做什麼？模組化之後我可以進行單元測試，所以寫了「如何進行使用 Jest 進行單元測試」等等，諸如此類的小問題，最後完成這一整個系列。\n\n當然 Webpack 還有很多很多我沒寫到而且很實用的東西，像是可以使用 Webpack merge 讓每個設定檔不會這麼又臭又長。\n\n這部份推薦六角分享團內另外一個大大 [慢慢變強的工程獅](https://medium.com/@cos214159) 寫的 [Webpack 筆記](https://medium.com/@cos214159)，目前連載到第 15 篇了，還不趕快追起來 ~\n\n我在寫這系列的文章時，有不少也是參考他的文章，真的對我幫助很大！\n\n也深刻的體會到，學習東西時，如果有一份淺白易懂的文件可以參考，是多麼幸福的事情！\n\n因此這可能不是一份高手向的 Webpack 文章，敘述用語、技巧可能不是非常正確，還請前輩們不吝指導分享。\n\n> 如果能夠幫助到跟我程度差不多的朋友，那就太好了。\n\n**以下附上文章連結 (按順序)**\n* [[Webpack]No.1 模組化 JavaScript 的方法](https://pvt5r486.github.io/webpack/20190430/3052134826)\n* [[Webpack]No.2 package.json 設置專屬我倆的小咒語](https://pvt5r486.github.io/webpack/20190501/1043079870)\n* [[Webpack]No.3 使用 Jest 進行 Unit Test](https://pvt5r486.github.io/webpack/20190501/1835145669)\n* [[Webpack]No.4 Babel 結合 Webpack 進行開發](https://pvt5r486.github.io/webpack/20190502/2179081137)\n* [[Webpack]No.5 第二份 webpack.config 設定](https://pvt5r486.github.io/webpack/20190504/374010663)\n* [[Webpack]No.6 讓 SCSS 也加入打包的行列](https://pvt5r486.github.io/webpack/20190505/611388121)\n* [[Webpack]No.7 把 HTML 也加入 Webpack](https://pvt5r486.github.io/webpack/20190509/2730949378)\n* [[Webpack]No.8 使用 Webpack 打包圖片](https://pvt5r486.github.io/webpack/20190510/3988138546)\n\n**GitHub**\n* [原始碼](https://github.com/pvt5r486/0430module)","tags":["Webpack"],"categories":["Webpack"]},{"title":"[Webpack]No.7 把 HTML 也加入 Webpack","url":"%2Fwebpack%2F20190509%2F2730949378%2F","content":"\n## 前言\n在我們知道如何調整 SCSS 並且成功打包輸出後，接著要嘗試打包 HTML 檔。\n\n![](https://cdn-images-1.medium.com/max/1600/0*KguC0HWFAVgh1Kdt)\n\n## 打包 HTML\n我們之前都是手動把 index.html 檔案加入到 dist 資料夾內，並且引用 CSS 與 JavaScript 檔案，現在我們要嘗試把 index.html 也一起打包。\n\n## 安裝 html-webpack-plugin\n```\nnpm install html-webpack-plugin --save-dev\n```\n同樣的在檔案開頭 `require` 進來，並且在 `plugins` 區塊加入設定：\n```\nconst HtmlWebpackPlugin = require('html-webpack-plugin');  \nmodule.exports = {  \n---略---  \n  plugins: [  \n    new MiniCssExtractPlugin({  \n      filename: '../dist/all.min.css',  \n    }),  \n    new HtmlWebpackPlugin({  \n      title: '首頁',  \n      filename: 'index.html',  \n      template: './index.html'  \n    })  \n  ]  \n}\n```\n* `title` - 輸出的 title 名稱\n* `filename` - 輸出檔名\n* `template` - 套用的模版\n\n這個輸出的檔案預設會引入 Webpack 打包之後的所有檔案(像是 .css 、 .js )，若是想要輸出多頁，則需要設定多個 `HtmlWebpackPlugin` 物件。\n\n### 調整路徑\n接著還需要調整一下路徑， `HtmlWebpackPlugin` 打包後產生的 HTML 內，這兩隻檔案的路徑就是根據對應的 `filename` 上的路徑怎麼寫的。\n\n> **做完這個步驟後，整體看起來會像是這樣：**\n\n![](https://cdn-images-1.medium.com/max/1600/1*Fp0Rey1uMMkT_5Pt0_kGDQ.png)\n\n### 設定樣版\n接著指定樣版為我們目前使用的 index.html ，然後把原先我們手動設定好的路徑全部都移除，不然會重覆。\n\n![](https://cdn-images-1.medium.com/max/1600/1*avPGQiMtsMn7UKPLAYI8Lg.png)\n\n### 設定好了，試試看吧！\n```\nnpm run build\n```\n![](https://cdn-images-1.medium.com/max/1600/1*-YSKiUaMFsqCqs0OWq2TWQ.png)\n\n## 美中不足的地方\n雖然設定好了，但有個地方的問題沒有解決，列出問題點如下:\n\n### 問題點\n* 作為樣版的 index.html 裡面不可以手動引入 JS 、 CSS 檔案否則打包後 HTML 內會重覆\n* 但如果 index.html 不手動引入 JS、 CSS 檔案，就沒辦法開發了\n* 如果考慮開發的 config 檔也加入 `HtmlWebpackPlugin` 設定，並同樣使用 index.html 作為模版，也會陷入死胡同。\n\n> 目前我有想到一個方式，但**可能不是最好的辦法，僅供參考**。\n\n### 解決的辦法：\n* 調整檔案結構，讓開發時的結構與打包部屬時的結構一致\n\n![](https://cdn-images-1.medium.com/max/1600/1*MegwDSxjdKTh5MD8p5sVrw.png)\n\n把要當成樣版的 index.html 搬到 src 資料夾內，這樣就可以使用相對路徑 `./all.min.css` 、 `./all.min.js` 引入對應檔案。\n\n* 修改開發用的 config 檔 - 調整編譯後的 .js 檔案名稱\n\n**調整後的 webpack.config 如下：**\n\n![不使用 HtmlWebpackPlugin](https://cdn-images-1.medium.com/max/1600/1*ZjFYJuH39C-pko5ohfBn5g.png)\n\n* 因為做為樣版的 index.html 移動了，所以 webpack.prod.conf 內也需要相對的調整，並且在 `HtmlWebpackPlugin` 追加設定：\n```\nplugins: [  \n  new MiniCssExtractPlugin({  \n    filename: './all.min.css',  \n  }),  \n  new HtmlWebpackPlugin({  \n    title: '首頁', // 輸出的 title 名稱  \n    filename: 'index.html', // 輸出檔名  \n    template: './src/index.html', // 套用的模版  \n    inject: false　// 不引用 CSS、JS 檔  \n  })  \n]\n```\n## 接著來測試看看吧\n透過這樣的調整，讓開發環境與部屬打包後的路徑一致，就可以在開發時先把路徑寫好，只透過 `HtmlWebpackPlugin` 幫我們產生其他的部分。\n```\nnpm run build\n```\n![dist 內的 index.html](https://cdn-images-1.medium.com/max/1600/1*f771mfX1bK4zN8PGP3XEdQ.png)\n\n> 這樣子就搞定了，雖然不確定這是不是最好的做法，但這是我目前想到的解法，就參考看看吧。","tags":["HTML"],"categories":["Webpack"]},{"title":"[Webpack]No.6 讓 SCSS 也加入打包的行列","url":"%2Fwebpack%2F20190505%2F611388121%2F","content":"\n## 前言\n接著我們要讓 Webpack 也支援 SCSS ，輸入指令後轉成 CSS 並且優化之後打包輸出，同樣地延續上一篇的專案資料夾。\n\n![](https://cdn-images-1.medium.com/max/800/0*Mk96FibxoYNY1zRT)\n\n## 建立 & 調整部份檔案\n* 於 src 資料夾內建立 scss 的資料夾，並且在裡面建立一些 .scss 的檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*r7AwkFRSF8e11IWHlJZjDQ.png)\n\n* 並且個別再 _a.scss 、 _b.scss 內寫了一些 CSS 語法，觀察變化。\n* index.html 也做一些微調，我希望使用 `dev` 指令時會輸出再 src 內，並且以 all.min.css 的檔名出現。\n\n![](https://cdn-images-1.medium.com/max/800/1*kXHtVUoYJJrMmRCw4bHNzg.png)\n\n## 安裝對應的 loader 與 plugins\n\n最基本的 Webpack 功能其實只有 Javascript 部份，因此若是希望 Webpack 也能幫我們做更多事情的話，就必須要仰賴相對應的 loader 與 plugins 。\n\n## 因此規畫之後我們需要以下的東西：\n* `css-loader` : 載入 .css 的檔案\n* `mini-css-extract-plugin` : 將 CSS 輸出成檔案\n* `sass-loader` : 載入 .scss 的檔案\n* `node-sass` : Sass 的編譯器\n\n**順序大致上是這樣的**：\n\n> sass-loader 載入 .scss 檔 > 編譯成 css 檔 > css-loader 載入 .css 檔 > 最後則是給 mini-css-extract-plugin 打包成檔案。\n\n全部串在一起下載回來吧！\n\n![](https://cdn-images-1.medium.com/max/800/1*9t4dj6-o8zYryPhskLucNA.png)\n![](https://cdn-images-1.medium.com/max/800/1*9CZU05MN_SrAnDQx7ZtV8A.png)\n\n## webpack.config 添加對應的設定\n\n由於上一篇提到的問題，所以我們將設定拆成了開發用以及部屬用的兩隻設定檔。\n\n![前情提要一下](https://cdn-images-1.medium.com/max/800/1*b4squ4jGLBlf7dcii13giQ.png)\n\n接下來我們要在開發用設定檔裡面增加 `loader` 設定，在物件 `module` 底下會有一個 `rules` 的陣列，在這個陣列裡面放置的每一個物件，是當 Webpack 無法辨識目前要載入的資源檔時，會到這邊去查找看看有沒有相對應的載入方式，在這個物件裡面會有兩個屬性：\n\n* `test` : 是一個正規表示式，主要是去查找目前要載入的檔案，有沒有跟這個正規表示式符合\n* `use` : 表示我們載入檔案要使用的 `loader`\n\n> 值得注意的是， Webpack 調用 `loader` 的順序是從**後面到前面**\n\n### 動手設定如下\n\n* 把 `mini-css-extract-plugin` 給 `require` 進來\n```\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n```\n* `use` 陣列內依序填入 `MiniCssExtractPlugin.loader` 、`css-loader`、 `sass-loader`\n* `test` 正則表達式的部份也要修改成 `test: /\\.(scss|sass)$/,`\n* 於 `module` 區塊下方補上 `plugins` 區塊\n```\nplugins: [  \n  new MiniCssExtractPlugin({  \n    filename: './src/all.min.css',  \n  })  \n]\n```\n這一段主要是使用 `MiniCssExtractPlugin` 指定 .css 檔案該輸出到哪裡。\n\n做完這些調整後，會長的像這樣：\n\n![](https://cdn-images-1.medium.com/max/800/1*D9gWyMUhqykh0-t6zycoAQ.png)\n\n> 別忘了我們的進入點是 all.js ，需要把 .scss 檔案給載入才會一起打包哦。\n\n![](https://cdn-images-1.medium.com/max/800/1*CSB8sIm_y5k5GUz1dTED_A.png)\n\n> 做到這邊先測試看看吧～ `npm run dev`\n\n![](https://cdn-images-1.medium.com/max/800/1*2PNzxcmM8f_z_KL9bETtzQ.png)\n\n網頁的部份也沒有問題哩！\n\n![](https://cdn-images-1.medium.com/max/800/1*nyX3NwYf0SHuybX0wSNKrQ.png)\n\n> 而且因為使用了 `--watch` ，每當檔案有異動、按下存檔時都會再度編譯，是不是跟 VS CODE 的插件 Live Sass Compiler 用起來體感相似呢？\n\n## 部屬時的 config 檔 也需要補上設定\n\n所以我們將剛才設定的內容都複製一份到這裡，我們會覺得有很多重複的東西感覺很不智慧，事實上這可以利用 Webpack-merge 來處理重複的部份，但這不在這次的討論範圍內，為了控制篇幅，就不提了。\n\n### 這邊附上相關的介紹\n* [Webpack 筆記整理 (七) — Webpack merge](https://medium.com/@cos214159/webpack-%E7%AD%86%E8%A8%98%E6%95%B4%E7%90%86-%E4%B8%83-webpack-merge-88b11227d180)\n\n### 調整後檔案設定如下\n\n![](https://cdn-images-1.medium.com/max/800/1*qS_ptYBJNhhK30bD-cXMKA.png)\n\n> 別忘了輸出路徑也要調整一下，才會輸出到正確的地方唷。\n\n### 確認一下輸出結果：\n\n![](https://cdn-images-1.medium.com/max/800/1*rYI1I5hnlUSpy4bVfRcPjA.png)\n\n雖然結果是正確的，但不夠理想。\n\n畢竟這是正式部屬的設定檔，我們需要針對 .css 做壓縮才行。\n\n### 使用 `optimize-css-assets-webpack-plugin`\n\n這個套件將幫助我們把 CSS 優化，馬上輸入指令下載回來\n```\nnpm install optimize-css-assets-webpack-plugin --save-dev\n```\n* 將 `optimize-css-assets-webpack-plugin` 載入\n* 接著再 `module` 下方額外加入 [optimization 物件](https://webpack.docschina.org/configuration/optimization/)，如：\n\n```\noptimization: {  \n  minimizer: [  \n    new OptimizeCssAssetsWebpackPlugin()  \n  ]  \n},\n```\n## 調整完之後，整體配置如：\n\n![](https://cdn-images-1.medium.com/max/800/1*uoANZzotPL2iVrBe5uzYIg.png)\n\n看起來完成了，測試看看吧！\n\n![](https://cdn-images-1.medium.com/max/800/1*PnZDS_UnFqjrhPuGuxmjFQ.png)\n\n> **成功的壓縮了，但...事情沒這麼簡單，我們的原先由 Webpack 自動幫我們壓縮好的 all.min.js 失去壓縮了。**\n\n![](https://cdn-images-1.medium.com/max/800/1*VHRlQNrrli0D1Y-y3QVaNA.png)\n\n## 為什麼 JavaScript 失去壓縮了\n\n因為 Webpack 預設是當我們使用部屬模式時，會自動的幫我們壓縮 .js 檔案，但是當我們自行加入 `optimization` 區塊時，它就會認為我們要自己管理，也就是說我們現在必須額外加入壓縮 JavaScript 的套件。\n\n* 加入 `terser-webpack-plugin`\n```\nnpm install terser-webpack-plugin --save-dev\n```\n\n如同加入 CSS 壓縮功能的步驟：\n\n* 將 `terser-webpack-plugin` require 進檔案\n* optimization 物件加入以下\n```\noptimization: {  \n  minimizer: [  \n    new TerserWebpackPlugin(),  \n    new OptimizeCssAssetsWebpackPlugin()  \n  ]  \n},\n```\n## 調整完之後，整體配置如：\n\n![](https://cdn-images-1.medium.com/max/800/1*jXYa6R7h9Fy5raND79ow-Q.png)\n\n再次測試看看吧！\n\n![](https://cdn-images-1.medium.com/max/800/1*Dhfo-FHpp18O9EpgWDMzuA.png)\n![](https://cdn-images-1.medium.com/max/800/1*7qv0As3Z2SXTG8oZCPLWCg.png)\n\n> **至此，設定全部都完成了呢！**\n\n## 替 CSS 加上前綴詞，讓開發更便利\n現在瀏覽器這麼多種，為了相容各式各樣的瀏覽器，有些時候我們得在 CSS 語法前手動補上一些前綴詞，才能在相應的瀏覽器內生效，但是這樣子不夠智慧。\n\n聰明的工程師想出了一套解決辦法：\n\n* [postCSS](https://postcss.org/) 和 [autoprefixer](https://autoprefixer.github.io/)\n\n透過這兩個工具，自動的為我們補上前綴詞\n\n事不宜遲，馬上下載安裝\n```\nnpm install postcss-loader autoprefixer --save-dev\n```\n## 順序\n我們知道在 Webpack 內 loader 載入的順序是有差別的，因此在加入這些套件後，順序應該調整為：\n\n* `sass-loader` 編譯\n* 交由 `postcss-loader` 加上前綴詞\n* 在給 `css-loader` 處理\n* 最後由 `MiniCssExtractPlugin.loader` 打包輸出\n\n## 調整設定\n得知順序後，開始著手調整設定吧。\n\n調整後的設定檔如下：\n\n![](https://cdn-images-1.medium.com/max/800/1*BAd3HPGpfaXXh90RA6IJTQ.png)\n\n### 測試看看是否成功加上前綴\n\n![_a.scss](https://cdn-images-1.medium.com/max/800/1*lCArcUahGtARHNGRiW6NwQ.png)\n![all.min.css](https://cdn-images-1.medium.com/max/800/1*_vxyAYTtfO_0legyAy8nbg.png)\n\n> 成功了！可喜可賀！別忘了把部屬用的設定檔也補上哦。\n\n## 心得\n透過這樣一連串的設定，對於如何替 Webpack 加裝一些套件有更深刻的體驗，幸好這樣的設定只要做一次，後續就可以直接沿用，否則每次要做這麼多的設定也是很麻煩的。","tags":["SCSS"],"categories":["Webpack"]},{"title":"[Webpack]No.5 第二份 webpack.config 設定","url":"%2Fwebpack%2F20190504%2F374010663%2F","content":"\n## 前言\n延續之前的專案資料夾，我們目前不僅能[模組化管理 JavaScript](https://pvt5r486.github.io/webpack/20190430/3052134826) 、[使用 Jest 進行單元測試](https://pvt5r486.github.io/webpack/20190501/1835145669)、[針對 JavaScript 語法使用 Babel 進行降版](https://pvt5r486.github.io/webpack/20190502/2179081137)、還能夠[自訂一些看起來很酷的指令](https://pvt5r486.github.io/webpack/20190501/1043079870)，最後打包輸出 bundle.js 在 dist 資料夾中。\n\n> 但似乎有哪裡不對勁，不是嗎？\n\n![](https://cdn-images-1.medium.com/max/800/0*0uWax-8cprShITK3)\n\n## 問題在於開發與部屬的衝突\n* 當設定好環境，準備要進行開發時，使用了 `npm run dev` ，打包出來的 .js 檔案居然放在 dist 資料夾內，而不是放在 src 資料夾內。\n* 如果反過來將打包出來的 .js 檔案設置輸出在 src 資料夾內，就會變成部屬時 dist 資料夾沒有 .js 檔案了。\n\n> **這怎麼想都很奇怪，這樣肯定是不行的！**\n\n## 從 package.js 中的 scripts 指令參數下手\n還記得之前是如何自定指令的嗎？ `scripts` 內的指令可以透過設置參數的方式，套用客製的 webpack.config 設定：\n\n* `--config [config 檔案路徑]`：可指定要套用的 config 檔案路徑，使指令套用此設定檔\n\n## 建立第二份 webpack.config 吧\n我們將原本那一份 webpack.config 當成開發時期用，接著建立一個新的資料夾 build ，並把原本那一份設定檔另存改名成 webpack.prod.conf 。\n\n### 調整 scripts 指令的設定：\n\n![](https://cdn-images-1.medium.com/max/800/1*YDPmskH9kr3u8kZCTvoaDA.png)\n\n如果檔名設定成 webpack.config 的話， Webpack 預設會認這個檔名，因此使用 `dev` 指令時不需要額外指定，而 build 指令我們希望套用別的設定檔，因此需要加上 `--config` 參數\n\n## 個別調整二份 config 檔的輸出位置\n\n* webpack.config 方面，用於開發時，因此希望輸出在 src 資料夾內\n\n![](https://cdn-images-1.medium.com/max/800/1*X2EW1s52rhn1uKSPfQ2g2A.png)\n\n調整了 path 路徑，使其不產生資料夾，並指定檔案輸出路徑。\n\n* webpack.prod.conf 方面，用於部屬時，因此希望輸出在 dist 資料夾內\n\n![](https://cdn-images-1.medium.com/max/800/1*oiWnqAxI-io8a4frgoPO5A.png)\n\n## 實際執行看看\n\n* 首先執行 `npm run dev` ，看看檔案是否打包輸出再預期的位置\n\n![](https://cdn-images-1.medium.com/max/800/1*VjS5vz3Q0r2FRrYyACvEzA.png)\n\n* 接著輸入 `npm run build` ，測試看看\n\n![](https://cdn-images-1.medium.com/max/800/1*rrz5V9DmRm4ICNdED8NIQw.png)\n\n> **大功告成～距離完善整個開發環境又更靠近一步了。**\n\n## 心得\n這麼一來，我們的開發環境又更完整了一些，但這樣子還不夠！\n\n預期還要加入自動壓縮打包 SCSS 、圖片、網頁，這樣才能更貼近實務在開發網頁時的需求，因此這系列後面幾篇就會著墨在如何設定這些東西哩。要設定的東西真的蠻多的，幸好只要做好一次環境後，之後都可以用複製的。\n\n寫這一系列的時候， slack 內也有一位大大跟我寫類似的東西，他目前專注於 Webpack 上，寫得相當仔細，目前已經完成高達 14 篇關於 Webpack ，內容與各參數的說明是相當的詳盡，做為自己文章的補充，將連結寫在這：\n\n* [Webpack 筆記整理 系列](https://medium.com/@cos214159/webpack-%E7%AD%86%E8%A8%98%E6%95%B4%E7%90%86-%E4%B8%80-7fc63bcf1ecb)\n\n而我的這一系列文章的目標，主要是圍繞在「**如何使用 Webpack 手把手搭起一個開發專案**」，然而有些東西我也尚在探索，因此看到有相關文章可以參考是非常令人感到開心的！","tags":["Webpack"],"categories":["Webpack"]},{"title":"[Webpack]No.4 Babel 結合 Webpack 進行開發","url":"%2Fwebpack%2F20190502%2F2179081137%2F","content":"\n## 前言\n當我們使用的 JavaScript 語法瀏覽器不支援時，大家想到的第一個解決方案可能就是 Babel ，那麼說歸說，到底要怎麼跟先前提到的 Webpack 做結合，實際運用在開發上呢？讓我們繼續看下去~\n\n![](https://cdn-images-1.medium.com/max/800/0*5jLUiGP_W-92K_ba)\n\n## 環境設置\n* 可以使用 npm 的指令\n* 有安裝 Webpack 並有 package.json 、 webpack.config.js\n\n> 如果不知道這些是什麼，可參考\n* [[Webpack]No.1 模組化 JavaScript 的方法](https://pvt5r486.github.io/webpack/20190430/3052134826)\n* [[Webpack]No.2 package.json 設置專屬我倆的小咒語](https://pvt5r486.github.io/webpack/20190501/1043079870)\n* [Webpack教學 (四)：JavaScript 與 Babel](https://medium.com/@Mike_Cheng1208/webpack%E6%95%99%E5%AD%B8-%E5%9B%9B-javascript-%E8%88%87-babel-1d7acd911e63)\n\n## 需求描述\n現在有一支 all.js 的檔案為主要進入點，因為我們模組化管理 JavaScript 檔案的關係，所以在這支檔案內 `import` 了一些寫好的 JavaScript 檔案。\n\n但這些 JavaScript 檔案有些是使用 ES6 以上的語法完成，因此可能在較低版本的瀏覽器會有不支援的情況發生，因此希望結合 Babel 把 ES6 以上的語法轉換成比較舊版本的寫法，並且透過 Webpack 打包輸出至 build 資料夾。\n\n## 使用 npm 將 babel 下載回來\n為了達成這個需求，我們要下載以下的檔案\n* `@babel/core`：程式需要調用 Babel 的 API 進行編譯\n* `@babel/preset-env`：告訴 Babel 幫我們轉換成什麼版本的 JS 語法\n* `babel-loader`：Webpack 中要去讀取任何檔案格式都需要靠 loader 這個工具去做判讀，接著去做轉換。\n\n因此我們可以利用 npm 把語法通通組起來：\n\n![](https://cdn-images-1.medium.com/max/800/1*ybOsKQLYF2Nw3B9Pa6HZDQ.png)\n\n* `--save`：代表希望把安裝的資訊寫到 package.json 依賴內，這個部份在比較高版本的 npm 已經是預設值了，但我還是習慣加上。\n* `-dev`：有特別寫上的話，代表這是開發時才會用到的依賴項目\n\n若是成功安裝，package.json 內會長得像這樣：\n\n![](https://cdn-images-1.medium.com/max/800/1*gB5Ifoqf9UZ4IJhzkBJk3Q.png)\n\n## 寫上自訂的指令\n接著要在 package.json 內的 `script` 內自訂一些指令方便使用：\n\n![](https://cdn-images-1.medium.com/max/800/1*dkiTd2ggWquDsIRRBT58zA.png)\n\n* `test`：是之前使用 Jest 進行測試的指令，與本次無關\n* `build`：當專案完成時，使用這個指令將專案打包發布\n* `dev`：開發時使用的指令\n\n## 參數說明\n* `--mode`：可設置開發版本 (development) 及產品版本 (production)，差別在於有沒有進行最小化壓縮。\n* `--watch`：持續監控編譯後的檔案，當來源檔案有變動時立即重新編譯，執行後若想終止監控，則按下 `ctrl + c` 終止。\n\n## 調整 package.json 檔案\n* 調整**程式的進入點**以及要**輸出的目的地**\n\n![](https://cdn-images-1.medium.com/max/800/1*oAghXPCnweyai9cPKCeJWA.png)\n\n* 加上 `module` 屬性\n\n![](https://cdn-images-1.medium.com/max/800/1*pABGKPbE_mFYM9t9h2V2Cg.png)\n\n## 準備一段含有 ES6 語法的程式\n\n在 all.js 內使用 `let` 以及 `const` 來宣告變數\n\n![](https://cdn-images-1.medium.com/max/800/1*73OzXZJsYRYnXWr8CkuBgA.png)\n\n## 試著編譯\n\n先使用 `npm run dev` 觀察是否有透過 Babel 並且由 Webpack 編譯輸出：\n\n![](https://cdn-images-1.medium.com/max/800/1*9d8BY_wF0sAgcIJVg-dfFw.png)\n\n看起來是有順利輸出，來看看長什麼樣子\n\n![](https://cdn-images-1.medium.com/max/800/1*z97sgEHR7fneB-aCnXeesw.png)\n\n產生了一大堆的程式碼，而我們也可以發現原本使用 `let` 以及 `const` 來宣告的變數都被換成 `var` 了。\n\n![](https://cdn-images-1.medium.com/max/800/1*2_rRzZtPp8KDJMvn_PMsQw.png)\n\n> 而瀏覽器的部分也順利運行編譯後的程式碼。\n\n我們為了觀察而使用 `npm run dev` ，這會使編譯後的檔案並不是以優化的方式編譯，因此若做為正式發布，應該使用 `npm run build` ，這點要特別注意哦。","tags":["Babel"],"categories":["Webpack"]},{"title":"[Webpack]No.3 使用 Jest 進行 Unit Test","url":"%2Fwebpack%2F20190501%2F1835145669%2F","content":"\n## 前言\n在學會如何模組化管理 JavaScript 與自定指令後，接著我們可以結合這些觀念，進行有系統的測試。尚未接觸這些東西前，我們在開發時如何檢測自己的函式寫的正不正確呢？沒錯，就是老老實實的使用 `console.log` 印出來，確認完之後再刪除，但這樣子很不方便，而這篇的主題就是為此而生。\n\n![](https://cdn-images-1.medium.com/max/800/0*BqPJ2rsAjCJkFNaj)\n\n## 讓我們先準備這篇文章的環境\n\n* [[Webpack]No.1 模組化 JavaScript 的方法](https://pvt5r486.github.io/webpack/20190430/3052134826)：說明如何安裝 npm 與 Webpack\n* [[Webpack]No.2 package.json 設置專屬我倆的小咒語](https://pvt5r486.github.io/webpack/20190501/1043079870)：說明如何自定指令\n\n* index.html：引入一個使用 Webpack 打包後產生的 .js 檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*ZQp7NhG_BbUX5YGyBzTwmQ.png)\n\n* util.js：寫了一個待會測試的字串反轉函式，並將它 `export` 出去\n\n![](https://cdn-images-1.medium.com/max/800/1*FEY93nsdAT8vwruzKOjakQ.png)\n\n* all.js：`require util.js` ，並且令 all.js 為進入點\n\n![](https://cdn-images-1.medium.com/max/800/1*BU_vt9-5LQ8LGIZ_jlTbpQ.png)\n\n## 使用 console.log 進行測試\n這是最基礎也最常使用的，在還沒接觸更進階的知識前，我們要如何知道程式的結果是什麼、到底寫的正不正確、符不符合我們預期，就是使用 `console.log` 印出後自己判斷正不正確。\n\n> 於是我們使用指令打包後，到瀏覽器確認結果\n\n![](https://cdn-images-1.medium.com/max/800/1*wiCLy5JQTvAAJ8d0zKNokg.png)\n\n在我們還沒掌握更進階的技術之前，都是透過這種方式來確保自己的函式輸出的結果如同自己預期，但是現在我們有更好的選擇了，透過 npm 來安裝別人寫好的測試 module ，本次要介紹的就是 Jest 。\n\n> 程式中最小的結構單位就是以 function 為劃分，像這樣測試每一個 function 的結果是否正確就是所謂的**單元測試 (Unit Test)**\n\n## 使用 Jest 進行測試\nJest 是個 Facebook 開源計劃的項目，我們只要知道這樣就夠了，直接來動手做看看吧。\n\n* [Jest 官網](https://jestjs.io/)\n* 透過 `npm install jest --save-dev` 安裝\n\n![](https://cdn-images-1.medium.com/max/800/1*UMiztIrCgbS41_8XrNrahw.png)\n\n* 使用 Jest 進行測試的好處是，測試的檔案是分開的，因此我可以額外開個資料夾放這些測試的檔案，而檔名按照慣例是「要測試的檔名加上 .test.js」，因此最後看起來會是這樣：\n\n![](https://cdn-images-1.medium.com/max/800/1*JKchHV_SyDnWZ7ObgTapJA.png)\n\n* 接著開始寫 util.test.js 的內容\n\n![](https://cdn-images-1.medium.com/max/800/1*y_t6HI3k6zzGNLH0_y-KTw.png)\n\n其實蠻簡單明瞭的，這段程式大致說明如下：\n* `test()` 是 Jest 提供的 function，第一個參數為文字敘述，第二個參數則是傳入一個 function\n* `expect()` 則是傳入要接受測試的函式\n* `toBe()` 就是我們預期得到的結果\n\n### 準備的差不多了，運行看看吧\n\n* 使用 `npm run jest` - 測試所有的測試檔案\n* 使用 `npm run jest 要測試的檔案` - 測試指定檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*NOSJHIMXxq3yanHRUjAiSg.png)\n\n馬上就得到錯誤，原因是我們並非全域的安裝 Jest ，所以沒辦法直接使用下指令的方式來運行。\n\n因此有個做法是，當你的 npm 版本為 5.2 以上時，可以使用另一個指令：\n\n* npx jest\n\n> **與 npm 不同的地方在於，npm 是從作業系統開始找這個套件，npx 則是從專案開始找。**\n\n![](https://cdn-images-1.medium.com/max/800/1*VJSwxq6xGHKHVDVhg_QzQA.png)\n\n像這樣，很快的發現了我的第一個錯誤， `require` 路徑寫錯了，讓我修改一下。\n\n![](https://cdn-images-1.medium.com/max/800/1*BTAW7PpXNQ4dDOzfIfzlzw.png)\n\n* 如果你的 npm 版本不支援 npx ，你可以自訂指令\n\n![](https://cdn-images-1.medium.com/max/800/1*SKn8V3Kn8gXCn9hWyPxO3A.png)\n\n像這樣，可以輸入 `npm run test` ，可獲得一樣的結果：\n\n![](https://cdn-images-1.medium.com/max/800/1*tzDwYqw__22DNfm02zGFTA.png)\n\n> 而為什麼寫在 package.json 就可以呢？原因是因為寫在裡面的話， npm 就會知道要從專案開始找，因此就不會跳出找不到的錯誤訊息囉。\n\n## 使用 Jest 進行多個測試\n\n要測試一個函式是否沒有 Bug 自然需要多個極端的測試案例，像是：\n\n![](https://cdn-images-1.medium.com/max/800/1*KfJce2iHwnHUu7NAMZ9uag.png)\n\n雖然這樣沒什麼問題，但對於有強迫症的人來說這樣子太沒有組織性了，所以我們可以像這樣把這一坨包起來：\n\n![](https://cdn-images-1.medium.com/max/800/1*pV6MiVuYJ5LlCU46hxvBjg.png)\n\n* `describe()` 也是 Jest 提供的函式，可以幫助我們整理這些零散的測試。\n\n> 運行看看吧！\n\n![](https://cdn-images-1.medium.com/max/800/1*nL2vFocUt8JQUq_ImHBr7Q.png)\n\n> 而如果你故意寫錯的話～\n\n![](https://cdn-images-1.medium.com/max/800/1*6mp5yfzU_gRjOFHE8biQoQ.png)\n\n你就會得到一大堆的錯誤，並且會告訴你「預期得到什麼」、「實際上輸出什麼」。\n\n> 這樣是不是讓人更清楚這些東西是在幹嘛的呢?\n\n## 心得\n覺得自己似乎又朝著前端更成長了一點，以前聽到單元測試，總覺得是個很厲害但令人摸不著頭緒的名詞，沒想到現在我居然也是個知道怎麼寫單元測試的工程師了。","tags":["Unit Test"],"categories":["Webpack"]},{"title":"[Webpack]No.2 package.json 設置專屬我倆的小咒語","url":"%2Fwebpack%2F20190501%2F1043079870%2F","content":"\n## 前言\n於[[Webpack]No.1 模組化 JavaScript 的方法](https://pvt5r486.github.io/webpack/20190430/3052134826)我們知道了如何模組化 JavaScript ，但是每次只要有 .js 檔案有異動，就得輸入指令重新 bundle 一次，好麻煩啊。別擔心，工程師是最怕麻煩的生物，早就有措施囉，這篇要介紹的是其中一種方式，自訂專屬於自己的指令。\n\n![](https://cdn-images-1.medium.com/max/800/0*xzJvKfQurAI5VNWE)\n\n## 首先，讓我們回到上一篇的環境\n![](https://cdn-images-1.medium.com/max/800/1*SOqn17fhYnaYwd9ss4_zoQ.png)\n\n為了能順利的寫下自己的咒語，我們需要建立一個 package.json ，而且讓我們先閱讀一下課外讀物，了解之間的差異。\n\n* [package.json 與 package-lock.json 的差異](https://www.itread01.com/content/1543392248.html)\n\n## 建立一個 package.json\n\n* 輸入 `npm init`\n\n![](https://cdn-images-1.medium.com/max/800/1*HUs5nYb_JaafckXvK25dTg.png)\n\n會詢問你這個專案名稱叫什麼、版本號、等等的，如果都不想設定就快速的按下 Enter 吧。\n\n![](https://cdn-images-1.medium.com/max/800/1*TNoeisJEHVI_iXCLrx-OPw.png)\n\n最後會再次詢問你，是不是真的要建立。輸入 `yes`\n\n![](https://cdn-images-1.medium.com/max/800/1*VK88DV8GmBF43mvbFL1VGA.png)\n\n> 於是我們就建立了 package.json。\n\n### 設置專屬我倆的小咒語\n\n接著就到重頭戲啦，打開 package.json 可以發現有一段是這麼寫的：\n```\n\"scripts\": {  \n    \"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\"  \n},\n```\n這一段是預設給我們測試的，可以在下方輸入 `npm run test`\n\n![](https://cdn-images-1.medium.com/max/800/1*Px2wcsIOXWZ0RnN-R94kHA.png)\n\n然後我們就會得到這樣的結果，聰明如你，應該知道怎麼運用了吧？\n\n沒錯，我們接下來就是要把指令搬移到這邊。\n\n修改如下：\n\n![](https://cdn-images-1.medium.com/max/800/1*UlI_PtT4whQFbKXrO4LLug.png)\n\n> \"指令名\": \"指令內容\"\n\n這邊輸入中文只是為了博君一笑，當然開發時才不會這麼做呢。\n\n接著我們測試看看吧！輸入以下指令：\n\n```\nnpm run 重生吧前鬼我還你原形\n```\n\n![](https://cdn-images-1.medium.com/max/800/1*d6_CKSP7vD4Y7ZfCC50zew.png)\n\n看起來很順利的完成了！來看看瀏覽器的狀況吧～\n\n![](https://cdn-images-1.medium.com/max/800/1*MizD2emBy5yT2teDtT1v0g.png)\n\n> 運行也沒有問題，看來中文指令是大成功的哩～\n\n## 心得\n\n當我們在開發 Vue 時，輸入的 `npm run dev` 、 `npm run serve` 其實不是魔法，現在你學會了這招，是不是也能來個有創意的指令呢？\n\n> 當學的越多，慢慢的知道框架其實就是個高度包裝過後的東西，本來覺得像魔法的東西也逐漸的了解，這種感覺真的很棒。","tags":["Webpack"],"categories":["Webpack"]},{"title":"[Webpack]No.1 模組化 JavaScript 的方法","url":"%2Fwebpack%2F20190430%2F3052134826%2F","content":"\n## 前言\n如果網站的規模不大，可能單純寫一支 all.js 就能搞定了，但如果今天與別人合作或者網站規模比較大，這時若只單靠一支 all.js 肯定是落落長的程式碼，每次要修改就得找半天，這樣是非常辛苦的。所以我們需要模組化 JavaScript ，這樣會方便很多，而模組化的好處遠不只這些，就不贅述了。\n\n![](https://cdn-images-1.medium.com/max/800/0*_QHMblw0Ma_I580v)\n\n## 把檔案分開就好嗎 ? 這我以前就這麼做了！\n這邊的模組化的意思並不是把程式碼拆成多支 .js 檔並且在 index.html 內引入，因為這麼做其實並不算真正的把檔案分開，在 JavaScript 內仍然把它們視為同一個檔案，只是堆疊在一起，就好比這樣：\n\n## 前置作業\n* 準備一支 index.html ，並且引入兩支檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*VpcY9gQ7z5e5FYxyt-Jj_w.png)\n\n* math.js 內容如下\n\n![](https://cdn-images-1.medium.com/max/800/1*zxM_Ww3IQVZsr0VppmeT-g.png)\n\n* all.js 內容如下\n\n![](https://cdn-images-1.medium.com/max/800/1*x_LVX1uTAR3NeFnsX8R2bA.png)\n\n於是輸出結果，會發現 all.js 會把寫在 math.js 內的全域變數給印出來，這代表程式執行時它們會拼合成一支檔案，而透過觀察這麼做會產生 2 次的 request ，因為用了兩次的 script 標籤。\n\n![](https://cdn-images-1.medium.com/max/800/1*xUdpYGBLc89eiNjIjq1crA.png)\n\n## 使用 ES5 export 與 require\n\n接著我們使用 ES5 `module.exports` 與 `require` 試著將 math.js 模組化...。\n\n> **你會發現根本不能運行，因為 module.exports 與 require 只有 node.js 環境下才可以使用**。\n\n不管是 ES5 `module.exports` 與 `require` 或 ES6 `import` 與 `export` ，如果想在瀏覽器環境使用模組化 JavaScript 就必須透過 Webpack 來搞定！\n\n### 於是我們需要做一些事前準備：\n\n* 下載安裝 npm - 可以到 [node.js](https://nodejs.org/en/) 下載安裝包\n\n打開 CLI 輸入 `node -v` ，若出現版本號代表安裝成功。\n\n* 切換到上個範例的資料夾內，輸入 `npm install webpack webpack-cli — save -dev`\n\n![可以看到版本號代表成功安裝](https://cdn-images-1.medium.com/max/800/1*cj1x8MHpdtxdIa3anExfYw.png)\n\n接著可以到 [webpack 官網](https://webpack.js.org/)看看如何起手\n\n![](https://cdn-images-1.medium.com/max/800/1*vI7rVur9GO9xNWMxMlIyIw.png)\n\n好的，我們要先在專案資料夾內建立一個叫做 webpack.config.js 的檔案，接著複製貼上這些程式碼，而這些程式碼的涵義也很簡單：\n\n* `entry` : 進入點，代表引用這些 modules 最主要的地方\n* `path` : 檔案輸出的路徑\n* `filename` : 檔名\n\n都設置完之後，大致上長這個樣子：\n\n![](https://cdn-images-1.medium.com/max/800/1*9Qlhp4-XLbVxcmHq4UCtcg.png)\n\n接著回到 index.html ，引用我們打包後的 bundle.js 檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*oDIvVoSevJ3iL9T890Q9XA.png)\n\n> **這樣事前準備就都完成了，終於可以進入使用 ES5 module.exports 與 require 的部分。**\n\n* 首先在 math.js 內使用 module.exports 將函式匯出\n\n![](https://cdn-images-1.medium.com/max/800/1*cuCGS2VNRRLv9B7bxuvdtQ.png)\n\n* 接著 all.js 把檔案 require 進來\n\n![](https://cdn-images-1.medium.com/max/800/1*C1nHVS2JuDiE4B__EQ6Ncw.png)\n\n* 最後別忘了執行 `.\\node_modules\\.bin\\webpack` 打包產生檔案\n\n![](https://cdn-images-1.medium.com/max/800/1*VvF356wcoDH6re6X32Y6kw.png)\n\n> 接著我們就可以到瀏覽器上觀察囉~\n\n![](https://cdn-images-1.medium.com/max/800/1*_RYwVUZr2-FcWidO2A-lbQ.png)\n\n![](https://cdn-images-1.medium.com/max/800/1*q_vMaJ0fCA8p-aJooU435Q.png)\n\n> 發現函式的確成功的呼叫了，而且並不會受到 math.js 內的全域變數干擾，而且也因為只有使用一次 script 標籤，因此 request 只有一次。\n\n### 想匯出的不只一支函式？可以建立物件來達成！\n\n* math.js 內配置\n```\nvar math = '我是全域變數，會影響到其他人';\n\nfunction double(num){  \n  return num*2;  \n}\n\nfunction triple(num){  \n  return num*3;  \n}\n\nmodule.exports = {  \n  double: double,  \n  triple: triple,  \n};\n```\n* all.js 內配置\n```\nconst myModule = require('./module/math');  \nconsole.log(myModule.double(10));  \nconsole.log(myModule.triple(10));  \nconsole.log(math);\n```\n因為匯出的東西是物件，所以我們也必須使用物件的方式來取用。\n\n別忘了**使用指令打包輸出**，接著來看看結果：\n\n![](https://cdn-images-1.medium.com/max/800/1*Z-kEifw5_1IcsLXOxG9vpg.png)\n\n> 蠻簡單的，對嗎？\n\n## 使用 ES6 export 與 import\n\n使用 ES6 比較尷尬的點是，有些流覽器並沒有完全支援 ES6 語法，因此必須使用 ES5 或者透過 Babel 來轉換 ES6 的語法，目前 `export` 與 `import` 支援的程度如下：\n\n![](https://cdn-images-1.medium.com/max/800/1*zyjtjc8s8ODDIPlKb_V84Q.png)\n\n嗯...好像還是紅紅的，所以要使用之前還是得先查一下支援程度，或者就乾脆使用 Babel 搞定這一切。\n\n### 怎麼使用\n* math.js 配置\n\n![](https://cdn-images-1.medium.com/max/800/1*lJ_fTsDD2_eWxRguy1UoZQ.png)\n\n* all.js 配置\n\n![](https://cdn-images-1.medium.com/max/800/1*_3Jl81F-WvsYqqyBFC25sg.png)\n![](https://cdn-images-1.medium.com/max/800/1*h9N4UvLWK3KIAnWt8EWsRA.png)\n\n可以看出跟 ES5 的差別在哪裡：\n\n* 函式前面可以加上 `export` 代表匯出該函式\n* 使用 `import {}` 承接， {} 內變數名稱需與匯出的函式相同\n* 可以 `export` 的東西不只函式，變數也可以\n\n### 除了這樣子寫以外，還有一些變化\n\n* import 可以使用 `*` 號配合 `as` 賦予別名\n\n![](https://cdn-images-1.medium.com/max/800/1*k92WrndwX-T5qJ9vysYKGg.png)\n\n而這個 `myModules` 是什麼呢？\n\n![](https://cdn-images-1.medium.com/max/800/1*iFu9yH-BxQ8jk8SjdtDP2g.png)\n\n是個物件，所以可以像一般使用物件的方式一樣操作即可。\n\n* 不想每個函式都加上 `export` ，可以這麼做\n\n![](https://cdn-images-1.medium.com/max/800/1*bLkZpsbjy7xLWlWM5TNdRg.png)\n![](https://cdn-images-1.medium.com/max/800/1*uQCzX6GbVAhMS0A2_97xGg.png)\n![](https://cdn-images-1.medium.com/max/800/1*6lkmflCmHQnKDDg6r5c2Ng.png)\n\n> 這邊要特別注意的是 `export{ }` 並不是物件\n\n* `export` 配合 `default` ，就可以 `import` 時不加 { } ，但只能有一個 `default。`\n\n![](https://cdn-images-1.medium.com/max/800/1*GS4RwgGkaRy4oCjtNVY8JA.png)\n![](https://cdn-images-1.medium.com/max/800/1*2imC2ZcMtLFTI5Ub58oJ8A.png)\n![](https://cdn-images-1.medium.com/max/800/1*QPco9BR1xUF-Z8sf4NyrYQ.png)\n\n> 是不是覺得 import 沒有 { } 感覺比較順手呢？\n\n## 心得\n\n個人比較喜歡取 `import *` 號取別名配合 `export{ }` 的方式，感覺最順手。\n\nES6 雖然好用歸好用，不過這樣的方式似乎目前支援度還是蠻差的，還是得透過 Babel ，如果確定專案會用上 Babel 了，那就不用客氣的用吧！\n\n如果不想使用 Babel 那就使用 ES5的 `require` + `module.exports` 囉。\n\n這邊撞了蠻多牆的，因為一開始很單蠢，不知道模組化必須得透過 Webpack 才能進行，還很納悶的想說語法都沒錯怎麼不能跑。","tags":["Webpack"],"categories":["Webpack"]},{"title":"初級 JavaScript 題目練習","url":"%2Fjavascript%2F20190428%2F910365601%2F","content":"\n## 前言\n這周是參加[**計劃**](https://github.com/Lidemy/mentor-program-3rd-pvt5r486)的第二周，每一周都過得很充實，不斷為自己打底的同時，也期待未來能遇到好的公司。之前繳交 OK 的作業也都可以透過這個 repo 看到，放上來也算是一種督促自己的心裡吧。\n\n這篇主要分享一些第二周時寫的一些初級 JavaScript 題目，題目是由 [Huli](https://medium.com/u/f1fb3e40dc37) 擬定的，剛接觸 JavaScript 的朋友可以寫看看。\n\n![](https://cdn-images-1.medium.com/max/800/0*hSKVeaZpWgpIzvU3)\n\n## 練習 LV 1\n* 請你分別用 for loop 以及 while 迴圈，印出 1 ~ 9\n```\n// 1  \n// 2  \n// ...  \n// 9\n```\n\n* 請寫一個函式叫做 print，接收一個是數字的參數 n，並且印出 1~n\n```\n// 1  \n// 2  \n// ...  \n// n\n```\n\n* 寫一個函式 star，接收一個參數 n ，並印出 n 個 *\n```\n// star(1) 預期輸出：  \n// *  \n// star(5) 預期輸出：  \n// *****\n```\n\n* 請寫出一個叫做 starReturn 的 function 並且接受一個參數 n，能回傳 n 個 *\n```\n// console.log(starReturn(1)); 預期輸出：  \n// *  \n// console.log(starReturn(5)); 預期輸出：  \n// *****\n```\n\n* 請寫一個叫做 isUpperCase 的 functuon，並且接收一個字串，回傳這個字串的第一個字母是否為大寫\n```\n// isUpperCase(\"abcd\") 正確回傳值：false  \n// isUpperCase(\"Abcd\") 正確回傳值：true\n```\n\n* 請寫一個 function position，接收一個字串並回傳這個字串裡面的第一個大寫字母跟它的 index，若沒有則回傳 -1\n```\nposition(\"abcd\") 正確回傳值：-1  \nposition(\"AbcD\") 正確回傳值：A 0  \nposition(\"abCD\") 正確回傳值：C 2\n```\n\n* 請寫出一個函式 findSmallCount，接收一個陣列跟一個數字 n，回傳有多少個數小於 n\n```\n// findSmallCount([1, 2, 3], 2) 預期回傳值：1  \n// findSmallCount([1, 2, 3, 4, 5], 0) 預期回傳值：0\n```\n\n* 請寫一個函式 findSmallerTotal，接收一個陣列以及數字 n，回傳陣列裡面所有小於 n 的數的總和\n```\n// findSmallerTotal([1, 2, 3], 3) 正確回傳值：3  \n// findSmallerTotal([1, 2, 3], 1) 正確回傳值：0  \n// findSmallerTotal([3, 2, 5, 8, 7], 999) 正確回傳值：25  \n// findSmallerTotal([3, 2, 5, 8, 7], 0) 正確回傳值：0\n```\n\n* 請寫一個函式 findAllSmall，接收一個陣列跟一個數字 n，回傳一個裡面有所有小於 n 的數的陣列（需按照原陣列順序）\n```\n// findAllSmall([1, 2, 3], 10) 正確回傳值：[1, 2, 3]\n// findAllSmall([1, 2, 3], 2) 正確回傳值：[1]\n// findAllSmall([1, 3, 5, 4, 2], 4) 正確回傳值：[1, 3, 2]\n```\n\n* 請寫一個 function sum，接收一個陣列並回傳陣列中數字的總和\n```\n// sum([1, 2, 3]) 預期回傳值：6  \n// sum([-1, 1, 2, -2, 3, -3]) 預期回傳值：0\n```\n\n## 練習 LV 2\n* 請寫出一個 function stars，接收一個參數 n，並且按照規律印出相對應的圖案\n```\n// stars(1) 預期輸出：  \n// *  \n// stars(3) 預期輸出：  \n// *  \n// **  \n// ***\n```\n\n* 請寫出一個 function makeStars，接收一個參數 n，並且根據規律「回傳」字串\n```\n// makeStars(1) 正確回傳值：*  \n// makeStars(2) 正確回傳值：*\\n**  \n// makeStars(5) 正確回傳值：*\\n**\\n***\\n****\\n*****\n```\n\n* 請寫出一個函式 stars2 ，接收一個參數 n ，並依照規律印出圖形\n```\n// stars2(1) 預期輸出：  \n// *  \n// stars2(3) 預期輸出：  \n// *  \n// **  \n// ***  \n// **  \n// *\n```\n\n* 請寫一個函式 table，接收一個數字 n ，印出 n * 1 ~ n * 9 的結果\n```\n// table(1) 預期輸出：  \n// 1*1 = 1  \n// 1*2 = 2  \n// 1*3 = 3  \n// 1*4 = 4  \n// 1*5 = 5  \n// 1*6 = 6  \n// 1*7 = 7  \n// 1*8 = 8  \n// 1*9 = 9\n```\n\n* 請寫出一個 function table9to9，並列出 1 * 1 ~ 9 * 9\n```\n// table9to9() 預期輸出：  \n// 1*1 = 1  \n// 1*2 = 2  \n// 1*3 = 3  \n// .....  \n// 5*1 = 5  \n// 5*2 = 10  \n// 5*3 = 15  \n// ....  \n// 9*7 = 63  \n// 9*8 = 72  \n// 9*9 = 81\n```\n\n* 費式數列的定義為：第 n 個數等於前兩個數的總和，因此這個數列會長的像這樣：1 1 2 3 5 8 13 21 ….\n```\n// fib(0) = 0  \n// fib(1) = 1  \n// for n >=2, fib(n) = fib(n-1) + fib(n-2)  \n// 現在，請你寫出一個 fib 的函式，回傳位在第 n 個位置的數字  \n// fib(1) 預期回傳值：1  \n// fib(2) 預期回傳值：1  \n// fib(8) 預期回傳值：21\n```\n\n* 請寫出一個函式 reverse，接收一個字串，並且回傳反轉過後的字串。（禁止使用內建函式 reverse）\n```\n// reverse(\"abcd\") 預期回傳值：dcba  \n// reverse(\"12345aa\") 預期回傳值：aa54321\n```\n\n* 請寫一個函式 swap，接收一個字串，並且回傳大小寫互換後的字串\n```\n// swap(\"Peter\") 預期回傳值：pETER  \n// swap(\"AbCdE\") 預期回傳值：aBcDe\n```\n\n* 請寫出一個函式 findMin，接收一個陣列並回傳陣列中的最小值。（禁止使用內建函式 sort）\n```\n// findMin([1, 2, 5, 6, 99, 4, 5]) 預期回傳值：1  \n// findMin([1, 6, 0, 33, 44, 88, -10]) 預期回傳值：-10\n```\n\n* 請寫一個 function findNthMin，接收一個陣列以及一個數字 n，找出第 n 小的數字。（禁止使用內建函式 sort）\n```\n// findNthMin(\\[1, 2, 3, 4, 5\\], 1) 預期回傳值：1  \n// findNthMin(\\[1, 3, 5, 7, 9\\], 3) 預期回傳值：5  \n// findNthMin(\\[1, 1, 1, 1, 1\\], 2) 預期回傳值：1\n```\n\n## 練習 LV 3\n* 請寫一個 function sort，接收一個陣列並且回傳由小到大排序後的陣列。（禁止使用內建函式 sort）\n```\n// sort([ 6, 8, 3, 2]) 預期回傳值：[2, 3, 6, 8]  \n// sort([ 1, 2, 7 ,5]) 預期回傳值：[1, 2, 5, 7]\n```\n\n* 請寫出一個 function flatten，接收一個多維陣列並回傳「壓平」後的陣列。\n```\n// flatten([1, 2, 3]) 預期回傳值：[1, 2, 3]  \n// flatten([1, 2, [1, 2], [1, 3], 6]) 預期回傳值：[1, 2, 1, 2, 1, 3, 6]  \n// flatten([1, [2, [3, [4]], 5], 6]) 預期回傳值：[1, 2, 3, 4, 5, 6]\n```\n\n* 請寫一個 function tree，接收一個數字 n，按照規律列印出大小為 n 的聖誕樹\n```\n// 為方便顯示，因此把空白代換成底線，實際請輸出空白  \n// tree(2) 預期輸出：  \n// _*  \n// ***  \n// _*  \n// _*\n\n// tree(5) 預期輸出：  \n// ____*  \n// ___***  \n// __*****  \n// _*******  \n// *********  \n// ____*  \n// ____*  \n// ____*  \n// ____*  \n// ____*\n```\n\n* 請寫出一個 function winner，接收一個代表圈圈叉叉的陣列，並回傳贏的是 O 還是 X，如果平手或還沒下完，請回傳 draw\n```\n// winner([  \n// ['O', 'O', 'X'],  \n// ['O', 'X', 'X'],  \n// ['O', 'X', 'O']  \n// ]) 預期回傳值：O\n\n// winner([  \n// ['O', 'O', 'X'],  \n// ['O', 'X', 'X'],  \n// ['X', 'X', 'O']  \n// ]) 預期回傳值：X\n\n// winner([  \n// ['O', 'O', 'X'],  \n// ['O', 'O', 'X'],  \n// ['X', 'X', '']  \n// ]) 預期回傳值：draw\n```\n* 請寫出一個 function isPrime，給定一個數字 n，回傳 n 是否為質數。（質數的定義：除了 1 以外，沒辦法被所有 < n 的正整數整除）\n```\nisPrime(1) 正確回傳值：false  \nisPrime(5) 正確回傳值：true  \nisPrime(37) 正確回傳值：true\n```\n\n## 心得\n總共 25 題，目前的能力大概是 22 題能初見殺，不過用的時間比較多一些，還沒辦法秒解，有 3 題是不太熟或者完全沒想到所以放棄的。\n\n解題的過程蠻有趣的，也是再練習如何把問題切碎切小，而有些題目彼此也有關聯性，這邊也附上我自己解完題的答案：\n\n*   [Github](https://github.com/pvt5r486/JS_Practice)","tags":["自我投資"],"categories":["JavaScript"]},{"title":"[初探後端]No.6 新手訓練告一段落","url":"%2Fb2e%2F20190424%2F607011541%2F","content":"\n## 前言\n在經過了一些摧殘後，初學的菜鳥雖然對於 PHP 語法還不是相當熟，但起碼有些微的語感了，這篇沒有什麼重點，只是簡單交代一下最近用什麼小題目練習 PHP，而基礎的 PHP 大概就到此先告一段落。\n\n![](https://cdn-images-1.medium.com/max/800/0*zf_eat52iQEtg1-o)\n\n## PHP 小題目\n我總共做了四種不同類型的應用，不過基本上都脫離不了 CRUD ， 兩種是純粹的 PHP 練習，另外兩種則是練習用 PHP 開 API 做前後端分離。\n\n畫面都頗陽春，主要著重在功能面的實作練習。\n\n### Job Board 職缺報報\n* [程式碼](https://github.com/pvt5r486/jobBoard)\n\n這個題目是我剛接觸 PHP 的第一個題目，屬於純粹的 PHP 練習，沒有任何 JavaScript 。\n\n**主要練習：**\n* 職缺的 CRUD\n* 註冊與登入\n* Session 的身分驗證\n* 管理員可以審核職缺\n\n### myBlog 部落格\n* [程式碼](https://github.com/pvt5r486/myBlog)\n\n作為接觸 PHP 的第二個題目，同樣是屬於純粹的 PHP 練習。\n\n**主要練習：**\n* 更多的 CRUD 操作、像是文章的評論等等\n* 更複雜的資料庫關聯 - 一篇文章可以有多個分類\n* 取得資料後的合併\n\n### ToDoList\n* [程式碼](https://github.com/pvt5r486/myTodoList)\n\n接著就是練習如何開 API 給前端接了，這個就是大家熟悉新技術通常都會拿來練手的題目，然後也重新複習一些 jQuery 。\n\n**主要練習：**\n* 後端如何開 API 給前端\n* 開 API 需要知道的一些小細節\n* 透過 AJAX 做 CRUD\n* jQuery 一些好用的 API\n* 資料的拖拉排序\n\n### Calendar\n* [程式碼](https://github.com/pvt5r486/myCalendar)\n\n最後就是練習開更多的 API ，做更多的 CRUD、寫更多的 PHP 。\n\n**主要練習：**\n* 設定 HTTP Status Code\n* 透過 AJAX 練習更多的 CRUD\n* 練習更多的 jQuery\n* 知道如何畫出月曆、並且計算日期並補上前面與後面的灰色空格\n\n## 心得\n大概就是這樣吧，雖然不敢說非常熟悉 PHP 了，但至少有一點上手了。基礎的 PHP 到此告一段落，接著會想嘗試挑戰看看 Laravel 。","tags":["PHP"],"categories":["後端學習"]},{"title":"[初探後端]No.5 遇到程式問題，如何把問題切細變得容易解決","url":"%2Fb2e%2F20190418%2F1009477553%2F","content":"\n## 前言\nNo.4 寫完之後，我果然還是很在意自己這樣子寫可不可以，於是我就請了一位大大來幫我看看，是不是有哪些地方可以調整，然後給了我三個建議。\n\n![](https://cdn-images-1.medium.com/max/800/0*aWli5-QK3DLlx15d)\n\n## 前情提要一下\n[[初探後端]No.4 對文章加上多個分類](https://pvt5r486.github.io/b2e/20190416/4221665571)\n\n* ref 表名字可以換一下，太臭長了\n* 更新的部份，因為知道原始分類、也知道目標所以可以想成這樣  \n  * source: 1, 2, 3  \n  * target: 1, 3, 5, 7  \n> 寫出來就能比較清楚知道要**保留、刪除、新增**哪些。  \n而我之前的做法是**無差別刪除，然後新增 (比較簡單、偷吃步)**\n* 取得文章可以不用連這麼多次資料庫，試著練習資料結構處理\n\n## 從資料庫取得的資料\n\n![](https://cdn-images-1.medium.com/max/800/1*C_dJNsv-4nftt7UQz688qA.png)\n\n因為本身還在學習 PHP ，所以對 PHP 語法可能不夠熟悉，因此不知道如何動手，所以才有那種相當耗資源的寫法。於是給我建議的大大說，那不然你把它想成這樣的結構\n```\n[  \n  {id: 1, content: 'hello', category: 'HTML'},  \n  {id: 1, content: 'hello', category: 'JS'},  \n  {id: 1, content: 'hello', category: 'CSS'},  \n  {id: 2, content: 'hi', category: 'CSS'},  \n]\n\n// 處理成下面這樣  \n[  \n  {id: 1, content: 'hello', category: 'HTML,JS,CSS'},  \n  {id: 2, content: 'hi', category: 'CSS'},  \n]\n```\n\n> **試著用 JavaScript 去把這個資料轉化成你想要的樣子**。\n\n老實說我這題卡了 6 小時，看起來需求很簡單，不過實際上當真的要動手寫的時候，會發現腦袋幾乎是空白的，再次驗證程式不能只用**看的、想的**，要真的動手寫。\n\n一開始，我把注意力都放在 ES5、6 的陣列方法上， 像是 `reduce` 、 `filter` 、 `foreach` 等等，怎麼樣就是不知道該怎麼繼續做下去。\n\n也查了一些什麼物件合併、陣列合併的方法，但好像有看跟沒看一樣。\n\n後來大大給了我其他的提示：\n\n* 不要想成直接把 A 轉成 B ，想成如何利用 A 的資訊，重新建構出一個你想要的 B\n* 資料結構先改成以下，先想辦法拼湊成這樣\n* 不要去想什麼陣列方法，這題用 `for` 迴圈就能解決\n```\n[  \n  {id: 1, content: 'hello'},  \n  {id: 2, content: 'hi'},  \n]\n\n// 處理成下面這樣  \n{  \n  1: {  \n    content: 'hello'  \n  },   \n  2: {  \n    content: 'hi'  \n  }  \n}\n```\n於是我好不容易拼湊出來了，在卡了好一陣之後。\n```\nlet dataLen = data.length;  \nlet obj = {};\n\nfor(let i = 0; i < dataLen; i++){  \n  id = data[i].id;  \n  obj[id] = {content:  data[i].content};  \n}\n\nconsole.log(obj);\n```\n![](https://cdn-images-1.medium.com/max/800/1*N3W7nxmUb4GDUlHnfkYIeg.png)\n\n接著說也奇怪，我似乎慢慢地知道該怎麼做了，於是我把資料補回原本的那樣，然後繼續維持輸出成物件的形式。\n\n* 因為我要跑 `for` 迴圈，肯定要知道這個陣列的長度\n* 接著最困難的點就是，要怎麼判斷「當前 `data` 陣列內 的這個物件跟下一個物件是不是一樣的」\n\n> 如果一樣，需要對分類做合併；不一樣就新增\n\n對於第二點，我的做法是使用「**`type of` 檢查 `obj` 物件，如果物件內沒有對應的 `id` 屬性，會顯示 `undefined` ，代表這筆資料是不同的，必須新增**」\n\n```\nlet data = [  \n  {id: 1, content: 'hello', category: 'HTML'},  \n  {id: 1, content: 'hello', category: 'JS'},  \n  {id: 1, content: 'hello', category: 'CSS'},  \n  {id: 2, content: 'hi', category: 'CSS'},  \n]\n\nlet dataLen = data.length;  \nlet obj = {};  \nfor(let i = 0; i < dataLen; i++){  \n  if(typeof obj[data[i].id] === 'undefined'){  \n    obj[data[i].id] = {  \n      content:  data[i].content,  \n      category: data[i].category  \n    };  \n  } else {  \n    obj[data[i].id].category = `${obj[data[i].id].category},${data[i].category}`;  \n  }  \n}  \nconsole.log(obj);\n```\n![](https://cdn-images-1.medium.com/max/800/1*_Xo9EyH2n30aWZdjKs3syw.png)\n\n後來我覺得還是把 `id` 也包進物件內好了，所以又自己補上去。\n\n到這邊就整個都通了，接著要把它換成一開始要求的樣子，於是我查到一個好用的方法 `Object.values()` ，補上即可轉換。\n```\nlet arr = Object.values(obj)  \nconsole.log(arr);\n```\n![](https://cdn-images-1.medium.com/max/800/1*EQSVSS_t-YpkqW-ODAYUAQ.png)\n\n## 後記\n最困難的部分已經克服了，接著就是要回到 PHP 實作，邏輯基本上都沒變，只是語法要稍微調整一下，相信不是太大問題。\n\n最後 PHP 部份我也順利的完成了，這一篇主要記錄的是「**當遇到問題，如何把問題切細，變得容易解決**」，非常感謝給我建議的大大，也花了不少時間引導我。","tags":["PHP"],"categories":["後端學習"]},{"title":"[初探後端]No.4 對文章加上多個分類","url":"%2Fb2e%2F20190416%2F4221665571%2F","content":"\n## 前言\n突然意識到似乎很久沒有上來這邊寫寫文章了，最近都在埋頭練習 PHP 與 MySQL ，實做了一個超級陽春的 job board 與 blog ，初期弄一個簡單的 blog ，自然是沒什麼問題。但隨著需求的提升，就困難許多了，像是「**把一篇文章只能有一個分類，變成一篇文章允許多個分類**」，這件事情就會讓難度高上不少，而這篇就是記錄這個過程哩，順便也描述一下自己遇到什麼困難。\n\n![](https://cdn-images-1.medium.com/max/800/0*8Y9f6Uw-skvmSa0e)\n\n## 資料庫架構的調整\n做這樣的改變，首當其衝的必然是資料表與資料表之間的關聯，如果「一篇文章只有一個分類」，我們只需要再 `article` 的資料表內新增一個 `categoryID` 的欄位，然後需要時，透過 `join` 查詢這樣就搞定了。\n\n> 但如果是「**一篇文章有多個分類**」呢？\n\n* 在 `articles` 的資料表內新增一個 `categoryID` 的欄位，利用字串拼接的方式儲存？\n* 多建立一張資料表以下簡稱 `ref` 表，儲存文章與類別的關聯性\n\n> 我最後想想是選擇了第二種方式，感覺比較好。\n\n## 於是使用 Workbench 規劃如下：\n\n![](https://cdn-images-1.medium.com/max/800/1*dgJEY1AIibcr5-2JO8AhEA.png)\n\n### 文章的新增 C\n主要是 PHP 與 MySQL 與 HTML 上的調整。\n\n* 新增文章的網頁\n\n由於變成可以選擇多個類別，所以這部份的選單需要變成多選式的，而我也是第一次發現可以再 `name` 屬性內加上 [] ，使其傳回陣列。\n```\n<select multiple=\"multiple\" name=\"category[]\" id=\"category\">  \n ...  \n</select>\n```\n* PHP\n\n這部份我是選擇分開處理，因為根據畫的 modal 圖， `articles` 這張表其實跟類別已經沒什麼關係了，所以我選擇拆成兩段：\n* 先進行文章的新增，取得文章 `id`\n* 接著於 `ref` 表內新增文章與類別的關聯\n\n而資料庫部份使用 PDO 來連接，認為比較關鍵的語法就是\n```\n$pdo->lastInsertId();\n```\n這可以讓我取得最後一筆新增的 `id` ，這樣我就知道新增的那篇文章 `id` 是多少。\n\n### 文章的讀取 R\n主要是 PHP 與 MySQL 的調整。需要在 admin.php (後台) 把文章資料讀出來，但這部份也是我比較苦惱的，因為對於 SQL 的語法並不是很擅長，這一段雖然我有做出來，但總覺得如果我更熟悉 SQL 語法，應該可以更好做。\n\n* MySQL\n\n這部份我試了好一陣，總是沒辦法單獨使用 MySQL 就把文章、類別、關聯表的資料漂亮的串好，頂多就串成下面這樣。\n```\nSELECT a.*, b.name  \nFROM articles as a, categories as b, articleandcategory_ref as c  \nWHERE a.id = c.articleID AND b.id = c.categoryID  \nORDER BY a.created_at DESC\n```\n![](https://cdn-images-1.medium.com/max/800/1*EHB9FTjjT1RLcotVvxIqpA.png)\n\n但這樣我也不知道該怎麼用，因為我想要得到的結果是，每篇文章只有一筆資料，然後後面會帶上類別名稱這樣。\n\n**這部份我卡了很久，後來決定用比較笨的方法，跟新增文章一樣分成兩段：**\n\n* 先取得全部的文章，存成陣列\n* 對這個陣列進行 `foreach` ，取得每篇文章 `id` 後，再透過 SQL 語法取得該文章對應的類別，最後插入陣列。\n\n> 因為不確定這麼做好不好，感覺這樣很沒有效率。\n\n### 文章的更新 U\n主要是 PHP 與 MySQL 與 HTML 上的調整，這部份的 HTML 畫面也讓我卡了好一陣子，原因是當類別變成多選後，進入編輯時需要將對應的類別設定預設選取，這部份會卡關主要是邏輯卡住了，因為我用了兩層的 `foreach` ，腦袋轉不過來，應該會有更好的解法但我不知道。\n\n![](https://cdn-images-1.medium.com/max/800/1*zbIzqr6uvxhwTF2AKLFSkw.png)\n\n> 這部份我也是不知道有沒有比較好的做法，也不確定我這麼做對不對。因為如果是更新到類別的話，勢必得到 ref 表內做一些查詢、修改，也有可能把原本的 3 個類別改成 2 個類別，那這樣子要怎麼做出相應的處理呢？\n\n**所以這部份我後來想到的做法是**\n\n* 先更新文章本身\n* 到 `ref` 表內刪除所有跟**這篇文章的關聯並重建關聯**\n\n> 這麼做的好處就是不用管要怎麼處理了，反正就是重建新的關聯，只是我不確定這麼做好不好就是了，只是這樣子做讓我輕鬆不少。\n\n### 文章的刪除 D\n\n主要是 PHP 與 MySQL 的調整，不過也不是說想刪除文章就可以直接刪除文章，MySQL 是關聯式資料庫，從 modal 上看來，文章關係到了 `ref` 表與 `comment` 表，所以如果直接針對文章做刪除是肯定會失敗的。\n\n所以這部份的做法是：**逐一刪除有關聯的部份**\n* 透過該文章 `ID` 刪除 `comment` 內對應的資料\n* 接著刪除 `ref` 表內對應的資料\n* 最後才是刪除文章本體\n\n> 刪除的部份是相對簡單的呢。\n\n## 心得\n折騰了一陣子總算是把功能都做完了，不過卻也開始懷疑這樣的做法 O 不 OK 就是了，但有做出來總是好的！\n\n**畢竟先求有再求好，對吧？**\n\n![非常非常陽春的界面](https://cdn-images-1.medium.com/max/800/1*OETv7-2MquUM4M-AWPhHhQ.png)","tags":["PHP"],"categories":["後端學習"]},{"title":"[初探後端]No.3 PHP 與 MySQL 連線的方式","url":"%2Fb2e%2F20190406%2F3982341698%2F","content":"\n## 前言\n開始進行 PHP 的練習後，最重要的大概就是資料庫的操作了吧，對後端而言與資料庫的關係像是魚跟水般密不可分，我在實作練習時發現 PHP 有三種方式可以跟 MySQL 連線，所以想記錄一下有哪些，不過這些大致上都有前輩寫過了，所以就只是單純記錄。\n\n![](https://cdn-images-1.medium.com/max/800/0*y8Psgz0lPIgJN0j2)\n\n## PHP 與 MySQL 連線的方式\n* PHP-MySQL\n* PHP-MySQLi\n* PDO\n\n### 前人寫好的文章：\n* [淺談 PHP-MySQL, PHP-MySQLi, PDO 的差異](https://blog.roga.tw/2010/06/2403)\n* [MySQLi vs PDO 比較](https://ithelp.ithome.com.tw/articles/10209190)\n\n經過一輪的比較，似乎是 PDO 用途會比較廣，畢竟 PDO 連接資料庫時，透過 Data Source Name (DSN) 來決定要連接何種資料庫，只是我還有點不習慣 PHP ，所以寫起程式碼來綁手綁腳的。\n\n因為 PDO 有支援 `try...catch` 所以也可以好好運用，找到一篇蠻完整的範例。\n* [使用 try-catch 來撰寫 PDO 程式碼](http://ps.hsuweni.idv.tw/?p=5061)","tags":["PDO"],"categories":["後端學習"]},{"title":"[初探後端]No.2 使用 VS Code 開發 PHP 的 Debug 設定與 Composer 套件管理","url":"%2Fb2e%2F20190402%2F1330110113%2F","content":"## 前言\n正當我興高采烈的想說 MySQL 的環境都設定好、前端版型也都 OK 了，該是來好好的學習一下 PHP 了。這時才發現，PHP 的 Debug 環境需要特別去設定，不像 JavaScript 這麼佛心只要打開 chrome 就能除錯，又撞牆了好一陣，終於把開發環境都建立起來了。\n\n![](https://cdn-images-1.medium.com/max/800/0*NTMQloMNCkf0hJTO)\n\n## 使用 VS Code 開發 PHP 的 Debug 設定\n事前準備你需要：\n* 安裝好 VS Code\n* 可以上網的環境\n\n### Step.1 打開 VS Code 並且安裝兩套插件\n\n* [PHP Intelephense](https://marketplace.visualstudio.com/items?itemName=bmewburn.vscode-intelephense-client) - 這是具有 PHP 語法智能提示的插件\n* [PHP Debug](https://marketplace.visualstudio.com/items?itemName=felixfbecker.php-debug) - 讓 VS Code 可以進行 PHP 的 Debug\n\n下載好且安裝成功後重啟 VS Code，開始進行設定。\n\n### Step.2 設定 PHP Debug 與 MAMP 上的 PHP\n\n隨便開一個空的 php ，並且在裡面寫上\n```\n<?php   \n phpinfo();  \n?>\n```\n進入到這個網頁，會看到這個畫面。\n\n![](https://cdn-images-1.medium.com/max/800/1*HuZ7pDkKHjVAA5jhtu3A7w.png)\n\n接著對著這個畫面直接全選複製 (Ctrl + A)\n\n並且到 PHP Debug 的 [XDebug installation wizard](https://xdebug.org/wizard.php) 貼上。\n\n![](https://cdn-images-1.medium.com/max/800/1*U-sOC1LnLp1cLg2Ue0e3FQ.png)\n\n按下按鈕，讓程式偵測還需要設定什麼。\n\n![](https://cdn-images-1.medium.com/max/800/1*5BiFT3CmKzPAxJ2cn9Mblw.png)\n\n很顯然的必須照著這些步驟去做，分別是\n1. 下載系統指定的檔案\n2. 放到它指定的路徑\n3. 打開指定路徑內的 php.ini 並且在最下方新增對應的路徑\n4. [**重點**]程式這邊沒有提到，還需要在 php.ini 內新增這一段才能正確使用 PHP Debug ，因此須在 php.ini 內新增如下內容。\n```\nzend_extension = C:\\MAMP\\bin\\php\\php7.2.10\\ext\\php_xdebug-2.7.0-7.2-vc15.dll\n\n[XDebug]  \nxdebug.remote_enable = 1  \nxdebug.remote_autostart = 1\n```\n存檔後重啟 MAMP ，另外路徑可能會有不同，適當做調整即可。\n\n到這邊 PHP Debug 與 MAMP 的設定就結束了，不過還沒完，還有 VS Code的部份需要調整呢！\n\n### Step.3 設定 VS Code\n\n打開 VS Code -> 設定 - > 搜尋設定 -> 輸入 PHP\n\n![](https://cdn-images-1.medium.com/max/800/1*3Lui5G_Wk-xtjM3DR8avdg.png)\n\n點擊「在 settings.json 內編輯」，然後順著裡面的格式補上這一段：\n\n![](https://cdn-images-1.medium.com/max/800/1*JkUL05koY3nLPMPzEPDWMg.png)\n\n後面的路徑也需要配合實際檔案位置作調整，儲存後就可以關閉囉。\n\n至此，設定就全數完成囉，來使用看看吧！\n\n### Step.4 使用 PHP Debug\n\n首先我們可以在寫好的程式上加入紅色的中斷點\n\n![](https://cdn-images-1.medium.com/max/800/1*o8pGrltegafNUCMlM7okAQ.png)\n\n接著打開 VS Code 左手邊的偵錯工具，選擇「Listen for XDebug」，並且按下綠色的三角型播放鈕，開始偵錯。\n\n![](https://cdn-images-1.medium.com/max/800/1*FVRHMwnEbdtEdyo7Bd5Qhw.png)\n\n接下來可以切換到這支 php 網頁，實際運行看看。\n\n會發現程式將停在我們設置的中斷點上，等待操作。\n\n![](https://cdn-images-1.medium.com/max/800/1*_44z2vDbsYQ_VMIr3F73Bw.png)\n\n此時因為尚未進入 `$foo = 1` ，因此 `$foo` 還是 `uninitialized` 的狀態，接著可以按下上方的逐步執行，觀察變化藉此除錯。\n\n![](https://cdn-images-1.medium.com/max/800/1*7LMmDJBuJb0A9PK1bDraow.png)\n\n> 太棒啦~到這邊終於可以開始寫 PHP 了。\n\n## Composer 套件管理\n在前端常見的套件管理常常聽到「NPM」、「Yarn」之類的，然而在 PHP 也有類似的套件管理工具哦，那就是 Composer 。\n\n根據作業系統不同有不一樣的安裝方法，我是 Windows 系統。\n\n* [到官方下載安裝檔](https://getcomposer.org/download/)\n\n安裝過程中會有這個畫面\n\n![](https://cdn-images-1.medium.com/max/800/1*3OaC_9bTONMHM4hx_Vp6kg.png)\n\n在這邊要選擇目前執行的是哪個版本的 PHP ，預設會是空白的，要自己點擊 Browse… 去尋找。\n\n之後就一直按下一步維持預設值就行了。\n\n### 如何測試 Composer 有沒有安裝好\n\n打開命令提示字元 (cmd) ，輸入 `composer` 看到以下畫面代表安裝成功。\n\n![](https://cdn-images-1.medium.com/max/800/1*utMFT2DoSdtUd9DFQWR66Q.png)\n\n### 在 VS Code 內實際使用看看吧\n\n試著下載 kint-php/kint 這個套件，在 VS Code 內的終端機輸入指令即可。\n\n關於這個套件的敘述：\n\n* [https://github.com/kint-php/kint](https://github.com/kint-php/kint)\n\n```\ncomposer require kint-php/kint\n```\n\n接著會發現專案資料夾內多了這些檔案：\n\n* vender 資料夾\n* composer.json\n* composer.lock\n\n最後在 php 檔案中引入即可使用囉！\n```\nrequire 'vendor/autoload.php';  \n$foo = \\[1,2,3\\];  \nd($foo);\n```\n![](https://cdn-images-1.medium.com/max/800/1*P5B8o4cUVQqo2BsxPJWdcg.png)\n\n## 後記\n\n後端真的很坑啊，真心不騙。\n\nPHP 對 MySQL 的資料庫連線我還有得撞牆呢...OTZ","tags":["Composer"],"categories":["後端學習"]},{"title":"[初探後端]No.1 MySQL Workbench 同步到 MAMP 的 MySQL Server","url":"%2Fb2e%2F20190401%2F1024411092%2F","content":"\n## 前言\n好不容易搞定 TodoList 前端部份，接著就是後端了。後端的部份我想使用 PHP + MySQL 來處理，但是這部份我幾乎完全沒有概念，到處碰壁，所以想要好好的記錄一下今天做了哪些事。\n\n![](https://cdn-images-1.medium.com/max/800/0*ihjZwIp5DeCF9EeW)\n\n## Workbench 是什麼\n> [**引用 WIKI 百科的解釋**](https://zh.wikipedia.org/wiki/MySQL_Workbench) - MySQL Workbench 是一款資料庫設計和建模工具，專門為 MySQL 設計。\n\n而我實際操作起來的感受的確也是這樣，我們可以在上面規劃、管理資料庫，最後再利用同步的功能將我們在上面設計的東西推到資料庫上，過程中一行程式碼都不用打，因為都幫我們處理好了。\n\n這感覺就好像，Workbench 是用來跟 MySQL 溝通的橋梁?\n\n> 也因為 Workbench 會自動生成對應的 MySQL 語法，因此 Workbench 內 Preferences 的 MySQL 版本以及目標的 MySQL Server 版本就很重要。\n\n![MySQL Workbench 8.0 CE](https://cdn-images-1.medium.com/max/800/1*BdIhShaJxGuISqEsJOefgg.png)\n\n## MAMP 是什麼\n簡單來說它就是一個初學者用的東西，因為幾乎不需要額外設定什麼就能使用，很適合一開始要接觸後端的人。\n\n裝好大概長這樣，沒有什麼很複雜的設定。\n\n![](https://cdn-images-1.medium.com/max/800/1*bOG-WXO6tD5fwQDsuFpdcQ.png)\n\n## Workbench 同步到 MAMP 的 MySQL Server\n首先我們要準備一份 Models ，這是等等要同步到 MySQL Server 的東西。不過這部份就不是本篇文章的重點，就不贅述了。\n\n### Step.1 設定 Workbench 上的 MySQL Connections\n\n![Workbench 上的 MySQL Connections](https://cdn-images-1.medium.com/max/800/1*nwNAYSFbNHLik0HdctD85w.png)\n\n目標是連到 MAMP 上的 MySQL**\n* 按下左下角的 New 新增一個連線\n* 連線方式選 TCP / IP\n* Hostname 就是 127.0.0.1 (localhost)\n* Port 的部份就要看 MAMP 上 MySQL 使用的 Port 是多少而定\n* 最後按下 Test Connection ，請確認 MAMP 上的 MySQL Server 有運行，否則會失敗，接著應該會要輸入密碼，預設值是 root 。\n\n![MAMP 上 MySQL 使用的 Port (每台電腦不盡相同)](https://cdn-images-1.medium.com/max/800/1*aRfyiuM5k6-vN3bR85fkPg.png)\n\n### Step.2 設定 Workbench 上指定的 MySQL 版本\n這個步驟相當重要，就是因為這個步驟害我卡住...。\n\n> 原因是我下載的這個 Workbench 是 8.0 版本，裡面預設是較高版本的 MySQL ，因此 Workbench 自動生成的 MySQL 語法自然也是較高版本的。\n\n而 MAMP 上的 MySQL Server 版本是 5.7.24 ，自然不能相容較高版本，因此若沒有先行設定這邊，後面同步的操作可能會失敗，所以在這邊必須要先進行調整。\n\n![MAMP 上的 MySQL Server](https://cdn-images-1.medium.com/max/800/1*PofnqShCTMuXIfydomQLJQ.png)\n\n![設定 Workbench 上指定的 MySQL 版本](https://cdn-images-1.medium.com/max/800/1*MT_b5GczGLS2rywDzvLzMg.png)\n\n最坑的莫過於指定 MySQL 版本居然不是做成下拉式選單，必須自己把版本輸入正確，輸入錯誤框框會反紅表示。\n\n### Step.3 打開 Model 開始同步吧\n\n![](https://cdn-images-1.medium.com/max/800/1*EHqrwe41UYR-kQfNDWdpCQ.png)\n\n* 接著應該會看到這個畫面，不過我們都設定完了，直接按下一步。\n\n![](https://cdn-images-1.medium.com/max/800/1*c1zpICyKFk8ppcbSiStD0g.png)\n\n* 之後會連續按好幾個下一步，初學嘛...基本上暫時維持預設值就好。\n\n![](https://cdn-images-1.medium.com/max/800/1*r6tHlKZ6z7gy6NRq6dKR4Q.png)\n![寫文之前就做過了，所以沒有 Update](https://cdn-images-1.medium.com/max/800/1*k2bgfVTbyWk2BtOmNnSaqg.png)\n\n> 基本上如果前面有設定好的話，這邊就是一直 Next ，然後調整一下是哪邊要 Update 到哪邊，這樣就結束了。\n\n### Step.4 用 Workbench 連線到 MySQL Server 看看內容\n\n![](https://cdn-images-1.medium.com/max/800/1*egaBkLyoNTHMHQMR2eR_vA.png)\n![](https://cdn-images-1.medium.com/max/800/1*Dx5o9lZQKjIxgrVi3rVkGQ.png)\n\n嗯~看起來都有呢，真棒！\n\n## 心得\n希望透過這樣的整理可以幫助到比我更菜的人，不會因為找到的文章都是一些艱深難懂的名詞而放棄學習。而我也可以透過這樣的方式加深自己的印象。","tags":["MAMP"],"categories":["後端學習"]},{"title":"自己對冒泡事件的誤解","url":"%2Fjavascript%2F20190330%2F2715926777%2F","content":"\n## 前言\n最近正著手往全端的技能樹點，然而又重新做了一份 TodoList 的練習，然後因為對冒泡事件的誤解，因此決定寫下來。\n\n![](https://cdn-images-1.medium.com/max/800/0*Jjq7EJMoU1iY6jua)\n\n## DEMO\n* [TodoList](https://codepen.io/pvt5r486/pen/KYPRYZ?fbclid=IwAR1UlirCK1nRx53KRt9M-olreonixPrkGaShY81D9xbtnTS9DLPYMmTARus)\n\n## 問題描述\n點擊 label 與 checkbox 時，會切換 complete 的狀態，但在 li 上有個雙擊事件，我不希望在快速切換 complete 狀態時會觸發雙擊的事件。\n\n因此我最初的想法是「**可能是因為冒泡事件導致的**」，畢竟點擊的是包覆在 li 內的 label 與 checkbox 。\n\n於是我在 complete 狀態切換的事件上加入 `e.stopPropagation();` 但是沒有效果。\n\n## 驗證與結果\n\n正當我不理解為何阻止冒泡事件不起作用時，我動手寫了個簡單的小範例，驗證自己的想法有沒有錯誤。\n* [驗證冒泡事件](https://codepen.io/pvt5r486/pen/jRNXOq?fbclid=IwAR049000nSXifFMOL20WUIFNxmBYFY3Hq7Qge9eaCDUkRhcnmk7HLKXtWfw)\n\n> **神奇的事情發生了，果然就是我誤會它了...。**\n\n## 驗證\n* 阻止冒泡事件僅限於同一種類型的事件，如範例中的 .box 與 body 若同樣都是 click 事件，那麼阻止冒泡事件就能發揮作用\n* 然而不同類型的事件是無效的，如果將 body 改成雙擊事件觸發，那麼就算阻止了冒泡事件，還是會因為 body 被雙擊而觸發事件\n\n## 結果\n最後我在雙擊的事件中補上判斷，當雙擊的目標是 label 或 checkbox 就離開雙擊事件。\n```\nif(e.target.nodeName === 'INPUT' || e.target.nodeName === 'LABEL') { return };\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.76 觀察 jQuery 架構然後動手做一個簡易 library (二)","url":"%2Fjavascript%2F20190326%2F2856162764%2F","content":"\n## 前言\n這一篇就是 JavaScript Weird 系列的最後一節了，接下來我們將繼續完成上一節沒有完成的部分～並且做一個很陽春的介面，選擇語言後按下按鈕就呈現對應的打招呼語句。\n\n![](https://cdn-images-1.medium.com/max/800/0*3EAyjczLUDnxAizV)\n\n繼續下個步驟之前，要先幫一個地方補上上一節寫好的驗證，這樣就能在一開始使用時就檢查出有沒有支援這個語系。\n\n![](https://cdn-images-1.medium.com/max/800/1*V_BDe3mi3iQEX2NRmQZeAQ.png)\n\n## STEP 4. 做一個陽春的介面\n```\n<div class=\"loginblock\">  \n  <select name=\"selectLang\" id=\"selectLang\">  \n    <option value=\"TW\">繁體中文</option>  \n    <option value=\"en\">English</option>  \n  </select>  \n  <button class=\"loginbtn\">登入</button>  \n</div>  \n<h1 id=\"sayHello\"></h1>\n```\n## STEP 5. 在 library 內使用 jQuery\n\n我們要將結果輸出到網頁上，這部分除了使用 jQuery 之外當然也可以透過原生 JavaScript 來達成，不過本次的目標是使用 jQuery。\n\n在原型下新增這個方法\n```\nHTMLSayHello(selector){  \n  if (!$){ throw '沒有載入 jQuery！'}  \n  if (!selector){ throw '沒有找到 selector'}  \n  $(selector).html(this.hello());  \n  return this;  \n}\n```\n## STEP 6. 都完成了！使用看看吧\n\n接著我們就來使用看看吧，順便測試一下鏈式寫法\n\n![](https://cdn-images-1.medium.com/max/800/1*gnrubS469e6rVC9zahOlKQ.png)\n![](https://cdn-images-1.medium.com/max/800/1*ZVO9YVqCmsSsk8_pTl7dpw.png)\n\n很順利的成功了~這樣我們就完成了一個非常陽春的 library ，當然還有很多細節沒有處理，不過這不是本次的目的。\n\n本次的目的是在於\n\n* 研究 jQuery 並嘗試模仿一些好的技巧、架構\n* 試著看開放原始碼不要抗拒它。\n\n## 完坑心得\n最後，JavaScript Weird 部分也結束了，沒想到我居然可以堅持這麼久，莫名的有成就感，總算是填坑完成啦！\n\n透過寫作也間接強化了對 JavaScript 底層觀念的認知，甚至我連支線都一起寫進去了，這一切感覺起來是這麼的不真實。\n\n翻著這些文章，想著原來這段時間我學了這麼多東西，這應該也是另類的學習歷程吧?\n\n接下來的目標會放在接觸後端上，畢竟想在高雄求職似乎也會要求後端，所以大致上會以 PHP Laravel 為新坑目標～\n","tags":["JavaScriptWeird"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.75 觀察 jQuery 架構然後動手做一個簡易 library (一)","url":"%2Fjavascript%2F20190326%2F4107907530%2F","content":"\n## 前言\n我跳過蠻多小節的，因為看起來沒什麼好紀錄的，這篇主要是紀錄看了 jQuery 的原始碼後，可以從中學習的技巧，以及綜合練習之前觀念。\n\n![](https://cdn-images-1.medium.com/max/800/0*xllXzqosxRKyO3Ee)\n\n## 觀察 jQuery 並實際應用在 簡易 Library\n* 用 IIFE 建立安全的執行環境，避免干擾\n* 回傳時補上 new ，讓實例化時不需要再補上 new\n* 將方法新增在原型上\n* 讓方法實現鏈式操作\n* 像 jQuery 一樣使用 $ 當成別名，不過這裡是使用 S$\n* 在 library 內使用另一個 library\n\n大致上是這樣，那就讓我們開始吧。\n### Step 1. 確保 library 是安全的\n\n* 這邊會使用 IIFE 包住整個程式碼，避免不同的 JavaScript 檔案影響到運作\n* 接著傳入全域物件 `window` 、 `jQuery` (之後會用到)\n```\n(function(global, $){\n\n})(window, jQuery);\n```\n### Step 2. 建立基本架構\n\n* 建立 constructor 內容，並且在回傳時補上 new\n```\n(function(global, $){  \n  let sayHelloer = function(firstName, lastName, lang){  \n    return new sayHelloer.init(firstName, lastName, lang);  \n  }\n\n  // constructor  \n  sayHelloer.init = function(firstName, lastName, lang){  \n    this.firstName = firstName || '';  \n    this.lastName = lastName || '';  \n    this.lang = lang || 'TW';  \n  }  \n})(window, jQuery)\n```\n* 設置要加入到 prototype 的方法\n```\nsayHelloer.prototype = {}\n```\n* 設置原型\n```\nsayHelloer.init.prototype = sayHelloer.prototype;\n```\n* 設置外部如何取用\n```\nglobal.S$ = global.sayHelloer = sayHelloer;\n```\n這樣外部就可以使用 `S$` 或是 `sayHelloer` 呼叫方法囉。\n\n於是這一步驟的程式碼整理如下：\n```\n(function(global, $){  \n  let sayHelloer = function(firstName, lastName, lang){  \n    return new sayHelloer.init(firstName, lastName, lang);  \n  }\n\n　// constructor  \n  sayHelloer.init = function(firstName, lastName, lang){  \n    this.firstName = firstName || '';  \n    this.lastName = lastName || '';  \n    this.lang = lang || 'TW';  \n  }  \n  sayHelloer.prototype = {}  \n  sayHelloer.init.prototype = sayHelloer.prototype;  \n  global.S$ = global.sayHelloer = sayHelloer;\n\n})(window, jQuery)\n```\n運行並且試著印出來\n```\nvar s = S$('小明','王','TW');  \nconsole.log(s);\n```\n![雛形](https://cdn-images-1.medium.com/max/800/1*5z9cuHVvgV-f7qUT1uH8dw.png)\n\n### Step 3. 根據需求寫方法\n這個 library 是拿來打招呼用的，所以大致擬訂一下需求：\n\n* 根據語系切換打招呼內容\n* 驗證有沒有支援這個語系\n* 可以直接切換語系，改變打招呼內容\n* **`return this`** 實現鏈式寫法\n```\n// 要加入至 prototype 的方法  \n  sayHelloer.prototype = {  \n    fullName: function(){  \n      return `${this.firstName} ${this.lastName}`;  \n    },  \n    hello: function(){  \n      return `${saySomething[this.lang]} ${this.firstName} !`  \n    },  \n    vaild: function(){  \n      if(langArray.indexOf(this.lang) === -1){  \n        throw '未支援的語言！'  \n      }  \n    },  \n    setLang: function(lang){  \n      this.lang = lang;  \n      this.vaild();  \n      return this;  \n    },  \n    sayHello: function(){  \n      let msg = this.hello();  \n      if (console){  \n        console.log(msg);  \n      }  \n      return this;  \n    }  \n  }\n```\n因為我們之前有 `return new` 的技巧，所以這邊不需要使用 `new` 。\n```\nvar s = S$('小明','王','TW');  \nconsole.log(s);  \nconsole.log(s.fullName());  \ns.sayHello().setLang('es').sayHello();\n```\n![](https://cdn-images-1.medium.com/max/800/1*BAY19KBr19ElBUbX-hzYPA.png)\n\n至此，大致上就快完成了，不過還剩下一些項目，我們將在下一節補齊。","tags":["JavaScriptWeird"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.74 Strict mode 嚴謹模式","url":"%2Fjavascript%2F20190325%2F1527136485%2F","content":"\n## 前言\n好的，終於又回到主線了，趕緊把這個坑填好。這篇主要是介紹關於 JavaScript 的嚴謹模式 (Strict mode)，當開啟這個模式後，JavaScript 的部分行為就會比較不一樣了，就讓我們一塊來看看吧。\n\n![](https://cdn-images-1.medium.com/max/800/0*GGBfBqR4xETznBxS)\n\n## 嚴謹模式 (Strict mode)\nJavaScript 的特性就是比較彈性自由，但為人詬病的也是因為太過彈性自由導致缺乏規範，讓沒有經驗的開發者很容易就寫出預料外的 BUG。\n\n而嚴謹模式就是在告訴 JavaScript 要用比較多的規範、限制來編譯這些程式碼，雖然這沒辦法完全改變 JavaScript 過於自由的問題，但還是幫助我們避免一些奇怪的錯誤。\n\n* 例如**變數打錯字**的問題\n```\nvar person;  \npersom = {};  \nconsole.log(persom);\n```\n像是把 `person` 打成 `persom` 的錯誤， JavaScript 會認為這是對的。\n\n而這麼做不會錯誤的原因是，JavaScript 把 `persom` 設定為 全域 `window` 物件內的屬性，顯然地這並不是我們所預想的樣子。\n\n因此我們需要告訴 JavaScript 打開**嚴謹模式**。\n```\n'use strict'  \nvar person;  \npersom = {};  \nconsole.log(persom);\n```\n![](https://cdn-images-1.medium.com/max/800/1*IfzO_NNCrQDKoY4ylbXObQ.png)\n\n當然嚴謹模式能做的不只這些，更多**特性**可以到 MDN 的文件查看：\n\n* [Strict mode](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode)\n\n### 全域、個別使用嚴謹模式\n\n嚴謹模式允許**全域使用**以及**個別地在函式**使用，使用方法很簡單，就只需要在 JavaScript 檔案的第一行或者是在函式內的第一行內宣告使用即可。\n\n### 全域使用嚴謹模式\n```\n'use strict'  \nvar person;  \npersom = {};  \nconsole.log(persom);\n```\n### 函式個別使用嚴謹模式\n```\nfunction test(){  \n 'use strict'  \n  var person2;  \n  persom2 = {};  \n  console.log(persom2);  \n}\n\nvar person;  \npersom = {};  \nconsole.log(persom);  \ntest();\n```\n![](https://cdn-images-1.medium.com/max/800/1*zx-KzmVxKQY8OV84Qc1oGA.png)\n\n## 嚴謹模式似乎很少被使用\n因為嚴謹模式並不是必要的，這只是一個額外的功能，而且並不是每個 JavaScript 引擎的嚴謹模式特性表現都一樣，因此在使用上會有比較多的限制。\n\n但如果我們仍然希望讓 JavaScript 更嚴格，可以試著使用 ESlint 配合 TypeScript 讓程式碼的品質更上一層樓。","tags":["JavaScriptWeird"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.73 學完物件導向後的 this (二)","url":"%2Fjavascript%2F20190324%2F3426590472%2F","content":"\n## 前言\n接續上一篇的 `this` ，我們將利用一種比較特別的方式來看 `this` 的值，以及介紹除了 `call()` 、` apply()` 之外還可以使用 `bind()` 強制綁定 `this` ，最後將提到 `this` 在箭頭函式下的特性。\n\n![](https://cdn-images-1.medium.com/max/800/0*6P_kzNSY9Zom2F90)\n\n## 用另一種角度看 this 的值\n上一節提到 `this` 基本只有在跟物件導向扯上關係的時候才有意義。\n```\nuse strict'  \nconst obj = {  \n  a: 123,  \n  test: function(){  \n    console.log(this);  \n  }  \n}\n\nobj.test();\n```\n而這個例子的輸出結果 `this` 指向的是 `obj` 。\n\n> 有沒有發現幾乎每次 `this` 有改變的時候都是 `ooo.xxx()` 之類的呼叫方式\n\n## this 的值與在哪邊呼叫函式、實際上寫在哪無關\n\n* 真正有關係的是，**如何去呼叫它**\n\n同一個例子**換個方式改寫**結果就不同了\n```\n'use strict'  \nconst obj = {  \n  a: 123,  \n  test: function(){  \n    console.log(this);  \n  }  \n}\n\nvar func = obj.test;  \nfunc();\n```\n這個例子就是在說，明明是同樣的輸出結果，但只要改變了呼叫的方式， `this` 就不一樣了。\n\n**是不是覺得要判斷 this 值是什麼有點困難？**\n\n可以試著帶入 `call()` 的方式去想！\n```\n'use strict'  \nconst obj = {  \n  a: 123,  \n  test: function(){  \n    console.log(this);  \n  }  \n}\n\n(這不是可以實際執行的 code )  \nobj.test(); => obj.test.call(obj)\n```\n**透過帶入 call() 的方式去想將有助於理解 this 的值是什麼。**\n\n以 `obj.test()` 來說，可以想像成在 `obj.test()` 後面補上 `call()` 並且填入呼叫 `test()` 之前的內容，就是 `this` 指向的地方。\n\n**在來個例子**\n```\n'use strict'  \nconst obj = {  \n  a: 123,  \n  inner: {  \n    test: function(){  \n      console.log(this);  \n    }  \n  }  \n}  \n(這不是可以實際執行的 code )  \nobj.inner.test() => obj.inner.test.call(obj.inner)\n```\n一樣使用上面提到的方式去判斷，因此可以得知結果的 `this` 會指向 `obj.inner` 。\n\n**所以現在就可以了解，第一個例子為什麼換個方式改寫輸出會是 undefined 了。**\n```\n'use strict'  \nconst obj = {  \n  a: 123,  \n  test: function(){  \n    console.log(this);  \n  }  \n}  \nvar func = obj.test;\n\n(這不是可以實際執行的 code )  \nfunc() => func.call(undefined)\n```\n* 因為 func 前面沒有任何東西可以放入 `call()` ，所以會指向 `undefined`\n\n## 做點小練習題複習一下 `this` 吧\n```\nfunction log() {  \n  console.log(this);  \n}\n\nvar a = { a: 1, log: log };  \nvar b = { a: 2, log: log };\n\nlog(); // 全域 window  \na.log(); // a\n\nb.log.apply(a) // a\n```\n\n## bind() 讓 this 從此乖乖的\n上一節介紹的 c`all()` 、 `apply()` 主要是呼叫該函式，並指定 `this` 值的指向。但是 `bind()`並不一樣：\n\n* `bind()` 會**回傳一個一模一樣的函式，並且將 this 值強制綁定**\n* 而且沒有辦法透過 `call()` 、 `apply()` 改變 `this` 值\n```\n'use strict'  \nconst obj = {  \n  a: 123,  \n  test: function(){  \n    console.log(this);  \n  }  \n}\n\nconst bindTest = obj.test.bind('aaa');  \nbindTest(); // aaa  \nbindTest.call('qweqwe'); // aaa\n```\n* `bind()` 的用法其實跟前面兩個蠻接近的，第一個參數都是指定 `this`\n\n## this 在箭頭函式下的特性\n在介紹之前做個小練習\n```\nclass Test{  \n  run(){  \n    console.log('run this:' ,this);  \n    setTimeout(function(){  \n      console.log(this);  \n    },100)  \n  }  \n}\n\nconst t = new Test();  \nt.run();\n```\n\n輸出的 log 分別為：\n\n* Test{}\n* 全域 window 物件\n\n但如果將 setTimeout 內的函式改成箭頭函式呢?\n```\nclass Test{  \n  run(){  \n    console.log('run this:' ,this);  \n    setTimeout(() => {  \n      console.log(this);  \n    },100)  \n  }  \n}\n\nconst t = new Test();  \nt.run();\n```\n\n![](https://cdn-images-1.medium.com/max/800/1*ZuDKy-jysJbrZdVG71yoLg.png)\n\n答案就會很明顯的不一樣囉。\n\n與 this 的特性相反\n\n* this 取決於函式如何被呼叫\n\n但箭頭函式內的 `this`\n\n*   跟函式怎麼被呼叫沒有關係\n*   表現跟 **scope 的行為**比較類似，取決於箭頭函式寫在哪\n\n## 回到例子\n箭頭函式內的 `this` 取決於被寫在哪，來決定 `this` 是什麼。\n\n以這個例子來說，因為這個方法是這樣被呼叫的 `t.run()` ，所以 run 函式內的 `this` 會指向 `t` ，而同樣在 `run` 函式中的箭頭函式 `this` 也會跟著變成 `t` 。\n\n而我們也可以透過這樣來觀察\n```\nclass Test{  \n  run(){  \n    console.log('run this:' ,this);  \n    setTimeout(() => {  \n      console.log(this);  \n    },100)  \n  }  \n}\n\nconst t = new Test();  \nt.run.call(456);\n```\n![](https://cdn-images-1.medium.com/max/800/1*rczYcNwkIwiP7Jx6KVcaHA.png)\n\n當我們指定 `this` 後，也會連帶的影響到箭頭函式內的 `this` 。\n\n也就是說箭頭函式內的 `this` **會是在被定義時那個區域的 `this` 值**。\n```\nfunction test(){  \n  console.log('first ', this);  \n  let arr = \\['apple', 'banana', 'lemon', 'apple', 'watermelon', 'grape'\\];  \n  let result = arr.filter((item, index, array) =>{  \n    console.log(this);  \n    //console.log(item, index, array);  \n    return item;  \n  });  \n}  \ntest.call('aa');\n```\n![](https://cdn-images-1.medium.com/max/800/1*Cm5sb2HnNM3nWj24cSp7bw.png)\n\n像是這個例子來說，如果沒有使用 `call()` 指定 `this` ，這邊印出的 `this` 值會全部都是全域 `window` ，但因為現在有指定 `this` ，所以全部都是 'aa' 。\n\n### 心得\n\n總算是把支線部分全部都讀完了，真的是對我的 JavaScript 底層的理解相當的有幫助，並且也把一些在奇怪部分 (我以為我懂但其實沒有) 的觀念釐清，像是我很喜歡模仿 JavaScript 引擎、找作用域、從 ECMA 理解 hosting 那些方式，像是偵探在找線索般，一層層的往回推，最後就可以理解為什麼會是這樣。\n\n> 接下來就是把剩下的主線完成， JavaScript 的坑就算完成啦。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.72 學完物件導向後的 this (一)","url":"%2Fjavascript%2F20190323%2F3824948085%2F","content":"\n## 前言\n結束物件導向的學習後，最後才介紹到 `this` ，這個安排是相當特別的。在奇怪部分時，記得是直接學習 **`this` 是什麼**以及什麼樣的情況下 **`this` 是什麼值**，而沒有認知到 **`this` 這個關鍵字是為了物件導向存在**的。\n\n![](https://cdn-images-1.medium.com/max/800/0*qsrpY_XRbIQV0CGF)\n\n## this 的意義在哪\n了解物件導向的觀念之後， `this` 就不是那麼困難了，雖然在講解物件導向的觀念時已經有使用 `this` ，但應該不難猜出 `this` 是什麼意思。\n\n> `this` 在英文裡面是「**這個**」的意思\n\n![](https://cdn-images-1.medium.com/max/800/1*jG943Wj--_r7df2wNbTpXw.png)\n\n而 `this` 是給物件導向觀念內使用的關鍵字，目的是「**代替現在對應到的實例(instance)**」。\n\n在這個範例中有變數 `d` 與 `c` 分別指向的兩個物件實例，而 `dog` 類別內的 `howling` 方法，裡面會印出 `this.name` 的值。\n\n意思就是**不同實例呼叫這個方法時，因為 `this` 指向不同會有不同的結果**。\n\n> 所以說在物件導向裡面， `this` 是相當有用而且必要的。\n\n## 非物件導向的情況下使用 this\n\n現在我們知道 `this` 大概是為了物件導向而存在，那如果在非物件導向的情況下使用會發生什麼事呢？\n```\nfunction test(){  \n  console.log(this);  \n}\n\ntest();\n```\n在一般情況下 `this` 會指向全域的 `window` 物件，而在 node.js 會印出 `global` 。\n\n但這樣的情形其實蠻奇怪的，因為 `this` 在這個範例中實際上應該沒有任何東西才是，為什麼會指向全域的 `window` 物件呢？\n```\n其實是因為 JavaScript 預設是一般模式，切換到**嚴謹模式**就不同了。\n\n'use strict'  // 使用嚴謹模式  \nfunction test(){  \n  console.log(this);  \n}\n\ntest(); // undefined\n```\n這樣子的結果就合理多了。\n\n## 複雜一點的例子\n```\n'use strict'  \nfunction test(){  \n  var a = 1;  \n  function inner(){  \n    console.log(this);  \n  }  \n  inner();  \n}\n\ntest(); // undefined\n```\n這樣也會是 `undefined`\n\n`this` 基本上跟函式沒有什麼太大的關連，也就是說 `this` 在非物件導向的情況下基本都會是預設值，只有**一個例外**。\n\n* 操作 DOM 元素處理瀏覽器事件的時候\n```\ndocument.querySelector('.btn').addEventListener('click',function(){\n\n})\n```\n這個時候的 `this` 就會是使用者實際操作到的東西。\n\n像是這個例子是 click， `this` 的內容就會是使用者在網頁上點選到的元素。\n\n### 控制 this\n\n之前在介紹 `new` 的行為時有用到 `call()` 的方法，其實除了這個方法外還有其他的方法可以改變 `this` 的指向，像是之前寫的：\n\n*   [[JavaScriptWeird]No.38 call()、apply()、bind()](https://pvt5r486.github.io/javascript/20190130/538224560)\n\n因此這邊稍微複習一下 `call()` 與 `apply()` 不同的地方\n```\n'use strict'  \nfunction test(){  \n  console.log(this);  \n}\n\ntest.call(123); // 傳入什麼 this 就是什麼\n\napply() 也可以做到一樣的事情\n\n'use strict'  \nfunction test(){  \n  console.log(this);  \n}\n\ntest.apply(123); // 傳入什麼 this 就是什麼\n```\n**而差別在於**\n\n* `call()` 能接受**多個用逗號隔開的參數**\n* `apply()` 只能接受**兩個參數且第二個必須是陣列**。\n\n**共同的目的**\n\n* 控制 `this`\n```\n'use strict'  \nfunction test(a,b,c){  \n  console.log(this);  \n  console.log(a,b,c);  \n}\n\ntest.call(123, 1, 2, 3);  \ntest.apply(123, [1, 2, 3]);\n```\n## 後記\n支線終於也到尾聲了，還真是不容易啊...寫筆記居然堅持了這麼久。\n還剩下一點點，請務必堅持到最後！","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.71 物件導向的繼承：Inheritance","url":"%2Fjavascript%2F20190322%2F3057702415%2F","content":"\n## 前言\n了解原型與原型鏈的關係之後，可以發現 JavaScript 就是利用這樣子的關係來產生繼承概念的，而在 ES6 之後也有更方便的做法。\n\n![](https://cdn-images-1.medium.com/max/800/0*JZ28rmzW4hcRxd4Q)\n\n## 物件導向的繼承\n```\nclass dog{  \n  constructor(name){  \n    this.name = name;  \n  }  \n  // 狗的天生技能：會吠叫  \n  howling(){  \n    console.log(this.name + ' 大聲吠叫');  \n  }  \n}\n\nvar d = new dog('狗');  \nd.howling();  \nconsole.log(d);\n```\n像這樣，先設定出普通品種的狗，而且牠們都會叫。\n\n## 狗藉由不斷的繁殖、演化最後產生了超級狗！\n```\nclass superDog extends dog{  \n  // 超級狗的天生技能：會轉圈  \n  turnAround(){  \n    console.log(this.name + ' 在原地轉了一圈');  \n  }  \n}  \nvar c = new superDog('超級狗');  \nc.howling();  \nc.turnAround();  \nconsole.log(c);\n```\n* 這個部分使用了 `extends` 使 `superDog` 繼承 `dog`\n* 而因為 `superDog` 內沒有 `constructor` 函式，所以會向上層尋找 (dog) `constructor` 函式並執行\n\n![](https://cdn-images-1.medium.com/max/800/1*haRP4-uaVO26dVmn160_-w.png)\n\n## 為什麼要繼承呢\n\n因為有些時候會有一些共同的行為，這時候可以透過**繼承**的方式，這樣不用重新寫。\n\n## 繼承的覆寫\n\n我們希望超級狗在被建立的時候立刻使出吠叫技能，於是我們想到可以在 superDog 的 constructor 函式內進行。\n```\nclass superDog extends dog{  \n  constructor(){  \n    this.howling();  \n  }  \n  // 超級狗的天生技能：會轉圈  \n  turnAround(){  \n    console.log(this.name + ' 在原地轉了一圈');  \n  }  \n}\n\nvar d = new dog('狗');  \nvar c = new superDog('超級狗');\n```\n但這麼寫馬上就遇到問題了。\n\n因為在 `superDog` 的 `constructor` 函式內呼叫的是 `dog` 的 `howling` 函式，而在 `dog` 還沒執行 `constructor` 之前是不能使用的，因此會出現如下警告。\n\n![](https://cdn-images-1.medium.com/max/800/1*o0YZ8upb79upAdj0NHvOkQ.png)\n\n這時需要補上 **`super()`** ，意思就是**先執行上一層的 `constructor` 函式**\n\n因此修正如下\n```\nclass superDog extends dog{  \n  constructor(){  \n    super();  \n    this.howling();  \n  }  \n  // 超級狗的天生技能：會轉圈  \n  turnAround(){  \n    console.log(this.name + ' 在原地轉了一圈');  \n  }  \n}  \nvar d = new dog('狗');  \nvar c = new superDog('超級狗');\n```\n而因為已經於 `superDog` 內**覆寫**了 `constructor` ，必須透過 `super` 函式把 `name` 傳入 `dog` 內的 `constructor` ，否則會顯示 `undefined` ，故修正如下：\n```\nclass superDog extends dog{  \n  constructor(name){  \n    super(name); // dog 的 constructor(name){}  \n    this.howling();  \n  }  \n  // 超級狗的天生技能：會轉圈  \n  turnAround(){  \n    console.log(this.name + ' 在原地轉了一圈');  \n  }  \n}  \nvar d = new dog('狗');  \nvar c = new superDog('超級狗'); // 超級狗 大聲吠叫\n```\n或者是**我們希望超級狗的吠叫可以再更強一點**，於是\n```\nclass dog{  \n  constructor(name){  \n    this.name = name;  \n  }  \n  // 狗的天生技能：會吠叫  \n  howling(){  \n    console.log(this.name + ' 大聲吠叫');  \n  }  \n}\n\nclass superDog extends dog{  \n  // 超級狗的天生技能：會轉圈  \n  turnAround(){  \n    console.log(this.name + ' 在原地轉了一圈');  \n  }  \n  // 覆寫 吠叫  \n  howling(){  \n    console.log(this.name + ' 更大聲吠叫');  \n  }  \n}\n\nvar d = new dog('狗');  \nd.howling();\n\nvar c = new superDog('超級狗');  \nc.howling();  \nc.turnAround();  \nconsole.log(d);  \nconsole.log(c);\n```\n![](https://cdn-images-1.medium.com/max/800/1*4llQM_vz02f1W6OAnT1z-g.png)\n\n> 如此一來是不是很方便呢～至此物件導向的觀念就了解得差不多囉，接著最後要了解的就是 this 啦～","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.70 new 到底做了什麼事","url":"%2Fjavascript%2F20190322%2F317251769%2F","content":"\n## 前言\n所以我說那個 `new` 到底做了什麼事，為什麼一定要加上 `new` 呢？\n\n![](https://cdn-images-1.medium.com/max/800/0*5zmo6UvVLNxNmWWO)\n\n## 函式建構子 new 做了什麼\n我們沿用前面的範例\n```\nfunction dog(name){  \n  this.name = name;  \n}\n\ndog.prototype.getName = function(){  \n  return this.name;  \n}\n\ndog.prototype.sayHello = function(){  \n  console.log(this.name + ' say Hello');  \n}\n\nvar d = new dog('abc');  \nd.sayHello();\n```\n在了解 `new` 做了什麼之前，我們需要先喚醒另個世界線的知識\n\n* [[JavaScriptWeird]No.38 call()、apply()、bind()](https://pvt5r486.github.io/javascript/20190130/538224560)\n\n### new 在背後偷偷做的事\n\n![](https://cdn-images-1.medium.com/max/800/1*VPHuyS-C_39sutM4Ebmbug.png)\n*   1486 行宣告 `newDog` 函式，並允許帶入參數 `name`\n*   1487 行宣告 `obj` 變數並令其指向空物件\n*   1488 行使用 `.call()` 方法執行 `dog` 函式，**令其 `this` 改指向為 `obj` 所指向的物件**\n*   1489 行令 `obj.__proto__ = dog.prototype;`\n*   1490 行回傳 `obj`\n\n這段程式執行的結果與原本使用 `new` 的結果輸出如下\n\n![](https://cdn-images-1.medium.com/max/800/1*bAyOpPTae-5BxODhICdWSg.png)\n\n由觀察得知，兩者是一模一樣的。\n\n### 透過觀察 new 實際上做了這些事\n\n*   會產生新的物件，於最後回傳它\n*   會使用 `.call()` 去呼叫 `constructor` 函式，並將 `this` 指向至新產生的物件\n*   設定新物件的「`.__proto__`」使其對應至相應的 `.prototype`\n\n以上就是用狗的範例來說明函式建構子 `new` 在背後偷偷做的事情了。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.69 從 prototype 來看「原型鏈」","url":"%2Fjavascript%2F20190322%2F1786194055%2F","content":"\n## 前言\n我們用上一節的範例來解釋什麼是 **原型 (prototype)** 與 **原型鏈 (prototype chain)**，然後也不難發現 JavaScript 很多底層的觀念都是鏈狀的。\n\n![](https://cdn-images-1.medium.com/max/800/0*SJaw-TLfk2tiMun8)\n\n## 回顧上一節的 ES5 範例\n```\nfunction dog(name){  \n  this.name = name;  \n}\n\ndog.prototype.getName = function(){  \n  return this.name;  \n}\n\ndog.prototype.sayHello = function(){  \n  console.log(this.name + ' say Hello');  \n}\n\nvar d = new dog('abc');  \nd.sayHello();  \nconsole.log(d.__proto__);\n```\n上一節的內容中，我們知道只要於 `dog.prototype` 上新增方法，這樣之後透過 `new` 產生的 `dog` 物件都具有 `sayHello` 方法。\n\n以這個例子來說，當我們印出 `d` 的內容時，可以發現當中有個隱藏的屬性「`.__proto__`」，也發現寫在 `dog.prototype` 上的方法在這邊出現了。\n\n**甚至會發現怎麼點開了「.__proto__」裡面還有一個「.__proto__」？**\n\n![](https://cdn-images-1.medium.com/max/800/1*eERzZjuPQ00yT28IwVFFBg.png)\n\n## 「.__proto__」\n\n以這個例子白話的說，意思就是當在**變數 `d` 指向的物件身上找不到對應的方法時**，便從「`.__proto__`」內尋找有沒有對應的方法，聽起來是不是跟之前解釋的 ScopeChain 有點像呢。\n```\n... 省略 ...  \nconsole.log(d.__proto__ === dog.prototype); // true\n```\n而使用三等號來比較的話，可以得知兩者是一樣的。\n\n## 當呼叫 `d.sayHello()` 的過程\n```\n... 省略 ...  \nd.sayHello();\n```\n* 檢查變數 `d` 指向的物件屬性內有沒有 `sayHello` ? 這個例子沒有。\n* 接著找該物件的 `__proto__` 屬性內有沒有 `sayHello` ，**若有就停止**不會繼續往後找下去。\n\n**以這個例子來說，在步驟二時就找到了，那如果沒有的情況呢？**\n\n還記得上面的一張圖嗎?\n\n> **怎麼點開了「`.__proto__`」裡面還有一個「`.__proto__`」？**\n\n*   如果還是找不到，便繼續往 `.__proto__` 尋找，如 `d.__proto__.__proto__`\n\n此時先抽離這個步驟，從這邊可以觀察出「`.__proto__`」是一層一層的，而越後面的「`.__proto__`」就越接近「底」的部分。\n\n而本例中 dog 物件的「`.__proto__`」下一層就是原始物件的 `prototype` ，所以下面程式碼為 `true`\n```\nconsole.log(d.__proto__.__proto__ === Object.prototype); // true\n```\n如何知道是不是已經找到底層了呢？只要輸出為 `null` 代表上一層就是頂層了。\n```\nconsole.log(d.__proto__.__proto__.__proto__); // null\n```\n![](https://cdn-images-1.medium.com/max/800/1*HXaf4C_eqkCw3U9sqZzg-g.png)\n\n## 回到剛才的步驟\n\n* 如果還是找不到，便會繼續往 `.__proto__` 尋找，直到找到為止\n* 如果找到底層了還是沒有，則跳出錯誤訊息。\n```\nfunction dog(name){  \n  this.name = name;  \n}\n\ndog.prototype.getName = function(){  \n  return this.name;  \n}\n\nvar d = new dog('abc');  \nd.sayHello();\n```\n![](https://cdn-images-1.medium.com/max/800/1*80jbtICe_QcLRBnvBVrimw.png)\n\n## 整理一下對應的關聯\n![](https://cdn-images-1.medium.com/max/800/1*s4hdapViRiq5Z5c2x5KLQw.png)\n\n可以得知這個過程是一層一層逐漸地往下找的，而這個過程被稱之為**原型鏈 (prototype chain)**，其實跟**範圍鏈 (scope chain)** 有點相似。\n\n這邊也順手觀察一下 `dog.__proto__` 是什麼\n```\nconsole.log(dog.__proto__); // ƒ () { \\[native code\\] }  \nconsole.log(dog.__proto__ === Function.prototype); //true\n```\n因為 dog 本身就是一個函式，出現這樣子是符合預期的。\n\n> 觀察至此，大部分的疑惑都解開，只剩下 `new` 了，接下來會提到 `new` 到底做了些什麼。\n\n## 知道了這些可以做什麼？\n可以進行一些比較**有趣**的事情，像是我們可以在 **String 的原型上**增加一個自己寫的方法，這樣之後只要**型別屬於 String** 就可以使用。\n```\nString.prototype.getFirst = function(){  \n  return this[0];  \n}\n\nvar a = '123';  \nconsole.log(a.__proto__ === String.prototype); // true  \nconsole.log(String.prototype);  \nconsole.log(a.getFirst()); // 1\n```\n![](https://cdn-images-1.medium.com/max/800/1*Jp8XtlueVEoh5n6yZmAQrw.png)","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.68 物件導向的基礎範例與 class","url":"%2Fjavascript%2F20190317%2F3356736604%2F","content":"\n## 前言\n這節要來研究一下如何使用 ES6 新增的 class 實作出物件導向的範例，以及尚未出現 class 時，是如何處理這部分的？\n\n![](https://cdn-images-1.medium.com/max/800/0*yg7ONikNQfuLZ0EW)\n\n## ES6 新增的 class\n直接看程式碼\n```\nclass dog {  \n  constructor(name) {  \n    this.name = name;  \n  }  \n  getName(){  \n    return this.name;  \n  }  \n  sayHello() {  \n    console.log(this.name + ' say Hello');  \n  }  \n}\n\nvar d = new dog('abc');  \nvar b = new dog('qqq');  \nconsole.log(d);  \nconsole.log(d.getName());  \nd.sayHello();  \nconsole.log(d.sayHello === b.sayHello); // true\n```\nES6 新增的 `class` 就像是一張**設計圖**，沒使用建構子 `new` 之前是沒有辦法使用的。\n\n以這個例子來說，我們要建立狗的類別，所以我們定義了三個函式，其中 `constructor` 函式比較特別，當使用建構子 `new` 實例化 **(instance)** 狗的 `class` 時，可在括號內放入參數，而 `constructor` 函式可以取得該參數。\n\n這個例子中以這樣的方式初始化每隻狗的名字，而我們可以更進一步的觀察\n\n* 此時的變數 `d` 與變數 `b` 使用 `typeof` 觀察會是**物件**\n* 以此設計圖新增的每隻狗都有定義在設計圖內的函式\n* 使用三等號比較兩者的 `sayHello` 方法，會回傳 `true` ，代表為**同個函式**。\n\n![](https://cdn-images-1.medium.com/max/800/1*2qAMK_LAyHHc3IKVmBfdgw.png)\n\n## ES5 沒有 class 的作法\n```\nfunction dog(name){  \n  this.name = name;  \n}\n\ndog.prototype.getName = function(){  \n  return this.name;  \n}\n\ndog.prototype.sayHello = function(){  \n  console.log(this.name + ' say Hello');  \n}\n\nvar d = new dog('abc');  \nvar b = new dog('qqq');  \nconsole.log(d);  \nconsole.log(d.getName());  \nd.sayHello();  \nconsole.log(d.sayHello === b.sayHello); // true\n```\n可以發現差別並不大，直觀來說下半部的程式碼幾乎是一樣的。\n\n主要就是需要宣告一個函式，而這個函式其實就是 ES6 `class` 內的 `constructor` 函式。\n\n而在 ES5 的時候，是看使用時**有沒有加入建構子 `new`** 來決定是否為 `constructor` 函式或是一般的函式。\n\n然後除了要宣告一個函式之外，也必須在該函式的 `prototype` 定義這些狗會做什麼。\n\n接下來進行一些觀察，可以得知跟上面那個例子的結果是一樣的。\n\n至於 **`prototype` 究竟是什麼**，下一節才會提到。\n\n## ES5 奇怪部份推薦的做法\n\n這部分我可能之後會去找一下答案，不太清楚箇中差異，但個人蠻喜歡這樣的做法，因為我覺得蠻好懂的，畢竟就是物件罷了。\n```\nvar cat = {  \n  setName: function(name) {  \n    this.name = name;  \n  },  \n  getName: function(){  \n    return this.name;  \n  },  \n  sayHello: function(){  \n    console.log(this.name + ' Meow');  \n  }  \n}\n\nvar c = Object.create(cat);  \nvar q = Object.create(cat);\n\nconsole.log(c);  \nconsole.log(typeof c);  \nc.setName('nice');  \nconsole.log(c.getName());  \nc.sayHello();\n\nconsole.log(c.sayHello === q.sayHello); // true\n```\n像這樣，建立一個貓物件，然後裡面定義一些方法。\n\n接著使用 `Object.create()` ，這樣就結束了。\n\n觀察後半部印出的內容，結果也與使用 `class` 實作出來的差別無異。\n\n對照一下兩者內容：\n\n![](https://cdn-images-1.medium.com/max/800/1*TzXI5NDEUBnar1XXJNhhrg.png)\n\n而我的疑問是：\n\n* 以這個範例來說，可以算是**物件導向的範例**嗎？  \n    我想應該是，畢竟也有達成 [MDN 對於物件導向程式設計的敘述](https://developer.mozilla.org/zh-TW/docs/Glossary/OOP)\n* 從對照圖可以看出結構不太一樣，但我不太清楚這**兩種實作方式的優劣**，在實務上會推薦使用哪一種呢?\n\n後來我找到了這兩篇\n\n* [[筆記] 談談JavaScript中最單純的原型繼承（prototypal inheritance）─ Object.create](https://pjchender.blogspot.com/2016/06/javascriptprototypal-inheritance.html)\n* [談談 JavaScript 中的 function constructor 和關鍵字 new](https://pjchender.blogspot.com/2016/06/javascriptfunction-constructornew.html)\n* [繼承與原型鏈](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E7%94%A2%E7%94%9F%E7%89%A9%E4%BB%B6%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%8F%88%E7%9A%84%E5%B9%BE%E7%A8%AE%E6%96%B9%E6%B3%95)\n\n然而也想起為何奇怪部分的影片講師會比較推薦 `Object.create()` 的方式，以下截自上述連結文章內描述。\n> 在其它的程式語言中，會用 class 這個關鍵字來設定該物件要長什麼樣子，然後透過關鍵字 `new` 來建立物件。  \n> 然而，和其他程式語言不同的地方在於，JavaScript 實際上使用的是**原型繼承 (Prototypal inheritance)**而不是古典繼承 (Classical Inheritance)，所以為了讓 JavaScript 回歸單純的**原型繼承**，現在的瀏覽器大部分都支援 Object.create() 這種單純的方式來建立物件。\n\n後來也取得了胡立大大的回應，在這邊整理一下:\n* 第一個問題，這樣也是物件導向\n* 第二個問題，實作上應該會以 class 為主， 無論是傳統的繼承方式還是原型繼承，兩者都是物件導向，而無論在哪個程式語言，就是用 class 這個語法，所以覺得最普遍而且也最容易懂\n\n> 也就是說，為了方便與其他人溝通，最好還是使用 class 會是最普遍的做法。\n\n至於 `Object.creat` 的部分，如果搜尋的話應該會看到 `Object.create(null)`，意思就是要產生一個「純粹的」物件，不繼承任何的函式，所以佔用的空間最少也很乾淨，例如說只是單純想存資料的話就會使用這個方法。\n\n後來也找到關於 `Object.create(null)` 的詳細敘述與範例，Vue 裡面也有運用到哦。\n*   [详解Object.create(null)](https://juejin.im/post/5acd8ced6fb9a028d444ee4e)","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.67 什麼是物件導向","url":"%2Fjavascript%2F20190315%2F2454788646%2F","content":"\n## 前言\n在 JavaScript 的世界裡我們很容易聽見物件導向這樣的名詞，那麼究竟物件導向又是什麼東西呢？這是接下來要了解的內容，我們先從**什麼是物件導向**起手吧。\n\n![](https://cdn-images-1.medium.com/max/800/0*7wINrKH2AfgsGt_K)\n\n## 什麼是物件導向\n**根據 MDN 的解釋是這樣的：**\n> **物件導向程式設計**（Object-Oriented Programming、OOP）是一種程式設計方法。其將資料封裝（encapsulate）於物件（[**objects**](https://developer.mozilla.org/en-US/docs/Glossary/object \"objects: Object refers to a data structure containing data and instructions for working with the data. Objects sometimes refer to real-world things, for example a car or map object in a racing game. JavaScript, Java, C++, Python, and Ruby are examples of object-oriented programming languages.\")）中，我們需透過物件間接操作這些被封裝的內部資料，而非直接操作資料本身。\n\n其實我們上一小節寫的閉包範例就有一點物件導向的味道了，讓我們回顧一下：\n\n![](https://cdn-images-1.medium.com/max/800/1*dYnLpV4_Ci_FVXkWhjSM6A.png)\n\n1361 行的時候，此時的 `myWallet` 是個物件，而我們透過了這個錢包物件**間接**的操作了被封裝的內部資料(像是 `myMoney` )，而不是直接的操作資料本身。\n* 像是 1362 行，可以很好的讀懂，錢包內多了錢\n* 1363 行，錢包的錢被用掉了\n\n透過了這個**間接**的行為，可以讓我們更清楚的知道\n\n* 「**誰**」多了錢\n* 「**誰**」的錢被用掉了\n\n在這裡自然是 `myWallet` 這個物件。\n\n可是如果我們不使用物件導向的概念來寫，就像一開始寫那樣：\n\n![](https://cdn-images-1.medium.com/max/800/1*kHEFS3ZZSCTmbwnwkLdvFA.png)\n\n有個很明顯的缺點，就是：\n* 沒辦法單獨於 1338 行看出「**誰**」多了錢\n* 沒辦法單獨於 1339 行看出「**誰**」的錢被用掉了\n\n> 儘管這兩種寫法都可以得到一樣的結果，但卻是有**物件導向概念的**比較容易被讀懂。\n\n以上就是關於**什麼是物件導向**的基本認知，下一節我們要學習更多物件導向的基礎範例～","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.66 Closure 可以應用在哪","url":"%2Fjavascript%2F20190315%2F3059385161%2F","content":"\n## 前言\n好的終於到閉包的最後一個章節了，前面有提到一個小範例是關於金魚腦的小明，那除了這樣的情境可以利用閉包之外，還有一個情境是可以利用閉包達成的，讓我們一起看看。\n\n![](https://cdn-images-1.medium.com/max/800/0*c0CHVpAVQ3ooBohR)\n\n## 利用閉包達成私有變數\n情境是這樣的，我有 100 元，如果我的錢變多了，就利用某個函式讓錢增加，如果支出超過 10 元，最多就只能付出10元。\n\n讓我們看一段沒有利用閉包的程式碼：\n```\nvar myMoney = 100;  \nfunction addMoney(addmoney){  \n  myMoney = myMoney + addmoney;  \n}\n\nfunction payMoney(paymoney){  \n  if (paymoney > 10){  \n    myMoney = myMoney - 10;  \n  } else {  \n    myMoney = myMoney - paymoney;  \n  }  \n}\n\naddMoney(1);  \npayMoney(11);  \nconsole.log(myMoney); // 91\n```\n好的，這樣我們就完成了這段情境的敘述。\n\n但是有個問題，如果今天與別人協作，別人如果沒有遵照我們訂的函式下去做增減，是可以直接對 **`myMoney` 重新賦值** 的，那這樣是不是不太 OK 呢？\n\n因此我們要利用**閉包將變數私有化**，令別人無法在外部直接對變數賦值，只能透過我們提供的方法來變更值。\n```\nfunction myWallet(InitMoney){  \n  var myMoney = InitMoney;  \n  return {  \n    addMoney: function(addmoney){  \n      myMoney = myMoney + addmoney;  \n    },  \n    payMoney: function(paymoney){  \n      if (paymoney > 10){  \n        myMoney = myMoney - 10;  \n      } else {  \n        myMoney = myMoney - paymoney;  \n      }  \n    },  \n    showMoney: function(){  \n      console.log(myMoney);  \n    }  \n  }  \n}\n\nvar myWallet = myWallet(100);  \nmyWallet.addMoney(1);  \nmyWallet.payMoney(11);  \nmyWallet.showMoney(); // 91\n```\n透過閉包可以確保讓我們的變數不會突然被修改掉，而且只能用我們定義好的函式對內部的變數進行操作，這樣一來可以確保變數是安全的。\n\n> 朕不給的，你不能要！\n\n### 心得\n\n接著就是物件導向的部分啦～不知不覺也複習了這麼多東西呢，也是該好好的認識一下物件導向了，尤其是物件導向的部分，這個名詞該如何簡單又白話的解釋呢？","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.65 作用域陷阱","url":"%2Fjavascript%2F20190314%2F3191948883%2F","content":"\n## 前言\n到了我最喜歡的部分囉～我滿喜歡透過小範例來討論一些寫程式可能會遇到的一些問題，這非常實用，在這個小節內我們要使用一些不一樣的做法來解決這個問題哦。\n\n![](https://cdn-images-1.medium.com/max/800/0*vQqZS1szWBkPB-Dn)\n\n## 題目君 1 號\n```\nvar arr = [];  \nfor (var i =0; i<5; i++){  \n  arr[i] = function(){  \n    console.log(i);  \n  }  \n}  \narr[0](); // 5\n```\n這是蠻容易遇到的問題，在此的輸出不會如我們所想會是 0 ，而是變成 5 ，而我們接下來要嘗試不同的方法把問題修正。\n\n### 產生非預期的原因為何\n*   因為並沒有使用函式包覆，因此再迴圈內宣告的 `i` 變數相當於全域變數\n*   而執行迴圈時，並沒有執行函式，僅將函式放入陣列\n*   而呼叫後的函式由於在所屬作用域找不到 `i` ，轉而向上層尋找 `i`\n\n### 解法 A\n\n這邊提到第一種解法，可以**多宣告一個函式並且使用閉包技巧**來記住當前 `i` 的值。\n```\nvar arr = [];  \nfor (var i =0; i<5; i++){  \n  arr[i] = logN(i);  \n}\n\nfunction logN(num){  \n  return function(){  \n    console.log(num);  \n  }  \n}\n\narr[0](); // 0  \narr[1](); // 1\n```\n可以把它想像成這樣\n\n![](https://cdn-images-1.medium.com/max/800/1*cgNatSPzltdZ1jb6FVIuIw.png)\n\n### 解法 B\n\n如果不想要額外宣告函式，也可以透過 IIFE 配合閉包的技巧來達成，關於 IIFE 的部分可以喚醒另外一個世界線的記憶(?\n\n* [[JavaScriptWeird]No.33 立即呼叫的函式表示式 IIFE](https://pvt5r486.github.io/javascript/20190128/3130923936)\n\n所以這段程式其實可以改寫成這樣，跟解法 A 差不多，只是把額外宣告函式的部分用 IIFE 取代掉了。\n```\nvar arr = [];  \nfor (var i =0; i<5; i++){  \n  arr[i] = (function(num){  \n    return function(){  \n      console.log(num);  \n    }  \n  })(i)  \n}\n\narr[0](); // 0  \narr[1](); // 1\n```\n### 解法 C\n\n我個人比較喜歡的一種，因為最容易。那就是使用 ES6 新增的 `let` 來處理這個問題， `let` 的作用域是以 block 也就是大括號來劃分，而 let 在迴圈中的表現出的特性又有點不同，每次迴圈執行時都會產生一個不同的 i 。\n```\nvar arr = [];  \nfor (let i =0; i<5; i++){  \n  arr[i] = function(){  \n    console.log(i);  \n  }  \n}\n\narr[0](); // 0\n```\n使用 `let` 來處理這樣的問題其實相當容易，就只是把 `var` 替換掉而已。\n\n然而我們可以把**每當迴圈執行時**的這段過程想像成這樣\n\n![](https://cdn-images-1.medium.com/max/800/1*puAl4Tg2xlr9eBXpRLK0Hw.png)\n\n而實際把右邊的內容放到左邊執行，結果是一樣的。\n\n![](https://cdn-images-1.medium.com/max/800/1*0Z_kog_XkiW6dFwfLSdGCw.png)","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.64 再次 Cosplay JavaScript 引擎","url":"%2Fjavascript%2F20190314%2F2550634754%2F","content":"\n## 前言\n接著我們繼續用類似的角度來觀察這一段閉包的程式碼。\n\n![](https://cdn-images-1.medium.com/max/800/0*lDYLcfMYzVkMI3AK)\n\n## 簡單的 Closure 程式\n```\nvar v1 = 10;  \nfunction test(){  \n  var vTest = 20;  \n  function inner(){  \n    console.log(v1, vTest);  \n  }  \n  return inner;  \n}  \nvar inner = test();  \ninner();\n```\n首先進入創造全域執行環境階段，初始化 VO 、scopeChain 以及設定 `test` 函式的 `[[Scope]]`。\n\n![](https://cdn-images-1.medium.com/max/800/1*-CQJIaYY-yVMguDcXMwEqA.png)\n\n接著執行程式碼：\n\n* 於 1273 行變數 `v1` 賦值為 10\n* 1274 ~ 1280 行跳過\n* 於 1281 行執行 `test` 函式\n\n![](https://cdn-images-1.medium.com/max/800/1*yFGEQ70RhF-HTWRkoC9rYw.png)\n\n進入 `test` 函式的創造執行環境階段，初始化 AO 、scopeChain 以及設定 `inner` 函式的 `[[Scope]]`。\n\n![](https://cdn-images-1.medium.com/max/800/1*Eqfek9l08VndHz5wVZKAlQ.png)\n\n接著逐行執行 `test` 函式內的程式碼：\n* 於 1275 行變數 `vTest` 賦值為 20\n* 1276 ~ 1278 跳過\n* 於 1279 行 `return inner`\n\n此時 testEC 執行完畢，被移出執行堆。\n\n但**因為 `inner.[[scope]]` 使用到 `testEC.AO` 所以 `testEC.AO` 不會被 JavaScript 的垃圾回收機制回收掉**，因此會被保留在記憶體中。\n\n![](https://cdn-images-1.medium.com/max/800/1*X8OWKa_fdfPm7yUHxIUisw.png)\n\n最後回到全域執行環境，繼續運行程式碼：\n\n* 於 1282 行呼叫 `inner()`\n\n進入 `inner` 函式的創造執行環境階段，初始化 AO 、scopeChain\n\n![](https://cdn-images-1.medium.com/max/800/1*V2rWJVS38U-5AhjSKztj5Q.png)\n\n逐行執行 `inner` 函式內的程式碼\n\n* 於 1277 行印出 log， 因 `innerEC.AO` 內找不到變數 `v1` ，因此循著 `innerEC.scopeChain` 最後於 `globalEC.VO` 內找到，值為 10 。  \n  * 同理，變數 `vTest` 則為 20 。\n* `inner` 函式執行完畢，移出執行堆。\n\n![](https://cdn-images-1.medium.com/max/800/1*TE3j08Kwj7XXom-3CeILcQ.png)\n\n程式全部運行完畢，全域執行環境移出執行堆。\n\n![](https://cdn-images-1.medium.com/max/800/1*EYRhdfB-N0GSE2Ybzs4Zew.png)\n\n到此我們的 cosplay 就到一段落了。\n\n## 所有的函式都是閉包\n偷用一下聳動的**殺人標題**，其實這個標題是可以解釋的。\n\n我們之前提到，閉包白話來說**就是一個函式裡面回傳一個函式**。\n\n而透過觀察，發現無論有無回傳， JavaScript 引擎背後紀錄的東西都是一樣的，**像是沒有回傳也有像是 AO、VO、scopeChain 這些東西。**\n\n所以如果我們以這個角度「**會記住這些周邊資訊的函式**」來定義閉包，那就成了這次的殺人標題啦，所有的函式都是閉包，因為每個函式都會記錄這些東西。\n\n不過一般提到閉包不會講到這種定義，一般來說都是講「**一個函式內回傳一個函式**」才是大家認知的閉包。\n\n## 心得\n至此，關於閉包的原理以及觀念已經學習完了，接著要來看**日常生活中可能會遇到的作用域陷阱**以及**閉包可以運用在哪**，我個人也是蠻關注這一塊的，畢竟學了武功就是希望能派上用場 ~ 要是學了卻不知道能用在哪也是怪怪的。\n\n學習到現在，覺得能慢慢地看懂程式碼，了解這些程式碼在背後偷偷做些什麼，讓人有點感動也覺得踏實，勉勵自己繼續投入。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.63 從 ECMAScript 看作用域","url":"%2Fjavascript%2F20190308%2F3093574974%2F","content":"\n## 前言\n之前我們已經在 hoisting 嘗試過從 ECMAScript 文件內找出其原理，然後假裝自己是 JavaScript 引擎，但那個時候我們描述的不夠完整，因此這一小節要補足剩餘的部分。閉包其實也與作用域、範圍鏈脫離不了關係，因此在繼續深入了解閉包之前，還是要先對這兩者之間有更多認識才行。\n\n![](https://cdn-images-1.medium.com/max/800/0*Ze7FQa0zL9t47eRd)\n\n## 作用域 & 範圍鏈\n### 本節使用文件\n* [ECMAScript — Ecma-262 ,1999年12月](https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf)\n\n於 hoisting 的章節時，我們有了執行環境 (EC)、變數物件 (VO) 的概念，本小節就繼續從這邊紀錄下去。\n> Every execution context has associated with it a scope chain.\n\n* 每個執行環境都有**範圍鏈 (Scope Chain)**\n> When control enters an execution context, a scope chain is created and populated with an initial set of objects\n\n* 大概的意思就是，當進入執行環境時，範圍鏈就會被建立\n> When control enters an execution context, the scope chain is created and initialised, variable instantiation is performed, and the this value is determined\n\n* 當進入執行環境時，範圍鍊被建立且初始化，變數也被初始化並且確定其值\n\n接著跳到 Function Code 的段落\n> The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object.\n* 當進入執行環境時，範圍鏈的初始化將包含 activation object ，以及函式的 `[[Scope]]` 屬性\n* 當進入執行環境時，如有宣告函式，則將該函式的 `[[Scope]]` 屬性賦值為自身的範圍鏈\n\n接著了解什麼是 **activation object ，以下稱為 AO**\n\n> When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name **arguments** and attributes { DontDelete }. The initial value of this property is the arguments object described below.\n\n> The activation object is then **used as the variable object** for the purposes of variable instantiation\n* 大致上的意思就是，當我們進入一個執行環境時，會產生一個 AO (之前都說 VO ，但實際上是AO)，而這個 AO 其實跟 VO 只有一些細微的差異，而大部分的行為都是相同的。\n* 只有全域執行環境有 VO\n\n接下來我們一樣假裝自己是 JS 引擎，分析一段簡單的程式碼：\n```\nvar a = 1;  \nfunction test() {  \n  var b = 2;  \n  function inner(){  \n    var c = 3;  \n    console.log(b);  \n    console.log(a);  \n  }  \n  inner();  \n}  \ntest();\n```\n* 創造全域執行環境，建立變數物件，並且初始化範圍鏈\n\n建立變數物件的時候，因為有宣告 `test` 函式，所以 `test.[[Scope]]` 被賦值為 自身執行環境的 scopeChain ，即為 `globalEC.scopeChain` 。\n\n而初始化範圍鏈的時候，因為本身並不是函式，所以 ScopeChain 並沒有包含 `[[Scope]]` 屬性，僅有 `globalEC.VO`。\n\n整理過後可以得到下圖，全域執行環境的範圍鏈就是自己的 VO 。\n\n![](https://cdn-images-1.medium.com/max/800/1*XmWbOWRPC2VJtRc1grcSkQ.png)\n\n創造階段結束後接著是執行階段，開始逐行執行程式碼。\n\n* 1260 行將全域變數 `a` 賦值為 1\n* 1261~1269 跳過\n* 1270 呼叫 `test()` ，創造並進入另一個執行環境\n\n目前的狀況是這樣的\n\n![](https://cdn-images-1.medium.com/max/800/1*HK5RaYyCPBLosYrHww2jEQ.png)\n\n### test () 內發生的事\n\n創造執行環境階段\n\n* 建立 AO ，並且初始化範圍鏈\n\n而 `testEC.scopeChain` 內的東西就是 `testEC.AO` 以及 `testEC.[[Scope]]` 屬性，透過代換後，可以發現 `testEC.[[Scope]]` 屬性就是 `globalEC.scopeChain` ，更進一步代換就是 `globalEC.VO` 。\n\n![](https://cdn-images-1.medium.com/max/800/1*Zs4Wl1zJbDeJo3aqL6Wdxg.png)\n\n接著逐行運行程式碼\n* 1262 行將變數 `b` 賦值為 2\n* 1263~1267跳過\n* 1268 呼叫 `inner()` ，創造並進入另一個執行環境\n\n![](https://cdn-images-1.medium.com/max/800/1*g4NwunpvD_b2pACxxOICPw.png)\n\n### inner () 內發生的事\n創造執行環境階段\n\n*   建立 AO ，並且初始化範圍鏈\n\n如同在 `test()` 內發生的事一樣， `innerEC` 的 ScopeChain 會被初始化，裡面會有 `innerEC.AO` 與 `inner.[[Scope]]` ，接著可以透過不斷的代換，得知其實 `innerEC` 的 ScopeChain 會按照順序去找 `innerEC.AO` 、 `testEC.AO` 、`globalEC.VO` 內的東西。\n\n![](https://cdn-images-1.medium.com/max/800/1*0It-5PpVvXE6a0U1KW-Bbw.png)\n\n接著逐行運行程式碼\n* 1264 行將變數 `c` 賦值為 3\n* 1265 行印出變數 `b` ，但自身 AO 內找不到，透過自身 ScopeChain 向 `testEC.scopeChain` 尋找，於 `testEC.AO` 內找到變數 `b` 為 2\n* 1266 行印出變數 `a` ，但自身 AO 內找不到，且 `testEC.AO` 內也找不到，因此繼續往 `globalEC.scopeChain` 找，最後在 `globalEC.VO` 找到變數 `a` 為 1\n* `inner` 函式結束，移出執行堆\n* 回到 `test` 函式繼續執行\n* `test` 函式結束，移出執行堆\n* 回到全域執行環境繼續執行\n* 程式碼執行完畢，全域執行環境移出執行堆\n\n透過這樣的方式可以更了解作用域以及範圍鏈，也明白範圍鏈在 JavaScript 中是如何一層一層的往外找到相應的變數。\n\n而我們模仿 JS 引擎的這個行為，除了可以幫助我們了解 hoisting 以及 範圍鏈之外，還能夠幫助理解閉包的行為，下一節我們將繼續使用這樣的方式來解析閉包。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.62 Closure 是什麼","url":"%2Fjavascript%2F20190307%2F4153660921%2F","content":"\n## 前言\n結束了關於 hoisting 的學習，接下來要討論的是 **Closure 閉包**，之前在奇怪部分也有紀錄到關於閉包的部分，但我期待接下來的幾節能帶給我不同的切入點，讓自己更了解閉包。\n\n![](https://cdn-images-1.medium.com/max/800/0*VPPhJwCsrl-3Eb5L)\n\n## **Closure 閉包**\n閉包也是個經常會被問到的問題，但我們在此先不要提理論，先使用一個簡單的例子來觀察閉包可以做些什麼事。\n```\nfunction test(){  \n  var a = 10;  \n  function inner(){  \n    a++;  \n    console.log(a);  \n  }  \n  inner();  \n}  \ntest();\n```\n這是一個結果顯而易見的程式，答案是 11 。\n\n但是如果不在 `test` 函式內呼叫 `inner()` ，而使用 `return` 回傳 `inner` 呢？\n\n在這之前我們要先複習一個小概念，函式呼叫。\n\n> 因為有沒有加上 () 是完全不同的兩件事。\n\n## 函式呼叫 ( Funtion Invocation )\n\n* 表示執行或者呼叫一個函式，在 JavaScript 我們用括號來表示這件事\n```\nfunction test(){  \n  var a = 10;  \n  function inner(){  \n    a++;  \n    console.log(a);  \n  }  \n  return inner;  \n}\n\nvar func = test();  \nfunc(); // 11  \nfunc(); // 12\n```\n使用 `return` 回傳 `inner` 函式，需要用一個變數來指向這個函式，方便後續使用它，也因為回傳的是**函式**，所以能直接加上 括號 () 執行，最後一樣能得到相同的結果 11 。\n\n> **而神奇的是變數 a 的值會保留，原因之後再提。**\n\n如果不想額外宣告一個變數，也可以這麼做：\n```\nfunction test(){  \n  var a = 10;  \n  function inner(){  \n    a++;  \n    console.log(a);  \n  }  \n  return inner;  \n}\n\ntest()(); // 11\n```\n意思是當 `test()` 執行完畢 `return inner` 時，馬上執行 `inner` 函式。\n\n當寫習慣之後，可以簡短成這樣\n```\nfunction test(){  \n  var a = 10;  \n  return function(){  \n    a++;  \n    console.log(a);  \n  }  \n}\n\nvar func = test();  \nfunc(); // 11  \nfunc(); // 12\n```\n因為目的就是回傳被包在 `test` 函式內的**那個函式**，所以可以使用匿名函式的技巧表示被包在內部的函式。\n\n## 目前觀察到的特性\n* 首先觀察到，我們把本來在函式內部執行的另一個函式拉出來，變成在外面呼叫這個函式。\n* 與先前的函式寫法不同，函式應該是執行完就釋放掉了，而這樣的做法，宣告在外層函式內變數指向的值會保留，似乎像是被鎖在函式內。\n\n**總結目前階段所認知的閉包**\n> 呃 ... 大概就是一個函式內又回傳另一個函式 ?\n\n## 以目前認知的閉包特性可以做些什麼事？\n\n有個情境是這樣的，我們用一個函式做重複的事情，例如複雜的計算，那麼可以這麼寫：\n```\nfunction openIcebox(item){  \n  console.log('打開冰箱看到');  \n  return item;  \n}\n\nconsole.log(openIcebox('蘋果'));  \nconsole.log(openIcebox('蘋果'));\n```\n相當容易，不是嗎？\n\n但是這麼做，**每次呼叫都會執行一次 openIcebox 函式**。\n\n這麼做就好比\n* 小美請小明打開冰箱，確認裡面是否有一顆蘋果？\n* 小明打開冰箱後確實看到了蘋果，並回答小美，有一顆蘋果在冰箱內。\n* 接著大熊也請小明打開冰箱，確認裡面是否有一顆蘋果？\n* 但小明金魚腦已經忘記了，所以小明又跑到冰箱前打開門看到了蘋果，並回答大熊，有一顆蘋果在冰箱內。\n\n> 像小明這麼金魚腦的人，每次問相同的問題，就必須打開冰箱門確認一次，這樣是不是很浪費電？\n\n**所以小明需要一張便條紙把這些記起來。**\n```\nfunction openIcebox(item){  \n  console.log('打開冰箱看到');  \n  return item;  \n}\n\nfunction haveMemo(func){  \n  var memo = '';  \n  return function(item){  \n    if (memo){  \n      console.log('便條紙上寫著冰箱內有');  \n      return memo;  \n    }  \n    memo = func(item);  \n    return item;  \n  }  \n}\n\nvar ming = haveMemo(openIcebox);  \nconsole.log(ming('蘋果'));   \nconsole.log(ming('蘋果'));   \nconsole.log(ming('蘋果'));\n```\n![](https://cdn-images-1.medium.com/max/800/1*OGQMfPN8hlfO6GhaUytpwA.png)\n\n對於金魚腦的小明來說，函式 `haveMemo` 內的變數 `memo` 就是小明的便條紙，因此上面那個小故事，我們可以想成：\n\n* 小美請小明打開冰箱，確認裡面是否有一顆蘋果？\n* 小明打開冰箱，看到蘋果並寫在便條紙上，隨後回答小美冰箱有蘋果。\n* 接著大熊也請小明打開冰箱，確認裡面是否有一顆蘋果？\n* 小明這時拿出便條紙，肯定的說冰箱內有蘋果，所以不用跑到冰箱前打開確認了。\n\n透過這樣子的比喻，方便了解透過閉包的特性可以做到什麼樣的事情，而從這個比喻了解到，小明**節省了反覆開冰箱浪費的電力以及自身的體力**。回到程式來說，透過這樣子的**設計**，能夠讓程式的效能更好。\n\n為什麼說是**設計**：\n\n*   因為**笨的方法一樣能達成目的**，只是小明可能會很累。而透過一連串巧妙的**設計**(如小明的便條紙)，可以使用聰明的方法達到同樣的目的。\n*   而閉包我想就是一種**設計**，如果能巧妙地運用，相信能讓程式效能更好。\n\n> 以上就是對於閉包 Closure 的初步概念，接下來我們要探討原理的部分。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.61 let 、 const 、 TDZ","url":"%2Fjavascript%2F20190307%2F3177998342%2F","content":"\n## 前言\n前面三節提到的變數均使用 `var` 宣告，原因是 ES6 之後加入的 `let` & `const` 在這部分的特性表現不一樣，本節將記錄它們有何不同之處。\n\n![](https://cdn-images-1.medium.com/max/800/0*tIlmwt5NEIA2NFLm)\n\n## let & const 的 hoisting\n當你看過之前的文章，或許你會試著觀察 `let` 與 `const` 對於 hoisting 上的表現，於是我們可能這樣子寫。\n```\nconsole.log(a); // a is not defined  \nlet a = 10;\n```\n或是這樣子\n```\nconsole.log(a); // a is not defined  \nconst a = 10;\n```\n然後我們可能就直接下了定論「 `let` 與 `const` 沒有 hoisting」\n\n## 但是這個小例子也許會讓我們更混淆\n```\nlet a = 10;  \nfunction test() {  \n  console.log(a);  \n  let a = 10;  \n}  \ntest(); // a is not defined\n```\n混淆的點在於\n* 如果 `let` & `const` 沒有 hoisting ，那麼變數 `a` 會往全域找到外部的變數 `a` ，但實際執行卻得到「`a is not defined`」\n* 但如果 `let` & `const` 有 hoisting，為什麼印出變數 `a` 時也會得到「`a is not defined`」而不是 「 `undefined` 」？\n\n於是假設 `let` & `const` 有 hoisting，只是表現出來的特性不一樣，導致我們認為它們沒有 hoisting 。\n\n> **那麼 let & const 的 hoisting 特性是什麼呢？**\n\n## 暫時性死區 (Temporal Dead Zone)\n\n暫時性死區 (Temporal Dead Zone) 以下簡稱 TDZ，是 `let` & `const` 在 進行 hoisting 過程中產生的一種現象。\n```\nfunction test() {  \n  console.log(a); // a 的 TDZ 開始  \n  let a = 10; // a 的 TDZ 結束  \n}  \ntest(); // a is not defined\n```\n換句話說 `let` & `const` 是有 hoisting 的，只是表現出來的特性不一樣\n\n* 與 `var` 宣告不同，這兩者不會於**創造執行環境階段時**被初始化為 `undefined`\n* **創造執行環境階段後**，對於 `let` 宣告如果沒有賦值，執行到該行時則賦值該變數為 `undefined` 。\n* 在**提升後～賦值前**會產生一個稱為暫時性死區 (TDZ) 的區域，在這個區域中**不能對該變數做任何的存取**，否則就會發生錯誤。\n* 必須等到**賦值後**，也就是 TDZ 結束後才能對變數進行存取。\n\n## 使用 let 宣告但沒有賦值\n```\nfunction test() {  \n  // a 的 TDZ 開始  \n  let a; // a 的 TDZ 結束  \n  console.log(a);  \n}  \ntest(); // undefined\n```\n以上就是 `let` & `const` & TDZ 的簡單觀念，其實這部分還有相當多細部的觀念可以寫，其餘較詳細的部分可以參考[這一篇](https://github.com/aszx87410/blog/issues/34)。\n\n## 後記\n其實在寫這一篇的時候，因為**糾結於部分觀念**，導致寫作時花了很多時間。主要是為了確認：\n\n* let 於 **創造執行環境階段時會不會被初始化為** undefined\n\n### 遲疑的原因：\n\n* 在奇怪部份時，講師提到 「**創造執行環境階段時全部的變數都會被初始化為 `undefined` 」，**但考量時間因素，這支影片是在 ES6 之前推出，因此待求證。\n* 但本小節影片提到「 `let` 不會被賦予初始值 `undefined` 」\n\n### 例子\n```\nfunction test() {  \n  let a;  \n  console.log(a);  \n}  \ntest();\n```\n*   如果 `let` 於創造執行環境階段時不會被初始化為 `undefined` ，那麼為什最後印出的結果會是 `undefined `?\n\n### 因此我有以下兩個想法\n* 「創造執行環境階段後，對於 `let` 宣告如果沒有賦值，執行到該行時則賦值該變數為 `undefined` 」\n* 「創造執行環境階段時全部的變數都會被初始化為 `undefined` ，只是 `let` 因為 TDZ 的關係，必須等到實際程式執行到宣告的那一行時才能對變數進行存取」\n\n### 於是我寫信求指點～獲得回應如下：\n的確兩種情況都有可能，到底是哪一種只能看 spec 來確認。\n\n我在[**《我知道你懂 hoisting，可是你了解到多深？》**](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)的最後面附了一大堆參考資料，其實都是很有用的資源。\n\n這兩篇有你要的解答：\n\n* [https://segmentfault.com/a/1190000008213835](https://segmentfault.com/a/1190000008213835)\n* [http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)\n\n連結內的文章有一段這麼寫：\n> `let` and `const` declarations define variables that are scoped to [the running execution context](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-execution-contexts)’s [LexicalEnvironment](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-execution-contexts). The variables are created when their containing [Lexical Environment](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-lexical-environments) is instantiated but may not be accessed in any way until **the variable’s LexicalBinding is evaluated**. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBindingin a `let` declaration does not have an Initializer the variable is assigned the value `undefined` when the LexicalBinding is evaluated.\n\n上面寫說執行環境被創建時，變數就被建立了，但是一直到「**the variable’s LexicalBinding is evaluated**」之前都沒辦法訪問，這就是 TDZ。\n\n### 那什麼是「the variable’s LexicalBinding is evaluated」？\n\n* 就是實際上宣告變數的那一行： `let a`\n\n接著又提到「If a LexicalBindingin a let declaration does not have an Initializer the variable is assigned the value undefined **when the LexicalBinding is evaluated**.」\n\n如果宣告變數時沒給值，預設值會是 `undefined` 。\n\n*   這邊的「宣告變數」指的是「**when the LexicalBinding is evaluated**」\n*   也就是實際上 `let a` 這一行\n\n> 所以總結以上，你的第一個理解才是正確的。\n\n到此我才確定自己的理解是正確的，感謝 Huli 大的熱心解答。\n\n## 結論是：\n* `let` 在創造執行環境階段時，不會被賦予初始值 `undefined`\n* 創造執行環境階段後，對於 `let` 宣告如果沒有賦值，執行到該行時則賦值該變數為 `undefined`\n\n本來是不用特地把這一段再補上來的，但我認為可能也有很多初學者跟我有一樣的疑問，所以把來龍去脈整理出來，也有助於加深自己的理解。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.60 cosplay JS 引擎","url":"%2Fjavascript%2F20190306%2F3610645134%2F","content":"\n## 前言\n好的，接著我們要假裝自己是 JS 引擎，然後用 ECMAScript 文件上的規則來找出上一節開頭問題的答案哦～\n\n![](https://cdn-images-1.medium.com/max/800/0*6IeGbybuSWzURKGQ)\n\n## hoisting & scope 小測驗\n```\nvar a = 1;  \nfunction test(){  \n  console.log('1.', a);  \n  var a = 7;  \n  console.log('2.', a);  \n  a++;  \n  var a;  \n  inner();  \n  console.log('4.', a);  \n  function inner(){  \n    console.log('3.', a);  \n    a = 30;  \n    b = 200;  \n  }  \n}  \ntest();  \nconsole.log('5.', a);  \na = 70;  \nconsole.log('6.', a);  \nconsole.log('7.', b);\n```\n請依序寫出 log 答案是多少，在這邊我們要採用不一樣的觀點來找出這題的答案。\n\n## 如果我是 JavaScript 引擎\n\n我們說過當 JavaScript 執行時，會先**創造全域執行環境**。\n*   接著會找有沒有參數，但它不是函式所以跳過\n*   再來會找有沒有宣告函式\n*   最後才找有沒有宣告變數，有則初始化為 `undefined`\n\n整理後可以得到這樣的結果\n![](https://cdn-images-1.medium.com/max/800/1*X14SN_1kjmwMQgYg1PDolw.png)\n\n接下來開始逐行執行程式碼\n\n* 1163 行 全域變數 `a` 被賦值為 1\n* 跳過 1164 ~ 1177 行的函式\n* 1178 行呼叫 `test` 函式，建立並**進入另一個執行環境**\n\n### test 函式內發生的事\n\n基本上做的事情會跟創造全域執行環境時一樣，因此：\n* 於 1172 行發現宣告 `inner` 函式\n* 於 1166 行發現宣告 `a` 變數\n\n整理後可得結果如下，至此 `test` 的執行環境建立完成。\n![](https://cdn-images-1.medium.com/max/800/1*0IFFv8BsLOav-ZFL8e5ZCw.png)\n\n接著逐行執行 `test` 函式內的程式碼\n* 於 1165 行印出變數 `a` ，此時對照 `test` 的 VO ，得知目前 `a` 為 `undefined`\n* 於 1166 行變數 `a` 被賦值為 7 ，此時 `test` 內 VO 的 a 為 7\n* 於 1167 行印出變數 `a` ，對照後得知目前 `a` 為 7\n* 於 1168 行執行 `a++` ， 此時 `test` 內 VO 的 `a` 為 8\n* 於 1169 行發現 `var a`，但已經有同名變數被宣告，直接跳過。\n* 於 1170 行呼叫 `inner` 函式，建立並**進入另一個執行環境**\n\n至此，狀態如下\n\n![](https://cdn-images-1.medium.com/max/800/1*1YEl6fVZvFLrLugBJaU-Xg.png)\n\n### inner 函式內發生的事\n\n與前面介紹的一樣，會先創造執行環境，因此\n* 在這個函式內找不到任何的參數、宣告函式、宣告變數\n\n所以當前狀態是這樣的\n\n![](https://cdn-images-1.medium.com/max/800/1*_AHwnsE7jdkO6MNoKgZbcw.png)\n\n接著逐行執行 `inner` 函式內的程式碼\n\n* 於 1173 行印出變數 `a` ，但所屬 VO 內找不到變數 `a` ，轉而向上一層尋找，此時會找到 test VO 的 `a` ，所以會印出 8\n* 於 1174 行對變數 `a` 賦值，但所屬 VO 內找不到變數 `a` ，所以這邊的賦值其實是對 test VO 的 `a` ，因此被重新賦值為 30\n* 於 1175 行對變數 `b` 賦值，但逐層往上找也找不到變數 `b` ，最後會在全域執行環境內產生變數 `b` ，並賦值 200\n\n**至此 `inner` 函式執行完畢，被移出執行堆。**\n\n![](https://cdn-images-1.medium.com/max/800/1*2OA5ia1GnQbDR3TIBdHg3A.png)\n\n目前執行堆最上方是 `test` 函式。\n\n### 因此會回到 test 函式內繼續進行沒執行的部分\n*   於 1171 行印出變數 `a` ，此時對照 `a` 為 30\n*   1172 ~ 1177 跳過\n\n**至此 `test` 函式執行完畢，被移出執行堆。**\n\n![](https://cdn-images-1.medium.com/max/800/1*4ZyKkQk9VmupFpj92yeAjw.png)\n\n### 回到全域執行環境，繼續進行沒執行的部分。\n*   於 1179 行印出變數 `a` ， 此時對照 `a` 為 1\n*   於 1180 行對變數 `a` 賦值，因此 `a` 被修改為 70\n*   於 1181 行印出變數 `a` ， 此時對照 `a` 為 70\n*   於 1182 行印出變數 `b` ，此時對照 `b` 為 200\n\n至此，程式碼執行完畢，全域執行環境被移出。\n\n![](https://cdn-images-1.medium.com/max/800/1*C2ugWkHMLiBoW0bfd1eE6w.png)\n\n接著我們可以實際運行這一段程式碼，會發現答案是吻合的。\n\n![](https://cdn-images-1.medium.com/max/800/1*Pt0s_Swz5iW1oCohyqhCwQ.png)\n\n是不是相當的神奇呢？\n\n## 心得\n\n若要我說觀看影片到現在的心得，我覺得最屌的莫過於上一篇跟這一篇了，沒想到還可以用這樣子的方式了解 hoisting ，這是我上 JS 奇怪部份時完全沒有的體驗，真的是太棒了！\n\n但我知道後面應該還有更多類似這樣的體驗，真的是很開心自己能有這樣的機會學習關於 JavaScript 底層。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.59 hoisting 的原理為何","url":"%2Fjavascript%2F20190306%2F3202359618%2F","content":"\n## 前言\n在受到前面兩小節的洗禮後，對於 hoisting 應該有更明確的認知，這節影片要帶領我們從 ECMAScript 了解 hoisting 的原理為何。\n\n![](https://cdn-images-1.medium.com/max/800/0*R2Pp4BuJiptMIOC1)\n\n## hoisting & scope 小測驗\n\n首先，讓我們打鐵趁熱，來份 hoisting 的考題吧，說不定面試會考哦？\n```\nvar a = 1;  \nfunction test(){  \n  console.log('1.', a);  \n  var a = 7;  \n  console.log('2.', a);  \n  a++;  \n  var a;  \n  inner();  \n  console.log('4.', a);  \n  function inner(){  \n    console.log('3.', a);  \n    a = 30;  \n    b = 200;  \n  }  \n}  \ntest();  \nconsole.log('5.', a);  \na = 70;  \nconsole.log('6.', a);  \nconsole.log('7.', b);\n```\n請依序寫出印出來的答案是多少。\n\n還沒看解答之前我的答案是這樣，我把內容調換過用來幫助自己思考。\n```\nvar a = 1;  \nfunction test(){  \n  function inner(){  \n    console.log('3.', a); // 8  \n    a = 30;  \n    b = 200;  \n  }  \n  var a;  \n  console.log('1.', a); // undefined  \n  a = 7;  \n  console.log('2.', a); // 7  \n  a=a+1;  \n  var a;  \n  inner();  \n  console.log('4.', a); // 8\n\n}  \ntest();  \nconsole.log('5.', a); // 1  \na = 70;  \nconsole.log('6.', a); // 70  \nconsole.log('7.', b); // 200\n```\n後來對照答案後，發現**第四題粗心寫錯了，應該是印出 30** 才對。\n\n但是其他都如同我想的，這代表先前的學習、寫文章記錄加深印象是有效的，往後我也會繼續這麼做。\n\n## 我判斷答案時用到的**觀念**有：\n*   ECMAScript基本觀念\n*   hoisting 順序\n*   變數作用域與範圍鏈\n*   var 的特性\n> **可...可惡，JavaScript 的陷阱真多！**\n\n## ECMAScript 如何解釋 hoisting\nECMAScript 是制定 JavaScript 的標準，因此也可以說是 JavaScript 的聖經，本節影片的作者要帶領我們如何透過 ECMAScript 的文件了解 JavaScript 的行為。\n\n隨著時間過去 ECMAScript 的文件也會越來越多，但並不會影響原作者想要傳達的目的，本節會使用較舊的版本介紹。\n\n### 本節使用文件\n* [ECMAScript — Ecma-262 ,1999年12月](https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf) 第 10 節\n\n### 執行環境 (Execution Contexts)\n\n> **以下節錄自文件**  \n> When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context\n\n不過我拿去 google 翻譯看完之後發現根本不懂這敘述再寫什麼 (汗\n\n但就之前的筆記，我對於**執行環境**的認知是：\n* 當 JavaScript 開始運行時，會先建立一個全域執行環境\n* 之後每進入一個函式 function 就會再度創造一個執行環境\n* 而這些執行環境會按照執行順序被堆疊起來，稱為執行堆\n* 執行堆最高的會優先被執行，執行完畢後將被移出執行堆\n* 當全域執行環境也被移出時，代表 JavaScript 程式已經運行完畢\n\n**以圖片來總結上面那些話，大概就長這樣**：\n\n![資料來源: [我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)](https://cdn-images-1.medium.com/max/800/1*cc85KDCTW5BzZ1sgCyKt1A.png)\n資料來源: [我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)\n\n### 變數初始化 (Variable Instantiation)\n\n> **以下節錄自文件**  \n> Every execution context has associated with it a **variable object**.Variables and functions declared in the source text are added as properties of the variable object.On entering an execution context, the properties are bound to the variable object in the following order:\n\n文件下面還有很多落落長的敘述，有興趣可以點進去看。\n\n### 我理解的大意是\n* 每一個執行環境都有一個**變數物件** (variable object)\n* 在執行環境內宣告的函式或變數都會被加到變數物件內成為屬性 (properties)\n* 當進入執行環境時，屬性會按照順序綁定到變數物件上\n* 當進入執行環境時，會把函式的參數放到變數物件上，值就是當時呼叫這個函式所帶入的值，若未傳入值則初始化為 `undefined`\n* 對於函式，如果變數物件已經有同名的屬性，則取代裡面的值\n* 對於變數，如果宣告的變數已經重複，則什麼事情都不會發生，若未重複則將該變數初始化為 `undefined`\n\n**白話的用一些程式表示**\n```\nvariableObject: {  \n  a: 1  \n}\n\nfunction test(){  \n  var a = 1;  \n}  \ntest();\n```\n* 當 `test` 函式被執行，執行環境建立並進入，裡面宣告的 `a` 會被加到變數物件內成為屬性\n```\nvariableObject: {  \n  a: 123,  \n  b: undefined  \n}\n\nfunction test(a, b){}  \ntest(123);\n```\n* 當進入執行環境時，會把函式的參數放到變數物件上，如果未傳入參數的值，則初始化為 `undefined`\n```\nvariableObject: {  \n  a: point to function a,  \n}\n\nfunction test(a){  \n  function a(){}  \n}  \ntest(123);\n```\n* 對於函式，如果變數物件已經有同名的屬性，則取代裡面的值\n```\nvariableObject: {  \n  a: 10  \n}\n\nfunction test(a){  \n  var a;  \n}  \ntest(10);\n```\n* 對於變數，如果宣告的變數已經重複，則什麼事情都不會發生\n\n## 後記\n透過 ECMAScript 的文件解釋，我們可以理解原來 hoisting 背後的原理是這樣，相較於前面我們對於 hoisting 的觀察是較為表面的 (所以那個時候都說，我們可以把這一段程式碼想成 ...)\n\n但現在我們透過 ECMAScript 文件了解這些規則，接下來我們要嘗試用這一套規則來回答一開始的問題。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.58 hoisting 順序","url":"%2Fjavascript%2F20190305%2F1172397453%2F","content":"\n## 前言\nhoisting 有**順序**? 抱歉我也不知道，不知道的東西就該好好記錄下來～\n\n![](https://cdn-images-1.medium.com/max/800/0*RFA8Udb3F6967pl-)\n\n## hoisting 順序問題\n前篇了解基礎觀念後，接著要來了解一些之前從來沒有想過的問題。\n```\nfunction test(){  \n  console.log(a);  \n  var a = 'local';  \n  function a(){}  \n}  \ntest();　// ƒ a(){}\n```\n宣告變數 `a` 之後，在宣告一個 `a` 的函式陳述式，結果居然會印出函式。\n```\nfunction test(){  \n  console.log(a);  \n  function a(){}  \n  var a = 'local';  \n}  \ntest();　// ƒ a(){}\n```\n再將順序調換，仍然印出函式。\n\n> 代表 hoisting 後的順序，**函式的優先權是比變數高的**\n```\nfunction test(){  \n  function a(){}  \n  var a;  \n  console.log(a);  \n  a = 'local';  \n}  \ntest(); // ƒ a(){}\n```\n可以把原本的程式碼想像成上面這樣，這邊也有個陷阱。\n\n我們可能會想說：「**明明下一行是 `var a` 可是為什麼印出來的 `a` 不是 `undefined`**」\n\n然而 JavaScript 是這樣的：\n* var 可以重複宣告變數\n* 使用 var 宣告的變數如果**已經存在**，且**新宣告同名的變數又未賦值**時，則不會對原本變數造成影響。\n\n這段話的意思用程式碼表達是這樣的：\n```\nvar a = 10;  \nvar a;  \nvar a;  \nconsole.log(a); // 10;  \nvar a;  \nvar a;  \nvar a;  \nvar a = '安安';  \nconsole.log(a); // 安安;\n```\n回到原本的例子，就可以明白為何還是印出函式了。\n\n**同樣的例子，再度調換程式碼位置**\n```\nfunction test(){  \n  var a = 'local';  \n  console.log(a);  \n  function a(){}  \n}  \ntest(); // local\n```\n如果這邊回答印出函式，那麼代表又中陷阱啦～\n\n根據剛剛的觀念，好好的來排一下順序:\n```\nfunction test(){  \n  function a(){}  \n  var a;  \n  a = 'local'  \n  console.log(a);  \n}  \ntest(); // local\n```\n* 函式有優先權，先提升\n* 再來是變數，**賦值不會提升**\n* 同名變數又被**重新賦值**\n\n所以結果才會是 local\n\n### 同名函式的 hoisting 優先順序\n```\nfunction test(){  \n  console.log(a);  \n  function a(){  \n    console.log(1);  \n  };  \n  function a(){  \n    console.log(2);  \n  };  \n  var a = 'local';  \n}  \ntest(); // ƒ a(){console.log(2);}\n```\n由此可知，同名函式的情況下，很合理的是**後面蓋前面**。\n\n### 函式有參數的情況下\n```\nfunction test(a){  \n  console.log(a);  \n  var a = 456;  \n}  \ntest(123); // 123\n```\n此時相當於\n```\nfunction test(a){  \n  var a;  \n  console.log(a);  \n  a = 456;  \n}  \ntest(123); // 123\n```\n可知**參數 hoisting 的優先權是大於變數的。**\n\n接著來測試**參數與函式的優先權**\n```\nfunction test(a){  \n  console.log(a);  \n  function a(){  \n      \n  }  \n}  \ntest(123); // ƒ a(){}\n```\n可知**函式 hoisting 的優先權是大於參數的。**\n\n## hoisting 優先順序總結\n*   函式 (function) 最優先\n*   參數 (arguments) 其次\n*   變數最後\n\n> 除了考慮 hoisting 順序以外，也與程式碼的執行順序有關。\n所以最後再來個例子，考考自己有沒有懂：\n```\nfunction test(a){  \n  console.log(a); // 123  \n  var a = 456;  \n  console.log(a); // 456  \n}  \ntest(123);\n```\n＝＝＝＝＝＝＝＝\n```\nfunction test(a){  \n  var a;  \n  console.log(a); // 123  \n  a = 456;  \n  console.log(a); // 456  \n}  \ntest(123);\n```\n## 心得\n這一小節真的是太猛啦，根據前世的記憶（？），奇怪部分對於 hoisting 的補充並沒有這麼多範例，而且我也從來沒想過 hoisting 這邊可以有這麼多陷阱。\n\n**真的是非常感謝這一系列影片，覺得自己又更認識 JavaSctipt 一點。**\n\n然後，關於 hoisting 還不只這樣哦，還要繼續深～下去。","tags":["支線"],"categories":["JavaScript"]},{"title":"[JavaScriptWeird]No.57 hoisting 基本觀念","url":"%2Fjavascript%2F20190305%2F727543988%2F","content":"\n## 前言\nhoisting (提升) 也是常常被拿出來詢問的觀念，所以我決定要好好地記錄下來，拆成多篇記錄，由淺入深。\n\n![](https://cdn-images-1.medium.com/max/800/0*OmXqrUkiOUcfgHfL)\n\n## hoisting (提升)\n使用一連串的範例來了解 hoisting 做了些什麼：\n```\nconsole.log(b); // b is not defined\n```\n因為辦法使用未宣告的變數。\n\n但如果改成這樣子寫，就不會出錯了。\n```\nconsole.log(a); // undefined  \nvar a = 10;\n```\n這裡就是 hoisting 的一個特性，可以想像成它把所有的宣告提升到第一行，也就是說這段程式碼與下列這段程式碼的結果是一樣的：\n```\nvar a;  \nconsole.log(a); // undefined  \na = 10;\n```\n> 但必須注意的是，hoisting 並不是真的物理性的把程式碼給拉到第一行。\n\n### 從這邊可以知道一些 hoisting 的特性：\n\n* 變數宣告會被提升，賦值不會\n\n除了變數之外，其實函式也具有 hoisting 特性，但在介紹之前，先簡單複習一下函式陳述式 (Function Statements) 與函式表示式 (Function Expressions)，或者點一下[[JavaScriptWeird]No.26 函式表示式與函式陳述句](https://pvt5r486.github.io/javascript/20190123/1596425308)複習。\n\n## 函式表示式與函式陳述式\n```\nfunction greet() {  \n  console.log('Hi');  \n}\n```\n上面是函式陳述式，下面是函式表示式\n```\nvar anonymousGreet = function greet() {  \n  console.log('Hi');  \n}\n```\n這邊只要知道這樣就可以了，接著來看範例。\n```\ntest();  \nfunction test(){  \n  console.log('Hello');  \n}\n```\n這個範例的 hoisting 就算是 JavaScript 的初學者一定也遇過，因為 hoisting 的關係，所以允許把函式寫在呼叫該函式的下方，這在某些程式語言是做不到的，而我們也可以把這段程式想像成這樣，結果是一樣的:\n```\nfunction test(){  \n  console.log('Hello');  \n}  \ntest();\n```\n**但如果函式寫成表示式的話，就沒有提升的效果了。**\n```\ntest(); // test is not a function  \nvar test = function(){  \n  console.log('Hello');  \n}\n```\n其實原因很簡單，因為我們一開始看的範例已經得知：\n\n> 只有變數宣告會被提升，賦值不會\n\n也就是說這段程式碼可以看成這樣：\n```\nvar test; // undefined  \ntest();  \ntest = function(){  \n  console.log('Hello');  \n}\n```\n由於變數 `test` 的值是 `undefined` ，並不是函式所以無法被呼叫。\n\n## 對現況再做個總整理：\n\n* 變數宣告會被提升，賦值不會\n* 函式陳述式會被提升，**函式表示式不會 (因為提升的是變數宣告)**\n\n## 最後再來個陷阱題\n```\nvar a = 'global';  \nfunction test(){  \n  console.log(a); // undefined  \n  var a = 'local';  \n}  \ntest();\n```\n可能會很直覺的回答變數 `a` 會印出 `global` ，因為 `test` 函式內並沒有看到變數 `a` 。\n\n但這邊事實上會印出 `undefined` ，因為 hoisting 會發生在變數的 scope 裡面，也就是說我們可以想像成這樣：\n```\nvar a = 'global';  \nfunction test(){  \n  var a;  \n  console.log(a); // undefined  \n  a = 'local';  \n}  \ntest();\n```\n> 可...可惡，陷阱真多！\n\n## 後記\n關於 hoisting 的基礎觀念大概是這樣，但其實 hoisting 背後還有相當深的觀念需要了解，特別推薦 Huli 大大的作品 - [**我知道你懂 hoisting，可是你了解到多深？**](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)","tags":["支線"],"categories":["JavaScript"]}]